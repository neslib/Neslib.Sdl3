unit Neslib.Sdl3.Api;

{ Simple DirectMedia Layer
  Copyright (C) 1997-2025 Sam Lantinga <slouken@libsdl.org>

  Neslib.Sdl3
  Copyright (C) 2025 Erik van Bilsen

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution. }

{ This unit is partially generated by Chet:
  https://github.com/neslib/Chet }

interface

{$REGION 'Libraries'}
uses
  {$IF Defined(MSWINDOWS)}
  Winapi.Windows,
  {$ELSEIF Defined(POSIX)}
  Posix.StdDef,
  {$ENDIF}
  System.SysUtils;

const
  {$IF Defined(MSWINDOWS)}
  LIB_SDL3 = 'SDL3.dll';
  _PU = '';
  {$ELSEIF Defined(MACOS64) and Defined(CPUARM64) and not Defined(IOS)}
  LIB_SDL3 = 'libSdl3_macos_arm.a';
  _PU = '';
  {$ELSEIF Defined(MACOS64) and Defined(CPUX64) and not Defined(IOS)}
  LIB_SDL3 = 'libSdl3_macos_intel.a';
  _PU = '';
  {$ELSEIF Defined(IOS)}
  LIB_SDL3 = 'libSdl3_ios.a';
  _PU = '';
  {$ELSEIF Defined(ANDROID32)}
  LIB_SDL3 = 'libSdl3_android32.a';
  _PU = '';
  {$ELSEIF Defined(ANDROID64)}
  LIB_SDL3 = 'libSdl3_android64.a';
  _PU = '';
  {$ELSE}
    {$MESSAGE Error 'Unsupported platform'}
  {$ENDIF}
{$ENDREGION 'Libraries'}

{$REGION 'Entry point'}
type
  { Type for procedure that forms the main entry point for the application.
    Used by SdlMain. }
  TSdlProc = procedure;

{ Starts an SDL application.
  You *MUST* use this method to start the application, otherwise your
  application will fail.

  Parameters:
    AMainProc: the procedure to call to start your application. This is the
      main entry point of your app.

  NOTE: On some platforms, this procedure returns immediately and will run
  AMainProc at a later time. So you cannot assume that the application has
  finished once this routine returns. }
procedure SdlMain(const AMainProc: TSdlProc);
{$ENDREGION 'Entry point'}

{$REGION 'SDL_version.h'}
(**
 * # CategoryVersion
 *
 * Functionality to query the current SDL version, both as headers the app was
 * compiled against, and a library the app is linked to.
 *)

const
  (**
   * The current major version of SDL headers.
   *
   * If this were SDL version 3.2.1, this value would be 3.
   *
   * \since This macro is available since SDL 3.2.0.
   *)
  SDL_MAJOR_VERSION = 3;

  (**
   * The current minor version of the SDL headers.
   *
   * If this were SDL version 3.2.1, this value would be 2.
   *
   * \since This macro is available since SDL 3.2.0.
   *)
  SDL_MINOR_VERSION = 2;

  (**
   * The current micro (or patchlevel) version of the SDL headers.
   *
   * If this were SDL version 3.2.1, this value would be 1.
   *
   * \since This macro is available since SDL 3.2.0.
   *)
  SDL_MICRO_VERSION = 6;

(**
 * This macro turns the version numbers into a numeric value.
 *
 * (1,2,3) becomes 1002003.
 *
 * \param major the major version number.
 * \param minor the minorversion number.
 * \param patch the patch version number.
 *
 * \since This macro is available since SDL 3.2.0.
 *)
function SDL_VersionNum(major, minor, patch: Integer): Integer; inline;

(**
 * This macro extracts the major version from a version number
 *
 * 1002003 becomes 1.
 *
 * \param version the version number.
 *
 * \since This macro is available since SDL 3.2.0.
 *)
function SDL_VersionNumMajor(version: Integer): Integer; inline;

(**
 * This macro extracts the minor version from a version number
 *
 * 1002003 becomes 2.
 *
 * \param version the version number.
 *
 * \since This macro is available since SDL 3.2.0.
 *)
function SDL_VersionNumMinor(version: Integer): Integer; inline;

(**
 * This macro extracts the micro version from a version number
 *
 * 1002003 becomes 3.
 *
 * \param version the version number.
 *
 * \since This macro is available since SDL 3.2.0.
 *)
function SDL_VersionNumMicro(version: Integer): Integer; inline;

const
  (**
   * This is the version number macro for the current SDL version.
   *
   * \since This macro is available since SDL 3.2.0.
   *
   * \sa SDL_GetVersion
   *)
  SDL_VERSION = (SDL_MAJOR_VERSION * 1000000) + (SDL_MINOR_VERSION * 1000) + SDL_MICRO_VERSION;

(**
 * This macro will evaluate to true if compiled with SDL at least X.Y.Z.
 *
 * \since This macro is available since SDL 3.2.0.
 *)
function SDL_VersionAtLeast(major, minor, patch: Integer): Boolean; inline;

(**
 * Get the version of SDL that is linked against your program.
 *
 * If you are linking to SDL dynamically, then it is possible that the current
 * version will be different than the version you compiled against. This
 * function returns the current version, while SDL_VERSION is the version you
 * compiled with.
 *
 * This function may be called safely at any time, even before SDL_Init().
 *
 * \returns the version of the linked library.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetRevision
 *)
function SDL_GetVersion(): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetVersion';

(**
 * Get the code revision of SDL that is linked against your program.
 *
 * This value is the revision of the code you are linked with and may be
 * different from the code you are compiling with, which is found in the
 * constant SDL_REVISION.
 *
 * The revision is arbitrary string (a hash value) uniquely identifying the
 * exact revision of the SDL library in use, and is only useful in comparing
 * against other revisions. It is NOT an incrementing number.
 *
 * If SDL wasn't built from a git repository with the appropriate tools, this
 * will return an empty string.
 *
 * You shouldn't use this function for anything but logging it for debugging
 * purposes. The string is not intended to be reliable in any way.
 *
 * \returns an arbitrary string, uniquely identifying the exact revision of
 *          the SDL library in use.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetVersion
 *)
function SDL_GetRevision(): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetRevision';
{$ENDREGION 'SDL_version.h'}

{$REGION 'SDL_stdinc.h'}
(**
 * # CategoryStdinc
 *
 * SDL provides its own implementation of some of the most important C runtime
 * functions.
 *
 * Using these functions allows an app to have access to common C
 * functionality without depending on a specific C runtime (or a C runtime at
 * all). More importantly, the SDL implementations work identically across
 * platforms, so apps can avoid surprises like snprintf() behaving differently
 * between Windows and Linux builds, or itoa() only existing on some
 * platforms.
 *
 * For many of the most common functions, like SDL_memcpy, SDL might just call
 * through to the usual C runtime behind the scenes, if it makes sense to do
 * so (if it's faster and always available/reliable on a given platform),
 * reducing library size and offering the most optimized option.
 *
 * SDL also offers other C-runtime-adjacent functionality in this header that
 * either isn't, strictly speaking, part of any C runtime standards, like
 * SDL_crc32() and SDL_reinterpret_cast, etc. It also offers a few better
 * options, like SDL_strlcpy(), which functions as a safer form of strcpy().
 *)

type
  (**
   * A signed 8-bit integer type.
   *
   * \since This macro is available since SDL 3.2.0.
   *)
  Sint8 = Int8;
  PSint8 = ^Sint8;

  PUint8 = PByte;
  PPUint8 = ^PUint8;

  (**
   * A signed 16-bit integer type.
   *
   * \since This macro is available since SDL 3.2.0.
   *)
  Sint16 = Int16;
  PSint16 = ^Sint16;

  PUint16 = ^UInt16;

  (**
   * A signed 32-bit integer type.
   *
   * \since This macro is available since SDL 3.2.0.
   *)
  Sint32 = Int32;
  PSint32 = ^Sint32;

  (**
   * A signed 64-bit integer type.
   *
   * \since This macro is available since SDL 3.2.0.
   *
   * \sa SDL_SINT64_C
   *)
  Sint64 = Int64;
  PSint64 = ^Sint64;

  (**
   * SDL times are signed, 64-bit integers representing nanoseconds since the
   * Unix epoch (Jan 1, 1970).
   *
   * They can be converted between POSIX time_t values with SDL_NS_TO_SECONDS()
   * and SDL_SECONDS_TO_NS(), and between Windows FILETIME values with
   * SDL_TimeToWindows() and SDL_TimeFromWindows().
   *
   * \since This macro is available since SDL 3.2.0.
   *
   * \sa SDL_MAX_SINT64
   * \sa SDL_MIN_SINT64
   *)
  SDL_Time = Sint64;
  PSDL_Time = ^SDL_Time;

  PPUTF8Char = ^PUTF8Char;

const
  SDL_MAX_SINT8 = $7F;
  SDL_MIN_SINT8 = Sint8(not $7F);
  SDL_MAX_UINT8 = $FF;
  SDL_MIN_UINT8 = $00;
  SDL_MAX_SINT16 = $7FFF;
  SDL_MIN_SINT16 = Sint16(not $7FFF);
  SDL_MAX_UINT16 = $FFFF;
  SDL_MIN_UINT16 = $0000;
  SDL_MAX_SINT32 = $7FFFFFFF;
  SDL_MIN_SINT32 = Sint32(not $7FFFFFFF);
  SDL_MAX_UINT32 = $FFFFFFFF;
  SDL_MIN_UINT32 = $00000000;
  SDL_MAX_SINT64 = $7FFFFFFFFFFFFFFF;
  SDL_MIN_SINT64 = Sint64(not $7FFFFFFFFFFFFFFF);
  SDL_MAX_UINT64 = $FFFFFFFFFFFFFFFF;
  SDL_MIN_UINT64 = $0000000000000000;
  SDL_MAX_TIME = SDL_MAX_SINT64;
  SDL_MIN_TIME = SDL_MIN_SINT64;
  SDL_FLT_EPSILON = 1.1920928955078125e-07;

const
  (**
   * The largest value that a `size_t` can hold for the target platform.
   *
   * `size_t` is generally the same size as a pointer in modern times, but this
   * can get weird on very old and very esoteric machines. For example, on a
   * 16-bit Intel 286, you might have a 32-bit "far" pointer (16-bit segment
   * plus 16-bit offset), but `size_t` is 16 bits, because it can only deal with
   * the offset into an individual segment.
   *
   * In modern times, it's generally expected to cover an entire linear address
   * space. But be careful!
   *
   * \since This macro is available since SDL 3.2.0.
   *)
  SDL_SIZE_MAX = size_t.MaxValue;

(**
 * Define a four character code as a Uint32.
 *
 * \param A the first ASCII character.
 * \param B the second ASCII character.
 * \param C the third ASCII character.
 * \param D the fourth ASCII character.
 * \returns the four characters converted into a Uint32, one character
 *          per-byte.
 *
 * \threadsafety It is safe to call this macro from any thread.
 *
 * \since This macro is available since SDL 3.2.0.
 *)
function SDL_FourCC(const A, B, C, D: Byte): UInt32; inline;

(**
 * Allocate uninitialized memory.
 *
 * The allocated memory returned by this function must be freed with
 * SDL_free().
 *
 * If `size` is 0, it will be set to 1.
 *
 * If you want to allocate memory aligned to a specific alignment, consider
 * using SDL_aligned_alloc().
 *
 * \param size the size to allocate.
 * \returns a pointer to the allocated memory, or NULL if allocation failed.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_free
 * \sa SDL_calloc
 * \sa SDL_realloc
 * \sa SDL_aligned_alloc
 *)
function SDL_malloc(size: NativeUInt): Pointer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_malloc';

(**
 * Allocate a zero-initialized array.
 *
 * The memory returned by this function must be freed with SDL_free().
 *
 * If either of `nmemb` or `size` is 0, they will both be set to 1.
 *
 * \param nmemb the number of elements in the array.
 * \param size the size of each element of the array.
 * \returns a pointer to the allocated array, or NULL if allocation failed.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_free
 * \sa SDL_malloc
 * \sa SDL_realloc
 *)
function SDL_calloc(nmemb: NativeUInt; size: NativeUInt): Pointer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_calloc';

(**
 * Change the size of allocated memory.
 *
 * The memory returned by this function must be freed with SDL_free().
 *
 * If `size` is 0, it will be set to 1. Note that this is unlike some other C
 * runtime `realloc` implementations, which may treat `realloc(mem, 0)` the
 * same way as `free(mem)`.
 *
 * If `mem` is NULL, the behavior of this function is equivalent to
 * SDL_malloc(). Otherwise, the function can have one of three possible
 * outcomes:
 *
 * - If it returns the same pointer as `mem`, it means that `mem` was resized
 *   in place without freeing.
 * - If it returns a different non-NULL pointer, it means that `mem` was freed
 *   and cannot be dereferenced anymore.
 * - If it returns NULL (indicating failure), then `mem` will remain valid and
 *   must still be freed with SDL_free().
 *
 * \param mem a pointer to allocated memory to reallocate, or NULL.
 * \param size the new size of the memory.
 * \returns a pointer to the newly allocated memory, or NULL if allocation
 *          failed.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_free
 * \sa SDL_malloc
 * \sa SDL_calloc
 *)
function SDL_realloc(mem: Pointer; size: NativeUInt): Pointer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_realloc';

(**
 * Free allocated memory.
 *
 * The pointer is no longer valid after this call and cannot be dereferenced
 * anymore.
 *
 * If `mem` is NULL, this function does nothing.
 *
 * \param mem a pointer to allocated memory, or NULL.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_malloc
 * \sa SDL_calloc
 * \sa SDL_realloc
 *)
procedure SDL_free(mem: Pointer); cdecl;
  external LIB_SDL3 name _PU + 'SDL_free';

type
  (**
   * A callback used to implement SDL_malloc().
   *
   * SDL will always ensure that the passed `size` is greater than 0.
   *
   * \param size the size to allocate.
   * \returns a pointer to the allocated memory, or NULL if allocation failed.
   *
   * \threadsafety It should be safe to call this callback from any thread.
   *
   * \since This datatype is available since SDL 3.2.0.
   *
   * \sa SDL_malloc
   * \sa SDL_GetOriginalMemoryFunctions
   * \sa SDL_GetMemoryFunctions
   * \sa SDL_SetMemoryFunctions
   *)
  SDL_malloc_func = function(size: NativeInt): Pointer; cdecl;
  PSDL_malloc_func = ^SDL_malloc_func;

  (**
   * A callback used to implement SDL_calloc().
   *
   * SDL will always ensure that the passed `nmemb` and `size` are both greater
   * than 0.
   *
   * \param nmemb the number of elements in the array.
   * \param size the size of each element of the array.
   * \returns a pointer to the allocated array, or NULL if allocation failed.
   *
   * \threadsafety It should be safe to call this callback from any thread.
   *
   * \since This datatype is available since SDL 3.2.0.
   *
   * \sa SDL_calloc
   * \sa SDL_GetOriginalMemoryFunctions
   * \sa SDL_GetMemoryFunctions
   * \sa SDL_SetMemoryFunctions
   *)
  SDL_calloc_func = function(nmemb: NativeInt; size: NativeInt): Pointer; cdecl;
  PSDL_calloc_func = ^SDL_calloc_func;

  (**
   * A callback used to implement SDL_realloc().
   *
   * SDL will always ensure that the passed `size` is greater than 0.
   *
   * \param mem a pointer to allocated memory to reallocate, or NULL.
   * \param size the new size of the memory.
   * \returns a pointer to the newly allocated memory, or NULL if allocation
   *          failed.
   *
   * \threadsafety It should be safe to call this callback from any thread.
   *
   * \since This datatype is available since SDL 3.2.0.
   *
   * \sa SDL_realloc
   * \sa SDL_GetOriginalMemoryFunctions
   * \sa SDL_GetMemoryFunctions
   * \sa SDL_SetMemoryFunctions
   *)
  SDL_realloc_func = function(mem: Pointer; size: NativeInt): Pointer; cdecl;
  PSDL_realloc_func = ^SDL_realloc_func;

  (**
   * A callback used to implement SDL_free().
   *
   * SDL will always ensure that the passed `mem` is a non-NULL pointer.
   *
   * \param mem a pointer to allocated memory.
   *
   * \threadsafety It should be safe to call this callback from any thread.
   *
   * \since This datatype is available since SDL 3.2.0.
   *
   * \sa SDL_free
   * \sa SDL_GetOriginalMemoryFunctions
   * \sa SDL_GetMemoryFunctions
   * \sa SDL_SetMemoryFunctions
   *)
  SDL_free_func = procedure(mem: Pointer); cdecl;
  PSDL_free_func = ^SDL_free_func;

(**
 * Get the original set of SDL memory functions.
 *
 * This is what SDL_malloc and friends will use by default, if there has been
 * no call to SDL_SetMemoryFunctions. This is not necessarily using the C
 * runtime's `malloc` functions behind the scenes! Different platforms and
 * build configurations might do any number of unexpected things.
 *
 * \param malloc_func filled with malloc function.
 * \param calloc_func filled with calloc function.
 * \param realloc_func filled with realloc function.
 * \param free_func filled with free function.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_GetOriginalMemoryFunctions(malloc_func: PSDL_malloc_func; calloc_func: PSDL_calloc_func; realloc_func: PSDL_realloc_func; free_func: PSDL_free_func); cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetOriginalMemoryFunctions';

(**
 * Get the current set of SDL memory functions.
 *
 * \param malloc_func filled with malloc function.
 * \param calloc_func filled with calloc function.
 * \param realloc_func filled with realloc function.
 * \param free_func filled with free function.
 *
 * \threadsafety This does not hold a lock, so do not call this in the
 *               unlikely event of a background thread calling
 *               SDL_SetMemoryFunctions simultaneously.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetMemoryFunctions
 * \sa SDL_GetOriginalMemoryFunctions
 *)
procedure SDL_GetMemoryFunctions(malloc_func: PSDL_malloc_func; calloc_func: PSDL_calloc_func; realloc_func: PSDL_realloc_func; free_func: PSDL_free_func); cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetMemoryFunctions';

(**
 * Replace SDL's memory allocation functions with a custom set.
 *
 * It is not safe to call this function once any allocations have been made,
 * as future calls to SDL_free will use the new allocator, even if they came
 * from an SDL_malloc made with the old one!
 *
 * If used, usually this needs to be the first call made into the SDL library,
 * if not the very first thing done at program startup time.
 *
 * \param malloc_func custom malloc function.
 * \param calloc_func custom calloc function.
 * \param realloc_func custom realloc function.
 * \param free_func custom free function.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety It is safe to call this function from any thread, but one
 *               should not replace the memory functions once any allocations
 *               are made!
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetMemoryFunctions
 * \sa SDL_GetOriginalMemoryFunctions
 *)
function SDL_SetMemoryFunctions(malloc_func: SDL_malloc_func; calloc_func: SDL_calloc_func; realloc_func: SDL_realloc_func; free_func: SDL_free_func): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetMemoryFunctions';

(**
 * Allocate memory aligned to a specific alignment.
 *
 * The memory returned by this function must be freed with SDL_aligned_free(),
 * _not_ SDL_free().
 *
 * If `alignment` is less than the size of `void *`, it will be increased to
 * match that.
 *
 * The returned memory address will be a multiple of the alignment value, and
 * the size of the memory allocated will be a multiple of the alignment value.
 *
 * \param alignment the alignment of the memory.
 * \param size the size to allocate.
 * \returns a pointer to the aligned memory, or NULL if allocation failed.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_aligned_free
 *)
function SDL_aligned_alloc(alignment: NativeUInt; size: NativeUInt): Pointer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_aligned_alloc';

(**
 * Free memory allocated by SDL_aligned_alloc().
 *
 * The pointer is no longer valid after this call and cannot be dereferenced
 * anymore.
 *
 * If `mem` is NULL, this function does nothing.
 *
 * \param mem a pointer previously returned by SDL_aligned_alloc(), or NULL.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_aligned_alloc
 *)
procedure SDL_aligned_free(mem: Pointer); cdecl;
  external LIB_SDL3 name _PU + 'SDL_aligned_free';

(**
 * Get the number of outstanding (unfreed) allocations.
 *
 * \returns the number of allocations or -1 if allocation counting is
 *          disabled.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetNumAllocations(): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetNumAllocations';

type
  (**
   * A thread-safe set of environment variables
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_GetEnvironment
   * \sa SDL_CreateEnvironment
   * \sa SDL_GetEnvironmentVariable
   * \sa SDL_GetEnvironmentVariables
   * \sa SDL_SetEnvironmentVariable
   * \sa SDL_UnsetEnvironmentVariable
   * \sa SDL_DestroyEnvironment
   *)
  SDL_Environment = THandle;

(**
 * Get the process environment.
 *
 * This is initialized at application start and is not affected by setenv()
 * and unsetenv() calls after that point. Use SDL_SetEnvironmentVariable() and
 * SDL_UnsetEnvironmentVariable() if you want to modify this environment, or
 * SDL_setenv_unsafe() or SDL_unsetenv_unsafe() if you want changes to persist
 * in the C runtime environment after SDL_Quit().
 *
 * \returns a pointer to the environment for the process or NULL on failure;
 *          call SDL_GetError() for more information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetEnvironmentVariable
 * \sa SDL_GetEnvironmentVariables
 * \sa SDL_SetEnvironmentVariable
 * \sa SDL_UnsetEnvironmentVariable
 *)
function SDL_GetEnvironment(): SDL_Environment; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetEnvironment';

(**
 * Create a set of environment variables
 *
 * \param populated true to initialize it from the C runtime environment,
 *                  false to create an empty environment.
 * \returns a pointer to the new environment or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * \threadsafety If `populated` is false, it is safe to call this function
 *               from any thread, otherwise it is safe if no other threads are
 *               calling setenv() or unsetenv()
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetEnvironmentVariable
 * \sa SDL_GetEnvironmentVariables
 * \sa SDL_SetEnvironmentVariable
 * \sa SDL_UnsetEnvironmentVariable
 * \sa SDL_DestroyEnvironment
 *)
function SDL_CreateEnvironment(populated: Boolean): SDL_Environment; cdecl;
  external LIB_SDL3 name _PU + 'SDL_CreateEnvironment';

(**
 * Get the value of a variable in the environment.
 *
 * \param env the environment to query.
 * \param name the name of the variable to get.
 * \returns a pointer to the value of the variable or NULL if it can't be
 *          found.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetEnvironment
 * \sa SDL_CreateEnvironment
 * \sa SDL_GetEnvironmentVariables
 * \sa SDL_SetEnvironmentVariable
 * \sa SDL_UnsetEnvironmentVariable
 *)
function SDL_GetEnvironmentVariable(env: SDL_Environment; const name: PUTF8Char): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetEnvironmentVariable';

(**
 * Get all variables in the environment.
 *
 * \param env the environment to query.
 * \returns a NULL terminated array of pointers to environment variables in
 *          the form "variable=value" or NULL on failure; call SDL_GetError()
 *          for more information. This is a single allocation that should be
 *          freed with SDL_free() when it is no longer needed.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetEnvironment
 * \sa SDL_CreateEnvironment
 * \sa SDL_GetEnvironmentVariables
 * \sa SDL_SetEnvironmentVariable
 * \sa SDL_UnsetEnvironmentVariable
 *)
function SDL_GetEnvironmentVariables(env: SDL_Environment): PPUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetEnvironmentVariables';

(**
 * Set the value of a variable in the environment.
 *
 * \param env the environment to modify.
 * \param name the name of the variable to set.
 * \param value the value of the variable to set.
 * \param overwrite true to overwrite the variable if it exists, false to
 *                  return success without setting the variable if it already
 *                  exists.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetEnvironment
 * \sa SDL_CreateEnvironment
 * \sa SDL_GetEnvironmentVariable
 * \sa SDL_GetEnvironmentVariables
 * \sa SDL_UnsetEnvironmentVariable
 *)
function SDL_SetEnvironmentVariable(env: SDL_Environment; const name: PUTF8Char; const value: PUTF8Char; overwrite: Boolean): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetEnvironmentVariable';

(**
 * Clear a variable from the environment.
 *
 * \param env the environment to modify.
 * \param name the name of the variable to unset.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetEnvironment
 * \sa SDL_CreateEnvironment
 * \sa SDL_GetEnvironmentVariable
 * \sa SDL_GetEnvironmentVariables
 * \sa SDL_SetEnvironmentVariable
 * \sa SDL_UnsetEnvironmentVariable
 *)
function SDL_UnsetEnvironmentVariable(env: SDL_Environment; const name: PUTF8Char): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_UnsetEnvironmentVariable';

(**
 * Destroy a set of environment variables.
 *
 * \param env the environment to destroy.
 *
 * \threadsafety It is safe to call this function from any thread, as long as
 *               the environment is no longer in use.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CreateEnvironment
 *)
procedure SDL_DestroyEnvironment(env: SDL_Environment); cdecl;
  external LIB_SDL3 name _PU + 'SDL_DestroyEnvironment';

(**
 * Get the value of a variable in the environment.
 *
 * This function uses SDL's cached copy of the environment and is thread-safe.
 *
 * \param name the name of the variable to get.
 * \returns a pointer to the value of the variable or NULL if it can't be
 *          found.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_getenv(const name: PUTF8Char): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_getenv';

(**
 * Get the value of a variable in the environment.
 *
 * This function bypasses SDL's cached copy of the environment and is not
 * thread-safe.
 *
 * \param name the name of the variable to get.
 * \returns a pointer to the value of the variable or NULL if it can't be
 *          found.
 *
 * \threadsafety This function is not thread safe, consider using SDL_getenv()
 *               instead.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_getenv
 *)
function SDL_getenv_unsafe(const name: PUTF8Char): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_getenv_unsafe';

(**
 * Set the value of a variable in the environment.
 *
 * \param name the name of the variable to set.
 * \param value the value of the variable to set.
 * \param overwrite 1 to overwrite the variable if it exists, 0 to return
 *                  success without setting the variable if it already exists.
 * \returns 0 on success, -1 on error.
 *
 * \threadsafety This function is not thread safe, consider using
 *               SDL_SetEnvironmentVariable() instead.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetEnvironmentVariable
 *)
function SDL_setenv_unsafe(const name: PUTF8Char; const value: PUTF8Char; overwrite: Integer): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_setenv_unsafe';

(**
 * Clear a variable from the environment.
 *
 * \param name the name of the variable to unset.
 * \returns 0 on success, -1 on error.
 *
 * \threadsafety This function is not thread safe, consider using
 *               SDL_UnsetEnvironmentVariable() instead.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_UnsetEnvironmentVariable
 *)
function SDL_unsetenv_unsafe(const name: PUTF8Char): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_unsetenv_unsafe';

type
  (**
   * A callback used with SDL sorting and binary search functions.
   *
   * \param a a pointer to the first element being compared.
   * \param b a pointer to the second element being compared.
   * \returns -1 if `a` should be sorted before `b`, 1 if `b` should be sorted
   *          before `a`, 0 if they are equal. If two elements are equal, their
   *          order in the sorted array is undefined.
   *
   * \since This callback is available since SDL 3.2.0.
   *
   * \sa SDL_bsearch
   * \sa SDL_qsort
   *)
  SDL_CompareCallback = function(const a: Pointer; const b: Pointer): Integer; cdecl;

(**
 * Sort an array.
 *
 * For example:
 *
 * ```c
 * typedef struct {
 *     int key;
 *     const char *string;
 * } data;
 *
 * int SDLCALL compare(const void *a, const void *b)
 * {
 *     const data *A = (const data * )a;
 *     const data *B = (const data * )b;
 *
 *     if (A->n < B->n) {
 *         return -1;
 *     } else if (B->n < A->n) {
 *         return 1;
 *     } else {
 *         return 0;
 *     }
 * }
 *
 * data values[] = {
 *     { 3, "third" }, { 1, "first" }, { 2, "second" }
 * };
 *
 * SDL_qsort(values, SDL_arraysize(values), sizeof(values[0]), compare);
 * ```
 *
 * \param base a pointer to the start of the array.
 * \param nmemb the number of elements in the array.
 * \param size the size of the elements in the array.
 * \param compare a function used to compare elements in the array.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_bsearch
 * \sa SDL_qsort_r
 *)
procedure SDL_qsort(base: Pointer; nmemb: NativeUInt; size: NativeUInt; compare: SDL_CompareCallback); cdecl;
  external LIB_SDL3 name _PU + 'SDL_qsort';

(**
 * Perform a binary search on a previously sorted array.
 *
 * For example:
 *
 * ```c
 * typedef struct {
 *     int key;
 *     const char *string;
 * } data;
 *
 * int SDLCALL compare(const void *a, const void *b)
 * {
 *     const data *A = (const data * )a;
 *     const data *B = (const data * )b;
 *
 *     if (A->n < B->n) {
 *         return -1;
 *     } else if (B->n < A->n) {
 *         return 1;
 *     } else {
 *         return 0;
 *     }
 * }
 *
 * data values[] = {
 *     { 1, "first" }, { 2, "second" }, { 3, "third" }
 * };
 * data key = { 2, NULL };
 *
 * data *result = SDL_bsearch(&key, values, SDL_arraysize(values), sizeof(values[0]), compare);
 * ```
 *
 * \param key a pointer to a key equal to the element being searched for.
 * \param base a pointer to the start of the array.
 * \param nmemb the number of elements in the array.
 * \param size the size of the elements in the array.
 * \param compare a function used to compare elements in the array.
 * \returns a pointer to the matching element in the array, or NULL if not
 *          found.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_bsearch_r
 * \sa SDL_qsort
 *)
function SDL_bsearch(const key: Pointer; const base: Pointer; nmemb: NativeUInt; size: NativeUInt; compare: SDL_CompareCallback): Pointer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_bsearch';

type
  (**
   * A callback used with SDL sorting and binary search functions.
   *
   * \param userdata the `userdata` pointer passed to the sort function.
   * \param a a pointer to the first element being compared.
   * \param b a pointer to the second element being compared.
   * \returns -1 if `a` should be sorted before `b`, 1 if `b` should be sorted
   *          before `a`, 0 if they are equal. If two elements are equal, their
   *          order in the sorted array is undefined.
   *
   * \since This callback is available since SDL 3.2.0.
   *
   * \sa SDL_qsort_r
   * \sa SDL_bsearch_r
   *)
  SDL_CompareCallback_r = function(userdata: Pointer; const a: Pointer; const b: Pointer): Integer; cdecl;

(**
 * Sort an array, passing a userdata pointer to the compare function.
 *
 * For example:
 *
 * ```c
 * typedef enum {
 *     sort_increasing,
 *     sort_decreasing,
 * } sort_method;
 *
 * typedef struct {
 *     int key;
 *     const char *string;
 * } data;
 *
 * int SDLCALL compare(const void *userdata, const void *a, const void *b)
 * {
 *     sort_method method = (sort_method)(uintptr_t)userdata;
 *     const data *A = (const data * )a;
 *     const data *B = (const data * )b;
 *
 *     if (A->key < B->key) {
 *         return (method == sort_increasing) ? -1 : 1;
 *     } else if (B->key < A->key) {
 *         return (method == sort_increasing) ? 1 : -1;
 *     } else {
 *         return 0;
 *     }
 * }
 *
 * data values[] = {
 *     { 3, "third" }, { 1, "first" }, { 2, "second" }
 * };
 *
 * SDL_qsort_r(values, SDL_arraysize(values), sizeof(values[0]), compare, (const void * )(uintptr_t)sort_increasing);
 * ```
 *
 * \param base a pointer to the start of the array.
 * \param nmemb the number of elements in the array.
 * \param size the size of the elements in the array.
 * \param compare a function used to compare elements in the array.
 * \param userdata a pointer to pass to the compare function.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_bsearch_r
 * \sa SDL_qsort
 *)
procedure SDL_qsort_r(base: Pointer; nmemb: NativeUInt; size: NativeUInt; compare: SDL_CompareCallback_r; userdata: Pointer); cdecl;
  external LIB_SDL3 name _PU + 'SDL_qsort_r';

(**
 * Perform a binary search on a previously sorted array, passing a userdata
 * pointer to the compare function.
 *
 * For example:
 *
 * ```c
 * typedef enum {
 *     sort_increasing,
 *     sort_decreasing,
 * } sort_method;
 *
 * typedef struct {
 *     int key;
 *     const char *string;
 * } data;
 *
 * int SDLCALL compare(const void *userdata, const void *a, const void *b)
 * {
 *     sort_method method = (sort_method)(uintptr_t)userdata;
 *     const data *A = (const data * )a;
 *     const data *B = (const data * )b;
 *
 *     if (A->key < B->key) {
 *         return (method == sort_increasing) ? -1 : 1;
 *     } else if (B->key < A->key) {
 *         return (method == sort_increasing) ? 1 : -1;
 *     } else {
 *         return 0;
 *     }
 * }
 *
 * data values[] = {
 *     { 1, "first" }, { 2, "second" }, { 3, "third" }
 * };
 * data key = { 2, NULL };
 *
 * data *result = SDL_bsearch_r(&key, values, SDL_arraysize(values), sizeof(values[0]), compare, (const void * )(uintptr_t)sort_increasing);
 * ```
 *
 * \param key a pointer to a key equal to the element being searched for.
 * \param base a pointer to the start of the array.
 * \param nmemb the number of elements in the array.
 * \param size the size of the elements in the array.
 * \param compare a function used to compare elements in the array.
 * \param userdata a pointer to pass to the compare function.
 * \returns a pointer to the matching element in the array, or NULL if not
 *          found.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_bsearch
 * \sa SDL_qsort_r
 *)
function SDL_bsearch_r(const key: Pointer; const base: Pointer; nmemb: NativeUInt; size: NativeUInt; compare: SDL_CompareCallback_r; userdata: Pointer): Pointer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_bsearch_r';

(**
 * Compute the absolute value of `x`.
 *
 * \param x an integer value.
 * \returns the absolute value of x.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_abs(x: Integer): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_abs';

(**
 * Query if a character is alphabetic (a letter).
 *
 * **WARNING**: Regardless of system locale, this will only treat ASCII values
 * for English 'a-z' and 'A-Z' as true.
 *
 * \param x character value to check.
 * \returns non-zero if x falls within the character class, zero otherwise.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_isalpha(x: Integer): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_isalpha';

(**
 * Query if a character is alphabetic (a letter) or a number.
 *
 * **WARNING**: Regardless of system locale, this will only treat ASCII values
 * for English 'a-z', 'A-Z', and '0-9' as true.
 *
 * \param x character value to check.
 * \returns non-zero if x falls within the character class, zero otherwise.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_isalnum(x: Integer): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_isalnum';

(**
 * Report if a character is blank (a space or tab).
 *
 * **WARNING**: Regardless of system locale, this will only treat ASCII values
 * 0x20 (space) or 0x9 (tab) as true.
 *
 * \param x character value to check.
 * \returns non-zero if x falls within the character class, zero otherwise.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_isblank(x: Integer): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_isblank';

(**
 * Report if a character is a control character.
 *
 * **WARNING**: Regardless of system locale, this will only treat ASCII values
 * 0 through 0x1F, and 0x7F, as true.
 *
 * \param x character value to check.
 * \returns non-zero if x falls within the character class, zero otherwise.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_iscntrl(x: Integer): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_iscntrl';

(**
 * Report if a character is a numeric digit.
 *
 * **WARNING**: Regardless of system locale, this will only treat ASCII values
 * '0' (0x30) through '9' (0x39), as true.
 *
 * \param x character value to check.
 * \returns non-zero if x falls within the character class, zero otherwise.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_isdigit(x: Integer): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_isdigit';

(**
 * Report if a character is a hexadecimal digit.
 *
 * **WARNING**: Regardless of system locale, this will only treat ASCII values
 * 'A' through 'F', 'a' through 'f', and '0' through '9', as true.
 *
 * \param x character value to check.
 * \returns non-zero if x falls within the character class, zero otherwise.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_isxdigit(x: Integer): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_isxdigit';

(**
 * Report if a character is a punctuation mark.
 *
 * **WARNING**: Regardless of system locale, this is equivalent to
 * `((SDL_isgraph(x)) && (!SDL_isalnum(x)))`.
 *
 * \param x character value to check.
 * \returns non-zero if x falls within the character class, zero otherwise.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_isgraph
 * \sa SDL_isalnum
 *)
function SDL_ispunct(x: Integer): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_ispunct';

(**
 * Report if a character is whitespace.
 *
 * **WARNING**: Regardless of system locale, this will only treat the
 * following ASCII values as true:
 *
 * - space (0x20)
 * - tab (0x09)
 * - newline (0x0A)
 * - vertical tab (0x0B)
 * - form feed (0x0C)
 * - return (0x0D)
 *
 * \param x character value to check.
 * \returns non-zero if x falls within the character class, zero otherwise.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_isspace(x: Integer): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_isspace';

(**
 * Report if a character is upper case.
 *
 * **WARNING**: Regardless of system locale, this will only treat ASCII values
 * 'A' through 'Z' as true.
 *
 * \param x character value to check.
 * \returns non-zero if x falls within the character class, zero otherwise.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_isupper(x: Integer): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_isupper';

(**
 * Report if a character is lower case.
 *
 * **WARNING**: Regardless of system locale, this will only treat ASCII values
 * 'a' through 'z' as true.
 *
 * \param x character value to check.
 * \returns non-zero if x falls within the character class, zero otherwise.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_islower(x: Integer): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_islower';

(**
 * Report if a character is "printable".
 *
 * Be advised that "printable" has a definition that goes back to text
 * terminals from the dawn of computing, making this a sort of special case
 * function that is not suitable for Unicode (or most any) text management.
 *
 * **WARNING**: Regardless of system locale, this will only treat ASCII values
 * ' ' (0x20) through '~' (0x7E) as true.
 *
 * \param x character value to check.
 * \returns non-zero if x falls within the character class, zero otherwise.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_isprint(x: Integer): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_isprint';

(**
 * Report if a character is any "printable" except space.
 *
 * Be advised that "printable" has a definition that goes back to text
 * terminals from the dawn of computing, making this a sort of special case
 * function that is not suitable for Unicode (or most any) text management.
 *
 * **WARNING**: Regardless of system locale, this is equivalent to
 * `(SDL_isprint(x)) && ((x) != ' ')`.
 *
 * \param x character value to check.
 * \returns non-zero if x falls within the character class, zero otherwise.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_isprint
 *)
function SDL_isgraph(x: Integer): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_isgraph';

(**
 * Convert low-ASCII English letters to uppercase.
 *
 * **WARNING**: Regardless of system locale, this will only convert ASCII
 * values 'a' through 'z' to uppercase.
 *
 * This function returns the uppercase equivalent of `x`. If a character
 * cannot be converted, or is already uppercase, this function returns `x`.
 *
 * \param x character value to check.
 * \returns capitalized version of x, or x if no conversion available.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_toupper(x: Integer): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_toupper';

(**
 * Convert low-ASCII English letters to lowercase.
 *
 * **WARNING**: Regardless of system locale, this will only convert ASCII
 * values 'A' through 'Z' to lowercase.
 *
 * This function returns the lowercase equivalent of `x`. If a character
 * cannot be converted, or is already lowercase, this function returns `x`.
 *
 * \param x character value to check.
 * \returns lowercase version of x, or x if no conversion available.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_tolower(x: Integer): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_tolower';

(**
 * Calculate a CRC-16 value.
 *
 * https://en.wikipedia.org/wiki/Cyclic_redundancy_check
 *
 * This function can be called multiple times, to stream data to be
 * checksummed in blocks. Each call must provide the previous CRC-16 return
 * value to be updated with the next block. The first call to this function
 * for a set of blocks should pass in a zero CRC value.
 *
 * \param crc the current checksum for this data set, or 0 for a new data set.
 * \param data a new block of data to add to the checksum.
 * \param len the size, in bytes, of the new block of data.
 * \returns a CRC-16 checksum value of all blocks in the data set.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_crc16(crc: Uint16; const data: Pointer; len: NativeUInt): Uint16; cdecl;
  external LIB_SDL3 name _PU + 'SDL_crc16';

(**
 * Calculate a CRC-32 value.
 *
 * https://en.wikipedia.org/wiki/Cyclic_redundancy_check
 *
 * This function can be called multiple times, to stream data to be
 * checksummed in blocks. Each call must provide the previous CRC-32 return
 * value to be updated with the next block. The first call to this function
 * for a set of blocks should pass in a zero CRC value.
 *
 * \param crc the current checksum for this data set, or 0 for a new data set.
 * \param data a new block of data to add to the checksum.
 * \param len the size, in bytes, of the new block of data.
 * \returns a CRC-32 checksum value of all blocks in the data set.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_crc32(crc: Uint32; const data: Pointer; len: NativeUInt): Uint32; cdecl;
  external LIB_SDL3 name _PU + 'SDL_crc32';

(**
 * Calculate a 32-bit MurmurHash3 value for a block of data.
 *
 * https://en.wikipedia.org/wiki/MurmurHash
 *
 * A seed may be specified, which changes the final results consistently, but
 * this does not work like SDL_crc16 and SDL_crc32: you can't feed a previous
 * result from this function back into itself as the next seed value to
 * calculate a hash in chunks; it won't produce the same hash as it would if
 * the same data was provided in a single call.
 *
 * If you aren't sure what to provide for a seed, zero is fine. Murmur3 is not
 * cryptographically secure, so it shouldn't be used for hashing top-secret
 * data.
 *
 * \param data the data to be hashed.
 * \param len the size of data, in bytes.
 * \param seed a value that alters the final hash value.
 * \returns a Murmur3 32-bit hash value.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_murmur3_32(const data: Pointer; len: NativeUInt; seed: Uint32): Uint32; cdecl;
  external LIB_SDL3 name _PU + 'SDL_murmur3_32';

(**
 * Copy non-overlapping memory.
 *
 * The memory regions must not overlap. If they do, use SDL_memmove() instead.
 *
 * \param dst The destination memory region. Must not be NULL, and must not
 *            overlap with `src`.
 * \param src The source memory region. Must not be NULL, and must not overlap
 *            with `dst`.
 * \param len The length in bytes of both `dst` and `src`.
 * \returns `dst`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_memmove
 *)
function SDL_memcpy(dst: Pointer; const src: Pointer; len: NativeUInt): Pointer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_memcpy';

(**
 * Copy memory ranges that might overlap.
 *
 * It is okay for the memory regions to overlap. If you are confident that the
 * regions never overlap, using SDL_memcpy() may improve performance.
 *
 * \param dst The destination memory region. Must not be NULL.
 * \param src The source memory region. Must not be NULL.
 * \param len The length in bytes of both `dst` and `src`.
 * \returns `dst`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_memcpy
 *)
function SDL_memmove(dst: Pointer; const src: Pointer; len: NativeUInt): Pointer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_memmove';

(**
 * Initialize all bytes of buffer of memory to a specific value.
 *
 * This function will set `len` bytes, pointed to by `dst`, to the value
 * specified in `c`.
 *
 * Despite `c` being an `int` instead of a `char`, this only operates on
 * bytes; `c` must be a value between 0 and 255, inclusive.
 *
 * \param dst the destination memory region. Must not be NULL.
 * \param c the byte value to set.
 * \param len the length, in bytes, to set in `dst`.
 * \returns `dst`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_memset(dst: Pointer; c: Integer; len: NativeUInt): Pointer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_memset';

(**
 * Initialize all 32-bit words of buffer of memory to a specific value.
 *
 * This function will set a buffer of `dwords` Uint32 values, pointed to by
 * `dst`, to the value specified in `val`.
 *
 * Unlike SDL_memset, this sets 32-bit values, not bytes, so it's not limited
 * to a range of 0-255.
 *
 * \param dst the destination memory region. Must not be NULL.
 * \param val the Uint32 value to set.
 * \param dwords the number of Uint32 values to set in `dst`.
 * \returns `dst`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_memset4(dst: Pointer; val: Uint32; dwords: NativeUInt): Pointer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_memset4';

(**
 * Compare two buffers of memory.
 *
 * \param s1 the first buffer to compare. NULL is not permitted!
 * \param s2 the second buffer to compare. NULL is not permitted!
 * \param len the number of bytes to compare between the buffers.
 * \returns less than zero if s1 is "less than" s2, greater than zero if s1 is
 *          "greater than" s2, and zero if the buffers match exactly for `len`
 *          bytes.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_memcmp(const s1: Pointer; const s2: Pointer; len: NativeUInt): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_memcmp';

(**
 * This works exactly like wcslen() but doesn't require access to a C runtime.
 *
 * Counts the number of wchar_t values in `wstr`, excluding the null
 * terminator.
 *
 * Like SDL_strlen only counts bytes and not codepoints in a UTF-8 string,
 * this counts wchar_t values in a string, even if the string's encoding is of
 * variable width, like UTF-16.
 *
 * Also be aware that wchar_t is different sizes on different platforms (4
 * bytes on Linux, 2 on Windows, etc).
 *
 * \param wstr The null-terminated wide string to read. Must not be NULL.
 * \returns the length (in wchar_t values, excluding the null terminator) of
 *          `wstr`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_wcsnlen
 * \sa SDL_utf8strlen
 * \sa SDL_utf8strnlen
 *)
function SDL_wcslen(const wstr: PWideChar): NativeUInt; cdecl;
  external LIB_SDL3 name _PU + 'SDL_wcslen';

(**
 * This works exactly like wcsnlen() but doesn't require access to a C
 * runtime.
 *
 * Counts up to a maximum of `maxlen` wchar_t values in `wstr`, excluding the
 * null terminator.
 *
 * Like SDL_strnlen only counts bytes and not codepoints in a UTF-8 string,
 * this counts wchar_t values in a string, even if the string's encoding is of
 * variable width, like UTF-16.
 *
 * Also be aware that wchar_t is different sizes on different platforms (4
 * bytes on Linux, 2 on Windows, etc).
 *
 * Also, `maxlen` is a count of wide characters, not bytes!
 *
 * \param wstr The null-terminated wide string to read. Must not be NULL.
 * \param maxlen The maximum amount of wide characters to count.
 * \returns the length (in wide characters, excluding the null terminator) of
 *          `wstr` but never more than `maxlen`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_wcslen
 * \sa SDL_utf8strlen
 * \sa SDL_utf8strnlen
 *)
function SDL_wcsnlen(const wstr: PWideChar; maxlen: NativeUInt): NativeUInt; cdecl;
  external LIB_SDL3 name _PU + 'SDL_wcsnlen';

(**
 * Copy a wide string.
 *
 * This function copies `maxlen` - 1 wide characters from `src` to `dst`, then
 * appends a null terminator.
 *
 * `src` and `dst` must not overlap.
 *
 * If `maxlen` is 0, no wide characters are copied and no null terminator is
 * written.
 *
 * \param dst The destination buffer. Must not be NULL, and must not overlap
 *            with `src`.
 * \param src The null-terminated wide string to copy. Must not be NULL, and
 *            must not overlap with `dst`.
 * \param maxlen The length (in wide characters) of the destination buffer.
 * \returns the length (in wide characters, excluding the null terminator) of
 *          `src`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_wcslcat
 *)
function SDL_wcslcpy(dst: PWideChar; const src: PWideChar; maxlen: NativeUInt): NativeUInt; cdecl;
  external LIB_SDL3 name _PU + 'SDL_wcslcpy';

(**
 * Concatenate wide strings.
 *
 * This function appends up to `maxlen` - SDL_wcslen(dst) - 1 wide characters
 * from `src` to the end of the wide string in `dst`, then appends a null
 * terminator.
 *
 * `src` and `dst` must not overlap.
 *
 * If `maxlen` - SDL_wcslen(dst) - 1 is less than or equal to 0, then `dst` is
 * unmodified.
 *
 * \param dst The destination buffer already containing the first
 *            null-terminated wide string. Must not be NULL and must not
 *            overlap with `src`.
 * \param src The second null-terminated wide string. Must not be NULL, and
 *            must not overlap with `dst`.
 * \param maxlen The length (in wide characters) of the destination buffer.
 * \returns the length (in wide characters, excluding the null terminator) of
 *          the string in `dst` plus the length of `src`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_wcslcpy
 *)
function SDL_wcslcat(dst: PWideChar; const src: PWideChar; maxlen: NativeUInt): NativeUInt; cdecl;
  external LIB_SDL3 name _PU + 'SDL_wcslcat';

(**
 * Allocate a copy of a wide string.
 *
 * This allocates enough space for a null-terminated copy of `wstr`, using
 * SDL_malloc, and then makes a copy of the string into this space.
 *
 * The returned string is owned by the caller, and should be passed to
 * SDL_free when no longer needed.
 *
 * \param wstr the string to copy.
 * \returns a pointer to the newly-allocated wide string.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_wcsdup(const wstr: PWideChar): PWideChar; cdecl;
  external LIB_SDL3 name _PU + 'SDL_wcsdup';

(**
 * Search a wide string for the first instance of a specific substring.
 *
 * The search ends once it finds the requested substring, or a null terminator
 * byte to end the string.
 *
 * Note that this looks for strings of _wide characters_, not _codepoints_, so
 * it's legal to search for malformed and incomplete UTF-16 sequences.
 *
 * \param haystack the wide string to search. Must not be NULL.
 * \param needle the wide string to search for. Must not be NULL.
 * \returns a pointer to the first instance of `needle` in the string, or NULL
 *          if not found.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_wcsstr(const haystack: PWideChar; const needle: PWideChar): PWideChar; cdecl;
  external LIB_SDL3 name _PU + 'SDL_wcsstr';

(**
 * Search a wide string, up to n wide chars, for the first instance of a
 * specific substring.
 *
 * The search ends once it finds the requested substring, or a null terminator
 * value to end the string, or `maxlen` wide character have been examined. It
 * is possible to use this function on a wide string without a null
 * terminator.
 *
 * Note that this looks for strings of _wide characters_, not _codepoints_, so
 * it's legal to search for malformed and incomplete UTF-16 sequences.
 *
 * \param haystack the wide string to search. Must not be NULL.
 * \param needle the wide string to search for. Must not be NULL.
 * \param maxlen the maximum number of wide characters to search in
 *               `haystack`.
 * \returns a pointer to the first instance of `needle` in the string, or NULL
 *          if not found.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_wcsnstr(const haystack: PWideChar; const needle: PWideChar; maxlen: NativeUInt): PWideChar; cdecl;
  external LIB_SDL3 name _PU + 'SDL_wcsnstr';

(**
 * Compare two null-terminated wide strings.
 *
 * This only compares wchar_t values until it hits a null-terminating
 * character; it does not care if the string is well-formed UTF-16 (or UTF-32,
 * depending on your platform's wchar_t size), or uses valid Unicode values.
 *
 * \param str1 the first string to compare. NULL is not permitted!
 * \param str2 the second string to compare. NULL is not permitted!
 * \returns less than zero if str1 is "less than" str2, greater than zero if
 *          str1 is "greater than" str2, and zero if the strings match
 *          exactly.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_wcscmp(const str1: PWideChar; const str2: PWideChar): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_wcscmp';

(**
 * Compare two wide strings up to a number of wchar_t values.
 *
 * This only compares wchar_t values; it does not care if the string is
 * well-formed UTF-16 (or UTF-32, depending on your platform's wchar_t size),
 * or uses valid Unicode values.
 *
 * Note that while this function is intended to be used with UTF-16 (or
 * UTF-32, depending on your platform's definition of wchar_t), it is
 * comparing raw wchar_t values and not Unicode codepoints: `maxlen` specifies
 * a wchar_t limit! If the limit lands in the middle of a multi-wchar UTF-16
 * sequence, it will only compare a portion of the final character.
 *
 * `maxlen` specifies a maximum number of wchar_t to compare; if the strings
 * match to this number of wide chars (or both have matched to a
 * null-terminator character before this count), they will be considered
 * equal.
 *
 * \param str1 the first string to compare. NULL is not permitted!
 * \param str2 the second string to compare. NULL is not permitted!
 * \param maxlen the maximum number of wchar_t to compare.
 * \returns less than zero if str1 is "less than" str2, greater than zero if
 *          str1 is "greater than" str2, and zero if the strings match
 *          exactly.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_wcsncmp(const str1: PWideChar; const str2: PWideChar; maxlen: NativeUInt): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_wcsncmp';

(**
 * Compare two null-terminated wide strings, case-insensitively.
 *
 * This will work with Unicode strings, using a technique called
 * "case-folding" to handle the vast majority of case-sensitive human
 * languages regardless of system locale. It can deal with expanding values: a
 * German Eszett character can compare against two ASCII 's' chars and be
 * considered a match, for example. A notable exception: it does not handle
 * the Turkish 'i' character; human language is complicated!
 *
 * Depending on your platform, "wchar_t" might be 2 bytes, and expected to be
 * UTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this
 * handles Unicode, it expects the string to be well-formed and not a
 * null-terminated string of arbitrary bytes. Characters that are not valid
 * UTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT
 * CHARACTER), which is to say two strings of random bits may turn out to
 * match if they convert to the same amount of replacement characters.
 *
 * \param str1 the first string to compare. NULL is not permitted!
 * \param str2 the second string to compare. NULL is not permitted!
 * \returns less than zero if str1 is "less than" str2, greater than zero if
 *          str1 is "greater than" str2, and zero if the strings match
 *          exactly.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_wcscasecmp(const str1: PWideChar; const str2: PWideChar): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_wcscasecmp';

(**
 * Compare two wide strings, case-insensitively, up to a number of wchar_t.
 *
 * This will work with Unicode strings, using a technique called
 * "case-folding" to handle the vast majority of case-sensitive human
 * languages regardless of system locale. It can deal with expanding values: a
 * German Eszett character can compare against two ASCII 's' chars and be
 * considered a match, for example. A notable exception: it does not handle
 * the Turkish 'i' character; human language is complicated!
 *
 * Depending on your platform, "wchar_t" might be 2 bytes, and expected to be
 * UTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this
 * handles Unicode, it expects the string to be well-formed and not a
 * null-terminated string of arbitrary bytes. Characters that are not valid
 * UTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT
 * CHARACTER), which is to say two strings of random bits may turn out to
 * match if they convert to the same amount of replacement characters.
 *
 * Note that while this function might deal with variable-sized characters,
 * `maxlen` specifies a _wchar_ limit! If the limit lands in the middle of a
 * multi-byte UTF-16 sequence, it may convert a portion of the final character
 * to one or more Unicode character U+FFFD (REPLACEMENT CHARACTER) so as not
 * to overflow a buffer.
 *
 * `maxlen` specifies a maximum number of wchar_t values to compare; if the
 * strings match to this number of wchar_t (or both have matched to a
 * null-terminator character before this number of bytes), they will be
 * considered equal.
 *
 * \param str1 the first string to compare. NULL is not permitted!
 * \param str2 the second string to compare. NULL is not permitted!
 * \param maxlen the maximum number of wchar_t values to compare.
 * \returns less than zero if str1 is "less than" str2, greater than zero if
 *          str1 is "greater than" str2, and zero if the strings match
 *          exactly.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_wcsncasecmp(const str1: PWideChar; const str2: PWideChar; maxlen: NativeUInt): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_wcsncasecmp';

(**
 * Parse a `long` from a wide string.
 *
 * If `str` starts with whitespace, then those whitespace characters are
 * skipped before attempting to parse the number.
 *
 * If the parsed number does not fit inside a `long`, the result is clamped to
 * the minimum and maximum representable `long` values.
 *
 * \param str The null-terminated wide string to read. Must not be NULL.
 * \param endp If not NULL, the address of the first invalid wide character
 *             (i.e. the next character after the parsed number) will be
 *             written to this pointer.
 * \param base The base of the integer to read. Supported values are 0 and 2
 *             to 36 inclusive. If 0, the base will be inferred from the
 *             number's prefix (0x for hexadecimal, 0 for octal, decimal
 *             otherwise).
 * \returns the parsed `long`, or 0 if no number could be parsed.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_strtol
 *)
function SDL_wcstol(const str: PWideChar; endp: PPWideChar; base: Integer): Longint; cdecl;
  external LIB_SDL3 name _PU + 'SDL_wcstol';

(**
 * This works exactly like strlen() but doesn't require access to a C runtime.
 *
 * Counts the bytes in `str`, excluding the null terminator.
 *
 * If you need the length of a UTF-8 string, consider using SDL_utf8strlen().
 *
 * \param str The null-terminated string to read. Must not be NULL.
 * \returns the length (in bytes, excluding the null terminator) of `src`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_strnlen
 * \sa SDL_utf8strlen
 * \sa SDL_utf8strnlen
 *)
function SDL_strlen(const str: PUTF8Char): NativeUInt; cdecl;
  external LIB_SDL3 name _PU + 'SDL_strlen';

(**
 * This works exactly like strnlen() but doesn't require access to a C
 * runtime.
 *
 * Counts up to a maximum of `maxlen` bytes in `str`, excluding the null
 * terminator.
 *
 * If you need the length of a UTF-8 string, consider using SDL_utf8strnlen().
 *
 * \param str The null-terminated string to read. Must not be NULL.
 * \param maxlen The maximum amount of bytes to count.
 * \returns the length (in bytes, excluding the null terminator) of `src` but
 *          never more than `maxlen`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_strlen
 * \sa SDL_utf8strlen
 * \sa SDL_utf8strnlen
 *)
function SDL_strnlen(const str: PUTF8Char; maxlen: NativeUInt): NativeUInt; cdecl;
  external LIB_SDL3 name _PU + 'SDL_strnlen';

(**
 * Copy a string.
 *
 * This function copies up to `maxlen` - 1 characters from `src` to `dst`,
 * then appends a null terminator.
 *
 * If `maxlen` is 0, no characters are copied and no null terminator is
 * written.
 *
 * If you want to copy an UTF-8 string but need to ensure that multi-byte
 * sequences are not truncated, consider using SDL_utf8strlcpy().
 *
 * \param dst The destination buffer. Must not be NULL, and must not overlap
 *            with `src`.
 * \param src The null-terminated string to copy. Must not be NULL, and must
 *            not overlap with `dst`.
 * \param maxlen The length (in characters) of the destination buffer.
 * \returns the length (in characters, excluding the null terminator) of
 *          `src`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_strlcat
 * \sa SDL_utf8strlcpy
 *)
function SDL_strlcpy(dst: PUTF8Char; const src: PUTF8Char; maxlen: NativeUInt): NativeUInt; cdecl;
  external LIB_SDL3 name _PU + 'SDL_strlcpy';

(**
 * Copy an UTF-8 string.
 *
 * This function copies up to `dst_bytes` - 1 bytes from `src` to `dst` while
 * also ensuring that the string written to `dst` does not end in a truncated
 * multi-byte sequence. Finally, it appends a null terminator.
 *
 * `src` and `dst` must not overlap.
 *
 * Note that unlike SDL_strlcpy(), this function returns the number of bytes
 * written, not the length of `src`.
 *
 * \param dst The destination buffer. Must not be NULL, and must not overlap
 *            with `src`.
 * \param src The null-terminated UTF-8 string to copy. Must not be NULL, and
 *            must not overlap with `dst`.
 * \param dst_bytes The length (in bytes) of the destination buffer. Must not
 *                  be 0.
 * \returns the number of bytes written, excluding the null terminator.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_strlcpy
 *)
function SDL_utf8strlcpy(dst: PUTF8Char; const src: PUTF8Char; dst_bytes: NativeUInt): NativeUInt; cdecl;
  external LIB_SDL3 name _PU + 'SDL_utf8strlcpy';

(**
 * Concatenate strings.
 *
 * This function appends up to `maxlen` - SDL_strlen(dst) - 1 characters from
 * `src` to the end of the string in `dst`, then appends a null terminator.
 *
 * `src` and `dst` must not overlap.
 *
 * If `maxlen` - SDL_strlen(dst) - 1 is less than or equal to 0, then `dst` is
 * unmodified.
 *
 * \param dst The destination buffer already containing the first
 *            null-terminated string. Must not be NULL and must not overlap
 *            with `src`.
 * \param src The second null-terminated string. Must not be NULL, and must
 *            not overlap with `dst`.
 * \param maxlen The length (in characters) of the destination buffer.
 * \returns the length (in characters, excluding the null terminator) of the
 *          string in `dst` plus the length of `src`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_strlcpy
 *)
function SDL_strlcat(dst: PUTF8Char; const src: PUTF8Char; maxlen: NativeUInt): NativeUInt; cdecl;
  external LIB_SDL3 name _PU + 'SDL_strlcat';

(**
 * Allocate a copy of a string.
 *
 * This allocates enough space for a null-terminated copy of `str`, using
 * SDL_malloc, and then makes a copy of the string into this space.
 *
 * The returned string is owned by the caller, and should be passed to
 * SDL_free when no longer needed.
 *
 * \param str the string to copy.
 * \returns a pointer to the newly-allocated string.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_strdup(const str: PUTF8Char): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_strdup';

(**
 * Allocate a copy of a string, up to n characters.
 *
 * This allocates enough space for a null-terminated copy of `str`, up to
 * `maxlen` bytes, using SDL_malloc, and then makes a copy of the string into
 * this space.
 *
 * If the string is longer than `maxlen` bytes, the returned string will be
 * `maxlen` bytes long, plus a null-terminator character that isn't included
 * in the count.
 *
 * The returned string is owned by the caller, and should be passed to
 * SDL_free when no longer needed.
 *
 * \param str the string to copy.
 * \param maxlen the maximum length of the copied string, not counting the
 *               null-terminator character.
 * \returns a pointer to the newly-allocated string.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_strndup(const str: PUTF8Char; maxlen: NativeUInt): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_strndup';

(**
 * Reverse a string's contents.
 *
 * This reverses a null-terminated string in-place. Only the content of the
 * string is reversed; the null-terminator character remains at the end of the
 * reversed string.
 *
 * **WARNING**: This function reverses the _bytes_ of the string, not the
 * codepoints. If `str` is a UTF-8 string with Unicode codepoints > 127, this
 * will ruin the string data. You should only use this function on strings
 * that are completely comprised of low ASCII characters.
 *
 * \param str the string to reverse.
 * \returns `str`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_strrev(str: PUTF8Char): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_strrev';

(**
 * Convert a string to uppercase.
 *
 * **WARNING**: Regardless of system locale, this will only convert ASCII
 * values 'A' through 'Z' to uppercase.
 *
 * This function operates on a null-terminated string of bytes--even if it is
 * malformed UTF-8!--and converts ASCII characters 'a' through 'z' to their
 * uppercase equivalents in-place, returning the original `str` pointer.
 *
 * \param str the string to convert in-place. Can not be NULL.
 * \returns the `str` pointer passed into this function.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_strlwr
 *)
function SDL_strupr(str: PUTF8Char): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_strupr';

(**
 * Convert a string to lowercase.
 *
 * **WARNING**: Regardless of system locale, this will only convert ASCII
 * values 'A' through 'Z' to lowercase.
 *
 * This function operates on a null-terminated string of bytes--even if it is
 * malformed UTF-8!--and converts ASCII characters 'A' through 'Z' to their
 * lowercase equivalents in-place, returning the original `str` pointer.
 *
 * \param str the string to convert in-place. Can not be NULL.
 * \returns the `str` pointer passed into this function.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_strupr
 *)
function SDL_strlwr(str: PUTF8Char): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_strlwr';

(**
 * Search a string for the first instance of a specific byte.
 *
 * The search ends once it finds the requested byte value, or a null
 * terminator byte to end the string.
 *
 * Note that this looks for _bytes_, not _characters_, so you cannot match
 * against a Unicode codepoint > 255, regardless of character encoding.
 *
 * \param str the string to search. Must not be NULL.
 * \param c the byte value to search for.
 * \returns a pointer to the first instance of `c` in the string, or NULL if
 *          not found.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_strchr(const str: PUTF8Char; c: Integer): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_strchr';

(**
 * Search a string for the last instance of a specific byte.
 *
 * The search must go until it finds a null terminator byte to end the string.
 *
 * Note that this looks for _bytes_, not _characters_, so you cannot match
 * against a Unicode codepoint > 255, regardless of character encoding.
 *
 * \param str the string to search. Must not be NULL.
 * \param c the byte value to search for.
 * \returns a pointer to the last instance of `c` in the string, or NULL if
 *          not found.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_strrchr(const str: PUTF8Char; c: Integer): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_strrchr';

(**
 * Search a string for the first instance of a specific substring.
 *
 * The search ends once it finds the requested substring, or a null terminator
 * byte to end the string.
 *
 * Note that this looks for strings of _bytes_, not _characters_, so it's
 * legal to search for malformed and incomplete UTF-8 sequences.
 *
 * \param haystack the string to search. Must not be NULL.
 * \param needle the string to search for. Must not be NULL.
 * \returns a pointer to the first instance of `needle` in the string, or NULL
 *          if not found.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_strstr(const haystack: PUTF8Char; const needle: PUTF8Char): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_strstr';

(**
 * Search a string, up to n bytes, for the first instance of a specific
 * substring.
 *
 * The search ends once it finds the requested substring, or a null terminator
 * byte to end the string, or `maxlen` bytes have been examined. It is
 * possible to use this function on a string without a null terminator.
 *
 * Note that this looks for strings of _bytes_, not _characters_, so it's
 * legal to search for malformed and incomplete UTF-8 sequences.
 *
 * \param haystack the string to search. Must not be NULL.
 * \param needle the string to search for. Must not be NULL.
 * \param maxlen the maximum number of bytes to search in `haystack`.
 * \returns a pointer to the first instance of `needle` in the string, or NULL
 *          if not found.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_strnstr(const haystack: PUTF8Char; const needle: PUTF8Char; maxlen: NativeUInt): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_strnstr';

(**
 * Search a UTF-8 string for the first instance of a specific substring,
 * case-insensitively.
 *
 * This will work with Unicode strings, using a technique called
 * "case-folding" to handle the vast majority of case-sensitive human
 * languages regardless of system locale. It can deal with expanding values: a
 * German Eszett character can compare against two ASCII 's' chars and be
 * considered a match, for example. A notable exception: it does not handle
 * the Turkish 'i' character; human language is complicated!
 *
 * Since this handles Unicode, it expects the strings to be well-formed UTF-8
 * and not a null-terminated string of arbitrary bytes. Bytes that are not
 * valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT
 * CHARACTER), which is to say two strings of random bits may turn out to
 * match if they convert to the same amount of replacement characters.
 *
 * \param haystack the string to search. Must not be NULL.
 * \param needle the string to search for. Must not be NULL.
 * \returns a pointer to the first instance of `needle` in the string, or NULL
 *          if not found.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_strcasestr(const haystack: PUTF8Char; const needle: PUTF8Char): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_strcasestr';

(**
 * This works exactly like strtok_r() but doesn't require access to a C
 * runtime.
 *
 * Break a string up into a series of tokens.
 *
 * To start tokenizing a new string, `str` should be the non-NULL address of
 * the string to start tokenizing. Future calls to get the next token from the
 * same string should specify a NULL.
 *
 * Note that this function will overwrite pieces of `str` with null chars to
 * split it into tokens. This function cannot be used with const/read-only
 * strings!
 *
 * `saveptr` just needs to point to a `char *` that can be overwritten; SDL
 * will use this to save tokenizing state between calls. It is initialized if
 * `str` is non-NULL, and used to resume tokenizing when `str` is NULL.
 *
 * \param str the string to tokenize, or NULL to continue tokenizing.
 * \param delim the delimiter string that separates tokens.
 * \param saveptr pointer to a char *, used for ongoing state.
 * \returns A pointer to the next token, or NULL if no tokens remain.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_strtok_r(str: PUTF8Char; const delim: PUTF8Char; saveptr: PPUTF8Char): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_strtok_r';

(**
 * Count the number of codepoints in a UTF-8 string.
 *
 * Counts the _codepoints_, not _bytes_, in `str`, excluding the null
 * terminator.
 *
 * If you need to count the bytes in a string instead, consider using
 * SDL_strlen().
 *
 * Since this handles Unicode, it expects the strings to be well-formed UTF-8
 * and not a null-terminated string of arbitrary bytes. Bytes that are not
 * valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT
 * CHARACTER), so a malformed or incomplete UTF-8 sequence might increase the
 * count by several replacement characters.
 *
 * \param str The null-terminated UTF-8 string to read. Must not be NULL.
 * \returns The length (in codepoints, excluding the null terminator) of
 *          `src`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_utf8strnlen
 * \sa SDL_strlen
 *)
function SDL_utf8strlen(const str: PUTF8Char): NativeUInt; cdecl;
  external LIB_SDL3 name _PU + 'SDL_utf8strlen';

(**
 * Count the number of codepoints in a UTF-8 string, up to n bytes.
 *
 * Counts the _codepoints_, not _bytes_, in `str`, excluding the null
 * terminator.
 *
 * If you need to count the bytes in a string instead, consider using
 * SDL_strnlen().
 *
 * The counting stops at `bytes` bytes (not codepoints!). This seems
 * counterintuitive, but makes it easy to express the total size of the
 * string's buffer.
 *
 * Since this handles Unicode, it expects the strings to be well-formed UTF-8
 * and not a null-terminated string of arbitrary bytes. Bytes that are not
 * valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT
 * CHARACTER), so a malformed or incomplete UTF-8 sequence might increase the
 * count by several replacement characters.
 *
 * \param str The null-terminated UTF-8 string to read. Must not be NULL.
 * \param bytes The maximum amount of bytes to count.
 * \returns The length (in codepoints, excluding the null terminator) of `src`
 *          but never more than `maxlen`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_utf8strlen
 * \sa SDL_strnlen
 *)
function SDL_utf8strnlen(const str: PUTF8Char; bytes: NativeUInt): NativeUInt; cdecl;
  external LIB_SDL3 name _PU + 'SDL_utf8strnlen';

(**
 * Convert an integer into a string.
 *
 * This requires a radix to specified for string format. Specifying 10
 * produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2
 * to 36.
 *
 * Note that this function will overflow a buffer if `str` is not large enough
 * to hold the output! It may be safer to use SDL_snprintf to clamp output, or
 * SDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate
 * much more space than you expect to use (and don't forget possible negative
 * signs, null terminator bytes, etc).
 *
 * \param value the integer to convert.
 * \param str the buffer to write the string into.
 * \param radix the radix to use for string generation.
 * \returns `str`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_uitoa
 * \sa SDL_ltoa
 * \sa SDL_lltoa
 *)
function SDL_itoa(value: Integer; str: PUTF8Char; radix: Integer): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_itoa';

(**
 * Convert an unsigned integer into a string.
 *
 * This requires a radix to specified for string format. Specifying 10
 * produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2
 * to 36.
 *
 * Note that this function will overflow a buffer if `str` is not large enough
 * to hold the output! It may be safer to use SDL_snprintf to clamp output, or
 * SDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate
 * much more space than you expect to use (and don't forget null terminator
 * bytes, etc).
 *
 * \param value the unsigned integer to convert.
 * \param str the buffer to write the string into.
 * \param radix the radix to use for string generation.
 * \returns `str`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_itoa
 * \sa SDL_ultoa
 * \sa SDL_ulltoa
 *)
function SDL_uitoa(value: Cardinal; str: PUTF8Char; radix: Integer): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_uitoa';

(**
 * Convert a long integer into a string.
 *
 * This requires a radix to specified for string format. Specifying 10
 * produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2
 * to 36.
 *
 * Note that this function will overflow a buffer if `str` is not large enough
 * to hold the output! It may be safer to use SDL_snprintf to clamp output, or
 * SDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate
 * much more space than you expect to use (and don't forget possible negative
 * signs, null terminator bytes, etc).
 *
 * \param value the long integer to convert.
 * \param str the buffer to write the string into.
 * \param radix the radix to use for string generation.
 * \returns `str`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_ultoa
 * \sa SDL_itoa
 * \sa SDL_lltoa
 *)
function SDL_ltoa(value: Longint; str: PUTF8Char; radix: Integer): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_ltoa';

(**
 * Convert an unsigned long integer into a string.
 *
 * This requires a radix to specified for string format. Specifying 10
 * produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2
 * to 36.
 *
 * Note that this function will overflow a buffer if `str` is not large enough
 * to hold the output! It may be safer to use SDL_snprintf to clamp output, or
 * SDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate
 * much more space than you expect to use (and don't forget null terminator
 * bytes, etc).
 *
 * \param value the unsigned long integer to convert.
 * \param str the buffer to write the string into.
 * \param radix the radix to use for string generation.
 * \returns `str`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_ltoa
 * \sa SDL_uitoa
 * \sa SDL_ulltoa
 *)
function SDL_ultoa(value: Longword; str: PUTF8Char; radix: Integer): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_ultoa';

(**
 * Convert a long long integer into a string.
 *
 * This requires a radix to specified for string format. Specifying 10
 * produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2
 * to 36.
 *
 * Note that this function will overflow a buffer if `str` is not large enough
 * to hold the output! It may be safer to use SDL_snprintf to clamp output, or
 * SDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate
 * much more space than you expect to use (and don't forget possible negative
 * signs, null terminator bytes, etc).
 *
 * \param value the long long integer to convert.
 * \param str the buffer to write the string into.
 * \param radix the radix to use for string generation.
 * \returns `str`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_ulltoa
 * \sa SDL_itoa
 * \sa SDL_ltoa
 *)
function SDL_lltoa(value: Int64; str: PUTF8Char; radix: Integer): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_lltoa';

(**
 * Convert an unsigned long long integer into a string.
 *
 * This requires a radix to specified for string format. Specifying 10
 * produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2
 * to 36.
 *
 * Note that this function will overflow a buffer if `str` is not large enough
 * to hold the output! It may be safer to use SDL_snprintf to clamp output, or
 * SDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate
 * much more space than you expect to use (and don't forget null terminator
 * bytes, etc).
 *
 * \param value the unsigned long long integer to convert.
 * \param str the buffer to write the string into.
 * \param radix the radix to use for string generation.
 * \returns `str`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_lltoa
 * \sa SDL_uitoa
 * \sa SDL_ultoa
 *)
function SDL_ulltoa(value: UInt64; str: PUTF8Char; radix: Integer): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_ulltoa';

(**
 * Parse an `int` from a string.
 *
 * The result of calling `SDL_atoi(str)` is equivalent to
 * `(int)SDL_strtol(str, NULL, 10)`.
 *
 * \param str The null-terminated string to read. Must not be NULL.
 * \returns the parsed `int`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_atof
 * \sa SDL_strtol
 * \sa SDL_strtoul
 * \sa SDL_strtoll
 * \sa SDL_strtoull
 * \sa SDL_strtod
 * \sa SDL_itoa
 *)
function SDL_atoi(const str: PUTF8Char): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_atoi';

(**
 * Parse a `double` from a string.
 *
 * The result of calling `SDL_atof(str)` is equivalent to `SDL_strtod(str,
 * NULL)`.
 *
 * \param str The null-terminated string to read. Must not be NULL.
 * \returns the parsed `double`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_atoi
 * \sa SDL_strtol
 * \sa SDL_strtoul
 * \sa SDL_strtoll
 * \sa SDL_strtoull
 * \sa SDL_strtod
 *)
function SDL_atof(const str: PUTF8Char): Double; cdecl;
  external LIB_SDL3 name _PU + 'SDL_atof';

(**
 * Parse a `long` from a string.
 *
 * If `str` starts with whitespace, then those whitespace characters are
 * skipped before attempting to parse the number.
 *
 * If the parsed number does not fit inside a `long`, the result is clamped to
 * the minimum and maximum representable `long` values.
 *
 * \param str The null-terminated string to read. Must not be NULL.
 * \param endp If not NULL, the address of the first invalid character (i.e.
 *             the next character after the parsed number) will be written to
 *             this pointer.
 * \param base The base of the integer to read. Supported values are 0 and 2
 *             to 36 inclusive. If 0, the base will be inferred from the
 *             number's prefix (0x for hexadecimal, 0 for octal, decimal
 *             otherwise).
 * \returns the parsed `long`, or 0 if no number could be parsed.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_atoi
 * \sa SDL_atof
 * \sa SDL_strtoul
 * \sa SDL_strtoll
 * \sa SDL_strtoull
 * \sa SDL_strtod
 * \sa SDL_ltoa
 * \sa SDL_wcstol
 *)
function SDL_strtol(const str: PUTF8Char; endp: PPUTF8Char; base: Integer): Longint; cdecl;
  external LIB_SDL3 name _PU + 'SDL_strtol';

(**
 * Parse an `unsigned long` from a string.
 *
 * If `str` starts with whitespace, then those whitespace characters are
 * skipped before attempting to parse the number.
 *
 * If the parsed number does not fit inside an `unsigned long`, the result is
 * clamped to the maximum representable `unsigned long` value.
 *
 * \param str The null-terminated string to read. Must not be NULL.
 * \param endp If not NULL, the address of the first invalid character (i.e.
 *             the next character after the parsed number) will be written to
 *             this pointer.
 * \param base The base of the integer to read. Supported values are 0 and 2
 *             to 36 inclusive. If 0, the base will be inferred from the
 *             number's prefix (0x for hexadecimal, 0 for octal, decimal
 *             otherwise).
 * \returns the parsed `unsigned long`, or 0 if no number could be parsed.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_atoi
 * \sa SDL_atof
 * \sa SDL_strtol
 * \sa SDL_strtoll
 * \sa SDL_strtoull
 * \sa SDL_strtod
 * \sa SDL_ultoa
 *)
function SDL_strtoul(const str: PUTF8Char; endp: PPUTF8Char; base: Integer): Longword; cdecl;
  external LIB_SDL3 name _PU + 'SDL_strtoul';

(**
 * Parse a `long long` from a string.
 *
 * If `str` starts with whitespace, then those whitespace characters are
 * skipped before attempting to parse the number.
 *
 * If the parsed number does not fit inside a `long long`, the result is
 * clamped to the minimum and maximum representable `long long` values.
 *
 * \param str The null-terminated string to read. Must not be NULL.
 * \param endp If not NULL, the address of the first invalid character (i.e.
 *             the next character after the parsed number) will be written to
 *             this pointer.
 * \param base The base of the integer to read. Supported values are 0 and 2
 *             to 36 inclusive. If 0, the base will be inferred from the
 *             number's prefix (0x for hexadecimal, 0 for octal, decimal
 *             otherwise).
 * \returns the parsed `long long`, or 0 if no number could be parsed.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_atoi
 * \sa SDL_atof
 * \sa SDL_strtol
 * \sa SDL_strtoul
 * \sa SDL_strtoull
 * \sa SDL_strtod
 * \sa SDL_lltoa
 *)
function SDL_strtoll(const str: PUTF8Char; endp: PPUTF8Char; base: Integer): Int64; cdecl;
  external LIB_SDL3 name _PU + 'SDL_strtoll';

(**
 * Parse an `unsigned long long` from a string.
 *
 * If `str` starts with whitespace, then those whitespace characters are
 * skipped before attempting to parse the number.
 *
 * If the parsed number does not fit inside an `unsigned long long`, the
 * result is clamped to the maximum representable `unsigned long long` value.
 *
 * \param str The null-terminated string to read. Must not be NULL.
 * \param endp If not NULL, the address of the first invalid character (i.e.
 *             the next character after the parsed number) will be written to
 *             this pointer.
 * \param base The base of the integer to read. Supported values are 0 and 2
 *             to 36 inclusive. If 0, the base will be inferred from the
 *             number's prefix (0x for hexadecimal, 0 for octal, decimal
 *             otherwise).
 * \returns the parsed `unsigned long long`, or 0 if no number could be
 *          parsed.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_atoi
 * \sa SDL_atof
 * \sa SDL_strtol
 * \sa SDL_strtoll
 * \sa SDL_strtoul
 * \sa SDL_strtod
 * \sa SDL_ulltoa
 *)
function SDL_strtoull(const str: PUTF8Char; endp: PPUTF8Char; base: Integer): UInt64; cdecl;
  external LIB_SDL3 name _PU + 'SDL_strtoull';

(**
 * Parse a `double` from a string.
 *
 * This function makes fewer guarantees than the C runtime `strtod`:
 *
 * - Only decimal notation is guaranteed to be supported. The handling of
 *   scientific and hexadecimal notation is unspecified.
 * - Whether or not INF and NAN can be parsed is unspecified.
 * - The precision of the result is unspecified.
 *
 * \param str the null-terminated string to read. Must not be NULL.
 * \param endp if not NULL, the address of the first invalid character (i.e.
 *             the next character after the parsed number) will be written to
 *             this pointer.
 * \returns the parsed `double`, or 0 if no number could be parsed.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_atoi
 * \sa SDL_atof
 * \sa SDL_strtol
 * \sa SDL_strtoll
 * \sa SDL_strtoul
 * \sa SDL_strtoull
 *)
function SDL_strtod(const str: PUTF8Char; endp: PPUTF8Char): Double; cdecl;
  external LIB_SDL3 name _PU + 'SDL_strtod';

(**
 * Compare two null-terminated UTF-8 strings.
 *
 * Due to the nature of UTF-8 encoding, this will work with Unicode strings,
 * since effectively this function just compares bytes until it hits a
 * null-terminating character. Also due to the nature of UTF-8, this can be
 * used with SDL_qsort() to put strings in (roughly) alphabetical order.
 *
 * \param str1 the first string to compare. NULL is not permitted!
 * \param str2 the second string to compare. NULL is not permitted!
 * \returns less than zero if str1 is "less than" str2, greater than zero if
 *          str1 is "greater than" str2, and zero if the strings match
 *          exactly.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_strcmp(const str1: PUTF8Char; const str2: PUTF8Char): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_strcmp';

(**
 * Compare two UTF-8 strings up to a number of bytes.
 *
 * Due to the nature of UTF-8 encoding, this will work with Unicode strings,
 * since effectively this function just compares bytes until it hits a
 * null-terminating character. Also due to the nature of UTF-8, this can be
 * used with SDL_qsort() to put strings in (roughly) alphabetical order.
 *
 * Note that while this function is intended to be used with UTF-8, it is
 * doing a bytewise comparison, and `maxlen` specifies a _byte_ limit! If the
 * limit lands in the middle of a multi-byte UTF-8 sequence, it will only
 * compare a portion of the final character.
 *
 * `maxlen` specifies a maximum number of bytes to compare; if the strings
 * match to this number of bytes (or both have matched to a null-terminator
 * character before this number of bytes), they will be considered equal.
 *
 * \param str1 the first string to compare. NULL is not permitted!
 * \param str2 the second string to compare. NULL is not permitted!
 * \param maxlen the maximum number of _bytes_ to compare.
 * \returns less than zero if str1 is "less than" str2, greater than zero if
 *          str1 is "greater than" str2, and zero if the strings match
 *          exactly.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_strncmp(const str1: PUTF8Char; const str2: PUTF8Char; maxlen: NativeUInt): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_strncmp';

(**
 * Compare two null-terminated UTF-8 strings, case-insensitively.
 *
 * This will work with Unicode strings, using a technique called
 * "case-folding" to handle the vast majority of case-sensitive human
 * languages regardless of system locale. It can deal with expanding values: a
 * German Eszett character can compare against two ASCII 's' chars and be
 * considered a match, for example. A notable exception: it does not handle
 * the Turkish 'i' character; human language is complicated!
 *
 * Since this handles Unicode, it expects the string to be well-formed UTF-8
 * and not a null-terminated string of arbitrary bytes. Bytes that are not
 * valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT
 * CHARACTER), which is to say two strings of random bits may turn out to
 * match if they convert to the same amount of replacement characters.
 *
 * \param str1 the first string to compare. NULL is not permitted!
 * \param str2 the second string to compare. NULL is not permitted!
 * \returns less than zero if str1 is "less than" str2, greater than zero if
 *          str1 is "greater than" str2, and zero if the strings match
 *          exactly.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_strcasecmp(const str1: PUTF8Char; const str2: PUTF8Char): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_strcasecmp';

(**
 * Compare two UTF-8 strings, case-insensitively, up to a number of bytes.
 *
 * This will work with Unicode strings, using a technique called
 * "case-folding" to handle the vast majority of case-sensitive human
 * languages regardless of system locale. It can deal with expanding values: a
 * German Eszett character can compare against two ASCII 's' chars and be
 * considered a match, for example. A notable exception: it does not handle
 * the Turkish 'i' character; human language is complicated!
 *
 * Since this handles Unicode, it expects the string to be well-formed UTF-8
 * and not a null-terminated string of arbitrary bytes. Bytes that are not
 * valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT
 * CHARACTER), which is to say two strings of random bits may turn out to
 * match if they convert to the same amount of replacement characters.
 *
 * Note that while this function is intended to be used with UTF-8, `maxlen`
 * specifies a _byte_ limit! If the limit lands in the middle of a multi-byte
 * UTF-8 sequence, it may convert a portion of the final character to one or
 * more Unicode character U+FFFD (REPLACEMENT CHARACTER) so as not to overflow
 * a buffer.
 *
 * `maxlen` specifies a maximum number of bytes to compare; if the strings
 * match to this number of bytes (or both have matched to a null-terminator
 * character before this number of bytes), they will be considered equal.
 *
 * \param str1 the first string to compare. NULL is not permitted!
 * \param str2 the second string to compare. NULL is not permitted!
 * \param maxlen the maximum number of bytes to compare.
 * \returns less than zero if str1 is "less than" str2, greater than zero if
 *          str1 is "greater than" str2, and zero if the strings match
 *          exactly.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_strncasecmp(const str1: PUTF8Char; const str2: PUTF8Char; maxlen: NativeUInt): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_strncasecmp';

(**
 * Searches a string for the first occurence of any character contained in a
 * breakset, and returns a pointer from the string to that character.
 *
 * \param str The null-terminated string to be searched. Must not be NULL, and
 *            must not overlap with `breakset`.
 * \param breakset A null-terminated string containing the list of characters
 *                 to look for. Must not be NULL, and must not overlap with
 *                 `str`.
 * \returns A pointer to the location, in str, of the first occurence of a
 *          character present in the breakset, or NULL if none is found.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_strpbrk(const str: PUTF8Char; const breakset: PUTF8Char): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_strpbrk';

const
  (**
   * The Unicode REPLACEMENT CHARACTER codepoint.
   *
   * SDL_StepUTF8() and SDL_StepBackUTF8() report this codepoint when they
   * encounter a UTF-8 string with encoding errors.
   *
   * This tends to render as something like a question mark in most places.
   *
   * \since This macro is available since SDL 3.2.0.
   *
   * \sa SDL_StepBackUTF8
   * \sa SDL_StepUTF8
   *)
  SDL_INVALID_UNICODE_CODEPOINT = $FFFD;

(**
 * Decode a UTF-8 string, one Unicode codepoint at a time.
 *
 * This will return the first Unicode codepoint in the UTF-8 encoded string in
 * `*pstr`, and then advance `*pstr` past any consumed bytes before returning.
 *
 * It will not access more than `*pslen` bytes from the string. `*pslen` will
 * be adjusted, as well, subtracting the number of bytes consumed.
 *
 * `pslen` is allowed to be NULL, in which case the string _must_ be
 * NULL-terminated, as the function will blindly read until it sees the NULL
 * char.
 *
 * if `*pslen` is zero, it assumes the end of string is reached and returns a
 * zero codepoint regardless of the contents of the string buffer.
 *
 * If the resulting codepoint is zero (a NULL terminator), or `*pslen` is
 * zero, it will not advance `*pstr` or `*pslen` at all.
 *
 * Generally this function is called in a loop until it returns zero,
 * adjusting its parameters each iteration.
 *
 * If an invalid UTF-8 sequence is encountered, this function returns
 * SDL_INVALID_UNICODE_CODEPOINT and advances the string/length by one byte
 * (which is to say, a multibyte sequence might produce several
 * SDL_INVALID_UNICODE_CODEPOINT returns before it syncs to the next valid
 * UTF-8 sequence).
 *
 * Several things can generate invalid UTF-8 sequences, including overlong
 * encodings, the use of UTF-16 surrogate values, and truncated data. Please
 * refer to
 * [RFC3629](https://www.ietf.org/rfc/rfc3629.txt)
 * for details.
 *
 * \param pstr a pointer to a UTF-8 string pointer to be read and adjusted.
 * \param pslen a pointer to the number of bytes in the string, to be read and
 *              adjusted. NULL is allowed.
 * \returns the first Unicode codepoint in the string.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_StepUTF8(pstr: PPUTF8Char; pslen: PNativeUInt): Uint32; cdecl;
  external LIB_SDL3 name _PU + 'SDL_StepUTF8';

(**
 * Decode a UTF-8 string in reverse, one Unicode codepoint at a time.
 *
 * This will go to the start of the previous Unicode codepoint in the string,
 * move `*pstr` to that location and return that codepoint.
 *
 * If `*pstr` is already at the start of the string), it will not advance
 * `*pstr` at all.
 *
 * Generally this function is called in a loop until it returns zero,
 * adjusting its parameter each iteration.
 *
 * If an invalid UTF-8 sequence is encountered, this function returns
 * SDL_INVALID_UNICODE_CODEPOINT.
 *
 * Several things can generate invalid UTF-8 sequences, including overlong
 * encodings, the use of UTF-16 surrogate values, and truncated data. Please
 * refer to
 * [RFC3629](https://www.ietf.org/rfc/rfc3629.txt)
 * for details.
 *
 * \param start a pointer to the beginning of the UTF-8 string.
 * \param pstr a pointer to a UTF-8 string pointer to be read and adjusted.
 * \returns the previous Unicode codepoint in the string.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_StepBackUTF8(const start: PUTF8Char; pstr: PPUTF8Char): Uint32; cdecl;
  external LIB_SDL3 name _PU + 'SDL_StepBackUTF8';

(**
 * Convert a single Unicode codepoint to UTF-8.
 *
 * The buffer pointed to by `dst` must be at least 4 bytes long, as this
 * function may generate between 1 and 4 bytes of output.
 *
 * This function returns the first byte _after_ the newly-written UTF-8
 * sequence, which is useful for encoding multiple codepoints in a loop, or
 * knowing where to write a NULL-terminator character to end the string (in
 * either case, plan to have a buffer of _more_ than 4 bytes!).
 *
 * If `codepoint` is an invalid value (outside the Unicode range, or a UTF-16
 * surrogate value, etc), this will use U+FFFD (REPLACEMENT CHARACTER) for the
 * codepoint instead, and not set an error.
 *
 * If `dst` is NULL, this returns NULL immediately without writing to the
 * pointer and without setting an error.
 *
 * \param codepoint a Unicode codepoint to convert to UTF-8.
 * \param dst the location to write the encoded UTF-8. Must point to at least
 *            4 bytes!
 * \returns the first byte past the newly-written UTF-8 sequence.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_UCS4ToUTF8(codepoint: Uint32; dst: PUTF8Char): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_UCS4ToUTF8';

(**
 * This works exactly like sscanf() but doesn't require access to a C runtime.
 *
 * Scan a string, matching a format string, converting each '%' item and
 * storing it to pointers provided through variable arguments.
 *
 * \param text the string to scan. Must not be NULL.
 * \param fmt a printf-style format string. Must not be NULL.
 * \param ... a list of pointers to values to be filled in with scanned items.
 * \returns the number of items that matched the format string.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_sscanf(const text: PUTF8Char; const fmt: PUTF8Char): Integer varargs; cdecl;
  external LIB_SDL3 name _PU + 'SDL_sscanf';

(**
 * This works exactly like vsscanf() but doesn't require access to a C
 * runtime.
 *
 * Functions identically to SDL_sscanf(), except it takes a `va_list` instead
 * of using `...` variable arguments.
 *
 * \param text the string to scan. Must not be NULL.
 * \param fmt a printf-style format string. Must not be NULL.
 * \param ap a `va_list` of pointers to values to be filled in with scanned
 *           items.
 * \returns the number of items that matched the format string.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_vsscanf(const text: PUTF8Char; const fmt: PUTF8Char; ap: Pointer): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_vsscanf';

(**
 * This works exactly like snprintf() but doesn't require access to a C
 * runtime.
 *
 * Format a string of up to `maxlen`-1 bytes, converting each '%' item with
 * values provided through variable arguments.
 *
 * While some C runtimes differ on how to deal with too-large strings, this
 * function null-terminates the output, by treating the null-terminator as
 * part of the `maxlen` count. Note that if `maxlen` is zero, however, no
 * bytes will be written at all.
 *
 * This function returns the number of _bytes_ (not _characters_) that should
 * be written, excluding the null-terminator character. If this returns a
 * number >= `maxlen`, it means the output string was truncated. A negative
 * return value means an error occurred.
 *
 * Referencing the output string's pointer with a format item is undefined
 * behavior.
 *
 * \param text the buffer to write the string into. Must not be NULL.
 * \param maxlen the maximum bytes to write, including the null-terminator.
 * \param fmt a printf-style format string. Must not be NULL.
 * \param ... a list of values to be used with the format string.
 * \returns the number of bytes that should be written, not counting the
 *          null-terminator char, or a negative value on error.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_snprintf(text: PUTF8Char; maxlen: NativeUInt; const fmt: PUTF8Char): Integer varargs; cdecl;
  external LIB_SDL3 name _PU + 'SDL_snprintf';

(**
 * This works exactly like swprintf() but doesn't require access to a C
 * runtime.
 *
 * Format a wide string of up to `maxlen`-1 wchar_t values, converting each
 * '%' item with values provided through variable arguments.
 *
 * While some C runtimes differ on how to deal with too-large strings, this
 * function null-terminates the output, by treating the null-terminator as
 * part of the `maxlen` count. Note that if `maxlen` is zero, however, no wide
 * characters will be written at all.
 *
 * This function returns the number of _wide characters_ (not _codepoints_)
 * that should be written, excluding the null-terminator character. If this
 * returns a number >= `maxlen`, it means the output string was truncated. A
 * negative return value means an error occurred.
 *
 * Referencing the output string's pointer with a format item is undefined
 * behavior.
 *
 * \param text the buffer to write the wide string into. Must not be NULL.
 * \param maxlen the maximum wchar_t values to write, including the
 *               null-terminator.
 * \param fmt a printf-style format string. Must not be NULL.
 * \param ... a list of values to be used with the format string.
 * \returns the number of wide characters that should be written, not counting
 *          the null-terminator char, or a negative value on error.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_swprintf(text: PWideChar; maxlen: NativeUInt; const fmt: PWideChar): Integer varargs; cdecl;
  external LIB_SDL3 name _PU + 'SDL_swprintf';

(**
 * This works exactly like vsnprintf() but doesn't require access to a C
 * runtime.
 *
 * Functions identically to SDL_snprintf(), except it takes a `va_list`
 * instead of using `...` variable arguments.
 *
 * \param text the buffer to write the string into. Must not be NULL.
 * \param maxlen the maximum bytes to write, including the null-terminator.
 * \param fmt a printf-style format string. Must not be NULL.
 * \param ap a `va_list` values to be used with the format string.
 * \returns the number of bytes that should be written, not counting the
 *          null-terminator char, or a negative value on error.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_vsnprintf(text: PUTF8Char; maxlen: NativeUInt; const fmt: PUTF8Char; ap: Pointer): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_vsnprintf';

(**
 * This works exactly like vswprintf() but doesn't require access to a C
 * runtime.
 *
 * Functions identically to SDL_swprintf(), except it takes a `va_list`
 * instead of using `...` variable arguments.
 *
 * \param text the buffer to write the string into. Must not be NULL.
 * \param maxlen the maximum wide characters to write, including the
 *               null-terminator.
 * \param fmt a printf-style format wide string. Must not be NULL.
 * \param ap a `va_list` values to be used with the format string.
 * \returns the number of wide characters that should be written, not counting
 *          the null-terminator char, or a negative value on error.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_vswprintf(text: PWideChar; maxlen: NativeUInt; const fmt: PWideChar; ap: Pointer): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_vswprintf';

(**
 * This works exactly like asprintf() but doesn't require access to a C
 * runtime.
 *
 * Functions identically to SDL_snprintf(), except it allocates a buffer large
 * enough to hold the output string on behalf of the caller.
 *
 * On success, this function returns the number of bytes (not characters)
 * comprising the output string, not counting the null-terminator character,
 * and sets `*strp` to the newly-allocated string.
 *
 * On error, this function returns a negative number, and the value of `*strp`
 * is undefined.
 *
 * The returned string is owned by the caller, and should be passed to
 * SDL_free when no longer needed.
 *
 * \param strp on output, is set to the new string. Must not be NULL.
 * \param fmt a printf-style format string. Must not be NULL.
 * \param ... a list of values to be used with the format string.
 * \returns the number of bytes in the newly-allocated string, not counting
 *          the null-terminator char, or a negative value on error.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_asprintf(strp: PPUTF8Char; const fmt: PUTF8Char): Integer varargs; cdecl;
  external LIB_SDL3 name _PU + 'SDL_asprintf';

(**
 * This works exactly like vasprintf() but doesn't require access to a C
 * runtime.
 *
 * Functions identically to SDL_asprintf(), except it takes a `va_list`
 * instead of using `...` variable arguments.
 *
 * \param strp on output, is set to the new string. Must not be NULL.
 * \param fmt a printf-style format string. Must not be NULL.
 * \param ap a `va_list` values to be used with the format string.
 * \returns the number of bytes in the newly-allocated string, not counting
 *          the null-terminator char, or a negative value on error.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_vasprintf(strp: PPUTF8Char; const fmt: PUTF8Char; ap: Pointer): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_vasprintf';

(**
 * Seeds the pseudo-random number generator.
 *
 * Reusing the seed number will cause SDL_rand_*() to repeat the same stream
 * of 'random' numbers.
 *
 * \param seed the value to use as a random number seed, or 0 to use
 *             SDL_GetPerformanceCounter().
 *
 * \threadsafety This should be called on the same thread that calls
 *               SDL_rand*()
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_rand
 * \sa SDL_rand_bits
 * \sa SDL_randf
 *)
procedure SDL_srand(seed: Uint64); cdecl;
  external LIB_SDL3 name _PU + 'SDL_srand';

(**
 * Generate a pseudo-random number less than n for positive n
 *
 * The method used is faster and of better quality than `rand() % n`. Odds are
 * roughly 99.9% even for n = 1 million. Evenness is better for smaller n, and
 * much worse as n gets bigger.
 *
 * Example: to simulate a d6 use `SDL_rand(6) + 1` The +1 converts 0..5 to
 * 1..6
 *
 * If you want to generate a pseudo-random number in the full range of Sint32,
 * you should use: (Sint32)SDL_rand_bits()
 *
 * If you want reproducible output, be sure to initialize with SDL_srand()
 * first.
 *
 * There are no guarantees as to the quality of the random sequence produced,
 * and this should not be used for security (cryptography, passwords) or where
 * money is on the line (loot-boxes, casinos). There are many random number
 * libraries available with different characteristics and you should pick one
 * of those to meet any serious needs.
 *
 * \param n the number of possible outcomes. n must be positive.
 * \returns a random value in the range of [0 .. n-1].
 *
 * \threadsafety All calls should be made from a single thread
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_srand
 * \sa SDL_randf
 *)
function SDL_rand(n: Sint32): Sint32; cdecl;
  external LIB_SDL3 name _PU + 'SDL_rand';

(**
 * Generate a uniform pseudo-random floating point number less than 1.0
 *
 * If you want reproducible output, be sure to initialize with SDL_srand()
 * first.
 *
 * There are no guarantees as to the quality of the random sequence produced,
 * and this should not be used for security (cryptography, passwords) or where
 * money is on the line (loot-boxes, casinos). There are many random number
 * libraries available with different characteristics and you should pick one
 * of those to meet any serious needs.
 *
 * \returns a random value in the range of [0.0, 1.0).
 *
 * \threadsafety All calls should be made from a single thread
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_srand
 * \sa SDL_rand
 *)
function SDL_randf(): Single; cdecl;
  external LIB_SDL3 name _PU + 'SDL_randf';

(**
 * Generate 32 pseudo-random bits.
 *
 * You likely want to use SDL_rand() to get a psuedo-random number instead.
 *
 * There are no guarantees as to the quality of the random sequence produced,
 * and this should not be used for security (cryptography, passwords) or where
 * money is on the line (loot-boxes, casinos). There are many random number
 * libraries available with different characteristics and you should pick one
 * of those to meet any serious needs.
 *
 * \returns a random value in the range of [0-SDL_MAX_UINT32].
 *
 * \threadsafety All calls should be made from a single thread
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_rand
 * \sa SDL_randf
 * \sa SDL_srand
 *)
function SDL_rand_bits(): Uint32; cdecl;
  external LIB_SDL3 name _PU + 'SDL_rand_bits';

(**
 * Generate a pseudo-random number less than n for positive n
 *
 * The method used is faster and of better quality than `rand() % n`. Odds are
 * roughly 99.9% even for n = 1 million. Evenness is better for smaller n, and
 * much worse as n gets bigger.
 *
 * Example: to simulate a d6 use `SDL_rand_r(state, 6) + 1` The +1 converts
 * 0..5 to 1..6
 *
 * If you want to generate a pseudo-random number in the full range of Sint32,
 * you should use: (Sint32)SDL_rand_bits_r(state)
 *
 * There are no guarantees as to the quality of the random sequence produced,
 * and this should not be used for security (cryptography, passwords) or where
 * money is on the line (loot-boxes, casinos). There are many random number
 * libraries available with different characteristics and you should pick one
 * of those to meet any serious needs.
 *
 * \param state a pointer to the current random number state, this may not be
 *              NULL.
 * \param n the number of possible outcomes. n must be positive.
 * \returns a random value in the range of [0 .. n-1].
 *
 * \threadsafety This function is thread-safe, as long as the state pointer
 *               isn't shared between threads.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_rand
 * \sa SDL_rand_bits_r
 * \sa SDL_randf_r
 *)
function SDL_rand_r(state: PUint64; n: Sint32): Sint32; cdecl;
  external LIB_SDL3 name _PU + 'SDL_rand_r';

(**
 * Generate a uniform pseudo-random floating point number less than 1.0
 *
 * If you want reproducible output, be sure to initialize with SDL_srand()
 * first.
 *
 * There are no guarantees as to the quality of the random sequence produced,
 * and this should not be used for security (cryptography, passwords) or where
 * money is on the line (loot-boxes, casinos). There are many random number
 * libraries available with different characteristics and you should pick one
 * of those to meet any serious needs.
 *
 * \param state a pointer to the current random number state, this may not be
 *              NULL.
 * \returns a random value in the range of [0.0, 1.0).
 *
 * \threadsafety This function is thread-safe, as long as the state pointer
 *               isn't shared between threads.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_rand_bits_r
 * \sa SDL_rand_r
 * \sa SDL_randf
 *)
function SDL_randf_r(state: PUint64): Single; cdecl;
  external LIB_SDL3 name _PU + 'SDL_randf_r';

(**
 * Generate 32 pseudo-random bits.
 *
 * You likely want to use SDL_rand_r() to get a psuedo-random number instead.
 *
 * There are no guarantees as to the quality of the random sequence produced,
 * and this should not be used for security (cryptography, passwords) or where
 * money is on the line (loot-boxes, casinos). There are many random number
 * libraries available with different characteristics and you should pick one
 * of those to meet any serious needs.
 *
 * \param state a pointer to the current random number state, this may not be
 *              NULL.
 * \returns a random value in the range of [0-SDL_MAX_UINT32].
 *
 * \threadsafety This function is thread-safe, as long as the state pointer
 *               isn't shared between threads.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_rand_r
 * \sa SDL_randf_r
 *)
function SDL_rand_bits_r(state: PUint64): Uint32; cdecl;
  external LIB_SDL3 name _PU + 'SDL_rand_bits_r';

const
  (**
   * The value of Pi, as a double-precision floating point literal.
   *
   * \since This macro is available since SDL 3.2.0.
   *
   * \sa SDL_PI_F
   *)
  SDL_PI_D = 3.141592653589793238462643383279502884;

  (**
   * The value of Pi, as a single-precision floating point literal.
   *
   * \since This macro is available since SDL 3.2.0.
   *
   * \sa SDL_PI_D
   *)
  SDL_PI_F = 3.141592653589793238462643383279502884;

(**
 * Compute the arc cosine of `x`.
 *
 * The definition of `y = acos(x)` is `x = cos(y)`.
 *
 * Domain: `-1 <= x <= 1`
 *
 * Range: `0 <= y <= Pi`
 *
 * This function operates on double-precision floating point values, use
 * SDL_acosf for single-precision floats.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * \param x floating point value.
 * \returns arc cosine of `x`, in radians.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_acosf
 * \sa SDL_asin
 * \sa SDL_cos
 *)
function SDL_acos(x: Double): Double; cdecl;
  external LIB_SDL3 name _PU + 'SDL_acos';

(**
 * Compute the arc cosine of `x`.
 *
 * The definition of `y = acos(x)` is `x = cos(y)`.
 *
 * Domain: `-1 <= x <= 1`
 *
 * Range: `0 <= y <= Pi`
 *
 * This function operates on single-precision floating point values, use
 * SDL_acos for double-precision floats.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * \param x floating point value.
 * \returns arc cosine of `x`, in radians.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_acos
 * \sa SDL_asinf
 * \sa SDL_cosf
 *)
function SDL_acosf(x: Single): Single; cdecl;
  external LIB_SDL3 name _PU + 'SDL_acosf';

(**
 * Compute the arc sine of `x`.
 *
 * The definition of `y = asin(x)` is `x = sin(y)`.
 *
 * Domain: `-1 <= x <= 1`
 *
 * Range: `-Pi/2 <= y <= Pi/2`
 *
 * This function operates on double-precision floating point values, use
 * SDL_asinf for single-precision floats.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * \param x floating point value.
 * \returns arc sine of `x`, in radians.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_asinf
 * \sa SDL_acos
 * \sa SDL_sin
 *)
function SDL_asin(x: Double): Double; cdecl;
  external LIB_SDL3 name _PU + 'SDL_asin';

(**
 * Compute the arc sine of `x`.
 *
 * The definition of `y = asin(x)` is `x = sin(y)`.
 *
 * Domain: `-1 <= x <= 1`
 *
 * Range: `-Pi/2 <= y <= Pi/2`
 *
 * This function operates on single-precision floating point values, use
 * SDL_asin for double-precision floats.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * \param x floating point value.
 * \returns arc sine of `x`, in radians.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_asin
 * \sa SDL_acosf
 * \sa SDL_sinf
 *)
function SDL_asinf(x: Single): Single; cdecl;
  external LIB_SDL3 name _PU + 'SDL_asinf';

(**
 * Compute the arc tangent of `x`.
 *
 * The definition of `y = atan(x)` is `x = tan(y)`.
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `-Pi/2 <= y <= Pi/2`
 *
 * This function operates on double-precision floating point values, use
 * SDL_atanf for single-precision floats.
 *
 * To calculate the arc tangent of y / x, use SDL_atan2.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * \param x floating point value.
 * \returns arc tangent of of `x` in radians, or 0 if `x = 0`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_atanf
 * \sa SDL_atan2
 * \sa SDL_tan
 *)
function SDL_atan(x: Double): Double; cdecl;
  external LIB_SDL3 name _PU + 'SDL_atan';

(**
 * Compute the arc tangent of `x`.
 *
 * The definition of `y = atan(x)` is `x = tan(y)`.
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `-Pi/2 <= y <= Pi/2`
 *
 * This function operates on single-precision floating point values, use
 * SDL_atan for dboule-precision floats.
 *
 * To calculate the arc tangent of y / x, use SDL_atan2f.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * \param x floating point value.
 * \returns arc tangent of of `x` in radians, or 0 if `x = 0`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_atan
 * \sa SDL_atan2f
 * \sa SDL_tanf
 *)
function SDL_atanf(x: Single): Single; cdecl;
  external LIB_SDL3 name _PU + 'SDL_atanf';

(**
 * Compute the arc tangent of `y / x`, using the signs of x and y to adjust
 * the result's quadrant.
 *
 * The definition of `z = atan2(x, y)` is `y = x tan(z)`, where the quadrant
 * of z is determined based on the signs of x and y.
 *
 * Domain: `-INF <= x <= INF`, `-INF <= y <= INF`
 *
 * Range: `-Pi/2 <= y <= Pi/2`
 *
 * This function operates on double-precision floating point values, use
 * SDL_atan2f for single-precision floats.
 *
 * To calculate the arc tangent of a single value, use SDL_atan.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * \param y floating point value of the numerator (y coordinate).
 * \param x floating point value of the denominator (x coordinate).
 * \returns arc tangent of of `y / x` in radians, or, if `x = 0`, either
 *          `-Pi/2`, `0`, or `Pi/2`, depending on the value of `y`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_atan2f
 * \sa SDL_atan
 * \sa SDL_tan
 *)
function SDL_atan2(y: Double; x: Double): Double; cdecl;
  external LIB_SDL3 name _PU + 'SDL_atan2';

(**
 * Compute the arc tangent of `y / x`, using the signs of x and y to adjust
 * the result's quadrant.
 *
 * The definition of `z = atan2(x, y)` is `y = x tan(z)`, where the quadrant
 * of z is determined based on the signs of x and y.
 *
 * Domain: `-INF <= x <= INF`, `-INF <= y <= INF`
 *
 * Range: `-Pi/2 <= y <= Pi/2`
 *
 * This function operates on single-precision floating point values, use
 * SDL_atan2 for double-precision floats.
 *
 * To calculate the arc tangent of a single value, use SDL_atanf.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * \param y floating point value of the numerator (y coordinate).
 * \param x floating point value of the denominator (x coordinate).
 * \returns arc tangent of of `y / x` in radians, or, if `x = 0`, either
 *          `-Pi/2`, `0`, or `Pi/2`, depending on the value of `y`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_atan2f
 * \sa SDL_atan
 * \sa SDL_tan
 *)
function SDL_atan2f(y: Single; x: Single): Single; cdecl;
  external LIB_SDL3 name _PU + 'SDL_atan2f';

(**
 * Compute the ceiling of `x`.
 *
 * The ceiling of `x` is the smallest integer `y` such that `y > x`, i.e `x`
 * rounded up to the nearest integer.
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `-INF <= y <= INF`, y integer
 *
 * This function operates on double-precision floating point values, use
 * SDL_ceilf for single-precision floats.
 *
 * \param x floating point value.
 * \returns the ceiling of `x`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_ceilf
 * \sa SDL_floor
 * \sa SDL_trunc
 * \sa SDL_round
 * \sa SDL_lround
 *)
function SDL_ceil(x: Double): Double; cdecl;
  external LIB_SDL3 name _PU + 'SDL_ceil';

(**
 * Compute the ceiling of `x`.
 *
 * The ceiling of `x` is the smallest integer `y` such that `y > x`, i.e `x`
 * rounded up to the nearest integer.
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `-INF <= y <= INF`, y integer
 *
 * This function operates on single-precision floating point values, use
 * SDL_ceil for double-precision floats.
 *
 * \param x floating point value.
 * \returns the ceiling of `x`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_ceil
 * \sa SDL_floorf
 * \sa SDL_truncf
 * \sa SDL_roundf
 * \sa SDL_lroundf
 *)
function SDL_ceilf(x: Single): Single; cdecl;
  external LIB_SDL3 name _PU + 'SDL_ceilf';

(**
 * Copy the sign of one floating-point value to another.
 *
 * The definition of copysign is that ``copysign(x, y) = abs(x) * sign(y)``.
 *
 * Domain: `-INF <= x <= INF`, ``-INF <= y <= f``
 *
 * Range: `-INF <= z <= INF`
 *
 * This function operates on double-precision floating point values, use
 * SDL_copysignf for single-precision floats.
 *
 * \param x floating point value to use as the magnitude.
 * \param y floating point value to use as the sign.
 * \returns the floating point value with the sign of y and the magnitude of
 *          x.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_copysignf
 * \sa SDL_fabs
 *)
function SDL_copysign(x: Double; y: Double): Double; cdecl;
  external LIB_SDL3 name _PU + 'SDL_copysign';

(**
 * Copy the sign of one floating-point value to another.
 *
 * The definition of copysign is that ``copysign(x, y) = abs(x) * sign(y)``.
 *
 * Domain: `-INF <= x <= INF`, ``-INF <= y <= f``
 *
 * Range: `-INF <= z <= INF`
 *
 * This function operates on single-precision floating point values, use
 * SDL_copysign for double-precision floats.
 *
 * \param x floating point value to use as the magnitude.
 * \param y floating point value to use as the sign.
 * \returns the floating point value with the sign of y and the magnitude of
 *          x.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_copysignf
 * \sa SDL_fabsf
 *)
function SDL_copysignf(x: Single; y: Single): Single; cdecl;
  external LIB_SDL3 name _PU + 'SDL_copysignf';

(**
 * Compute the cosine of `x`.
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `-1 <= y <= 1`
 *
 * This function operates on double-precision floating point values, use
 * SDL_cosf for single-precision floats.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * \param x floating point value, in radians.
 * \returns cosine of `x`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_cosf
 * \sa SDL_acos
 * \sa SDL_sin
 *)
function SDL_cos(x: Double): Double; cdecl;
  external LIB_SDL3 name _PU + 'SDL_cos';

(**
 * Compute the cosine of `x`.
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `-1 <= y <= 1`
 *
 * This function operates on single-precision floating point values, use
 * SDL_cos for double-precision floats.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * \param x floating point value, in radians.
 * \returns cosine of `x`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_cos
 * \sa SDL_acosf
 * \sa SDL_sinf
 *)
function SDL_cosf(x: Single): Single; cdecl;
  external LIB_SDL3 name _PU + 'SDL_cosf';

(**
 * Compute the exponential of `x`.
 *
 * The definition of `y = exp(x)` is `y = e^x`, where `e` is the base of the
 * natural logarithm. The inverse is the natural logarithm, SDL_log.
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `0 <= y <= INF`
 *
 * The output will overflow if `exp(x)` is too large to be represented.
 *
 * This function operates on double-precision floating point values, use
 * SDL_expf for single-precision floats.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * \param x floating point value.
 * \returns value of `e^x`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_expf
 * \sa SDL_log
 *)
function SDL_exp(x: Double): Double; cdecl;
  external LIB_SDL3 name _PU + 'SDL_exp';

(**
 * Compute the exponential of `x`.
 *
 * The definition of `y = exp(x)` is `y = e^x`, where `e` is the base of the
 * natural logarithm. The inverse is the natural logarithm, SDL_logf.
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `0 <= y <= INF`
 *
 * The output will overflow if `exp(x)` is too large to be represented.
 *
 * This function operates on single-precision floating point values, use
 * SDL_exp for double-precision floats.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * \param x floating point value.
 * \returns value of `e^x`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_exp
 * \sa SDL_logf
 *)
function SDL_expf(x: Single): Single; cdecl;
  external LIB_SDL3 name _PU + 'SDL_expf';

(**
 * Compute the absolute value of `x`
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `0 <= y <= INF`
 *
 * This function operates on double-precision floating point values, use
 * SDL_copysignf for single-precision floats.
 *
 * \param x floating point value to use as the magnitude.
 * \returns the absolute value of `x`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_fabsf
 *)
function SDL_fabs(x: Double): Double; cdecl;
  external LIB_SDL3 name _PU + 'SDL_fabs';

(**
 * Compute the absolute value of `x`
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `0 <= y <= INF`
 *
 * This function operates on single-precision floating point values, use
 * SDL_copysignf for double-precision floats.
 *
 * \param x floating point value to use as the magnitude.
 * \returns the absolute value of `x`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_fabs
 *)
function SDL_fabsf(x: Single): Single; cdecl;
  external LIB_SDL3 name _PU + 'SDL_fabsf';

(**
 * Compute the floor of `x`.
 *
 * The floor of `x` is the largest integer `y` such that `y > x`, i.e `x`
 * rounded down to the nearest integer.
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `-INF <= y <= INF`, y integer
 *
 * This function operates on double-precision floating point values, use
 * SDL_floorf for single-precision floats.
 *
 * \param x floating point value.
 * \returns the floor of `x`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_floorf
 * \sa SDL_ceil
 * \sa SDL_trunc
 * \sa SDL_round
 * \sa SDL_lround
 *)
function SDL_floor(x: Double): Double; cdecl;
  external LIB_SDL3 name _PU + 'SDL_floor';

(**
 * Compute the floor of `x`.
 *
 * The floor of `x` is the largest integer `y` such that `y > x`, i.e `x`
 * rounded down to the nearest integer.
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `-INF <= y <= INF`, y integer
 *
 * This function operates on single-precision floating point values, use
 * SDL_floorf for double-precision floats.
 *
 * \param x floating point value.
 * \returns the floor of `x`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_floor
 * \sa SDL_ceilf
 * \sa SDL_truncf
 * \sa SDL_roundf
 * \sa SDL_lroundf
 *)
function SDL_floorf(x: Single): Single; cdecl;
  external LIB_SDL3 name _PU + 'SDL_floorf';

(**
 * Truncate `x` to an integer.
 *
 * Rounds `x` to the next closest integer to 0. This is equivalent to removing
 * the fractional part of `x`, leaving only the integer part.
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `-INF <= y <= INF`, y integer
 *
 * This function operates on double-precision floating point values, use
 * SDL_truncf for single-precision floats.
 *
 * \param x floating point value.
 * \returns `x` truncated to an integer.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_truncf
 * \sa SDL_fmod
 * \sa SDL_ceil
 * \sa SDL_floor
 * \sa SDL_round
 * \sa SDL_lround
 *)
function SDL_trunc(x: Double): Double; cdecl;
  external LIB_SDL3 name _PU + 'SDL_trunc';

(**
 * Truncate `x` to an integer.
 *
 * Rounds `x` to the next closest integer to 0. This is equivalent to removing
 * the fractional part of `x`, leaving only the integer part.
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `-INF <= y <= INF`, y integer
 *
 * This function operates on single-precision floating point values, use
 * SDL_truncf for double-precision floats.
 *
 * \param x floating point value.
 * \returns `x` truncated to an integer.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_trunc
 * \sa SDL_fmodf
 * \sa SDL_ceilf
 * \sa SDL_floorf
 * \sa SDL_roundf
 * \sa SDL_lroundf
 *)
function SDL_truncf(x: Single): Single; cdecl;
  external LIB_SDL3 name _PU + 'SDL_truncf';

(**
 * Return the floating-point remainder of `x / y`
 *
 * Divides `x` by `y`, and returns the remainder.
 *
 * Domain: `-INF <= x <= INF`, `-INF <= y <= INF`, `y != 0`
 *
 * Range: `-y <= z <= y`
 *
 * This function operates on double-precision floating point values, use
 * SDL_fmodf for single-precision floats.
 *
 * \param x the numerator.
 * \param y the denominator. Must not be 0.
 * \returns the remainder of `x / y`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_fmodf
 * \sa SDL_modf
 * \sa SDL_trunc
 * \sa SDL_ceil
 * \sa SDL_floor
 * \sa SDL_round
 * \sa SDL_lround
 *)
function SDL_fmod(x: Double; y: Double): Double; cdecl;
  external LIB_SDL3 name _PU + 'SDL_fmod';

(**
 * Return the floating-point remainder of `x / y`
 *
 * Divides `x` by `y`, and returns the remainder.
 *
 * Domain: `-INF <= x <= INF`, `-INF <= y <= INF`, `y != 0`
 *
 * Range: `-y <= z <= y`
 *
 * This function operates on single-precision floating point values, use
 * SDL_fmod for single-precision floats.
 *
 * \param x the numerator.
 * \param y the denominator. Must not be 0.
 * \returns the remainder of `x / y`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_fmod
 * \sa SDL_truncf
 * \sa SDL_modff
 * \sa SDL_ceilf
 * \sa SDL_floorf
 * \sa SDL_roundf
 * \sa SDL_lroundf
 *)
function SDL_fmodf(x: Single; y: Single): Single; cdecl;
  external LIB_SDL3 name _PU + 'SDL_fmodf';

(**
 * Return whether the value is infinity.
 *
 * \param x double-precision floating point value.
 * \returns non-zero if the value is infinity, 0 otherwise.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_isinff
 *)
function SDL_isinf(x: Double): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_isinf';

(**
 * Return whether the value is infinity.
 *
 * \param x floating point value.
 * \returns non-zero if the value is infinity, 0 otherwise.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_isinf
 *)
function SDL_isinff(x: Single): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_isinff';

(**
 * Return whether the value is NaN.
 *
 * \param x double-precision floating point value.
 * \returns non-zero if the value is NaN, 0 otherwise.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_isnanf
 *)
function SDL_isnan(x: Double): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_isnan';

(**
 * Return whether the value is NaN.
 *
 * \param x floating point value.
 * \returns non-zero if the value is NaN, 0 otherwise.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_isnan
 *)
function SDL_isnanf(x: Single): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_isnanf';

(**
 * Compute the natural logarithm of `x`.
 *
 * Domain: `0 < x <= INF`
 *
 * Range: `-INF <= y <= INF`
 *
 * It is an error for `x` to be less than or equal to 0.
 *
 * This function operates on double-precision floating point values, use
 * SDL_logf for single-precision floats.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * \param x floating point value. Must be greater than 0.
 * \returns the natural logarithm of `x`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_logf
 * \sa SDL_log10
 * \sa SDL_exp
 *)
function SDL_log(x: Double): Double; overload; cdecl;
  external LIB_SDL3 name _PU + 'SDL_log';

(**
 * Compute the natural logarithm of `x`.
 *
 * Domain: `0 < x <= INF`
 *
 * Range: `-INF <= y <= INF`
 *
 * It is an error for `x` to be less than or equal to 0.
 *
 * This function operates on single-precision floating point values, use
 * SDL_log for double-precision floats.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * \param x floating point value. Must be greater than 0.
 * \returns the natural logarithm of `x`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_log
 * \sa SDL_expf
 *)
function SDL_logf(x: Single): Single; cdecl;
  external LIB_SDL3 name _PU + 'SDL_logf';

(**
 * Compute the base-10 logarithm of `x`.
 *
 * Domain: `0 < x <= INF`
 *
 * Range: `-INF <= y <= INF`
 *
 * It is an error for `x` to be less than or equal to 0.
 *
 * This function operates on double-precision floating point values, use
 * SDL_log10f for single-precision floats.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * \param x floating point value. Must be greater than 0.
 * \returns the logarithm of `x`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_log10f
 * \sa SDL_log
 * \sa SDL_pow
 *)
function SDL_log10(x: Double): Double; cdecl;
  external LIB_SDL3 name _PU + 'SDL_log10';

(**
 * Compute the base-10 logarithm of `x`.
 *
 * Domain: `0 < x <= INF`
 *
 * Range: `-INF <= y <= INF`
 *
 * It is an error for `x` to be less than or equal to 0.
 *
 * This function operates on single-precision floating point values, use
 * SDL_log10 for double-precision floats.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * \param x floating point value. Must be greater than 0.
 * \returns the logarithm of `x`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_log10
 * \sa SDL_logf
 * \sa SDL_powf
 *)
function SDL_log10f(x: Single): Single; cdecl;
  external LIB_SDL3 name _PU + 'SDL_log10f';

(**
 * Split `x` into integer and fractional parts
 *
 * This function operates on double-precision floating point values, use
 * SDL_modff for single-precision floats.
 *
 * \param x floating point value.
 * \param y output pointer to store the integer part of `x`.
 * \returns the fractional part of `x`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_modff
 * \sa SDL_trunc
 * \sa SDL_fmod
 *)
function SDL_modf(x: Double; y: PDouble): Double; cdecl;
  external LIB_SDL3 name _PU + 'SDL_modf';

(**
 * Split `x` into integer and fractional parts
 *
 * This function operates on single-precision floating point values, use
 * SDL_modf for double-precision floats.
 *
 * \param x floating point value.
 * \param y output pointer to store the integer part of `x`.
 * \returns the fractional part of `x`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_modf
 * \sa SDL_truncf
 * \sa SDL_fmodf
 *)
function SDL_modff(x: Single; y: PSingle): Single; cdecl;
  external LIB_SDL3 name _PU + 'SDL_modff';

(**
 * Raise `x` to the power `y`
 *
 * Domain: `-INF <= x <= INF`, `-INF <= y <= INF`
 *
 * Range: `-INF <= z <= INF`
 *
 * If `y` is the base of the natural logarithm (e), consider using SDL_exp
 * instead.
 *
 * This function operates on double-precision floating point values, use
 * SDL_powf for single-precision floats.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * \param x the base.
 * \param y the exponent.
 * \returns `x` raised to the power `y`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_powf
 * \sa SDL_exp
 * \sa SDL_log
 *)
function SDL_pow(x: Double; y: Double): Double; cdecl;
  external LIB_SDL3 name _PU + 'SDL_pow';

(**
 * Raise `x` to the power `y`
 *
 * Domain: `-INF <= x <= INF`, `-INF <= y <= INF`
 *
 * Range: `-INF <= z <= INF`
 *
 * If `y` is the base of the natural logarithm (e), consider using SDL_exp
 * instead.
 *
 * This function operates on single-precision floating point values, use
 * SDL_powf for double-precision floats.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * \param x the base.
 * \param y the exponent.
 * \returns `x` raised to the power `y`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_pow
 * \sa SDL_expf
 * \sa SDL_logf
 *)
function SDL_powf(x: Single; y: Single): Single; cdecl;
  external LIB_SDL3 name _PU + 'SDL_powf';

(**
 * Round `x` to the nearest integer.
 *
 * Rounds `x` to the nearest integer. Values halfway between integers will be
 * rounded away from zero.
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `-INF <= y <= INF`, y integer
 *
 * This function operates on double-precision floating point values, use
 * SDL_roundf for single-precision floats. To get the result as an integer
 * type, use SDL_lround.
 *
 * \param x floating point value.
 * \returns the nearest integer to `x`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_roundf
 * \sa SDL_lround
 * \sa SDL_floor
 * \sa SDL_ceil
 * \sa SDL_trunc
 *)
function SDL_round(x: Double): Double; cdecl;
  external LIB_SDL3 name _PU + 'SDL_round';

(**
 * Round `x` to the nearest integer.
 *
 * Rounds `x` to the nearest integer. Values halfway between integers will be
 * rounded away from zero.
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `-INF <= y <= INF`, y integer
 *
 * This function operates on double-precision floating point values, use
 * SDL_roundf for single-precision floats. To get the result as an integer
 * type, use SDL_lroundf.
 *
 * \param x floating point value.
 * \returns the nearest integer to `x`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_round
 * \sa SDL_lroundf
 * \sa SDL_floorf
 * \sa SDL_ceilf
 * \sa SDL_truncf
 *)
function SDL_roundf(x: Single): Single; cdecl;
  external LIB_SDL3 name _PU + 'SDL_roundf';

(**
 * Round `x` to the nearest integer representable as a long
 *
 * Rounds `x` to the nearest integer. Values halfway between integers will be
 * rounded away from zero.
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `MIN_LONG <= y <= MAX_LONG`
 *
 * This function operates on double-precision floating point values, use
 * SDL_lround for single-precision floats. To get the result as a
 * floating-point type, use SDL_round.
 *
 * \param x floating point value.
 * \returns the nearest integer to `x`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_lroundf
 * \sa SDL_round
 * \sa SDL_floor
 * \sa SDL_ceil
 * \sa SDL_trunc
 *)
function SDL_lround(x: Double): Longint; cdecl;
  external LIB_SDL3 name _PU + 'SDL_lround';

(**
 * Round `x` to the nearest integer representable as a long
 *
 * Rounds `x` to the nearest integer. Values halfway between integers will be
 * rounded away from zero.
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `MIN_LONG <= y <= MAX_LONG`
 *
 * This function operates on single-precision floating point values, use
 * SDL_lroundf for double-precision floats. To get the result as a
 * floating-point type, use SDL_roundf,
 *
 * \param x floating point value.
 * \returns the nearest integer to `x`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_lround
 * \sa SDL_roundf
 * \sa SDL_floorf
 * \sa SDL_ceilf
 * \sa SDL_truncf
 *)
function SDL_lroundf(x: Single): Longint; cdecl;
  external LIB_SDL3 name _PU + 'SDL_lroundf';

(**
 * Scale `x` by an integer power of two.
 *
 * Multiplies `x` by the `n`th power of the floating point radix (always 2).
 *
 * Domain: `-INF <= x <= INF`, `n` integer
 *
 * Range: `-INF <= y <= INF`
 *
 * This function operates on double-precision floating point values, use
 * SDL_scalbnf for single-precision floats.
 *
 * \param x floating point value to be scaled.
 * \param n integer exponent.
 * \returns `x * 2^n`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_scalbnf
 * \sa SDL_pow
 *)
function SDL_scalbn(x: Double; n: Integer): Double; cdecl;
  external LIB_SDL3 name _PU + 'SDL_scalbn';

(**
 * Scale `x` by an integer power of two.
 *
 * Multiplies `x` by the `n`th power of the floating point radix (always 2).
 *
 * Domain: `-INF <= x <= INF`, `n` integer
 *
 * Range: `-INF <= y <= INF`
 *
 * This function operates on single-precision floating point values, use
 * SDL_scalbn for double-precision floats.
 *
 * \param x floating point value to be scaled.
 * \param n integer exponent.
 * \returns `x * 2^n`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_scalbn
 * \sa SDL_powf
 *)
function SDL_scalbnf(x: Single; n: Integer): Single; cdecl;
  external LIB_SDL3 name _PU + 'SDL_scalbnf';

(**
 * Compute the sine of `x`.
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `-1 <= y <= 1`
 *
 * This function operates on double-precision floating point values, use
 * SDL_sinf for single-precision floats.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * \param x floating point value, in radians.
 * \returns sine of `x`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_sinf
 * \sa SDL_asin
 * \sa SDL_cos
 *)
function SDL_sin(x: Double): Double; cdecl;
  external LIB_SDL3 name _PU + 'SDL_sin';

(**
 * Compute the sine of `x`.
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `-1 <= y <= 1`
 *
 * This function operates on single-precision floating point values, use
 * SDL_sin for double-precision floats.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * \param x floating point value, in radians.
 * \returns sine of `x`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_sin
 * \sa SDL_asinf
 * \sa SDL_cosf
 *)
function SDL_sinf(x: Single): Single; cdecl;
  external LIB_SDL3 name _PU + 'SDL_sinf';

(**
 * Compute the square root of `x`.
 *
 * Domain: `0 <= x <= INF`
 *
 * Range: `0 <= y <= INF`
 *
 * This function operates on double-precision floating point values, use
 * SDL_sqrtf for single-precision floats.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * \param x floating point value. Must be greater than or equal to 0.
 * \returns square root of `x`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_sqrtf
 *)
function SDL_sqrt(x: Double): Double; cdecl;
  external LIB_SDL3 name _PU + 'SDL_sqrt';

(**
 * Compute the square root of `x`.
 *
 * Domain: `0 <= x <= INF`
 *
 * Range: `0 <= y <= INF`
 *
 * This function operates on single-precision floating point values, use
 * SDL_sqrt for double-precision floats.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * \param x floating point value. Must be greater than or equal to 0.
 * \returns square root of `x`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_sqrt
 *)
function SDL_sqrtf(x: Single): Single; cdecl;
  external LIB_SDL3 name _PU + 'SDL_sqrtf';

(**
 * Compute the tangent of `x`.
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `-INF <= y <= INF`
 *
 * This function operates on double-precision floating point values, use
 * SDL_tanf for single-precision floats.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * \param x floating point value, in radians.
 * \returns tangent of `x`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_tanf
 * \sa SDL_sin
 * \sa SDL_cos
 * \sa SDL_atan
 * \sa SDL_atan2
 *)
function SDL_tan(x: Double): Double; cdecl;
  external LIB_SDL3 name _PU + 'SDL_tan';

(**
 * Compute the tangent of `x`.
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `-INF <= y <= INF`
 *
 * This function operates on single-precision floating point values, use
 * SDL_tanf for double-precision floats.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * \param x floating point value, in radians.
 * \returns tangent of `x`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_tan
 * \sa SDL_sinf
 * \sa SDL_cosf
 * \sa SDL_atanf
 * \sa SDL_atan2f
 *)
function SDL_tanf(x: Single): Single; cdecl;
  external LIB_SDL3 name _PU + 'SDL_tanf';

type
  (**
   * An opaque handle representing string encoding conversion state.
   *
   * \since This datatype is available since SDL 3.2.0.
   *
   * \sa SDL_iconv_open
   *)
  SDL_iconv_t = THandle;

(**
 * This function allocates a context for the specified character set
 * conversion.
 *
 * \param tocode The target character encoding, must not be NULL.
 * \param fromcode The source character encoding, must not be NULL.
 * \returns a handle that must be freed with SDL_iconv_close, or
 *          SDL_ICONV_ERROR on failure.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_iconv
 * \sa SDL_iconv_close
 * \sa SDL_iconv_string
 *)
function SDL_iconv_open(const tocode: PUTF8Char; const fromcode: PUTF8Char): SDL_iconv_t; cdecl;
  external LIB_SDL3 name _PU + 'SDL_iconv_open';

(**
 * This function frees a context used for character set conversion.
 *
 * \param cd The character set conversion handle.
 * \returns 0 on success, or -1 on failure.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_iconv
 * \sa SDL_iconv_open
 * \sa SDL_iconv_string
 *)
function SDL_iconv_close(cd: SDL_iconv_t): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_iconv_close';

(**
 * This function converts text between encodings, reading from and writing to
 * a buffer.
 *
 * It returns the number of succesful conversions on success. On error,
 * SDL_ICONV_E2BIG is returned when the output buffer is too small, or
 * SDL_ICONV_EILSEQ is returned when an invalid input sequence is encountered,
 * or SDL_ICONV_EINVAL is returned when an incomplete input sequence is
 * encountered.
 *
 * On exit:
 *
 * - inbuf will point to the beginning of the next multibyte sequence. On
 *   error, this is the location of the problematic input sequence. On
 *   success, this is the end of the input sequence.
 * - inbytesleft will be set to the number of bytes left to convert, which
 *   will be 0 on success.
 * - outbuf will point to the location where to store the next output byte.
 * - outbytesleft will be set to the number of bytes left in the output
 *   buffer.
 *
 * \param cd The character set conversion context, created in
 *           SDL_iconv_open().
 * \param inbuf Address of variable that points to the first character of the
 *              input sequence.
 * \param inbytesleft The number of bytes in the input buffer.
 * \param outbuf Address of variable that points to the output buffer.
 * \param outbytesleft The number of bytes in the output buffer.
 * \returns the number of conversions on success, or a negative error code.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_iconv_open
 * \sa SDL_iconv_close
 * \sa SDL_iconv_string
 *)
function SDL_iconv(cd: SDL_iconv_t; inbuf: PPUTF8Char; inbytesleft: PNativeUInt; outbuf: PPUTF8Char; outbytesleft: PNativeUInt): NativeUInt; cdecl;
  external LIB_SDL3 name _PU + 'SDL_iconv';

const
  SDL_ICONV_ERROR  = -1; // Generic error. Check SDL_GetError()?
  SDL_ICONV_E2BIG  = -2; // Output buffer was too small.
  SDL_ICONV_EILSEQ = -3; // Invalid input sequence was encountered.
  SDL_ICONV_EINVAL = -4; // Incomplete input sequence was encountered.

(**
 * Helper function to convert a string's encoding in one call.
 *
 * This function converts a buffer or string between encodings in one pass.
 *
 * The string does not need to be NULL-terminated; this function operates on
 * the number of bytes specified in `inbytesleft` whether there is a NULL
 * character anywhere in the buffer.
 *
 * The returned string is owned by the caller, and should be passed to
 * SDL_free when no longer needed.
 *
 * \param tocode the character encoding of the output string. Examples are
 *               "UTF-8", "UCS-4", etc.
 * \param fromcode the character encoding of data in `inbuf`.
 * \param inbuf the string to convert to a different encoding.
 * \param inbytesleft the size of the input string _in bytes_.
 * \returns a new string, converted to the new encoding, or NULL on error.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_iconv_open
 * \sa SDL_iconv_close
 * \sa SDL_iconv
 *)
function SDL_iconv_string(const tocode: PUTF8Char; const fromcode: PUTF8Char; const inbuf: PUTF8Char; inbytesleft: NativeUInt): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_iconv_string';

(**
 * Convert a UTF-8 string to the current locale's character encoding.
 *
 * This is a helper macro that might be more clear than calling
 * SDL_iconv_string directly. However, it double-evaluates its parameter, so
 * do not use an expression with side-effects here.
 *
 * \param S the string to convert.
 * \returns a new string, converted to the new encoding, or NULL on error.
 *
 * \since This macro is available since SDL 3.2.0.
 *)
function SDL_iconv_utf8_locale(S: PUTF8Char): PUTF8Char; inline;

(**
 * Convert a UTF-8 string to UCS-2.
 *
 * This is a helper macro that might be more clear than calling
 * SDL_iconv_string directly. However, it double-evaluates its parameter, so
 * do not use an expression with side-effects here.
 *
 * \param S the string to convert.
 * \returns a new string, converted to the new encoding, or NULL on error.
 *
 * \since This macro is available since SDL 3.2.0.
 *)
function SDL_iconv_utf8_ucs2(S: PUTF8Char): PUTF8Char; inline;

(**
 * Convert a UTF-8 string to UCS-4.
 *
 * This is a helper macro that might be more clear than calling
 * SDL_iconv_string directly. However, it double-evaluates its parameter, so
 * do not use an expression with side-effects here.
 *
 * \param S the string to convert.
 * \returns a new string, converted to the new encoding, or NULL on error.
 *
 * \since This macro is available since SDL 3.2.0.
 *)
function SDL_iconv_utf8_ucs4(S: PUTF8Char): PUTF8Char; inline;

(**
 * Convert a wchar_t string to UTF-8.
 *
 * This is a helper macro that might be more clear than calling
 * SDL_iconv_string directly. However, it double-evaluates its parameter, so
 * do not use an expression with side-effects here.
 *
 * \param S the string to convert.
 * \returns a new string, converted to the new encoding, or NULL on error.
 *
 * \since This macro is available since SDL 3.2.0.
 *)
function SDL_iconv_wchar_utf8(S: PWideChar): PUTF8Char; inline;

(**
 * Multiply two integers, checking for overflow.
 *
 * If `a * b` would overflow, return false.
 *
 * Otherwise store `a * b` via ret and return true.
 *
 * \param a the multiplicand.
 * \param b the multiplier.
 * \param ret on non-overflow output, stores the multiplication result, may
 *            not be NULL.
 * \returns false on overflow, true if result is multiplied without overflow.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_size_mul_check_overflow(a, b: size_t; out ret: size_t): Boolean; inline;

(**
 * Add two integers, checking for overflow.
 *
 * If `a + b` would overflow, return false.
 *
 * Otherwise store `a + b` via ret and return true.
 *
 * \param a the first addend.
 * \param b the second addend.
 * \param ret on non-overflow output, stores the addition result, may not be
 *            NULL.
 * \returns false on overflow, true if result is added without overflow.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_size_add_check_overflow(a, b: size_t; out ret: size_t): Boolean; inline;

type
  SDL_FunctionPointer = Pointer;
{$ENDREGION 'SDL_stdinc.h'}

{$REGION 'SDL_assert.h'}
(**
 * # CategoryAssert
 *
 * A helpful assertion macro!
 *
 * SDL assertions operate like your usual `assert` macro, but with some added
 * features:
 *
 * - It uses a trick with the `sizeof` operator, so disabled assertions
 *   vaporize out of the compiled code, but variables only referenced in the
 *   assertion won't trigger compiler warnings about being unused.
 * - It is safe to use with a dangling-else: `if (x) SDL_assert(y); else
 *   do_something();`
 * - It works the same everywhere, instead of counting on various platforms'
 *   compiler and C runtime to behave.
 * - It provides multiple levels of assertion (SDL_assert, SDL_assert_release,
 *   SDL_assert_paranoid) instead of a single all-or-nothing option.
 * - It offers a variety of responses when an assertion fails (retry, trigger
 *   the debugger, abort the program, ignore the failure once, ignore it for
 *   the rest of the program's run).
 * - It tries to show the user a dialog by default, if possible, but the app
 *   can provide a callback to handle assertion failures however they like.
 * - It lets failed assertions be retried. Perhaps you had a network failure
 *   and just want to retry the test after plugging your network cable back
 *   in? You can.
 * - It lets the user ignore an assertion failure, if there's a harmless
 *   problem that one can continue past.
 * - It lets the user mark an assertion as ignored for the rest of the
 *   program's run; if there's a harmless problem that keeps popping up.
 * - It provides statistics and data on all failed assertions to the app.
 * - It allows the default assertion handler to be controlled with environment
 *   variables, in case an automated script needs to control it.
 * - It can be used as an aid to Clang's static analysis; it will treat SDL
 *   assertions as universally true (under the assumption that you are serious
 *   about the asserted claims and that your debug builds will detect when
 *   these claims were wrong). This can help the analyzer avoid false
 *   positives.
 *
 * To use it: compile a debug build and just sprinkle around tests to check
 * your code!
 *)

(**
 * Possible outcomes from a triggered assertion.
 *
 * When an enabled assertion triggers, it may call the assertion handler
 * (possibly one provided by the app via SDL_SetAssertionHandler), which will
 * return one of these values, possibly after asking the user.
 *
 * Then SDL will respond based on this outcome (loop around to retry the
 * condition, try to break in a debugger, kill the program, or ignore the
 * problem).
 *
 * \since This enum is available since SDL 3.2.0.
 *)
type
  SDL_AssertState = Integer;

const
  (** Retry the assert immediately. *)
  SDL_ASSERTION_RETRY = 0;
  (** Make the debugger trigger a breakpoint. *)
  SDL_ASSERTION_BREAK = 1;
  (** Terminate the program. *)
  SDL_ASSERTION_ABORT = 2;
  (** Ignore the assert. *)
  SDL_ASSERTION_IGNORE = 3;
  (** Ignore the assert from now on. *)
  SDL_ASSERTION_ALWAYS_IGNORE = 4;

type
  (**
   * Information about an assertion failure.
   *
   * This structure is filled in with information about a triggered assertion,
   * used by the assertion handler, then added to the assertion report. This is
   * returned as a linked list from SDL_GetAssertionReport().
   *
   * \since This struct is available since SDL 3.2.0.
   *)
  PSDL_AssertData = ^SDL_AssertData;
  SDL_AssertData = record
    (** true if app should always continue when assertion is triggered. *)
    always_ignore: Boolean;
    (** Number of times this assertion has been triggered. *)
    trigger_count: Cardinal;
    (** A string of this assert's test code. *)
    condition: PUTF8Char;
    (** The source file where this assert lives. *)
    filename: PUTF8Char;
    (** The line in `filename` where this assert lives. *)
    linenum: Integer;
    (** The name of the function where this assert lives. *)
    &function: PUTF8Char;
    (** next item in the linked list. *)
    next: PSDL_AssertData;
  end;

(**
 * Never call this directly.
 *
 * Use the SDL_assert macros instead.
 *
 * \param data assert data structure.
 * \param func function name.
 * \param file file name.
 * \param line line number.
 * \returns assert state.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_ReportAssertion(data: PSDL_AssertData; const func: PUTF8Char; const &file: PUTF8Char; line: Integer): SDL_AssertState; cdecl;
  external LIB_SDL3 name _PU + 'SDL_ReportAssertion';

type
  (**
   * A callback that fires when an SDL assertion fails.
   *
   * \param data a pointer to the SDL_AssertData structure corresponding to the
   *             current assertion.
   * \param userdata what was passed as `userdata` to SDL_SetAssertionHandler().
   * \returns an SDL_AssertState value indicating how to handle the failure.
   *
   * \threadsafety This callback may be called from any thread that triggers an
   *               assert at any time.
   *
   * \since This datatype is available since SDL 3.2.0.
   *)
  SDL_AssertionHandler = function(const data: PSDL_AssertData; userdata: Pointer): SDL_AssertState; cdecl;

(**
 * Set an application-defined assertion handler.
 *
 * This function allows an application to show its own assertion UI and/or
 * force the response to an assertion failure. If the application doesn't
 * provide this, SDL will try to do the right thing, popping up a
 * system-specific GUI dialog, and probably minimizing any fullscreen windows.
 *
 * This callback may fire from any thread, but it runs wrapped in a mutex, so
 * it will only fire from one thread at a time.
 *
 * This callback is NOT reset to SDL's internal handler upon SDL_Quit()!
 *
 * \param handler the SDL_AssertionHandler function to call when an assertion
 *                fails or NULL for the default handler.
 * \param userdata a pointer that is passed to `handler`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetAssertionHandler
 *)
procedure SDL_SetAssertionHandler(handler: SDL_AssertionHandler; userdata: Pointer); cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetAssertionHandler';

(**
 * Get the default assertion handler.
 *
 * This returns the function pointer that is called by default when an
 * assertion is triggered. This is an internal function provided by SDL, that
 * is used for assertions when SDL_SetAssertionHandler() hasn't been used to
 * provide a different function.
 *
 * \returns the default SDL_AssertionHandler that is called when an assert
 *          triggers.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetAssertionHandler
 *)
function SDL_GetDefaultAssertionHandler(): SDL_AssertionHandler; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetDefaultAssertionHandler';

(**
 * Get the current assertion handler.
 *
 * This returns the function pointer that is called when an assertion is
 * triggered. This is either the value last passed to
 * SDL_SetAssertionHandler(), or if no application-specified function is set,
 * is equivalent to calling SDL_GetDefaultAssertionHandler().
 *
 * The parameter `puserdata` is a pointer to a void*, which will store the
 * "userdata" pointer that was passed to SDL_SetAssertionHandler(). This value
 * will always be NULL for the default handler. If you don't care about this
 * data, it is safe to pass a NULL pointer to this function to ignore it.
 *
 * \param puserdata pointer which is filled with the "userdata" pointer that
 *                  was passed to SDL_SetAssertionHandler().
 * \returns the SDL_AssertionHandler that is called when an assert triggers.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetAssertionHandler
 *)
function SDL_GetAssertionHandler(puserdata: PPointer): SDL_AssertionHandler; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetAssertionHandler';

(**
 * Get a list of all assertion failures.
 *
 * This function gets all assertions triggered since the last call to
 * SDL_ResetAssertionReport(), or the start of the program.
 *
 * The proper way to examine this data looks something like this:
 *
 * ```c
 * const SDL_AssertData *item = SDL_GetAssertionReport();
 * while (item) {
 *    printf("'%s', %s (%s:%d), triggered %u times, always ignore: %s.\\n",
 *           item->condition, item->function, item->filename,
 *           item->linenum, item->trigger_count,
 *           item->always_ignore ? "yes" : "no");
 *    item = item->next;
 * }
 * ```
 *
 * \returns a list of all failed assertions or NULL if the list is empty. This
 *          memory should not be modified or freed by the application. This
 *          pointer remains valid until the next call to SDL_Quit() or
 *          SDL_ResetAssertionReport().
 *
 * \threadsafety This function is not thread safe. Other threads calling
 *               SDL_ResetAssertionReport() simultaneously, may render the
 *               returned pointer invalid.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_ResetAssertionReport
 *)
function SDL_GetAssertionReport(): PSDL_AssertData; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetAssertionReport';

(**
 * Clear the list of all assertion failures.
 *
 * This function will clear the list of all assertions triggered up to that
 * point. Immediately following this call, SDL_GetAssertionReport will return
 * no items. In addition, any previously-triggered assertions will be reset to
 * a trigger_count of zero, and their always_ignore state will be false.
 *
 * \threadsafety This function is not thread safe. Other threads triggering an
 *               assertion, or simultaneously calling this function may cause
 *               memory leaks or crashes.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetAssertionReport
 *)
procedure SDL_ResetAssertionReport(); cdecl;
  external LIB_SDL3 name _PU + 'SDL_ResetAssertionReport';
{$ENDREGION 'SDL_assert.h'}

{$REGION 'SDL_asyncio.h'}
(**
 * # CategoryAsyncIO
 *
 * SDL offers a way to perform I/O asynchronously. This allows an app to read
 * or write files without waiting for data to actually transfer; the functions
 * that request I/O never block while the request is fulfilled.
 *
 * Instead, the data moves in the background and the app can check for results
 * at their leisure.
 *
 * This is more complicated than just reading and writing files in a
 * synchronous way, but it can allow for more efficiency, and never having
 * framerate drops as the hard drive catches up, etc.
 *
 * The general usage pattern for async I/O is:
 *
 * - Create one or more SDL_AsyncIOQueue objects.
 * - Open files with SDL_AsyncIOFromFile.
 * - Start I/O tasks to the files with SDL_ReadAsyncIO or SDL_WriteAsyncIO,
 *   putting those tasks into one of the queues.
 * - Later on, use SDL_GetAsyncIOResult on a queue to see if any task is
 *   finished without blocking. Tasks might finish in any order with success
 *   or failure.
 * - When all your tasks are done, close the file with SDL_CloseAsyncIO. This
 *   also generates a task, since it might flush data to disk!
 *
 * This all works, without blocking, in a single thread, but one can also wait
 * on a queue in a background thread, sleeping until new results have arrived:
 *
 * - Call SDL_WaitAsyncIOResult from one or more threads to efficiently block
 *   until new tasks complete.
 * - When shutting down, call SDL_SignalAsyncIOQueue to unblock any sleeping
 *   threads despite there being no new tasks completed.
 *
 * And, of course, to match the synchronous SDL_LoadFile, we offer
 * SDL_LoadFileAsync as a convenience function. This will handle allocating a
 * buffer, slurping in the file data, and null-terminating it; you still check
 * for results later.
 *
 * Behind the scenes, SDL will use newer, efficient APIs on platforms that
 * support them: Linux's io_uring and Windows 11's IoRing, for example. If
 * those technologies aren't available, SDL will offload the work to a thread
 * pool that will manage otherwise-synchronous loads without blocking the app.
 *
 * ## Best Practices
 *
 * Simple non-blocking I/O--for an app that just wants to pick up data
 * whenever it's ready without losing framerate waiting on disks to spin--can
 * use whatever pattern works well for the program. In this case, simply call
 * SDL_ReadAsyncIO, or maybe SDL_LoadFileAsync, as needed. Once a frame, call
 * SDL_GetAsyncIOResult to check for any completed tasks and deal with the
 * data as it arrives.
 *
 * If two separate pieces of the same program need their own I/O, it is legal
 * for each to create their own queue. This will prevent either piece from
 * accidentally consuming the other's completed tasks. Each queue does require
 * some amount of resources, but it is not an overwhelming cost. Do not make a
 * queue for each task, however. It is better to put many tasks into a single
 * queue. They will be reported in order of completion, not in the order they
 * were submitted, so it doesn't generally matter what order tasks are
 * started.
 *
 * One async I/O queue can be shared by multiple threads, or one thread can
 * have more than one queue, but the most efficient way--if ruthless
 * efficiency is the goal--is to have one queue per thread, with multiple
 * threads working in parallel, and attempt to keep each queue loaded with
 * tasks that are both started by and consumed by the same thread. On modern
 * platforms that can use newer interfaces, this can keep data flowing as
 * efficiently as possible all the way from storage hardware to the app, with
 * no contention between threads for access to the same queue.
 *
 * Written data is not guaranteed to make it to physical media by the time a
 * closing task is completed, unless SDL_CloseAsyncIO is called with its
 * `flush` parameter set to true, which is to say that a successful result
 * here can still result in lost data during an unfortunately-timed power
 * outage if not flushed. However, flushing will take longer and may be
 * unnecessary, depending on the app's needs.
 *)

type
  (**
   * The asynchronous I/O operation structure.
   *
   * This operates as an opaque handle. One can then request read or write
   * operations on it.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_AsyncIOFromFile
   *)
  SDL_AsyncIO = THandle;

(**
 * Types of asynchronous I/O tasks.
 *
 * \since This enum is available since SDL 3.2.0.
 *)
type
  SDL_AsyncIOTaskType = Integer;

const
  (** A read operation. *)
  SDL_ASYNCIO_TASK_READ = 0;
  (** A write operation. *)
  SDL_ASYNCIO_TASK_WRITE = 1;
  (** A close operation. *)
  SDL_ASYNCIO_TASK_CLOSE = 2;

(**
 * Possible outcomes of an asynchronous I/O task.
 *
 * \since This enum is available since SDL 3.2.0.
 *)
type
  SDL_AsyncIOResult = Integer;

const
  (** request was completed without error *)
  SDL_ASYNCIO_COMPLETE = 0;
  (** request failed for some reason; check SDL_GetError()! *)
  SDL_ASYNCIO_FAILURE = 1;
  (** request was canceled before completing. *)
  SDL_ASYNCIO_CANCELED = 2;

type
  (**
   * Information about a completed asynchronous I/O request.
   *
   * \since This struct is available since SDL 3.2.0.
   *)
  SDL_AsyncIOOutcome = record
    (** what generated this task. This pointer will be invalid if it was closed! *)
    asyncio: SDL_AsyncIO;
    (** What sort of task was this? Read, write, etc? *)
    &type: SDL_AsyncIOTaskType;
    (** the result of the work (success, failure, cancellation). *)
    result: SDL_AsyncIOResult;
    (** buffer where data was read/written. *)
    buffer: Pointer;
    (** offset in the SDL_AsyncIO where data was read/written. *)
    offset: Int64;
    (** number of bytes the task was to read/write. *)
    bytes_requested: Int64;
    (** actual number of bytes that were read/written. *)
    bytes_transferred: Int64;
    (** pointer provided by the app when starting the task *)
    userdata: Pointer;
  end;
  PSDL_AsyncIOOutcome = ^SDL_AsyncIOOutcome;

  (**
   * A queue of completed asynchronous I/O tasks.
   *
   * When starting an asynchronous operation, you specify a queue for the new
   * task. A queue can be asked later if any tasks in it have completed,
   * allowing an app to manage multiple pending tasks in one place, in whatever
   * order they complete.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_CreateAsyncIOQueue
   * \sa SDL_ReadAsyncIO
   * \sa SDL_WriteAsyncIO
   * \sa SDL_GetAsyncIOResult
   * \sa SDL_WaitAsyncIOResult
   *)
  SDL_AsyncIOQueue = THandle;

(**
 * Use this function to create a new SDL_AsyncIO object for reading from
 * and/or writing to a named file.
 *
 * The `mode` string understands the following values:
 *
 * - "r": Open a file for reading only. It must exist.
 * - "w": Open a file for writing only. It will create missing files or
 *   truncate existing ones.
 * - "r+": Open a file for update both reading and writing. The file must
 *   exist.
 * - "w+": Create an empty file for both reading and writing. If a file with
 *   the same name already exists its content is erased and the file is
 *   treated as a new empty file.
 *
 * There is no "b" mode, as there is only "binary" style I/O, and no "a" mode
 * for appending, since you specify the position when starting a task.
 *
 * This function supports Unicode filenames, but they must be encoded in UTF-8
 * format, regardless of the underlying operating system.
 *
 * This call is _not_ asynchronous; it will open the file before returning,
 * under the assumption that doing so is generally a fast operation. Future
 * reads and writes to the opened file will be async, however.
 *
 * \param file a UTF-8 string representing the filename to open.
 * \param mode an ASCII string representing the mode to be used for opening
 *             the file.
 * \returns a pointer to the SDL_AsyncIO structure that is created or NULL on
 *          failure; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CloseAsyncIO
 * \sa SDL_ReadAsyncIO
 * \sa SDL_WriteAsyncIO
 *)
function SDL_AsyncIOFromFile(const &file: PUTF8Char; const mode: PUTF8Char): SDL_AsyncIO; cdecl;
  external LIB_SDL3 name _PU + 'SDL_AsyncIOFromFile';

(**
 * Use this function to get the size of the data stream in an SDL_AsyncIO.
 *
 * This call is _not_ asynchronous; it assumes that obtaining this info is a
 * non-blocking operation in most reasonable cases.
 *
 * \param asyncio the SDL_AsyncIO to get the size of the data stream from.
 * \returns the size of the data stream in the SDL_IOStream on success or a
 *          negative error code on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetAsyncIOSize(asyncio: SDL_AsyncIO): Sint64; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetAsyncIOSize';

(**
 * Start an async read.
 *
 * This function reads up to `size` bytes from `offset` position in the data
 * source to the area pointed at by `ptr`. This function may read less bytes
 * than requested.
 *
 * This function returns as quickly as possible; it does not wait for the read
 * to complete. On a successful return, this work will continue in the
 * background. If the work begins, even failure is asynchronous: a failing
 * return value from this function only means the work couldn't start at all.
 *
 * `ptr` must remain available until the work is done, and may be accessed by
 * the system at any time until then. Do not allocate it on the stack, as this
 * might take longer than the life of the calling function to complete!
 *
 * An SDL_AsyncIOQueue must be specified. The newly-created task will be added
 * to it when it completes its work.
 *
 * \param asyncio a pointer to an SDL_AsyncIO structure.
 * \param ptr a pointer to a buffer to read data into.
 * \param offset the position to start reading in the data source.
 * \param size the number of bytes to read from the data source.
 * \param queue a queue to add the new SDL_AsyncIO to.
 * \param userdata an app-defined pointer that will be provided with the task
 *                 results.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_WriteAsyncIO
 * \sa SDL_CreateAsyncIOQueue
 *)
function SDL_ReadAsyncIO(asyncio: SDL_AsyncIO; ptr: Pointer; offset: Uint64; size: Uint64; queue: SDL_AsyncIOQueue; userdata: Pointer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_ReadAsyncIO';

(**
 * Start an async write.
 *
 * This function writes `size` bytes from `offset` position in the data source
 * to the area pointed at by `ptr`.
 *
 * This function returns as quickly as possible; it does not wait for the
 * write to complete. On a successful return, this work will continue in the
 * background. If the work begins, even failure is asynchronous: a failing
 * return value from this function only means the work couldn't start at all.
 *
 * `ptr` must remain available until the work is done, and may be accessed by
 * the system at any time until then. Do not allocate it on the stack, as this
 * might take longer than the life of the calling function to complete!
 *
 * An SDL_AsyncIOQueue must be specified. The newly-created task will be added
 * to it when it completes its work.
 *
 * \param asyncio a pointer to an SDL_AsyncIO structure.
 * \param ptr a pointer to a buffer to write data from.
 * \param offset the position to start writing to the data source.
 * \param size the number of bytes to write to the data source.
 * \param queue a queue to add the new SDL_AsyncIO to.
 * \param userdata an app-defined pointer that will be provided with the task
 *                 results.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_ReadAsyncIO
 * \sa SDL_CreateAsyncIOQueue
 *)
function SDL_WriteAsyncIO(asyncio: SDL_AsyncIO; ptr: Pointer; offset: Uint64; size: Uint64; queue: SDL_AsyncIOQueue; userdata: Pointer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_WriteAsyncIO';

(**
 * Close and free any allocated resources for an async I/O object.
 *
 * Closing a file is _also_ an asynchronous task! If a write failure were to
 * happen during the closing process, for example, the task results will
 * report it as usual.
 *
 * Closing a file that has been written to does not guarantee the data has
 * made it to physical media; it may remain in the operating system's file
 * cache, for later writing to disk. This means that a successfully-closed
 * file can be lost if the system crashes or loses power in this small window.
 * To prevent this, call this function with the `flush` parameter set to true.
 * This will make the operation take longer, and perhaps increase system load
 * in general, but a successful result guarantees that the data has made it to
 * physical storage. Don't use this for temporary files, caches, and
 * unimportant data, and definitely use it for crucial irreplaceable files,
 * like game saves.
 *
 * This function guarantees that the close will happen after any other pending
 * tasks to `asyncio`, so it's safe to open a file, start several operations,
 * close the file immediately, then check for all results later. This function
 * will not block until the tasks have completed.
 *
 * Once this function returns true, `asyncio` is no longer valid, regardless
 * of any future outcomes. Any completed tasks might still contain this
 * pointer in their SDL_AsyncIOOutcome data, in case the app was using this
 * value to track information, but it should not be used again.
 *
 * If this function returns false, the close wasn't started at all, and it's
 * safe to attempt to close again later.
 *
 * An SDL_AsyncIOQueue must be specified. The newly-created task will be added
 * to it when it completes its work.
 *
 * \param asyncio a pointer to an SDL_AsyncIO structure to close.
 * \param flush true if data should sync to disk before the task completes.
 * \param queue a queue to add the new SDL_AsyncIO to.
 * \param userdata an app-defined pointer that will be provided with the task
 *                 results.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety It is safe to call this function from any thread, but two
 *               threads should not attempt to close the same object.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_CloseAsyncIO(asyncio: SDL_AsyncIO; flush: Boolean; queue: SDL_AsyncIOQueue; userdata: Pointer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_CloseAsyncIO';

(**
 * Create a task queue for tracking multiple I/O operations.
 *
 * Async I/O operations are assigned to a queue when started. The queue can be
 * checked for completed tasks thereafter.
 *
 * \returns a new task queue object or NULL if there was an error; call
 *          SDL_GetError() for more information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_DestroyAsyncIOQueue
 * \sa SDL_GetAsyncIOResult
 * \sa SDL_WaitAsyncIOResult
 *)
function SDL_CreateAsyncIOQueue(): SDL_AsyncIOQueue; cdecl;
  external LIB_SDL3 name _PU + 'SDL_CreateAsyncIOQueue';

(**
 * Destroy a previously-created async I/O task queue.
 *
 * If there are still tasks pending for this queue, this call will block until
 * those tasks are finished. All those tasks will be deallocated. Their
 * results will be lost to the app.
 *
 * Any pending reads from SDL_LoadFileAsync() that are still in this queue
 * will have their buffers deallocated by this function, to prevent a memory
 * leak.
 *
 * Once this function is called, the queue is no longer valid and should not
 * be used, including by other threads that might access it while destruction
 * is blocking on pending tasks.
 *
 * Do not destroy a queue that still has threads waiting on it through
 * SDL_WaitAsyncIOResult(). You can call SDL_SignalAsyncIOQueue() first to
 * unblock those threads, and take measures (such as SDL_WaitThread()) to make
 * sure they have finished their wait and won't wait on the queue again.
 *
 * \param queue the task queue to destroy.
 *
 * \threadsafety It is safe to call this function from any thread, so long as
 *               no other thread is waiting on the queue with
 *               SDL_WaitAsyncIOResult.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_DestroyAsyncIOQueue(queue: SDL_AsyncIOQueue); cdecl;
  external LIB_SDL3 name _PU + 'SDL_DestroyAsyncIOQueue';

(**
 * Query an async I/O task queue for completed tasks.
 *
 * If a task assigned to this queue has finished, this will return true and
 * fill in `outcome` with the details of the task. If no task in the queue has
 * finished, this function will return false. This function does not block.
 *
 * If a task has completed, this function will free its resources and the task
 * pointer will no longer be valid. The task will be removed from the queue.
 *
 * It is safe for multiple threads to call this function on the same queue at
 * once; a completed task will only go to one of the threads.
 *
 * \param queue the async I/O task queue to query.
 * \param outcome details of a finished task will be written here. May not be
 *                NULL.
 * \returns true if a task has completed, false otherwise.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_WaitAsyncIOResult
 *)
function SDL_GetAsyncIOResult(queue: SDL_AsyncIOQueue; outcome: PSDL_AsyncIOOutcome): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetAsyncIOResult';

(**
 * Block until an async I/O task queue has a completed task.
 *
 * This function puts the calling thread to sleep until there a task assigned
 * to the queue that has finished.
 *
 * If a task assigned to the queue has finished, this will return true and
 * fill in `outcome` with the details of the task. If no task in the queue has
 * finished, this function will return false.
 *
 * If a task has completed, this function will free its resources and the task
 * pointer will no longer be valid. The task will be removed from the queue.
 *
 * It is safe for multiple threads to call this function on the same queue at
 * once; a completed task will only go to one of the threads.
 *
 * Note that by the nature of various platforms, more than one waiting thread
 * may wake to handle a single task, but only one will obtain it, so
 * `timeoutMS` is a _maximum_ wait time, and this function may return false
 * sooner.
 *
 * This function may return false if there was a system error, the OS
 * inadvertently awoke multiple threads, or if SDL_SignalAsyncIOQueue() was
 * called to wake up all waiting threads without a finished task.
 *
 * A timeout can be used to specify a maximum wait time, but rather than
 * polling, it is possible to have a timeout of -1 to wait forever, and use
 * SDL_SignalAsyncIOQueue() to wake up the waiting threads later.
 *
 * \param queue the async I/O task queue to wait on.
 * \param outcome details of a finished task will be written here. May not be
 *                NULL.
 * \param timeoutMS the maximum time to wait, in milliseconds, or -1 to wait
 *                  indefinitely.
 * \returns true if task has completed, false otherwise.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SignalAsyncIOQueue
 *)
function SDL_WaitAsyncIOResult(queue: SDL_AsyncIOQueue; outcome: PSDL_AsyncIOOutcome; timeoutMS: Sint32): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_WaitAsyncIOResult';

(**
 * Wake up any threads that are blocking in SDL_WaitAsyncIOResult().
 *
 * This will unblock any threads that are sleeping in a call to
 * SDL_WaitAsyncIOResult for the specified queue, and cause them to return
 * from that function.
 *
 * This can be useful when destroying a queue to make sure nothing is touching
 * it indefinitely. In this case, once this call completes, the caller should
 * take measures to make sure any previously-blocked threads have returned
 * from their wait and will not touch the queue again (perhaps by setting a
 * flag to tell the threads to terminate and then using SDL_WaitThread() to
 * make sure they've done so).
 *
 * \param queue the async I/O task queue to signal.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_WaitAsyncIOResult
 *)
procedure SDL_SignalAsyncIOQueue(queue: SDL_AsyncIOQueue); cdecl;
  external LIB_SDL3 name _PU + 'SDL_SignalAsyncIOQueue';

(**
 * Load all the data from a file path, asynchronously.
 *
 * This function returns as quickly as possible; it does not wait for the read
 * to complete. On a successful return, this work will continue in the
 * background. If the work begins, even failure is asynchronous: a failing
 * return value from this function only means the work couldn't start at all.
 *
 * The data is allocated with a zero byte at the end (null terminated) for
 * convenience. This extra byte is not included in SDL_AsyncIOOutcome's
 * bytes_transferred value.
 *
 * This function will allocate the buffer to contain the file. It must be
 * deallocated by calling SDL_free() on SDL_AsyncIOOutcome's buffer field
 * after completion.
 *
 * An SDL_AsyncIOQueue must be specified. The newly-created task will be added
 * to it when it completes its work.
 *
 * \param file the path to read all available data from.
 * \param queue a queue to add the new SDL_AsyncIO to.
 * \param userdata an app-defined pointer that will be provided with the task
 *                 results.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_LoadFile_IO
 *)
function SDL_LoadFileAsync(const &file: PUTF8Char; queue: SDL_AsyncIOQueue; userdata: Pointer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_LoadFileAsync';
{$ENDREGION 'SDL_asyncio.h'}

{$REGION 'SDL_atomic.h'}
(**
 * # CategoryAtomic
 *
 * Atomic operations.
 *
 * IMPORTANT: If you are not an expert in concurrent lockless programming, you
 * should not be using any functions in this file. You should be protecting
 * your data structures with full mutexes instead.
 *
 * ***Seriously, here be dragons!***
 *
 * You can find out a little more about lockless programming and the subtle
 * issues that can arise here:
 * https://learn.microsoft.com/en-us/windows/win32/dxtecharts/lockless-programming
 *
 * There's also lots of good information here:
 *
 * - https://www.1024cores.net/home/lock-free-algorithms
 * - https://preshing.com/
 *
 * These operations may or may not actually be implemented using processor
 * specific atomic operations. When possible they are implemented as true
 * processor specific atomic operations. When that is not possible the are
 * implemented using locks that *do* use the available atomic operations.
 *
 * All of the atomic operations that modify memory are full memory barriers.
 *)

type
  (**
   * An atomic spinlock.
   *
   * The atomic locks are efficient spinlocks using CPU instructions, but are
   * vulnerable to starvation and can spin forever if a thread holding a lock
   * has been terminated. For this reason you should minimize the code executed
   * inside an atomic lock and never do expensive things like API or system
   * calls while holding them.
   *
   * They are also vulnerable to starvation if the thread holding the lock is
   * lower priority than other threads and doesn't get scheduled. In general you
   * should use mutexes instead, since they have better performance and
   * contention behavior.
   *
   * The atomic locks are not safe to lock recursively.
   *
   * Porting Note: The spin lock functions and type are required and can not be
   * emulated because they are used in the atomic emulation code.
   *)
  SDL_SpinLock = Integer;
  PSDL_SpinLock = ^SDL_SpinLock;

(**
 * Try to lock a spin lock by setting it to a non-zero value.
 *
 * ***Please note that spinlocks are dangerous if you don't know what you're
 * doing. Please be careful using any sort of spinlock!***
 *
 * \param lock a pointer to a lock variable.
 * \returns true if the lock succeeded, false if the lock is already held.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_LockSpinlock
 * \sa SDL_UnlockSpinlock
 *)
function SDL_TryLockSpinlock(lock: PSDL_SpinLock): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_TryLockSpinlock';

(**
 * Lock a spin lock by setting it to a non-zero value.
 *
 * ***Please note that spinlocks are dangerous if you don't know what you're
 * doing. Please be careful using any sort of spinlock!***
 *
 * \param lock a pointer to a lock variable.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_TryLockSpinlock
 * \sa SDL_UnlockSpinlock
 *)
procedure SDL_LockSpinlock(lock: PSDL_SpinLock); cdecl;
  external LIB_SDL3 name _PU + 'SDL_LockSpinlock';

(**
 * Unlock a spin lock by setting it to 0.
 *
 * Always returns immediately.
 *
 * ***Please note that spinlocks are dangerous if you don't know what you're
 * doing. Please be careful using any sort of spinlock!***
 *
 * \param lock a pointer to a lock variable.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_LockSpinlock
 * \sa SDL_TryLockSpinlock
 *)
procedure SDL_UnlockSpinlock(lock: PSDL_SpinLock); cdecl;
  external LIB_SDL3 name _PU + 'SDL_UnlockSpinlock';

(**
 * Insert a memory release barrier (function version).
 *
 * Please refer to SDL_MemoryBarrierRelease for details. This is a function
 * version, which might be useful if you need to use this functionality from a
 * scripting language, etc. Also, some of the macro versions call this
 * function behind the scenes, where more heavy lifting can happen inside of
 * SDL. Generally, though, an app written in C/C++/etc should use the macro
 * version, as it will be more efficient.
 *
 * \threadsafety Obviously this function is safe to use from any thread at any
 *               time, but if you find yourself needing this, you are probably
 *               dealing with some very sensitive code; be careful!
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_MemoryBarrierRelease
 *)
procedure SDL_MemoryBarrierReleaseFunction(); cdecl;
  external LIB_SDL3 name _PU + 'SDL_MemoryBarrierReleaseFunction';

(**
 * Insert a memory acquire barrier (function version).
 *
 * Please refer to SDL_MemoryBarrierRelease for details. This is a function
 * version, which might be useful if you need to use this functionality from a
 * scripting language, etc. Also, some of the macro versions call this
 * function behind the scenes, where more heavy lifting can happen inside of
 * SDL. Generally, though, an app written in C/C++/etc should use the macro
 * version, as it will be more efficient.
 *
 * \threadsafety Obviously this function is safe to use from any thread at any
 *               time, but if you find yourself needing this, you are probably
 *               dealing with some very sensitive code; be careful!
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_MemoryBarrierAcquire
 *)
procedure SDL_MemoryBarrierAcquireFunction(); cdecl;
  external LIB_SDL3 name _PU + 'SDL_MemoryBarrierAcquireFunction';

type
  (**
   * A type representing an atomic integer value.
   *
   * This can be used to manage a value that is synchronized across multiple
   * CPUs without a race condition; when an app sets a value with
   * SDL_SetAtomicInt all other threads, regardless of the CPU it is running on,
   * will see that value when retrieved with SDL_GetAtomicInt, regardless of CPU
   * caches, etc.
   *
   * This is also useful for atomic compare-and-swap operations: a thread can
   * change the value as long as its current value matches expectations. When
   * done in a loop, one can guarantee data consistency across threads without a
   * lock (but the usual warnings apply: if you don't know what you're doing, or
   * you don't do it carefully, you can confidently cause any number of
   * disasters with this, so in most cases, you _should_ use a mutex instead of
   * this!).
   *
   * This is a struct so people don't accidentally use numeric operations on it
   * directly. You have to use SDL atomic functions.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_CompareAndSwapAtomicInt
   * \sa SDL_GetAtomicInt
   * \sa SDL_SetAtomicInt
   * \sa SDL_AddAtomicInt
   *)
  SDL_AtomicInt = record
    value: Integer;
  end;
  PSDL_AtomicInt = ^SDL_AtomicInt;

(**
 * Set an atomic variable to a new value if it is currently an old value.
 *
 * ***Note: If you don't know what this function is for, you shouldn't use
 * it!***
 *
 * \param a a pointer to an SDL_AtomicInt variable to be modified.
 * \param oldval the old value.
 * \param newval the new value.
 * \returns true if the atomic variable was set, false otherwise.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetAtomicInt
 * \sa SDL_SetAtomicInt
 *)
function SDL_CompareAndSwapAtomicInt(a: PSDL_AtomicInt; oldval: Integer; newval: Integer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_CompareAndSwapAtomicInt';

(**
 * Set an atomic variable to a value.
 *
 * This function also acts as a full memory barrier.
 *
 * ***Note: If you don't know what this function is for, you shouldn't use
 * it!***
 *
 * \param a a pointer to an SDL_AtomicInt variable to be modified.
 * \param v the desired value.
 * \returns the previous value of the atomic variable.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetAtomicInt
 *)
function SDL_SetAtomicInt(a: PSDL_AtomicInt; v: Integer): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetAtomicInt';

(**
 * Get the value of an atomic variable.
 *
 * ***Note: If you don't know what this function is for, you shouldn't use
 * it!***
 *
 * \param a a pointer to an SDL_AtomicInt variable.
 * \returns the current value of an atomic variable.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetAtomicInt
 *)
function SDL_GetAtomicInt(a: PSDL_AtomicInt): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetAtomicInt';

(**
 * Add to an atomic variable.
 *
 * This function also acts as a full memory barrier.
 *
 * ***Note: If you don't know what this function is for, you shouldn't use
 * it!***
 *
 * \param a a pointer to an SDL_AtomicInt variable to be modified.
 * \param v the desired value to add.
 * \returns the previous value of the atomic variable.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_AtomicDecRef
 * \sa SDL_AtomicIncRef
 *)
function SDL_AddAtomicInt(a: PSDL_AtomicInt; v: Integer): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_AddAtomicInt';

type
  (**
   * A type representing an atomic unsigned 32-bit value.
   *
   * This can be used to manage a value that is synchronized across multiple
   * CPUs without a race condition; when an app sets a value with
   * SDL_SetAtomicU32 all other threads, regardless of the CPU it is running on,
   * will see that value when retrieved with SDL_GetAtomicU32, regardless of CPU
   * caches, etc.
   *
   * This is also useful for atomic compare-and-swap operations: a thread can
   * change the value as long as its current value matches expectations. When
   * done in a loop, one can guarantee data consistency across threads without a
   * lock (but the usual warnings apply: if you don't know what you're doing, or
   * you don't do it carefully, you can confidently cause any number of
   * disasters with this, so in most cases, you _should_ use a mutex instead of
   * this!).
   *
   * This is a struct so people don't accidentally use numeric operations on it
   * directly. You have to use SDL atomic functions.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_CompareAndSwapAtomicU32
   * \sa SDL_GetAtomicU32
   * \sa SDL_SetAtomicU32
   *)
  SDL_AtomicU32 = record
    value: Uint32;
  end;
  PSDL_AtomicU32 = ^SDL_AtomicU32;

(**
 * Set an atomic variable to a new value if it is currently an old value.
 *
 * ***Note: If you don't know what this function is for, you shouldn't use
 * it!***
 *
 * \param a a pointer to an SDL_AtomicU32 variable to be modified.
 * \param oldval the old value.
 * \param newval the new value.
 * \returns true if the atomic variable was set, false otherwise.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetAtomicU32
 * \sa SDL_SetAtomicU32
 *)
function SDL_CompareAndSwapAtomicU32(a: PSDL_AtomicU32; oldval: Uint32; newval: Uint32): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_CompareAndSwapAtomicU32';

(**
 * Set an atomic variable to a value.
 *
 * This function also acts as a full memory barrier.
 *
 * ***Note: If you don't know what this function is for, you shouldn't use
 * it!***
 *
 * \param a a pointer to an SDL_AtomicU32 variable to be modified.
 * \param v the desired value.
 * \returns the previous value of the atomic variable.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetAtomicU32
 *)
function SDL_SetAtomicU32(a: PSDL_AtomicU32; v: Uint32): Uint32; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetAtomicU32';

(**
 * Get the value of an atomic variable.
 *
 * ***Note: If you don't know what this function is for, you shouldn't use
 * it!***
 *
 * \param a a pointer to an SDL_AtomicU32 variable.
 * \returns the current value of an atomic variable.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetAtomicU32
 *)
function SDL_GetAtomicU32(a: PSDL_AtomicU32): Uint32; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetAtomicU32';

(**
 * Set a pointer to a new value if it is currently an old value.
 *
 * ***Note: If you don't know what this function is for, you shouldn't use
 * it!***
 *
 * \param a a pointer to a pointer.
 * \param oldval the old pointer value.
 * \param newval the new pointer value.
 * \returns true if the pointer was set, false otherwise.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CompareAndSwapAtomicInt
 * \sa SDL_GetAtomicPointer
 * \sa SDL_SetAtomicPointer
 *)
function SDL_CompareAndSwapAtomicPointer(a: PPointer; oldval: Pointer; newval: Pointer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_CompareAndSwapAtomicPointer';

(**
 * Set a pointer to a value atomically.
 *
 * ***Note: If you don't know what this function is for, you shouldn't use
 * it!***
 *
 * \param a a pointer to a pointer.
 * \param v the desired pointer value.
 * \returns the previous value of the pointer.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CompareAndSwapAtomicPointer
 * \sa SDL_GetAtomicPointer
 *)
function SDL_SetAtomicPointer(a: PPointer; v: Pointer): Pointer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetAtomicPointer';

(**
 * Get the value of a pointer atomically.
 *
 * ***Note: If you don't know what this function is for, you shouldn't use
 * it!***
 *
 * \param a a pointer to a pointer.
 * \returns the current value of a pointer.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CompareAndSwapAtomicPointer
 * \sa SDL_SetAtomicPointer
 *)
function SDL_GetAtomicPointer(a: PPointer): Pointer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetAtomicPointer';
{$ENDREGION 'SDL_atomic.h'}

{$REGION 'SDL_properties.h'}
(**
 * # CategoryProperties
 *
 * A property is a variable that can be created and retrieved by name at
 * runtime.
 *
 * All properties are part of a property group (SDL_PropertiesID). A property
 * group can be created with the SDL_CreateProperties function and destroyed
 * with the SDL_DestroyProperties function.
 *
 * Properties can be added to and retrieved from a property group through the
 * following functions:
 *
 * - SDL_SetPointerProperty and SDL_GetPointerProperty operate on `void*`
 *   pointer types.
 * - SDL_SetStringProperty and SDL_GetStringProperty operate on string types.
 * - SDL_SetNumberProperty and SDL_GetNumberProperty operate on signed 64-bit
 *   integer types.
 * - SDL_SetFloatProperty and SDL_GetFloatProperty operate on floating point
 *   types.
 * - SDL_SetBooleanProperty and SDL_GetBooleanProperty operate on boolean
 *   types.
 *
 * Properties can be removed from a group by using SDL_ClearProperty.
 *)

type
  (**
   * SDL properties ID
   *
   * \since This datatype is available since SDL 3.2.0.
   *)
  SDL_PropertiesID = Uint32;

(**
 * SDL property type
 *
 * \since This enum is available since SDL 3.2.0.
 *)
type
  SDL_PropertyType = Integer;

const
  SDL_PROPERTY_TYPE_INVALID = 0;
  SDL_PROPERTY_TYPE_POINTER = 1;
  SDL_PROPERTY_TYPE_STRING = 2;
  SDL_PROPERTY_TYPE_NUMBER = 3;
  SDL_PROPERTY_TYPE_FLOAT = 4;
  SDL_PROPERTY_TYPE_BOOLEAN = 5;

(**
 * Get the global SDL properties.
 *
 * \returns a valid property ID on success or 0 on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetGlobalProperties(): SDL_PropertiesID; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetGlobalProperties';

(**
 * Create a group of properties.
 *
 * All properties are automatically destroyed when SDL_Quit() is called.
 *
 * \returns an ID for a new group of properties, or 0 on failure; call
 *          SDL_GetError() for more information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_DestroyProperties
 *)
function SDL_CreateProperties(): SDL_PropertiesID; cdecl;
  external LIB_SDL3 name _PU + 'SDL_CreateProperties';

(**
 * Copy a group of properties.
 *
 * Copy all the properties from one group of properties to another, with the
 * exception of properties requiring cleanup (set using
 * SDL_SetPointerPropertyWithCleanup()), which will not be copied. Any
 * property that already exists on `dst` will be overwritten.
 *
 * \param src the properties to copy.
 * \param dst the destination properties.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_CopyProperties(src: SDL_PropertiesID; dst: SDL_PropertiesID): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_CopyProperties';

(**
 * Lock a group of properties.
 *
 * Obtain a multi-threaded lock for these properties. Other threads will wait
 * while trying to lock these properties until they are unlocked. Properties
 * must be unlocked before they are destroyed.
 *
 * The lock is automatically taken when setting individual properties, this
 * function is only needed when you want to set several properties atomically
 * or want to guarantee that properties being queried aren't freed in another
 * thread.
 *
 * \param props the properties to lock.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_UnlockProperties
 *)
function SDL_LockProperties(props: SDL_PropertiesID): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_LockProperties';

(**
 * Unlock a group of properties.
 *
 * \param props the properties to unlock.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_LockProperties
 *)
procedure SDL_UnlockProperties(props: SDL_PropertiesID); cdecl;
  external LIB_SDL3 name _PU + 'SDL_UnlockProperties';

type
  (**
   * A callback used to free resources when a property is deleted.
   *
   * This should release any resources associated with `value` that are no
   * longer needed.
   *
   * This callback is set per-property. Different properties in the same group
   * can have different cleanup callbacks.
   *
   * This callback will be called _during_ SDL_SetPointerPropertyWithCleanup if
   * the function fails for any reason.
   *
   * \param userdata an app-defined pointer passed to the callback.
   * \param value the pointer assigned to the property to clean up.
   *
   * \threadsafety This callback may fire without any locks held; if this is a
   *               concern, the app should provide its own locking.
   *
   * \since This datatype is available since SDL 3.2.0.
   *
   * \sa SDL_SetPointerPropertyWithCleanup
   *)
  SDL_CleanupPropertyCallback = procedure(userdata: Pointer; value: Pointer); cdecl;

(**
 * Set a pointer property in a group of properties with a cleanup function
 * that is called when the property is deleted.
 *
 * The cleanup function is also called if setting the property fails for any
 * reason.
 *
 * For simply setting basic data types, like numbers, bools, or strings, use
 * SDL_SetNumberProperty, SDL_SetBooleanProperty, or SDL_SetStringProperty
 * instead, as those functions will handle cleanup on your behalf. This
 * function is only for more complex, custom data.
 *
 * \param props the properties to modify.
 * \param name the name of the property to modify.
 * \param value the new value of the property, or NULL to delete the property.
 * \param cleanup the function to call when this property is deleted, or NULL
 *                if no cleanup is necessary.
 * \param userdata a pointer that is passed to the cleanup function.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetPointerProperty
 * \sa SDL_SetPointerProperty
 * \sa SDL_CleanupPropertyCallback
 *)
function SDL_SetPointerPropertyWithCleanup(props: SDL_PropertiesID; const name: PUTF8Char; value: Pointer; cleanup: SDL_CleanupPropertyCallback; userdata: Pointer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetPointerPropertyWithCleanup';

(**
 * Set a pointer property in a group of properties.
 *
 * \param props the properties to modify.
 * \param name the name of the property to modify.
 * \param value the new value of the property, or NULL to delete the property.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetPointerProperty
 * \sa SDL_HasProperty
 * \sa SDL_SetBooleanProperty
 * \sa SDL_SetFloatProperty
 * \sa SDL_SetNumberProperty
 * \sa SDL_SetPointerPropertyWithCleanup
 * \sa SDL_SetStringProperty
 *)
function SDL_SetPointerProperty(props: SDL_PropertiesID; const name: PUTF8Char; value: Pointer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetPointerProperty';

(**
 * Set a string property in a group of properties.
 *
 * This function makes a copy of the string; the caller does not have to
 * preserve the data after this call completes.
 *
 * \param props the properties to modify.
 * \param name the name of the property to modify.
 * \param value the new value of the property, or NULL to delete the property.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetStringProperty
 *)
function SDL_SetStringProperty(props: SDL_PropertiesID; const name: PUTF8Char; const value: PUTF8Char): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetStringProperty';

(**
 * Set an integer property in a group of properties.
 *
 * \param props the properties to modify.
 * \param name the name of the property to modify.
 * \param value the new value of the property.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetNumberProperty
 *)
function SDL_SetNumberProperty(props: SDL_PropertiesID; const name: PUTF8Char; value: Sint64): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetNumberProperty';

(**
 * Set a floating point property in a group of properties.
 *
 * \param props the properties to modify.
 * \param name the name of the property to modify.
 * \param value the new value of the property.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetFloatProperty
 *)
function SDL_SetFloatProperty(props: SDL_PropertiesID; const name: PUTF8Char; value: Single): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetFloatProperty';

(**
 * Set a boolean property in a group of properties.
 *
 * \param props the properties to modify.
 * \param name the name of the property to modify.
 * \param value the new value of the property.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetBooleanProperty
 *)
function SDL_SetBooleanProperty(props: SDL_PropertiesID; const name: PUTF8Char; value: Boolean): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetBooleanProperty';

(**
 * Return whether a property exists in a group of properties.
 *
 * \param props the properties to query.
 * \param name the name of the property to query.
 * \returns true if the property exists, or false if it doesn't.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetPropertyType
 *)
function SDL_HasProperty(props: SDL_PropertiesID; const name: PUTF8Char): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_HasProperty';

(**
 * Get the type of a property in a group of properties.
 *
 * \param props the properties to query.
 * \param name the name of the property to query.
 * \returns the type of the property, or SDL_PROPERTY_TYPE_INVALID if it is
 *          not set.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_HasProperty
 *)
function SDL_GetPropertyType(props: SDL_PropertiesID; const name: PUTF8Char): SDL_PropertyType; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetPropertyType';

(**
 * Get a pointer property from a group of properties.
 *
 * By convention, the names of properties that SDL exposes on objects will
 * start with "SDL.", and properties that SDL uses internally will start with
 * "SDL.internal.". These should be considered read-only and should not be
 * modified by applications.
 *
 * \param props the properties to query.
 * \param name the name of the property to query.
 * \param default_value the default value of the property.
 * \returns the value of the property, or `default_value` if it is not set or
 *          not a pointer property.
 *
 * \threadsafety It is safe to call this function from any thread, although
 *               the data returned is not protected and could potentially be
 *               freed if you call SDL_SetPointerProperty() or
 *               SDL_ClearProperty() on these properties from another thread.
 *               If you need to avoid this, use SDL_LockProperties() and
 *               SDL_UnlockProperties().
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetBooleanProperty
 * \sa SDL_GetFloatProperty
 * \sa SDL_GetNumberProperty
 * \sa SDL_GetPropertyType
 * \sa SDL_GetStringProperty
 * \sa SDL_HasProperty
 * \sa SDL_SetPointerProperty
 *)
function SDL_GetPointerProperty(props: SDL_PropertiesID; const name: PUTF8Char; default_value: Pointer): Pointer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetPointerProperty';

(**
 * Get a string property from a group of properties.
 *
 * \param props the properties to query.
 * \param name the name of the property to query.
 * \param default_value the default value of the property.
 * \returns the value of the property, or `default_value` if it is not set or
 *          not a string property.
 *
 * \threadsafety It is safe to call this function from any thread, although
 *               the data returned is not protected and could potentially be
 *               freed if you call SDL_SetStringProperty() or
 *               SDL_ClearProperty() on these properties from another thread.
 *               If you need to avoid this, use SDL_LockProperties() and
 *               SDL_UnlockProperties().
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetPropertyType
 * \sa SDL_HasProperty
 * \sa SDL_SetStringProperty
 *)
function SDL_GetStringProperty(props: SDL_PropertiesID; const name: PUTF8Char; const default_value: PUTF8Char): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetStringProperty';

(**
 * Get a number property from a group of properties.
 *
 * You can use SDL_GetPropertyType() to query whether the property exists and
 * is a number property.
 *
 * \param props the properties to query.
 * \param name the name of the property to query.
 * \param default_value the default value of the property.
 * \returns the value of the property, or `default_value` if it is not set or
 *          not a number property.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetPropertyType
 * \sa SDL_HasProperty
 * \sa SDL_SetNumberProperty
 *)
function SDL_GetNumberProperty(props: SDL_PropertiesID; const name: PUTF8Char; default_value: Sint64): Sint64; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetNumberProperty';

(**
 * Get a floating point property from a group of properties.
 *
 * You can use SDL_GetPropertyType() to query whether the property exists and
 * is a floating point property.
 *
 * \param props the properties to query.
 * \param name the name of the property to query.
 * \param default_value the default value of the property.
 * \returns the value of the property, or `default_value` if it is not set or
 *          not a float property.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetPropertyType
 * \sa SDL_HasProperty
 * \sa SDL_SetFloatProperty
 *)
function SDL_GetFloatProperty(props: SDL_PropertiesID; const name: PUTF8Char; default_value: Single): Single; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetFloatProperty';

(**
 * Get a boolean property from a group of properties.
 *
 * You can use SDL_GetPropertyType() to query whether the property exists and
 * is a boolean property.
 *
 * \param props the properties to query.
 * \param name the name of the property to query.
 * \param default_value the default value of the property.
 * \returns the value of the property, or `default_value` if it is not set or
 *          not a boolean property.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetPropertyType
 * \sa SDL_HasProperty
 * \sa SDL_SetBooleanProperty
 *)
function SDL_GetBooleanProperty(props: SDL_PropertiesID; const name: PUTF8Char; default_value: Boolean): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetBooleanProperty';

(**
 * Clear a property from a group of properties.
 *
 * \param props the properties to modify.
 * \param name the name of the property to clear.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_ClearProperty(props: SDL_PropertiesID; const name: PUTF8Char): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_ClearProperty';

type
  (**
   * A callback used to enumerate all the properties in a group of properties.
   *
   * This callback is called from SDL_EnumerateProperties(), and is called once
   * per property in the set.
   *
   * \param userdata an app-defined pointer passed to the callback.
   * \param props the SDL_PropertiesID that is being enumerated.
   * \param name the next property name in the enumeration.
   *
   * \threadsafety SDL_EnumerateProperties holds a lock on `props` during this
   *               callback.
   *
   * \since This datatype is available since SDL 3.2.0.
   *
   * \sa SDL_EnumerateProperties
   *)
  SDL_EnumeratePropertiesCallback = procedure(userdata: Pointer; props: SDL_PropertiesID; const name: PUTF8Char); cdecl;

(**
 * Enumerate the properties contained in a group of properties.
 *
 * The callback function is called for each property in the group of
 * properties. The properties are locked during enumeration.
 *
 * \param props the properties to query.
 * \param callback the function to call for each property.
 * \param userdata a pointer that is passed to `callback`.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_EnumerateProperties(props: SDL_PropertiesID; callback: SDL_EnumeratePropertiesCallback; userdata: Pointer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_EnumerateProperties';

(**
 * Destroy a group of properties.
 *
 * All properties are deleted and their cleanup functions will be called, if
 * any.
 *
 * \param props the properties to destroy.
 *
 * \threadsafety This function should not be called while these properties are
 *               locked or other threads might be setting or getting values
 *               from these properties.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CreateProperties
 *)
procedure SDL_DestroyProperties(props: SDL_PropertiesID); cdecl;
  external LIB_SDL3 name _PU + 'SDL_DestroyProperties';
{$ENDREGION 'SDL_properties.h'}

{$REGION 'SDL_iostream.h'}
(**
 * # CategoryIOStream
 *
 * SDL provides an abstract interface for reading and writing data streams. It
 * offers implementations for files, memory, etc, and the app can provide
 * their own implementations, too.
 *
 * SDL_IOStream is not related to the standard C++ iostream class, other than
 * both are abstract interfaces to read/write data.
 *)

(**
 * SDL_IOStream status, set by a read or write operation.
 *
 * \since This enum is available since SDL 3.2.0.
 *)
type
  SDL_IOStatus = Integer;
  PSDL_IOStatus = ^SDL_IOStatus;

const
  (** Everything is ready (no errors and not EOF). *)
  SDL_IO_STATUS_READY = 0;
  (** Read or write I/O error *)
  SDL_IO_STATUS_ERROR = 1;
  (** End of file *)
  SDL_IO_STATUS_EOF = 2;
  (** Non blocking I/O, not ready *)
  SDL_IO_STATUS_NOT_READY = 3;
  (** Tried to write a read-only buffer *)
  SDL_IO_STATUS_READONLY = 4;
  (** Tried to read a write-only buffer *)
  SDL_IO_STATUS_WRITEONLY = 5;

(**
 * Possible `whence` values for SDL_IOStream seeking.
 *
 * These map to the same "whence" concept that `fseek` or `lseek` use in the
 * standard C runtime.
 *
 * \since This enum is available since SDL 3.2.0.
 *)
type
  SDL_IOWhence = Integer;

const
  (** Seek from the beginning of data *)
  SDL_IO_SEEK_SET = 0;
  (** Seek relative to current read point *)
  SDL_IO_SEEK_CUR = 1;
  (** Seek relative to the end of data *)
  SDL_IO_SEEK_END = 2;

type
  (**
   * The function pointers that drive an SDL_IOStream.
   *
   * Applications can provide this struct to SDL_OpenIO() to create their own
   * implementation of SDL_IOStream. This is not necessarily required, as SDL
   * already offers several common types of I/O streams, via functions like
   * SDL_IOFromFile() and SDL_IOFromMem().
   *
   * This structure should be initialized using SDL_INIT_INTERFACE()
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_INIT_INTERFACE
   *)
  SDL_IOStreamInterface = record
    version: Uint32;
    (**
     *  Return the number of bytes in this SDL_IOStream
     *
     *  \return the total size of the data stream, or -1 on error.
     *)
    size: function(userdata: Pointer): Sint64; cdecl;
    (**
     *  Seek to `offset` relative to `whence`, one of stdio's whence values:
     *  SDL_IO_SEEK_SET, SDL_IO_SEEK_CUR, SDL_IO_SEEK_END
     *
     *  \return the final offset in the data stream, or -1 on error.
     *)
    seek: function(userdata: Pointer; offset: Sint64; whence: SDL_IOWhence): Sint64; cdecl;
    (**
     *  Read up to `size` bytes from the data stream to the area pointed
     *  at by `ptr`.
     *
     *  On an incomplete read, you should set `*status` to a value from the
     *  SDL_IOStatus enum. You do not have to explicitly set this on
     *  a complete, successful read.
     *
     *  \return the number of bytes read
     *)
    read: function(userdata: Pointer; ptr: Pointer; size: NativeUInt; status: PSDL_IOStatus): NativeUInt; cdecl;
    (**
     *  Write exactly `size` bytes from the area pointed at by `ptr`
     *  to data stream.
     *
     *  On an incomplete write, you should set `*status` to a value from the
     *  SDL_IOStatus enum. You do not have to explicitly set this on
     *  a complete, successful write.
     *
     *  \return the number of bytes written
     *)
    write: function(userdata: Pointer; const ptr: Pointer; size: NativeUInt; status: PSDL_IOStatus): NativeUInt; cdecl;
    (**
     *  If the stream is buffering, make sure the data is written out.
     *
     *  On failure, you should set `*status` to a value from the
     *  SDL_IOStatus enum. You do not have to explicitly set this on
     *  a successful flush.
     *
     *  \return true if successful or false on write error when flushing data.
     *)
    flush: function(userdata: Pointer; status: PSDL_IOStatus): Boolean; cdecl;
    (**
     *  Close and free any allocated resources.
     *
     *  This does not guarantee file writes will sync to physical media; they
     *  can be in the system's file cache, waiting to go to disk.
     *
     *  The SDL_IOStream is still destroyed even if this fails, so clean up anything
     *  even if flushing buffers, etc, returns an error.
     *
     *  \return true if successful or false on write error when flushing data.
     *)
    close: function(userdata: Pointer): Boolean; cdecl;
  end;
  PSDL_IOStreamInterface = ^SDL_IOStreamInterface;

type
  (**
   * The read/write operation structure.
   *
   * This operates as an opaque handle. There are several APIs to create various
   * types of I/O streams, or an app can supply an SDL_IOStreamInterface to
   * SDL_OpenIO() to provide their own stream implementation behind this
   * struct's abstract interface.
   *
   * \since This struct is available since SDL 3.2.0.
   *)
  SDL_IOStream = THandle;

(**
 * Use this function to create a new SDL_IOStream structure for reading from
 * and/or writing to a named file.
 *
 * The `mode` string is treated roughly the same as in a call to the C
 * library's fopen(), even if SDL doesn't happen to use fopen() behind the
 * scenes.
 *
 * Available `mode` strings:
 *
 * - "r": Open a file for reading. The file must exist.
 * - "w": Create an empty file for writing. If a file with the same name
 *   already exists its content is erased and the file is treated as a new
 *   empty file.
 * - "a": Append to a file. Writing operations append data at the end of the
 *   file. The file is created if it does not exist.
 * - "r+": Open a file for update both reading and writing. The file must
 *   exist.
 * - "w+": Create an empty file for both reading and writing. If a file with
 *   the same name already exists its content is erased and the file is
 *   treated as a new empty file.
 * - "a+": Open a file for reading and appending. All writing operations are
 *   performed at the end of the file, protecting the previous content to be
 *   overwritten. You can reposition (fseek, rewind) the internal pointer to
 *   anywhere in the file for reading, but writing operations will move it
 *   back to the end of file. The file is created if it does not exist.
 *
 * **NOTE**: In order to open a file as a binary file, a "b" character has to
 * be included in the `mode` string. This additional "b" character can either
 * be appended at the end of the string (thus making the following compound
 * modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the
 * letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").
 * Additional characters may follow the sequence, although they should have no
 * effect. For example, "t" is sometimes appended to make explicit the file is
 * a text file.
 *
 * This function supports Unicode filenames, but they must be encoded in UTF-8
 * format, regardless of the underlying operating system.
 *
 * In Android, SDL_IOFromFile() can be used to open content:// URIs. As a
 * fallback, SDL_IOFromFile() will transparently open a matching filename in
 * the app's `assets`.
 *
 * Closing the SDL_IOStream will close SDL's internal file handle.
 *
 * The following properties may be set at creation time by SDL:
 *
 * - `SDL_PROP_IOSTREAM_WINDOWS_HANDLE_POINTER`: a pointer, that can be cast
 *   to a win32 `HANDLE`, that this SDL_IOStream is using to access the
 *   filesystem. If the program isn't running on Windows, or SDL used some
 *   other method to access the filesystem, this property will not be set.
 * - `SDL_PROP_IOSTREAM_STDIO_FILE_POINTER`: a pointer, that can be cast to a
 *   stdio `FILE *`, that this SDL_IOStream is using to access the filesystem.
 *   If SDL used some other method to access the filesystem, this property
 *   will not be set. PLEASE NOTE that if SDL is using a different C runtime
 *   than your app, trying to use this pointer will almost certainly result in
 *   a crash! This is mostly a problem on Windows; make sure you build SDL and
 *   your app with the same compiler and settings to avoid it.
 * - `SDL_PROP_IOSTREAM_FILE_DESCRIPTOR_NUMBER`: a file descriptor that this
 *   SDL_IOStream is using to access the filesystem.
 * - `SDL_PROP_IOSTREAM_ANDROID_AASSET_POINTER`: a pointer, that can be cast
 *   to an Android NDK `AAsset *`, that this SDL_IOStream is using to access
 *   the filesystem. If SDL used some other method to access the filesystem,
 *   this property will not be set.
 *
 * \param file a UTF-8 string representing the filename to open.
 * \param mode an ASCII string representing the mode to be used for opening
 *             the file.
 * \returns a pointer to the SDL_IOStream structure that is created or NULL on
 *          failure; call SDL_GetError() for more information.
 *
 * \threadsafety This function is not thread safe.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CloseIO
 * \sa SDL_FlushIO
 * \sa SDL_ReadIO
 * \sa SDL_SeekIO
 * \sa SDL_TellIO
 * \sa SDL_WriteIO
 *)
function SDL_IOFromFile(const &file: PUTF8Char; const mode: PUTF8Char): SDL_IOStream; cdecl;
  external LIB_SDL3 name _PU + 'SDL_IOFromFile';

const
  SDL_PROP_IOSTREAM_WINDOWS_HANDLE_POINTER = 'SDL.iostream.windows.handle';
  SDL_PROP_IOSTREAM_STDIO_FILE_POINTER = 'SDL.iostream.stdio.file';
  SDL_PROP_IOSTREAM_FILE_DESCRIPTOR_NUMBER = 'SDL.iostream.file_descriptor';
  SDL_PROP_IOSTREAM_ANDROID_AASSET_POINTER = 'SDL.iostream.android.aasset';

(**
 * Use this function to prepare a read-write memory buffer for use with
 * SDL_IOStream.
 *
 * This function sets up an SDL_IOStream struct based on a memory area of a
 * certain size, for both read and write access.
 *
 * This memory buffer is not copied by the SDL_IOStream; the pointer you
 * provide must remain valid until you close the stream. Closing the stream
 * will not free the original buffer.
 *
 * If you need to make sure the SDL_IOStream never writes to the memory
 * buffer, you should use SDL_IOFromConstMem() with a read-only buffer of
 * memory instead.
 *
 * The following properties will be set at creation time by SDL:
 *
 * - `SDL_PROP_IOSTREAM_MEMORY_POINTER`: this will be the `mem` parameter that
 *   was passed to this function.
 * - `SDL_PROP_IOSTREAM_MEMORY_SIZE_NUMBER`: this will be the `size` parameter
 *   that was passed to this function.
 *
 * \param mem a pointer to a buffer to feed an SDL_IOStream stream.
 * \param size the buffer size, in bytes.
 * \returns a pointer to a new SDL_IOStream structure or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_IOFromConstMem
 * \sa SDL_CloseIO
 * \sa SDL_FlushIO
 * \sa SDL_ReadIO
 * \sa SDL_SeekIO
 * \sa SDL_TellIO
 * \sa SDL_WriteIO
 *)
function SDL_IOFromMem(mem: Pointer; size: NativeUInt): SDL_IOStream; cdecl;
  external LIB_SDL3 name _PU + 'SDL_IOFromMem';

const
  SDL_PROP_IOSTREAM_MEMORY_POINTER = 'SDL.iostream.memory.base';
  SDL_PROP_IOSTREAM_MEMORY_SIZE_NUMBER = 'SDL.iostream.memory.size';

(**
 * Use this function to prepare a read-only memory buffer for use with
 * SDL_IOStream.
 *
 * This function sets up an SDL_IOStream struct based on a memory area of a
 * certain size. It assumes the memory area is not writable.
 *
 * Attempting to write to this SDL_IOStream stream will report an error
 * without writing to the memory buffer.
 *
 * This memory buffer is not copied by the SDL_IOStream; the pointer you
 * provide must remain valid until you close the stream. Closing the stream
 * will not free the original buffer.
 *
 * If you need to write to a memory buffer, you should use SDL_IOFromMem()
 * with a writable buffer of memory instead.
 *
 * The following properties will be set at creation time by SDL:
 *
 * - `SDL_PROP_IOSTREAM_MEMORY_POINTER`: this will be the `mem` parameter that
 *   was passed to this function.
 * - `SDL_PROP_IOSTREAM_MEMORY_SIZE_NUMBER`: this will be the `size` parameter
 *   that was passed to this function.
 *
 * \param mem a pointer to a read-only buffer to feed an SDL_IOStream stream.
 * \param size the buffer size, in bytes.
 * \returns a pointer to a new SDL_IOStream structure or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_IOFromMem
 * \sa SDL_CloseIO
 * \sa SDL_ReadIO
 * \sa SDL_SeekIO
 * \sa SDL_TellIO
 *)
function SDL_IOFromConstMem(const mem: Pointer; size: NativeUInt): SDL_IOStream; cdecl;
  external LIB_SDL3 name _PU + 'SDL_IOFromConstMem';

(**
 * Use this function to create an SDL_IOStream that is backed by dynamically
 * allocated memory.
 *
 * This supports the following properties to provide access to the memory and
 * control over allocations:
 *
 * - `SDL_PROP_IOSTREAM_DYNAMIC_MEMORY_POINTER`: a pointer to the internal
 *   memory of the stream. This can be set to NULL to transfer ownership of
 *   the memory to the application, which should free the memory with
 *   SDL_free(). If this is done, the next operation on the stream must be
 *   SDL_CloseIO().
 * - `SDL_PROP_IOSTREAM_DYNAMIC_CHUNKSIZE_NUMBER`: memory will be allocated in
 *   multiples of this size, defaulting to 1024.
 *
 * \returns a pointer to a new SDL_IOStream structure or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CloseIO
 * \sa SDL_ReadIO
 * \sa SDL_SeekIO
 * \sa SDL_TellIO
 * \sa SDL_WriteIO
 *)
function SDL_IOFromDynamicMem(): SDL_IOStream; cdecl;
  external LIB_SDL3 name _PU + 'SDL_IOFromDynamicMem';

const
  SDL_PROP_IOSTREAM_DYNAMIC_MEMORY_POINTER = 'SDL.iostream.dynamic.memory';
  SDL_PROP_IOSTREAM_DYNAMIC_CHUNKSIZE_NUMBER = 'SDL.iostream.dynamic.chunksize';

(**
 * Create a custom SDL_IOStream.
 *
 * Applications do not need to use this function unless they are providing
 * their own SDL_IOStream implementation. If you just need an SDL_IOStream to
 * read/write a common data source, you should use the built-in
 * implementations in SDL, like SDL_IOFromFile() or SDL_IOFromMem(), etc.
 *
 * This function makes a copy of `iface` and the caller does not need to keep
 * it around after this call.
 *
 * \param iface the interface that implements this SDL_IOStream, initialized
 *              using SDL_INIT_INTERFACE().
 * \param userdata the pointer that will be passed to the interface functions.
 * \returns a pointer to the allocated memory on success or NULL on failure;
 *          call SDL_GetError() for more information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CloseIO
 * \sa SDL_INIT_INTERFACE
 * \sa SDL_IOFromConstMem
 * \sa SDL_IOFromFile
 * \sa SDL_IOFromMem
 *)
function SDL_OpenIO(const iface: PSDL_IOStreamInterface; userdata: Pointer): SDL_IOStream; cdecl;
  external LIB_SDL3 name _PU + 'SDL_OpenIO';

(**
 * Close and free an allocated SDL_IOStream structure.
 *
 * SDL_CloseIO() closes and cleans up the SDL_IOStream stream. It releases any
 * resources used by the stream and frees the SDL_IOStream itself. This
 * returns true on success, or false if the stream failed to flush to its
 * output (e.g. to disk).
 *
 * Note that if this fails to flush the stream for any reason, this function
 * reports an error, but the SDL_IOStream is still invalid once this function
 * returns.
 *
 * This call flushes any buffered writes to the operating system, but there
 * are no guarantees that those writes have gone to physical media; they might
 * be in the OS's file cache, waiting to go to disk later. If it's absolutely
 * crucial that writes go to disk immediately, so they are definitely stored
 * even if the power fails before the file cache would have caught up, one
 * should call SDL_FlushIO() before closing. Note that flushing takes time and
 * makes the system and your app operate less efficiently, so do so sparingly.
 *
 * \param context SDL_IOStream structure to close.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function is not thread safe.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_OpenIO
 *)
function SDL_CloseIO(context: SDL_IOStream): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_CloseIO';

(**
 * Get the properties associated with an SDL_IOStream.
 *
 * \param context a pointer to an SDL_IOStream structure.
 * \returns a valid property ID on success or 0 on failure; call
 *          SDL_GetError() for more information.
 *
 * \threadsafety This function is not thread safe.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetIOProperties(context: SDL_IOStream): SDL_PropertiesID; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetIOProperties';

(**
 * Query the stream status of an SDL_IOStream.
 *
 * This information can be useful to decide if a short read or write was due
 * to an error, an EOF, or a non-blocking operation that isn't yet ready to
 * complete.
 *
 * An SDL_IOStream's status is only expected to change after a SDL_ReadIO or
 * SDL_WriteIO call; don't expect it to change if you just call this query
 * function in a tight loop.
 *
 * \param context the SDL_IOStream to query.
 * \returns an SDL_IOStatus enum with the current state.
 *
 * \threadsafety This function is not thread safe.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetIOStatus(context: SDL_IOStream): SDL_IOStatus; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetIOStatus';

(**
 * Use this function to get the size of the data stream in an SDL_IOStream.
 *
 * \param context the SDL_IOStream to get the size of the data stream from.
 * \returns the size of the data stream in the SDL_IOStream on success or a
 *          negative error code on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function is not thread safe.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetIOSize(context: SDL_IOStream): Sint64; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetIOSize';

(**
 * Seek within an SDL_IOStream data stream.
 *
 * This function seeks to byte `offset`, relative to `whence`.
 *
 * `whence` may be any of the following values:
 *
 * - `SDL_IO_SEEK_SET`: seek from the beginning of data
 * - `SDL_IO_SEEK_CUR`: seek relative to current read point
 * - `SDL_IO_SEEK_END`: seek relative to the end of data
 *
 * If this stream can not seek, it will return -1.
 *
 * \param context a pointer to an SDL_IOStream structure.
 * \param offset an offset in bytes, relative to `whence` location; can be
 *               negative.
 * \param whence any of `SDL_IO_SEEK_SET`, `SDL_IO_SEEK_CUR`,
 *               `SDL_IO_SEEK_END`.
 * \returns the final offset in the data stream after the seek or -1 on
 *          failure; call SDL_GetError() for more information.
 *
 * \threadsafety This function is not thread safe.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_TellIO
 *)
function SDL_SeekIO(context: SDL_IOStream; offset: Sint64; whence: SDL_IOWhence): Sint64; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SeekIO';

(**
 * Determine the current read/write offset in an SDL_IOStream data stream.
 *
 * SDL_TellIO is actually a wrapper function that calls the SDL_IOStream's
 * `seek` method, with an offset of 0 bytes from `SDL_IO_SEEK_CUR`, to
 * simplify application development.
 *
 * \param context an SDL_IOStream data stream object from which to get the
 *                current offset.
 * \returns the current offset in the stream, or -1 if the information can not
 *          be determined.
 *
 * \threadsafety This function is not thread safe.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SeekIO
 *)
function SDL_TellIO(context: SDL_IOStream): Sint64; cdecl;
  external LIB_SDL3 name _PU + 'SDL_TellIO';

(**
 * Read from a data source.
 *
 * This function reads up `size` bytes from the data source to the area
 * pointed at by `ptr`. This function may read less bytes than requested.
 *
 * This function will return zero when the data stream is completely read, and
 * SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If zero is returned and
 * the stream is not at EOF, SDL_GetIOStatus() will return a different error
 * value and SDL_GetError() will offer a human-readable message.
 *
 * \param context a pointer to an SDL_IOStream structure.
 * \param ptr a pointer to a buffer to read data into.
 * \param size the number of bytes to read from the data source.
 * \returns the number of bytes read, or 0 on end of file or other failure;
 *          call SDL_GetError() for more information.
 *
 * \threadsafety This function is not thread safe.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_WriteIO
 * \sa SDL_GetIOStatus
 *)
function SDL_ReadIO(context: SDL_IOStream; ptr: Pointer; size: NativeUInt): NativeUInt; cdecl;
  external LIB_SDL3 name _PU + 'SDL_ReadIO';

(**
 * Write to an SDL_IOStream data stream.
 *
 * This function writes exactly `size` bytes from the area pointed at by `ptr`
 * to the stream. If this fails for any reason, it'll return less than `size`
 * to demonstrate how far the write progressed. On success, it returns `size`.
 *
 * On error, this function still attempts to write as much as possible, so it
 * might return a positive value less than the requested write size.
 *
 * The caller can use SDL_GetIOStatus() to determine if the problem is
 * recoverable, such as a non-blocking write that can simply be retried later,
 * or a fatal error.
 *
 * \param context a pointer to an SDL_IOStream structure.
 * \param ptr a pointer to a buffer containing data to write.
 * \param size the number of bytes to write.
 * \returns the number of bytes written, which will be less than `size` on
 *          failure; call SDL_GetError() for more information.
 *
 * \threadsafety This function is not thread safe.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_IOprintf
 * \sa SDL_ReadIO
 * \sa SDL_SeekIO
 * \sa SDL_FlushIO
 * \sa SDL_GetIOStatus
 *)
function SDL_WriteIO(context: SDL_IOStream; const ptr: Pointer; size: NativeUInt): NativeUInt; cdecl;
  external LIB_SDL3 name _PU + 'SDL_WriteIO';

(**
 * Print to an SDL_IOStream data stream.
 *
 * This function does formatted printing to the stream.
 *
 * \param context a pointer to an SDL_IOStream structure.
 * \param fmt a printf() style format string.
 * \param ... additional parameters matching % tokens in the `fmt` string, if
 *            any.
 * \returns the number of bytes written or 0 on failure; call SDL_GetError()
 *          for more information.
 *
 * \threadsafety This function is not thread safe.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_IOvprintf
 * \sa SDL_WriteIO
 *)
function SDL_IOprintf(context: SDL_IOStream; const fmt: PUTF8Char): NativeUInt varargs; cdecl;
  external LIB_SDL3 name _PU + 'SDL_IOprintf';

(**
 * Print to an SDL_IOStream data stream.
 *
 * This function does formatted printing to the stream.
 *
 * \param context a pointer to an SDL_IOStream structure.
 * \param fmt a printf() style format string.
 * \param ap a variable argument list.
 * \returns the number of bytes written or 0 on failure; call SDL_GetError()
 *          for more information.
 *
 * \threadsafety This function is not thread safe.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_IOprintf
 * \sa SDL_WriteIO
 *)
function SDL_IOvprintf(context: SDL_IOStream; const fmt: PUTF8Char; ap: Pointer): NativeUInt; cdecl;
  external LIB_SDL3 name _PU + 'SDL_IOvprintf';

(**
 * Flush any buffered data in the stream.
 *
 * This function makes sure that any buffered data is written to the stream.
 * Normally this isn't necessary but if the stream is a pipe or socket it
 * guarantees that any pending data is sent.
 *
 * \param context SDL_IOStream structure to flush.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function is not thread safe.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_OpenIO
 * \sa SDL_WriteIO
 *)
function SDL_FlushIO(context: SDL_IOStream): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_FlushIO';

(**
 * Load all the data from an SDL data stream.
 *
 * The data is allocated with a zero byte at the end (null terminated) for
 * convenience. This extra byte is not included in the value reported via
 * `datasize`.
 *
 * The data should be freed with SDL_free().
 *
 * \param src the SDL_IOStream to read all available data from.
 * \param datasize a pointer filled in with the number of bytes read, may be
 *                 NULL.
 * \param closeio if true, calls SDL_CloseIO() on `src` before returning, even
 *                in the case of an error.
 * \returns the data or NULL on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function is not thread safe.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_LoadFile
 * \sa SDL_SaveFile_IO
 *)
function SDL_LoadFile_IO(src: SDL_IOStream; datasize: PNativeUInt; closeio: Boolean): Pointer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_LoadFile_IO';

(**
 * Load all the data from a file path.
 *
 * The data is allocated with a zero byte at the end (null terminated) for
 * convenience. This extra byte is not included in the value reported via
 * `datasize`.
 *
 * The data should be freed with SDL_free().
 *
 * \param file the path to read all available data from.
 * \param datasize if not NULL, will store the number of bytes read.
 * \returns the data or NULL on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function is not thread safe.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_LoadFile_IO
 * \sa SDL_SaveFile
 *)
function SDL_LoadFile(const &file: PUTF8Char; datasize: PNativeUInt): Pointer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_LoadFile';

(**
 * Save all the data into an SDL data stream.
 *
 * \param src the SDL_IOStream to write all data to.
 * \param data the data to be written. If datasize is 0, may be NULL or a
 *             invalid pointer.
 * \param datasize the number of bytes to be written.
 * \param closeio if true, calls SDL_CloseIO() on `src` before returning, even
 *                in the case of an error.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function is not thread safe.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SaveFile
 * \sa SDL_LoadFile_IO
 *)
function SDL_SaveFile_IO(src: SDL_IOStream; const data: Pointer; datasize: NativeUInt; closeio: Boolean): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SaveFile_IO';

(**
 * Save all the data into a file path.
 *
 * \param file the path to write all available data into.
 * \param data the data to be written. If datasize is 0, may be NULL or a
 *             invalid pointer.
 * \param datasize the number of bytes to be written.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function is not thread safe.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SaveFile_IO
 * \sa SDL_LoadFile
 *)
function SDL_SaveFile(const &file: PUTF8Char; const data: Pointer; datasize: NativeUInt): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SaveFile';

(**
 * Use this function to read a byte from an SDL_IOStream.
 *
 * This function will return false when the data stream is completely read,
 * and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned
 * and the stream is not at EOF, SDL_GetIOStatus() will return a different
 * error value and SDL_GetError() will offer a human-readable message.
 *
 * \param src the SDL_IOStream to read from.
 * \param value a pointer filled in with the data read.
 * \returns true on success or false on failure or EOF; call SDL_GetError()
 *          for more information.
 *
 * \threadsafety This function is not thread safe.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_ReadU8(src: SDL_IOStream; value: PUint8): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_ReadU8';

(**
 * Use this function to read a signed byte from an SDL_IOStream.
 *
 * This function will return false when the data stream is completely read,
 * and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned
 * and the stream is not at EOF, SDL_GetIOStatus() will return a different
 * error value and SDL_GetError() will offer a human-readable message.
 *
 * \param src the SDL_IOStream to read from.
 * \param value a pointer filled in with the data read.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function is not thread safe.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_ReadS8(src: SDL_IOStream; value: PSint8): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_ReadS8';

(**
 * Use this function to read 16 bits of little-endian data from an
 * SDL_IOStream and return in native format.
 *
 * SDL byteswaps the data only if necessary, so the data returned will be in
 * the native byte order.
 *
 * This function will return false when the data stream is completely read,
 * and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned
 * and the stream is not at EOF, SDL_GetIOStatus() will return a different
 * error value and SDL_GetError() will offer a human-readable message.
 *
 * \param src the stream from which to read data.
 * \param value a pointer filled in with the data read.
 * \returns true on successful write or false on failure; call SDL_GetError()
 *          for more information.
 *
 * \threadsafety This function is not thread safe.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_ReadU16LE(src: SDL_IOStream; value: PUint16): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_ReadU16LE';

(**
 * Use this function to read 16 bits of little-endian data from an
 * SDL_IOStream and return in native format.
 *
 * SDL byteswaps the data only if necessary, so the data returned will be in
 * the native byte order.
 *
 * This function will return false when the data stream is completely read,
 * and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned
 * and the stream is not at EOF, SDL_GetIOStatus() will return a different
 * error value and SDL_GetError() will offer a human-readable message.
 *
 * \param src the stream from which to read data.
 * \param value a pointer filled in with the data read.
 * \returns true on successful write or false on failure; call SDL_GetError()
 *          for more information.
 *
 * \threadsafety This function is not thread safe.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_ReadS16LE(src: SDL_IOStream; value: PSint16): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_ReadS16LE';

(**
 * Use this function to read 16 bits of big-endian data from an SDL_IOStream
 * and return in native format.
 *
 * SDL byteswaps the data only if necessary, so the data returned will be in
 * the native byte order.
 *
 * This function will return false when the data stream is completely read,
 * and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned
 * and the stream is not at EOF, SDL_GetIOStatus() will return a different
 * error value and SDL_GetError() will offer a human-readable message.
 *
 * \param src the stream from which to read data.
 * \param value a pointer filled in with the data read.
 * \returns true on successful write or false on failure; call SDL_GetError()
 *          for more information.
 *
 * \threadsafety This function is not thread safe.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_ReadU16BE(src: SDL_IOStream; value: PUint16): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_ReadU16BE';

(**
 * Use this function to read 16 bits of big-endian data from an SDL_IOStream
 * and return in native format.
 *
 * SDL byteswaps the data only if necessary, so the data returned will be in
 * the native byte order.
 *
 * This function will return false when the data stream is completely read,
 * and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned
 * and the stream is not at EOF, SDL_GetIOStatus() will return a different
 * error value and SDL_GetError() will offer a human-readable message.
 *
 * \param src the stream from which to read data.
 * \param value a pointer filled in with the data read.
 * \returns true on successful write or false on failure; call SDL_GetError()
 *          for more information.
 *
 * \threadsafety This function is not thread safe.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_ReadS16BE(src: SDL_IOStream; value: PSint16): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_ReadS16BE';

(**
 * Use this function to read 32 bits of little-endian data from an
 * SDL_IOStream and return in native format.
 *
 * SDL byteswaps the data only if necessary, so the data returned will be in
 * the native byte order.
 *
 * This function will return false when the data stream is completely read,
 * and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned
 * and the stream is not at EOF, SDL_GetIOStatus() will return a different
 * error value and SDL_GetError() will offer a human-readable message.
 *
 * \param src the stream from which to read data.
 * \param value a pointer filled in with the data read.
 * \returns true on successful write or false on failure; call SDL_GetError()
 *          for more information.
 *
 * \threadsafety This function is not thread safe.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_ReadU32LE(src: SDL_IOStream; value: PUint32): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_ReadU32LE';

(**
 * Use this function to read 32 bits of little-endian data from an
 * SDL_IOStream and return in native format.
 *
 * SDL byteswaps the data only if necessary, so the data returned will be in
 * the native byte order.
 *
 * This function will return false when the data stream is completely read,
 * and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned
 * and the stream is not at EOF, SDL_GetIOStatus() will return a different
 * error value and SDL_GetError() will offer a human-readable message.
 *
 * \param src the stream from which to read data.
 * \param value a pointer filled in with the data read.
 * \returns true on successful write or false on failure; call SDL_GetError()
 *          for more information.
 *
 * \threadsafety This function is not thread safe.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_ReadS32LE(src: SDL_IOStream; value: PSint32): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_ReadS32LE';

(**
 * Use this function to read 32 bits of big-endian data from an SDL_IOStream
 * and return in native format.
 *
 * SDL byteswaps the data only if necessary, so the data returned will be in
 * the native byte order.
 *
 * This function will return false when the data stream is completely read,
 * and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned
 * and the stream is not at EOF, SDL_GetIOStatus() will return a different
 * error value and SDL_GetError() will offer a human-readable message.
 *
 * \param src the stream from which to read data.
 * \param value a pointer filled in with the data read.
 * \returns true on successful write or false on failure; call SDL_GetError()
 *          for more information.
 *
 * \threadsafety This function is not thread safe.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_ReadU32BE(src: SDL_IOStream; value: PUint32): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_ReadU32BE';

(**
 * Use this function to read 32 bits of big-endian data from an SDL_IOStream
 * and return in native format.
 *
 * SDL byteswaps the data only if necessary, so the data returned will be in
 * the native byte order.
 *
 * This function will return false when the data stream is completely read,
 * and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned
 * and the stream is not at EOF, SDL_GetIOStatus() will return a different
 * error value and SDL_GetError() will offer a human-readable message.
 *
 * \param src the stream from which to read data.
 * \param value a pointer filled in with the data read.
 * \returns true on successful write or false on failure; call SDL_GetError()
 *          for more information.
 *
 * \threadsafety This function is not thread safe.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_ReadS32BE(src: SDL_IOStream; value: PSint32): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_ReadS32BE';

(**
 * Use this function to read 64 bits of little-endian data from an
 * SDL_IOStream and return in native format.
 *
 * SDL byteswaps the data only if necessary, so the data returned will be in
 * the native byte order.
 *
 * This function will return false when the data stream is completely read,
 * and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned
 * and the stream is not at EOF, SDL_GetIOStatus() will return a different
 * error value and SDL_GetError() will offer a human-readable message.
 *
 * \param src the stream from which to read data.
 * \param value a pointer filled in with the data read.
 * \returns true on successful write or false on failure; call SDL_GetError()
 *          for more information.
 *
 * \threadsafety This function is not thread safe.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_ReadU64LE(src: SDL_IOStream; value: PUint64): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_ReadU64LE';

(**
 * Use this function to read 64 bits of little-endian data from an
 * SDL_IOStream and return in native format.
 *
 * SDL byteswaps the data only if necessary, so the data returned will be in
 * the native byte order.
 *
 * This function will return false when the data stream is completely read,
 * and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned
 * and the stream is not at EOF, SDL_GetIOStatus() will return a different
 * error value and SDL_GetError() will offer a human-readable message.
 *
 * \param src the stream from which to read data.
 * \param value a pointer filled in with the data read.
 * \returns true on successful write or false on failure; call SDL_GetError()
 *          for more information.
 *
 * \threadsafety This function is not thread safe.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_ReadS64LE(src: SDL_IOStream; value: PSint64): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_ReadS64LE';

(**
 * Use this function to read 64 bits of big-endian data from an SDL_IOStream
 * and return in native format.
 *
 * SDL byteswaps the data only if necessary, so the data returned will be in
 * the native byte order.
 *
 * This function will return false when the data stream is completely read,
 * and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned
 * and the stream is not at EOF, SDL_GetIOStatus() will return a different
 * error value and SDL_GetError() will offer a human-readable message.
 *
 * \param src the stream from which to read data.
 * \param value a pointer filled in with the data read.
 * \returns true on successful write or false on failure; call SDL_GetError()
 *          for more information.
 *
 * \threadsafety This function is not thread safe.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_ReadU64BE(src: SDL_IOStream; value: PUint64): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_ReadU64BE';

(**
 * Use this function to read 64 bits of big-endian data from an SDL_IOStream
 * and return in native format.
 *
 * SDL byteswaps the data only if necessary, so the data returned will be in
 * the native byte order.
 *
 * This function will return false when the data stream is completely read,
 * and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned
 * and the stream is not at EOF, SDL_GetIOStatus() will return a different
 * error value and SDL_GetError() will offer a human-readable message.
 *
 * \param src the stream from which to read data.
 * \param value a pointer filled in with the data read.
 * \returns true on successful write or false on failure; call SDL_GetError()
 *          for more information.
 *
 * \threadsafety This function is not thread safe.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_ReadS64BE(src: SDL_IOStream; value: PSint64): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_ReadS64BE';

(**
 * Use this function to write a byte to an SDL_IOStream.
 *
 * \param dst the SDL_IOStream to write to.
 * \param value the byte value to write.
 * \returns true on successful write or false on failure; call SDL_GetError()
 *          for more information.
 *
 * \threadsafety This function is not thread safe.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_WriteU8(dst: SDL_IOStream; value: Uint8): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_WriteU8';

(**
 * Use this function to write a signed byte to an SDL_IOStream.
 *
 * \param dst the SDL_IOStream to write to.
 * \param value the byte value to write.
 * \returns true on successful write or false on failure; call SDL_GetError()
 *          for more information.
 *
 * \threadsafety This function is not thread safe.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_WriteS8(dst: SDL_IOStream; value: Sint8): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_WriteS8';

(**
 * Use this function to write 16 bits in native format to an SDL_IOStream as
 * little-endian data.
 *
 * SDL byteswaps the data only if necessary, so the application always
 * specifies native format, and the data written will be in little-endian
 * format.
 *
 * \param dst the stream to which data will be written.
 * \param value the data to be written, in native format.
 * \returns true on successful write or false on failure; call SDL_GetError()
 *          for more information.
 *
 * \threadsafety This function is not thread safe.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_WriteU16LE(dst: SDL_IOStream; value: Uint16): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_WriteU16LE';

(**
 * Use this function to write 16 bits in native format to an SDL_IOStream as
 * little-endian data.
 *
 * SDL byteswaps the data only if necessary, so the application always
 * specifies native format, and the data written will be in little-endian
 * format.
 *
 * \param dst the stream to which data will be written.
 * \param value the data to be written, in native format.
 * \returns true on successful write or false on failure; call SDL_GetError()
 *          for more information.
 *
 * \threadsafety This function is not thread safe.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_WriteS16LE(dst: SDL_IOStream; value: Sint16): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_WriteS16LE';

(**
 * Use this function to write 16 bits in native format to an SDL_IOStream as
 * big-endian data.
 *
 * SDL byteswaps the data only if necessary, so the application always
 * specifies native format, and the data written will be in big-endian format.
 *
 * \param dst the stream to which data will be written.
 * \param value the data to be written, in native format.
 * \returns true on successful write or false on failure; call SDL_GetError()
 *          for more information.
 *
 * \threadsafety This function is not thread safe.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_WriteU16BE(dst: SDL_IOStream; value: Uint16): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_WriteU16BE';

(**
 * Use this function to write 16 bits in native format to an SDL_IOStream as
 * big-endian data.
 *
 * SDL byteswaps the data only if necessary, so the application always
 * specifies native format, and the data written will be in big-endian format.
 *
 * \param dst the stream to which data will be written.
 * \param value the data to be written, in native format.
 * \returns true on successful write or false on failure; call SDL_GetError()
 *          for more information.
 *
 * \threadsafety This function is not thread safe.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_WriteS16BE(dst: SDL_IOStream; value: Sint16): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_WriteS16BE';

(**
 * Use this function to write 32 bits in native format to an SDL_IOStream as
 * little-endian data.
 *
 * SDL byteswaps the data only if necessary, so the application always
 * specifies native format, and the data written will be in little-endian
 * format.
 *
 * \param dst the stream to which data will be written.
 * \param value the data to be written, in native format.
 * \returns true on successful write or false on failure; call SDL_GetError()
 *          for more information.
 *
 * \threadsafety This function is not thread safe.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_WriteU32LE(dst: SDL_IOStream; value: Uint32): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_WriteU32LE';

(**
 * Use this function to write 32 bits in native format to an SDL_IOStream as
 * little-endian data.
 *
 * SDL byteswaps the data only if necessary, so the application always
 * specifies native format, and the data written will be in little-endian
 * format.
 *
 * \param dst the stream to which data will be written.
 * \param value the data to be written, in native format.
 * \returns true on successful write or false on failure; call SDL_GetError()
 *          for more information.
 *
 * \threadsafety This function is not thread safe.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_WriteS32LE(dst: SDL_IOStream; value: Sint32): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_WriteS32LE';

(**
 * Use this function to write 32 bits in native format to an SDL_IOStream as
 * big-endian data.
 *
 * SDL byteswaps the data only if necessary, so the application always
 * specifies native format, and the data written will be in big-endian format.
 *
 * \param dst the stream to which data will be written.
 * \param value the data to be written, in native format.
 * \returns true on successful write or false on failure; call SDL_GetError()
 *          for more information.
 *
 * \threadsafety This function is not thread safe.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_WriteU32BE(dst: SDL_IOStream; value: Uint32): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_WriteU32BE';

(**
 * Use this function to write 32 bits in native format to an SDL_IOStream as
 * big-endian data.
 *
 * SDL byteswaps the data only if necessary, so the application always
 * specifies native format, and the data written will be in big-endian format.
 *
 * \param dst the stream to which data will be written.
 * \param value the data to be written, in native format.
 * \returns true on successful write or false on failure; call SDL_GetError()
 *          for more information.
 *
 * \threadsafety This function is not thread safe.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_WriteS32BE(dst: SDL_IOStream; value: Sint32): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_WriteS32BE';

(**
 * Use this function to write 64 bits in native format to an SDL_IOStream as
 * little-endian data.
 *
 * SDL byteswaps the data only if necessary, so the application always
 * specifies native format, and the data written will be in little-endian
 * format.
 *
 * \param dst the stream to which data will be written.
 * \param value the data to be written, in native format.
 * \returns true on successful write or false on failure; call SDL_GetError()
 *          for more information.
 *
 * \threadsafety This function is not thread safe.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_WriteU64LE(dst: SDL_IOStream; value: Uint64): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_WriteU64LE';

(**
 * Use this function to write 64 bits in native format to an SDL_IOStream as
 * little-endian data.
 *
 * SDL byteswaps the data only if necessary, so the application always
 * specifies native format, and the data written will be in little-endian
 * format.
 *
 * \param dst the stream to which data will be written.
 * \param value the data to be written, in native format.
 * \returns true on successful write or false on failure; call SDL_GetError()
 *          for more information.
 *
 * \threadsafety This function is not thread safe.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_WriteS64LE(dst: SDL_IOStream; value: Sint64): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_WriteS64LE';

(**
 * Use this function to write 64 bits in native format to an SDL_IOStream as
 * big-endian data.
 *
 * SDL byteswaps the data only if necessary, so the application always
 * specifies native format, and the data written will be in big-endian format.
 *
 * \param dst the stream to which data will be written.
 * \param value the data to be written, in native format.
 * \returns true on successful write or false on failure; call SDL_GetError()
 *          for more information.
 *
 * \threadsafety This function is not thread safe.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_WriteU64BE(dst: SDL_IOStream; value: Uint64): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_WriteU64BE';

(**
 * Use this function to write 64 bits in native format to an SDL_IOStream as
 * big-endian data.
 *
 * SDL byteswaps the data only if necessary, so the application always
 * specifies native format, and the data written will be in big-endian format.
 *
 * \param dst the stream to which data will be written.
 * \param value the data to be written, in native format.
 * \returns true on successful write or false on failure; call SDL_GetError()
 *          for more information.
 *
 * \threadsafety This function is not thread safe.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_WriteS64BE(dst: SDL_IOStream; value: Sint64): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_WriteS64BE';
{$ENDREGION 'SDL_iostream.h'}

{$REGION 'SDL_audio.h'}
(**
 * # CategoryAudio
 *
 * Audio functionality for the SDL library.
 *
 * All audio in SDL3 revolves around SDL_AudioStream. Whether you want to play
 * or record audio, convert it, stream it, buffer it, or mix it, you're going
 * to be passing it through an audio stream.
 *
 * Audio streams are quite flexible; they can accept any amount of data at a
 * time, in any supported format, and output it as needed in any other format,
 * even if the data format changes on either side halfway through.
 *
 * An app opens an audio device and binds any number of audio streams to it,
 * feeding more data to the streams as available. When the device needs more
 * data, it will pull it from all bound streams and mix them together for
 * playback.
 *
 * Audio streams can also use an app-provided callback to supply data
 * on-demand, which maps pretty closely to the SDL2 audio model.
 *
 * SDL also provides a simple .WAV loader in SDL_LoadWAV (and SDL_LoadWAV_IO
 * if you aren't reading from a file) as a basic means to load sound data into
 * your program.
 *
 * ## Logical audio devices
 *
 * In SDL3, opening a physical device (like a SoundBlaster 16 Pro) gives you a
 * logical device ID that you can bind audio streams to. In almost all cases,
 * logical devices can be used anywhere in the API that a physical device is
 * normally used. However, since each device opening generates a new logical
 * device, different parts of the program (say, a VoIP library, or
 * text-to-speech framework, or maybe some other sort of mixer on top of SDL)
 * can have their own device opens that do not interfere with each other; each
 * logical device will mix its separate audio down to a single buffer, fed to
 * the physical device, behind the scenes. As many logical devices as you like
 * can come and go; SDL will only have to open the physical device at the OS
 * level once, and will manage all the logical devices on top of it
 * internally.
 *
 * One other benefit of logical devices: if you don't open a specific physical
 * device, instead opting for the default, SDL can automatically migrate those
 * logical devices to different hardware as circumstances change: a user
 * plugged in headphones? The system default changed? SDL can transparently
 * migrate the logical devices to the correct physical device seamlessly and
 * keep playing; the app doesn't even have to know it happened if it doesn't
 * want to.
 *
 * ## Simplified audio
 *
 * As a simplified model for when a single source of audio is all that's
 * needed, an app can use SDL_OpenAudioDeviceStream, which is a single
 * function to open an audio device, create an audio stream, bind that stream
 * to the newly-opened device, and (optionally) provide a callback for
 * obtaining audio data. When using this function, the primary interface is
 * the SDL_AudioStream and the device handle is mostly hidden away; destroying
 * a stream created through this function will also close the device, stream
 * bindings cannot be changed, etc. One other quirk of this is that the device
 * is started in a _paused_ state and must be explicitly resumed; this is
 * partially to offer a clean migration for SDL2 apps and partially because
 * the app might have to do more setup before playback begins; in the
 * non-simplified form, nothing will play until a stream is bound to a device,
 * so they start _unpaused_.
 *
 * ## Channel layouts
 *
 * Audio data passing through SDL is uncompressed PCM data, interleaved. One
 * can provide their own decompression through an MP3, etc, decoder, but SDL
 * does not provide this directly. Each interleaved channel of data is meant
 * to be in a specific order.
 *
 * Abbreviations:
 *
 * - FRONT = single mono speaker
 * - FL = front left speaker
 * - FR = front right speaker
 * - FC = front center speaker
 * - BL = back left speaker
 * - BR = back right speaker
 * - SR = surround right speaker
 * - SL = surround left speaker
 * - BC = back center speaker
 * - LFE = low-frequency speaker
 *
 * These are listed in the order they are laid out in memory, so "FL, FR"
 * means "the front left speaker is laid out in memory first, then the front
 * right, then it repeats for the next audio frame".
 *
 * - 1 channel (mono) layout: FRONT
 * - 2 channels (stereo) layout: FL, FR
 * - 3 channels (2.1) layout: FL, FR, LFE
 * - 4 channels (quad) layout: FL, FR, BL, BR
 * - 5 channels (4.1) layout: FL, FR, LFE, BL, BR
 * - 6 channels (5.1) layout: FL, FR, FC, LFE, BL, BR (last two can also be
 *   SL, SR)
 * - 7 channels (6.1) layout: FL, FR, FC, LFE, BC, SL, SR
 * - 8 channels (7.1) layout: FL, FR, FC, LFE, BL, BR, SL, SR
 *
 * This is the same order as DirectSound expects, but applied to all
 * platforms; SDL will swizzle the channels as necessary if a platform expects
 * something different.
 *
 * SDL_AudioStream can also be provided channel maps to change this ordering
 * to whatever is necessary, in other audio processing scenarios.
 *)

const
  (**
   * Mask of bits in an SDL_AudioFormat that contains the format bit size.
   *
   * Generally one should use SDL_AUDIO_BITSIZE instead of this macro directly.
   *
   * \since This macro is available since SDL 3.2.0.
   *)
  SDL_AUDIO_MASK_BITSIZE = $FF;

  (**
   * Mask of bits in an SDL_AudioFormat that contain the floating point flag.
   *
   * Generally one should use SDL_AUDIO_ISFLOAT instead of this macro directly.
   *
   * \since This macro is available since SDL 3.2.0.
   *)
  SDL_AUDIO_MASK_FLOAT = (1 shl 8);

  (**
   * Mask of bits in an SDL_AudioFormat that contain the bigendian flag.
   *
   * Generally one should use SDL_AUDIO_ISBIGENDIAN or SDL_AUDIO_ISLITTLEENDIAN
   * instead of this macro directly.
   *
   * \since This macro is available since SDL 3.2.0.
   *)
  SDL_AUDIO_MASK_BIG_ENDIAN = (1 shl 12);

  (**
   * Mask of bits in an SDL_AudioFormat that contain the signed data flag.
   *
   * Generally one should use SDL_AUDIO_ISSIGNED instead of this macro directly.
   *
   * \since This macro is available since SDL 3.2.0.
   *)
  SDL_AUDIO_MASK_SIGNED = (1 shl 15);

(**
 * Define an SDL_AudioFormat value.
 *
 * SDL does not support custom audio formats, so this macro is not of much use
 * externally, but it can be illustrative as to what the various bits of an
 * SDL_AudioFormat mean.
 *
 * For example, SDL_AUDIO_S32LE looks like this:
 *
 * ```c
 * SDL_DEFINE_AUDIO_FORMAT(1, 0, 0, 32)
 * ```
 *
 * \param signed 1 for signed data, 0 for unsigned data.
 * \param bigendian 1 for bigendian data, 0 for littleendian data.
 * \param flt 1 for floating point data, 0 for integer data.
 * \param size number of bits per sample.
 * \returns a format value in the style of SDL_AudioFormat.
 *
 * \threadsafety It is safe to call this macro from any thread.
 *
 * \since This macro is available since SDL 3.2.0.
 *)
function SDL_DefineAudioFormat(signed, bigendian, flt: Boolean; size: Byte): Word; inline;

(**
 * Audio format.
 *
 * \since This enum is available since SDL 3.2.0.
 *
 * \sa SDL_AUDIO_BITSIZE
 * \sa SDL_AUDIO_BYTESIZE
 * \sa SDL_AUDIO_ISINT
 * \sa SDL_AUDIO_ISFLOAT
 * \sa SDL_AUDIO_ISBIGENDIAN
 * \sa SDL_AUDIO_ISLITTLEENDIAN
 * \sa SDL_AUDIO_ISSIGNED
 * \sa SDL_AUDIO_ISUNSIGNED
 *)
type
  SDL_AudioFormat = Integer;

const
  (** Unspecified audio format *)
  SDL_AUDIO_UNKNOWN = 0;
  (** Unsigned 8-bit samples *)
  SDL_AUDIO_U8 = 8;
  (** Signed 8-bit samples *)
  SDL_AUDIO_S8 = 32776;
  (** Signed 16-bit samples *)
  SDL_AUDIO_S16LE = 32784;
  (** As above, but big-endian byte order *)
  SDL_AUDIO_S16BE = 36880;
  (** 32-bit integer samples *)
  SDL_AUDIO_S32LE = 32800;
  (** As above, but big-endian byte order *)
  SDL_AUDIO_S32BE = 36896;
  (** 32-bit floating point samples *)
  SDL_AUDIO_F32LE = 33056;
  (** As above, but big-endian byte order *)
  SDL_AUDIO_F32BE = 37152;
  SDL_AUDIO_S16 = 32784;
  SDL_AUDIO_S32 = 32800;
  SDL_AUDIO_F32 = 33056;

(**
 * Retrieve the size, in bits, from an SDL_AudioFormat.
 *
 * For example, `SDL_AUDIO_BITSIZE(SDL_AUDIO_S16)` returns 16.
 *
 * \param x an SDL_AudioFormat value.
 * \returns data size in bits.
 *
 * \threadsafety It is safe to call this macro from any thread.
 *
 * \since This macro is available since SDL 3.2.0.
 *)
function SDL_AudioBitSize(x: Word): Byte; inline;

(**
 * Retrieve the size, in bytes, from an SDL_AudioFormat.
 *
 * For example, `SDL_AUDIO_BYTESIZE(SDL_AUDIO_S16)` returns 2.
 *
 * \param x an SDL_AudioFormat value.
 * \returns data size in bytes.
 *
 * \threadsafety It is safe to call this macro from any thread.
 *
 * \since This macro is available since SDL 3.2.0.
 *)
function SDL_AudioByteSize(x: Word): Byte; inline;

(**
 * Determine if an SDL_AudioFormat represents floating point data.
 *
 * For example, `SDL_AUDIO_ISFLOAT(SDL_AUDIO_S16)` returns 0.
 *
 * \param x an SDL_AudioFormat value.
 * \returns non-zero if format is floating point, zero otherwise.
 *
 * \threadsafety It is safe to call this macro from any thread.
 *
 * \since This macro is available since SDL 3.2.0.
 *)
function SDL_AudioIsFloat(x: Word): Boolean; inline;

(**
 * Determine if an SDL_AudioFormat represents bigendian data.
 *
 * For example, `SDL_AUDIO_ISBIGENDIAN(SDL_AUDIO_S16LE)` returns 0.
 *
 * \param x an SDL_AudioFormat value.
 * \returns non-zero if format is bigendian, zero otherwise.
 *
 * \threadsafety It is safe to call this macro from any thread.
 *
 * \since This macro is available since SDL 3.2.0.
 *)
function SDL_AudioIsBigEndian(x: Word): Boolean; inline;

(**
 * Determine if an SDL_AudioFormat represents littleendian data.
 *
 * For example, `SDL_AUDIO_ISLITTLEENDIAN(SDL_AUDIO_S16BE)` returns 0.
 *
 * \param x an SDL_AudioFormat value.
 * \returns non-zero if format is littleendian, zero otherwise.
 *
 * \threadsafety It is safe to call this macro from any thread.
 *
 * \since This macro is available since SDL 3.2.0.
 *)
function SDL_AudioIsLittleEndian(x: Word): Boolean; inline;

(**
 * Determine if an SDL_AudioFormat represents signed data.
 *
 * For example, `SDL_AUDIO_ISSIGNED(SDL_AUDIO_U8)` returns 0.
 *
 * \param x an SDL_AudioFormat value.
 * \returns non-zero if format is signed, zero otherwise.
 *
 * \threadsafety It is safe to call this macro from any thread.
 *
 * \since This macro is available since SDL 3.2.0.
 *)
function SDL_AudioIsSigned(x: Word): Boolean; inline;

(**
 * Determine if an SDL_AudioFormat represents integer data.
 *
 * For example, `SDL_AUDIO_ISINT(SDL_AUDIO_F32)` returns 0.
 *
 * \param x an SDL_AudioFormat value.
 * \returns non-zero if format is integer, zero otherwise.
 *
 * \threadsafety It is safe to call this macro from any thread.
 *
 * \since This macro is available since SDL 3.2.0.
 *)
function SDL_AudioIsInt(x: Word): Boolean; inline;

(**
 * Determine if an SDL_AudioFormat represents unsigned data.
 *
 * For example, `SDL_AUDIO_ISUNSIGNED(SDL_AUDIO_S16)` returns 0.
 *
 * \param x an SDL_AudioFormat value.
 * \returns non-zero if format is unsigned, zero otherwise.
 *
 * \threadsafety It is safe to call this macro from any thread.
 *
 * \since This macro is available since SDL 3.2.0.
 *)
function SDL_AudioIsUnsigned(x: Word): Boolean; inline;

type
  (**
   * SDL Audio Device instance IDs.
   *
   * Zero is used to signify an invalid/null device.
   *
   * \since This datatype is available since SDL 3.2.0.
   *)
  SDL_AudioDeviceID = Uint32;
  PSDL_AudioDeviceID = ^SDL_AudioDeviceID;

const
  (**
   * A value used to request a default playback audio device.
   *
   * Several functions that require an SDL_AudioDeviceID will accept this value
   * to signify the app just wants the system to choose a default device instead
   * of the app providing a specific one.
   *
   * \since This macro is available since SDL 3.2.0.
   *)
  SDL_AUDIO_DEVICE_DEFAULT_PLAYBACK = $FFFFFFFF;

  (**
   * A value used to request a default recording audio device.
   *
   * Several functions that require an SDL_AudioDeviceID will accept this value
   * to signify the app just wants the system to choose a default device instead
   * of the app providing a specific one.
   *
   * \since This macro is available since SDL 3.2.0.
   *)
  SDL_AUDIO_DEVICE_DEFAULT_RECORDING = $FFFFFFFE;

type
  (**
   * Format specifier for audio data.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_AudioFormat
   *)
  SDL_AudioSpec = record
    (** Audio data format *)
    format: SDL_AudioFormat;
    (** Number of channels: 1 mono, 2 stereo, etc *)
    channels: Integer;
    (** sample rate: sample frames per second *)
    freq: Integer;
  end;
  PSDL_AudioSpec = ^SDL_AudioSpec;

(**
 * Calculate the size of each audio frame (in bytes) from an SDL_AudioSpec.
 *
 * This reports on the size of an audio sample frame: stereo Sint16 data (2
 * channels of 2 bytes each) would be 4 bytes per frame, for example.
 *
 * \param x an SDL_AudioSpec to query.
 * \returns the number of bytes used per sample frame.
 *
 * \threadsafety It is safe to call this macro from any thread.
 *
 * \since This macro is available since SDL 3.2.0.
 *)
function SDL_AudioFrameSize(x: SDL_AudioSpec): Integer; inline;

type
  (**
   * The opaque handle that represents an audio stream.
   *
   * SDL_AudioStream is an audio conversion interface.
   *
   * - It can handle resampling data in chunks without generating artifacts,
   *   when it doesn't have the complete buffer available.
   * - It can handle incoming data in any variable size.
   * - It can handle input/output format changes on the fly.
   * - It can remap audio channels between inputs and outputs.
   * - You push data as you have it, and pull it when you need it
   * - It can also function as a basic audio data queue even if you just have
   *   sound that needs to pass from one place to another.
   * - You can hook callbacks up to them when more data is added or requested,
   *   to manage data on-the-fly.
   *
   * Audio streams are the core of the SDL3 audio interface. You create one or
   * more of them, bind them to an opened audio device, and feed data to them
   * (or for recording, consume data from them).
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_CreateAudioStream
   *)
  SDL_AudioStream = THandle;
  PSDL_AudioStream = ^SDL_AudioStream;

(**
 * Use this function to get the number of built-in audio drivers.
 *
 * This function returns a hardcoded number. This never returns a negative
 * value; if there are no drivers compiled into this build of SDL, this
 * function returns zero. The presence of a driver in this list does not mean
 * it will function, it just means SDL is capable of interacting with that
 * interface. For example, a build of SDL might have esound support, but if
 * there's no esound server available, SDL's esound driver would fail if used.
 *
 * By default, SDL tries all drivers, in its preferred order, until one is
 * found to be usable.
 *
 * \returns the number of built-in audio drivers.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetAudioDriver
 *)
function SDL_GetNumAudioDrivers(): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetNumAudioDrivers';

(**
 * Use this function to get the name of a built in audio driver.
 *
 * The list of audio drivers is given in the order that they are normally
 * initialized by default; the drivers that seem more reasonable to choose
 * first (as far as the SDL developers believe) are earlier in the list.
 *
 * The names of drivers are all simple, low-ASCII identifiers, like "alsa",
 * "coreaudio" or "wasapi". These never have Unicode characters, and are not
 * meant to be proper names.
 *
 * \param index the index of the audio driver; the value ranges from 0 to
 *              SDL_GetNumAudioDrivers() - 1.
 * \returns the name of the audio driver at the requested index, or NULL if an
 *          invalid index was specified.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetNumAudioDrivers
 *)
function SDL_GetAudioDriver(index: Integer): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetAudioDriver';

(**
 * Get the name of the current audio driver.
 *
 * The names of drivers are all simple, low-ASCII identifiers, like "alsa",
 * "coreaudio" or "wasapi". These never have Unicode characters, and are not
 * meant to be proper names.
 *
 * \returns the name of the current audio driver or NULL if no driver has been
 *          initialized.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetCurrentAudioDriver(): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetCurrentAudioDriver';

(**
 * Get a list of currently-connected audio playback devices.
 *
 * This returns of list of available devices that play sound, perhaps to
 * speakers or headphones ("playback" devices). If you want devices that
 * record audio, like a microphone ("recording" devices), use
 * SDL_GetAudioRecordingDevices() instead.
 *
 * This only returns a list of physical devices; it will not have any device
 * IDs returned by SDL_OpenAudioDevice().
 *
 * If this function returns NULL, to signify an error, `*count` will be set to
 * zero.
 *
 * \param count a pointer filled in with the number of devices returned, may
 *              be NULL.
 * \returns a 0 terminated array of device instance IDs or NULL on error; call
 *          SDL_GetError() for more information. This should be freed with
 *          SDL_free() when it is no longer needed.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_OpenAudioDevice
 * \sa SDL_GetAudioRecordingDevices
 *)
function SDL_GetAudioPlaybackDevices(count: PInteger): PSDL_AudioDeviceID; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetAudioPlaybackDevices';

(**
 * Get a list of currently-connected audio recording devices.
 *
 * This returns of list of available devices that record audio, like a
 * microphone ("recording" devices). If you want devices that play sound,
 * perhaps to speakers or headphones ("playback" devices), use
 * SDL_GetAudioPlaybackDevices() instead.
 *
 * This only returns a list of physical devices; it will not have any device
 * IDs returned by SDL_OpenAudioDevice().
 *
 * If this function returns NULL, to signify an error, `*count` will be set to
 * zero.
 *
 * \param count a pointer filled in with the number of devices returned, may
 *              be NULL.
 * \returns a 0 terminated array of device instance IDs, or NULL on failure;
 *          call SDL_GetError() for more information. This should be freed
 *          with SDL_free() when it is no longer needed.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_OpenAudioDevice
 * \sa SDL_GetAudioPlaybackDevices
 *)
function SDL_GetAudioRecordingDevices(count: PInteger): PSDL_AudioDeviceID; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetAudioRecordingDevices';

(**
 * Get the human-readable name of a specific audio device.
 *
 * \param devid the instance ID of the device to query.
 * \returns the name of the audio device, or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetAudioPlaybackDevices
 * \sa SDL_GetAudioRecordingDevices
 *)
function SDL_GetAudioDeviceName(devid: SDL_AudioDeviceID): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetAudioDeviceName';

(**
 * Get the current audio format of a specific audio device.
 *
 * For an opened device, this will report the format the device is currently
 * using. If the device isn't yet opened, this will report the device's
 * preferred format (or a reasonable default if this can't be determined).
 *
 * You may also specify SDL_AUDIO_DEVICE_DEFAULT_PLAYBACK or
 * SDL_AUDIO_DEVICE_DEFAULT_RECORDING here, which is useful for getting a
 * reasonable recommendation before opening the system-recommended default
 * device.
 *
 * You can also use this to request the current device buffer size. This is
 * specified in sample frames and represents the amount of data SDL will feed
 * to the physical hardware in each chunk. This can be converted to
 * milliseconds of audio with the following equation:
 *
 * `ms = (int) ((((Sint64) frames) * 1000) / spec.freq);`
 *
 * Buffer size is only important if you need low-level control over the audio
 * playback timing. Most apps do not need this.
 *
 * \param devid the instance ID of the device to query.
 * \param spec on return, will be filled with device details.
 * \param sample_frames pointer to store device buffer size, in sample frames.
 *                      Can be NULL.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetAudioDeviceFormat(devid: SDL_AudioDeviceID; spec: PSDL_AudioSpec; sample_frames: PInteger): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetAudioDeviceFormat';

(**
 * Get the current channel map of an audio device.
 *
 * Channel maps are optional; most things do not need them, instead passing
 * data in the [order that SDL expects](CategoryAudio#channel-layouts).
 *
 * Audio devices usually have no remapping applied. This is represented by
 * returning NULL, and does not signify an error.
 *
 * \param devid the instance ID of the device to query.
 * \param count On output, set to number of channels in the map. Can be NULL.
 * \returns an array of the current channel mapping, with as many elements as
 *          the current output spec's channels, or NULL if default. This
 *          should be freed with SDL_free() when it is no longer needed.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetAudioStreamInputChannelMap
 *)
function SDL_GetAudioDeviceChannelMap(devid: SDL_AudioDeviceID; count: PInteger): PInteger; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetAudioDeviceChannelMap';

(**
 * Open a specific audio device.
 *
 * You can open both playback and recording devices through this function.
 * Playback devices will take data from bound audio streams, mix it, and send
 * it to the hardware. Recording devices will feed any bound audio streams
 * with a copy of any incoming data.
 *
 * An opened audio device starts out with no audio streams bound. To start
 * audio playing, bind a stream and supply audio data to it. Unlike SDL2,
 * there is no audio callback; you only bind audio streams and make sure they
 * have data flowing into them (however, you can simulate SDL2's semantics
 * fairly closely by using SDL_OpenAudioDeviceStream instead of this
 * function).
 *
 * If you don't care about opening a specific device, pass a `devid` of either
 * `SDL_AUDIO_DEVICE_DEFAULT_PLAYBACK` or
 * `SDL_AUDIO_DEVICE_DEFAULT_RECORDING`. In this case, SDL will try to pick
 * the most reasonable default, and may also switch between physical devices
 * seamlessly later, if the most reasonable default changes during the
 * lifetime of this opened device (user changed the default in the OS's system
 * preferences, the default got unplugged so the system jumped to a new
 * default, the user plugged in headphones on a mobile device, etc). Unless
 * you have a good reason to choose a specific device, this is probably what
 * you want.
 *
 * You may request a specific format for the audio device, but there is no
 * promise the device will honor that request for several reasons. As such,
 * it's only meant to be a hint as to what data your app will provide. Audio
 * streams will accept data in whatever format you specify and manage
 * conversion for you as appropriate. SDL_GetAudioDeviceFormat can tell you
 * the preferred format for the device before opening and the actual format
 * the device is using after opening.
 *
 * It's legal to open the same device ID more than once; each successful open
 * will generate a new logical SDL_AudioDeviceID that is managed separately
 * from others on the same physical device. This allows libraries to open a
 * device separately from the main app and bind its own streams without
 * conflicting.
 *
 * It is also legal to open a device ID returned by a previous call to this
 * function; doing so just creates another logical device on the same physical
 * device. This may be useful for making logical groupings of audio streams.
 *
 * This function returns the opened device ID on success. This is a new,
 * unique SDL_AudioDeviceID that represents a logical device.
 *
 * Some backends might offer arbitrary devices (for example, a networked audio
 * protocol that can connect to an arbitrary server). For these, as a change
 * from SDL2, you should open a default device ID and use an SDL hint to
 * specify the target if you care, or otherwise let the backend figure out a
 * reasonable default. Most backends don't offer anything like this, and often
 * this would be an end user setting an environment variable for their custom
 * need, and not something an application should specifically manage.
 *
 * When done with an audio device, possibly at the end of the app's life, one
 * should call SDL_CloseAudioDevice() on the returned device id.
 *
 * \param devid the device instance id to open, or
 *              SDL_AUDIO_DEVICE_DEFAULT_PLAYBACK or
 *              SDL_AUDIO_DEVICE_DEFAULT_RECORDING for the most reasonable
 *              default device.
 * \param spec the requested device configuration. Can be NULL to use
 *             reasonable defaults.
 * \returns the device ID on success or 0 on failure; call SDL_GetError() for
 *          more information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CloseAudioDevice
 * \sa SDL_GetAudioDeviceFormat
 *)
function SDL_OpenAudioDevice(devid: SDL_AudioDeviceID; const spec: PSDL_AudioSpec): SDL_AudioDeviceID; cdecl;
  external LIB_SDL3 name _PU + 'SDL_OpenAudioDevice';

(**
 * Determine if an audio device is physical (instead of logical).
 *
 * An SDL_AudioDeviceID that represents physical hardware is a physical
 * device; there is one for each piece of hardware that SDL can see. Logical
 * devices are created by calling SDL_OpenAudioDevice or
 * SDL_OpenAudioDeviceStream, and while each is associated with a physical
 * device, there can be any number of logical devices on one physical device.
 *
 * For the most part, logical and physical IDs are interchangeable--if you try
 * to open a logical device, SDL understands to assign that effort to the
 * underlying physical device, etc. However, it might be useful to know if an
 * arbitrary device ID is physical or logical. This function reports which.
 *
 * This function may return either true or false for invalid device IDs.
 *
 * \param devid the device ID to query.
 * \returns true if devid is a physical device, false if it is logical.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_IsAudioDevicePhysical(devid: SDL_AudioDeviceID): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_IsAudioDevicePhysical';

(**
 * Determine if an audio device is a playback device (instead of recording).
 *
 * This function may return either true or false for invalid device IDs.
 *
 * \param devid the device ID to query.
 * \returns true if devid is a playback device, false if it is recording.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_IsAudioDevicePlayback(devid: SDL_AudioDeviceID): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_IsAudioDevicePlayback';

(**
 * Use this function to pause audio playback on a specified device.
 *
 * This function pauses audio processing for a given device. Any bound audio
 * streams will not progress, and no audio will be generated. Pausing one
 * device does not prevent other unpaused devices from running.
 *
 * Unlike in SDL2, audio devices start in an _unpaused_ state, since an app
 * has to bind a stream before any audio will flow. Pausing a paused device is
 * a legal no-op.
 *
 * Pausing a device can be useful to halt all audio without unbinding all the
 * audio streams. This might be useful while a game is paused, or a level is
 * loading, etc.
 *
 * Physical devices can not be paused or unpaused, only logical devices
 * created through SDL_OpenAudioDevice() can be.
 *
 * \param devid a device opened by SDL_OpenAudioDevice().
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_ResumeAudioDevice
 * \sa SDL_AudioDevicePaused
 *)
function SDL_PauseAudioDevice(devid: SDL_AudioDeviceID): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_PauseAudioDevice';

(**
 * Use this function to unpause audio playback on a specified device.
 *
 * This function unpauses audio processing for a given device that has
 * previously been paused with SDL_PauseAudioDevice(). Once unpaused, any
 * bound audio streams will begin to progress again, and audio can be
 * generated.
 *
 * Unlike in SDL2, audio devices start in an _unpaused_ state, since an app
 * has to bind a stream before any audio will flow. Unpausing an unpaused
 * device is a legal no-op.
 *
 * Physical devices can not be paused or unpaused, only logical devices
 * created through SDL_OpenAudioDevice() can be.
 *
 * \param devid a device opened by SDL_OpenAudioDevice().
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_AudioDevicePaused
 * \sa SDL_PauseAudioDevice
 *)
function SDL_ResumeAudioDevice(devid: SDL_AudioDeviceID): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_ResumeAudioDevice';

(**
 * Use this function to query if an audio device is paused.
 *
 * Unlike in SDL2, audio devices start in an _unpaused_ state, since an app
 * has to bind a stream before any audio will flow.
 *
 * Physical devices can not be paused or unpaused, only logical devices
 * created through SDL_OpenAudioDevice() can be. Physical and invalid device
 * IDs will report themselves as unpaused here.
 *
 * \param devid a device opened by SDL_OpenAudioDevice().
 * \returns true if device is valid and paused, false otherwise.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_PauseAudioDevice
 * \sa SDL_ResumeAudioDevice
 *)
function SDL_AudioDevicePaused(devid: SDL_AudioDeviceID): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_AudioDevicePaused';

(**
 * Get the gain of an audio device.
 *
 * The gain of a device is its volume; a larger gain means a louder output,
 * with a gain of zero being silence.
 *
 * Audio devices default to a gain of 1.0f (no change in output).
 *
 * Physical devices may not have their gain changed, only logical devices, and
 * this function will always return -1.0f when used on physical devices.
 *
 * \param devid the audio device to query.
 * \returns the gain of the device or -1.0f on failure; call SDL_GetError()
 *          for more information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetAudioDeviceGain
 *)
function SDL_GetAudioDeviceGain(devid: SDL_AudioDeviceID): Single; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetAudioDeviceGain';

(**
 * Change the gain of an audio device.
 *
 * The gain of a device is its volume; a larger gain means a louder output,
 * with a gain of zero being silence.
 *
 * Audio devices default to a gain of 1.0f (no change in output).
 *
 * Physical devices may not have their gain changed, only logical devices, and
 * this function will always return false when used on physical devices. While
 * it might seem attractive to adjust several logical devices at once in this
 * way, it would allow an app or library to interfere with another portion of
 * the program's otherwise-isolated devices.
 *
 * This is applied, along with any per-audiostream gain, during playback to
 * the hardware, and can be continuously changed to create various effects. On
 * recording devices, this will adjust the gain before passing the data into
 * an audiostream; that recording audiostream can then adjust its gain further
 * when outputting the data elsewhere, if it likes, but that second gain is
 * not applied until the data leaves the audiostream again.
 *
 * \param devid the audio device on which to change gain.
 * \param gain the gain. 1.0f is no change, 0.0f is silence.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety It is safe to call this function from any thread, as it holds
 *               a stream-specific mutex while running.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetAudioDeviceGain
 *)
function SDL_SetAudioDeviceGain(devid: SDL_AudioDeviceID; gain: Single): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetAudioDeviceGain';

(**
 * Close a previously-opened audio device.
 *
 * The application should close open audio devices once they are no longer
 * needed.
 *
 * This function may block briefly while pending audio data is played by the
 * hardware, so that applications don't drop the last buffer of data they
 * supplied if terminating immediately afterwards.
 *
 * \param devid an audio device id previously returned by
 *              SDL_OpenAudioDevice().
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_OpenAudioDevice
 *)
procedure SDL_CloseAudioDevice(devid: SDL_AudioDeviceID); cdecl;
  external LIB_SDL3 name _PU + 'SDL_CloseAudioDevice';

(**
 * Bind a list of audio streams to an audio device.
 *
 * Audio data will flow through any bound streams. For a playback device, data
 * for all bound streams will be mixed together and fed to the device. For a
 * recording device, a copy of recorded data will be provided to each bound
 * stream.
 *
 * Audio streams can only be bound to an open device. This operation is
 * atomic--all streams bound in the same call will start processing at the
 * same time, so they can stay in sync. Also: either all streams will be bound
 * or none of them will be.
 *
 * It is an error to bind an already-bound stream; it must be explicitly
 * unbound first.
 *
 * Binding a stream to a device will set its output format for playback
 * devices, and its input format for recording devices, so they match the
 * device's settings. The caller is welcome to change the other end of the
 * stream's format at any time with SDL_SetAudioStreamFormat().
 *
 * \param devid an audio device to bind a stream to.
 * \param streams an array of audio streams to bind.
 * \param num_streams number streams listed in the `streams` array.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_BindAudioStreams
 * \sa SDL_UnbindAudioStream
 * \sa SDL_GetAudioStreamDevice
 *)
function SDL_BindAudioStreams(devid: SDL_AudioDeviceID; const streams: PSDL_AudioStream; num_streams: Integer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_BindAudioStreams';

(**
 * Bind a single audio stream to an audio device.
 *
 * This is a convenience function, equivalent to calling
 * `SDL_BindAudioStreams(devid, &stream, 1)`.
 *
 * \param devid an audio device to bind a stream to.
 * \param stream an audio stream to bind to a device.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_BindAudioStreams
 * \sa SDL_UnbindAudioStream
 * \sa SDL_GetAudioStreamDevice
 *)
function SDL_BindAudioStream(devid: SDL_AudioDeviceID; stream: SDL_AudioStream): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_BindAudioStream';

(**
 * Unbind a list of audio streams from their audio devices.
 *
 * The streams being unbound do not all have to be on the same device. All
 * streams on the same device will be unbound atomically (data will stop
 * flowing through all unbound streams on the same device at the same time).
 *
 * Unbinding a stream that isn't bound to a device is a legal no-op.
 *
 * \param streams an array of audio streams to unbind. Can be NULL or contain
 *                NULL.
 * \param num_streams number streams listed in the `streams` array.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_BindAudioStreams
 *)
procedure SDL_UnbindAudioStreams(const streams: PSDL_AudioStream; num_streams: Integer); cdecl;
  external LIB_SDL3 name _PU + 'SDL_UnbindAudioStreams';

(**
 * Unbind a single audio stream from its audio device.
 *
 * This is a convenience function, equivalent to calling
 * `SDL_UnbindAudioStreams(&stream, 1)`.
 *
 * \param stream an audio stream to unbind from a device. Can be NULL.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_BindAudioStream
 *)
procedure SDL_UnbindAudioStream(stream: SDL_AudioStream); cdecl;
  external LIB_SDL3 name _PU + 'SDL_UnbindAudioStream';

(**
 * Query an audio stream for its currently-bound device.
 *
 * This reports the audio device that an audio stream is currently bound to.
 *
 * If not bound, or invalid, this returns zero, which is not a valid device
 * ID.
 *
 * \param stream the audio stream to query.
 * \returns the bound audio device, or 0 if not bound or invalid.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_BindAudioStream
 * \sa SDL_BindAudioStreams
 *)
function SDL_GetAudioStreamDevice(stream: SDL_AudioStream): SDL_AudioDeviceID; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetAudioStreamDevice';

(**
 * Create a new audio stream.
 *
 * \param src_spec the format details of the input audio.
 * \param dst_spec the format details of the output audio.
 * \returns a new audio stream on success or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_PutAudioStreamData
 * \sa SDL_GetAudioStreamData
 * \sa SDL_GetAudioStreamAvailable
 * \sa SDL_FlushAudioStream
 * \sa SDL_ClearAudioStream
 * \sa SDL_SetAudioStreamFormat
 * \sa SDL_DestroyAudioStream
 *)
function SDL_CreateAudioStream(const src_spec: PSDL_AudioSpec; const dst_spec: PSDL_AudioSpec): SDL_AudioStream; cdecl;
  external LIB_SDL3 name _PU + 'SDL_CreateAudioStream';

(**
 * Get the properties associated with an audio stream.
 *
 * \param stream the SDL_AudioStream to query.
 * \returns a valid property ID on success or 0 on failure; call
 *          SDL_GetError() for more information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetAudioStreamProperties(stream: SDL_AudioStream): SDL_PropertiesID; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetAudioStreamProperties';

(**
 * Query the current format of an audio stream.
 *
 * \param stream the SDL_AudioStream to query.
 * \param src_spec where to store the input audio format; ignored if NULL.
 * \param dst_spec where to store the output audio format; ignored if NULL.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety It is safe to call this function from any thread, as it holds
 *               a stream-specific mutex while running.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetAudioStreamFormat
 *)
function SDL_GetAudioStreamFormat(stream: SDL_AudioStream; src_spec: PSDL_AudioSpec; dst_spec: PSDL_AudioSpec): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetAudioStreamFormat';

(**
 * Change the input and output formats of an audio stream.
 *
 * Future calls to and SDL_GetAudioStreamAvailable and SDL_GetAudioStreamData
 * will reflect the new format, and future calls to SDL_PutAudioStreamData
 * must provide data in the new input formats.
 *
 * Data that was previously queued in the stream will still be operated on in
 * the format that was current when it was added, which is to say you can put
 * the end of a sound file in one format to a stream, change formats for the
 * next sound file, and start putting that new data while the previous sound
 * file is still queued, and everything will still play back correctly.
 *
 * If a stream is bound to a device, then the format of the side of the stream
 * bound to a device cannot be changed (src_spec for recording devices,
 * dst_spec for playback devices). Attempts to make a change to this side will
 * be ignored, but this will not report an error. The other side's format can
 * be changed.
 *
 * \param stream the stream the format is being changed.
 * \param src_spec the new format of the audio input; if NULL, it is not
 *                 changed.
 * \param dst_spec the new format of the audio output; if NULL, it is not
 *                 changed.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety It is safe to call this function from any thread, as it holds
 *               a stream-specific mutex while running.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetAudioStreamFormat
 * \sa SDL_SetAudioStreamFrequencyRatio
 *)
function SDL_SetAudioStreamFormat(stream: SDL_AudioStream; const src_spec: PSDL_AudioSpec; const dst_spec: PSDL_AudioSpec): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetAudioStreamFormat';

(**
 * Get the frequency ratio of an audio stream.
 *
 * \param stream the SDL_AudioStream to query.
 * \returns the frequency ratio of the stream or 0.0 on failure; call
 *          SDL_GetError() for more information.
 *
 * \threadsafety It is safe to call this function from any thread, as it holds
 *               a stream-specific mutex while running.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetAudioStreamFrequencyRatio
 *)
function SDL_GetAudioStreamFrequencyRatio(stream: SDL_AudioStream): Single; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetAudioStreamFrequencyRatio';

(**
 * Change the frequency ratio of an audio stream.
 *
 * The frequency ratio is used to adjust the rate at which input data is
 * consumed. Changing this effectively modifies the speed and pitch of the
 * audio. A value greater than 1.0 will play the audio faster, and at a higher
 * pitch. A value less than 1.0 will play the audio slower, and at a lower
 * pitch.
 *
 * This is applied during SDL_GetAudioStreamData, and can be continuously
 * changed to create various effects.
 *
 * \param stream the stream the frequency ratio is being changed.
 * \param ratio the frequency ratio. 1.0 is normal speed. Must be between 0.01
 *              and 100.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety It is safe to call this function from any thread, as it holds
 *               a stream-specific mutex while running.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetAudioStreamFrequencyRatio
 * \sa SDL_SetAudioStreamFormat
 *)
function SDL_SetAudioStreamFrequencyRatio(stream: SDL_AudioStream; ratio: Single): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetAudioStreamFrequencyRatio';

(**
 * Get the gain of an audio stream.
 *
 * The gain of a stream is its volume; a larger gain means a louder output,
 * with a gain of zero being silence.
 *
 * Audio streams default to a gain of 1.0f (no change in output).
 *
 * \param stream the SDL_AudioStream to query.
 * \returns the gain of the stream or -1.0f on failure; call SDL_GetError()
 *          for more information.
 *
 * \threadsafety It is safe to call this function from any thread, as it holds
 *               a stream-specific mutex while running.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetAudioStreamGain
 *)
function SDL_GetAudioStreamGain(stream: SDL_AudioStream): Single; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetAudioStreamGain';

(**
 * Change the gain of an audio stream.
 *
 * The gain of a stream is its volume; a larger gain means a louder output,
 * with a gain of zero being silence.
 *
 * Audio streams default to a gain of 1.0f (no change in output).
 *
 * This is applied during SDL_GetAudioStreamData, and can be continuously
 * changed to create various effects.
 *
 * \param stream the stream on which the gain is being changed.
 * \param gain the gain. 1.0f is no change, 0.0f is silence.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety It is safe to call this function from any thread, as it holds
 *               a stream-specific mutex while running.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetAudioStreamGain
 *)
function SDL_SetAudioStreamGain(stream: SDL_AudioStream; gain: Single): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetAudioStreamGain';

(**
 * Get the current input channel map of an audio stream.
 *
 * Channel maps are optional; most things do not need them, instead passing
 * data in the [order that SDL expects](CategoryAudio#channel-layouts).
 *
 * Audio streams default to no remapping applied. This is represented by
 * returning NULL, and does not signify an error.
 *
 * \param stream the SDL_AudioStream to query.
 * \param count On output, set to number of channels in the map. Can be NULL.
 * \returns an array of the current channel mapping, with as many elements as
 *          the current output spec's channels, or NULL if default. This
 *          should be freed with SDL_free() when it is no longer needed.
 *
 * \threadsafety It is safe to call this function from any thread, as it holds
 *               a stream-specific mutex while running.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetAudioStreamInputChannelMap
 *)
function SDL_GetAudioStreamInputChannelMap(stream: SDL_AudioStream; count: PInteger): PInteger; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetAudioStreamInputChannelMap';

(**
 * Get the current output channel map of an audio stream.
 *
 * Channel maps are optional; most things do not need them, instead passing
 * data in the [order that SDL expects](CategoryAudio#channel-layouts).
 *
 * Audio streams default to no remapping applied. This is represented by
 * returning NULL, and does not signify an error.
 *
 * \param stream the SDL_AudioStream to query.
 * \param count On output, set to number of channels in the map. Can be NULL.
 * \returns an array of the current channel mapping, with as many elements as
 *          the current output spec's channels, or NULL if default. This
 *          should be freed with SDL_free() when it is no longer needed.
 *
 * \threadsafety It is safe to call this function from any thread, as it holds
 *               a stream-specific mutex while running.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetAudioStreamInputChannelMap
 *)
function SDL_GetAudioStreamOutputChannelMap(stream: SDL_AudioStream; count: PInteger): PInteger; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetAudioStreamOutputChannelMap';

(**
 * Set the current input channel map of an audio stream.
 *
 * Channel maps are optional; most things do not need them, instead passing
 * data in the [order that SDL expects](CategoryAudio#channel-layouts).
 *
 * The input channel map reorders data that is added to a stream via
 * SDL_PutAudioStreamData. Future calls to SDL_PutAudioStreamData must provide
 * data in the new channel order.
 *
 * Each item in the array represents an input channel, and its value is the
 * channel that it should be remapped to. To reverse a stereo signal's left
 * and right values, you'd have an array of `{ 1, 0 }`. It is legal to remap
 * multiple channels to the same thing, so `{ 1, 1 }` would duplicate the
 * right channel to both channels of a stereo signal. An element in the
 * channel map set to -1 instead of a valid channel will mute that channel,
 * setting it to a silence value.
 *
 * You cannot change the number of channels through a channel map, just
 * reorder/mute them.
 *
 * Data that was previously queued in the stream will still be operated on in
 * the order that was current when it was added, which is to say you can put
 * the end of a sound file in one order to a stream, change orders for the
 * next sound file, and start putting that new data while the previous sound
 * file is still queued, and everything will still play back correctly.
 *
 * Audio streams default to no remapping applied. Passing a NULL channel map
 * is legal, and turns off remapping.
 *
 * SDL will copy the channel map; the caller does not have to save this array
 * after this call.
 *
 * If `count` is not equal to the current number of channels in the audio
 * stream's format, this will fail. This is a safety measure to make sure a
 * race condition hasn't changed the format while this call is setting the
 * channel map.
 *
 * Unlike attempting to change the stream's format, the input channel map on a
 * stream bound to a recording device is permitted to change at any time; any
 * data added to the stream from the device after this call will have the new
 * mapping, but previously-added data will still have the prior mapping.
 *
 * \param stream the SDL_AudioStream to change.
 * \param chmap the new channel map, NULL to reset to default.
 * \param count The number of channels in the map.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety It is safe to call this function from any thread, as it holds
 *               a stream-specific mutex while running. Don't change the
 *               stream's format to have a different number of channels from a
 *               a different thread at the same time, though!
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetAudioStreamInputChannelMap
 *)
function SDL_SetAudioStreamInputChannelMap(stream: SDL_AudioStream; const chmap: PInteger; count: Integer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetAudioStreamInputChannelMap';

(**
 * Set the current output channel map of an audio stream.
 *
 * Channel maps are optional; most things do not need them, instead passing
 * data in the [order that SDL expects](CategoryAudio#channel-layouts).
 *
 * The output channel map reorders data that leaving a stream via
 * SDL_GetAudioStreamData.
 *
 * Each item in the array represents an input channel, and its value is the
 * channel that it should be remapped to. To reverse a stereo signal's left
 * and right values, you'd have an array of `{ 1, 0 }`. It is legal to remap
 * multiple channels to the same thing, so `{ 1, 1 }` would duplicate the
 * right channel to both channels of a stereo signal. An element in the
 * channel map set to -1 instead of a valid channel will mute that channel,
 * setting it to a silence value.
 *
 * You cannot change the number of channels through a channel map, just
 * reorder/mute them.
 *
 * The output channel map can be changed at any time, as output remapping is
 * applied during SDL_GetAudioStreamData.
 *
 * Audio streams default to no remapping applied. Passing a NULL channel map
 * is legal, and turns off remapping.
 *
 * SDL will copy the channel map; the caller does not have to save this array
 * after this call.
 *
 * If `count` is not equal to the current number of channels in the audio
 * stream's format, this will fail. This is a safety measure to make sure a
 * race condition hasn't changed the format while this call is setting the
 * channel map.
 *
 * Unlike attempting to change the stream's format, the output channel map on
 * a stream bound to a recording device is permitted to change at any time;
 * any data added to the stream after this call will have the new mapping, but
 * previously-added data will still have the prior mapping. When the channel
 * map doesn't match the hardware's channel layout, SDL will convert the data
 * before feeding it to the device for playback.
 *
 * \param stream the SDL_AudioStream to change.
 * \param chmap the new channel map, NULL to reset to default.
 * \param count The number of channels in the map.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety It is safe to call this function from any thread, as it holds
 *               a stream-specific mutex while running. Don't change the
 *               stream's format to have a different number of channels from a
 *               a different thread at the same time, though!
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetAudioStreamInputChannelMap
 *)
function SDL_SetAudioStreamOutputChannelMap(stream: SDL_AudioStream; const chmap: PInteger; count: Integer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetAudioStreamOutputChannelMap';

(**
 * Add data to the stream.
 *
 * This data must match the format/channels/samplerate specified in the latest
 * call to SDL_SetAudioStreamFormat, or the format specified when creating the
 * stream if it hasn't been changed.
 *
 * Note that this call simply copies the unconverted data for later. This is
 * different than SDL2, where data was converted during the Put call and the
 * Get call would just dequeue the previously-converted data.
 *
 * \param stream the stream the audio data is being added to.
 * \param buf a pointer to the audio data to add.
 * \param len the number of bytes to write to the stream.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety It is safe to call this function from any thread, but if the
 *               stream has a callback set, the caller might need to manage
 *               extra locking.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_ClearAudioStream
 * \sa SDL_FlushAudioStream
 * \sa SDL_GetAudioStreamData
 * \sa SDL_GetAudioStreamQueued
 *)
function SDL_PutAudioStreamData(stream: SDL_AudioStream; const buf: Pointer; len: Integer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_PutAudioStreamData';

(**
 * Get converted/resampled data from the stream.
 *
 * The input/output data format/channels/samplerate is specified when creating
 * the stream, and can be changed after creation by calling
 * SDL_SetAudioStreamFormat.
 *
 * Note that any conversion and resampling necessary is done during this call,
 * and SDL_PutAudioStreamData simply queues unconverted data for later. This
 * is different than SDL2, where that work was done while inputting new data
 * to the stream and requesting the output just copied the converted data.
 *
 * \param stream the stream the audio is being requested from.
 * \param buf a buffer to fill with audio data.
 * \param len the maximum number of bytes to fill.
 * \returns the number of bytes read from the stream or -1 on failure; call
 *          SDL_GetError() for more information.
 *
 * \threadsafety It is safe to call this function from any thread, but if the
 *               stream has a callback set, the caller might need to manage
 *               extra locking.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_ClearAudioStream
 * \sa SDL_GetAudioStreamAvailable
 * \sa SDL_PutAudioStreamData
 *)
function SDL_GetAudioStreamData(stream: SDL_AudioStream; buf: Pointer; len: Integer): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetAudioStreamData';

(**
 * Get the number of converted/resampled bytes available.
 *
 * The stream may be buffering data behind the scenes until it has enough to
 * resample correctly, so this number might be lower than what you expect, or
 * even be zero. Add more data or flush the stream if you need the data now.
 *
 * If the stream has so much data that it would overflow an int, the return
 * value is clamped to a maximum value, but no queued data is lost; if there
 * are gigabytes of data queued, the app might need to read some of it with
 * SDL_GetAudioStreamData before this function's return value is no longer
 * clamped.
 *
 * \param stream the audio stream to query.
 * \returns the number of converted/resampled bytes available or -1 on
 *          failure; call SDL_GetError() for more information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetAudioStreamData
 * \sa SDL_PutAudioStreamData
 *)
function SDL_GetAudioStreamAvailable(stream: SDL_AudioStream): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetAudioStreamAvailable';

(**
 * Get the number of bytes currently queued.
 *
 * This is the number of bytes put into a stream as input, not the number that
 * can be retrieved as output. Because of several details, it's not possible
 * to calculate one number directly from the other. If you need to know how
 * much usable data can be retrieved right now, you should use
 * SDL_GetAudioStreamAvailable() and not this function.
 *
 * Note that audio streams can change their input format at any time, even if
 * there is still data queued in a different format, so the returned byte
 * count will not necessarily match the number of _sample frames_ available.
 * Users of this API should be aware of format changes they make when feeding
 * a stream and plan accordingly.
 *
 * Queued data is not converted until it is consumed by
 * SDL_GetAudioStreamData, so this value should be representative of the exact
 * data that was put into the stream.
 *
 * If the stream has so much data that it would overflow an int, the return
 * value is clamped to a maximum value, but no queued data is lost; if there
 * are gigabytes of data queued, the app might need to read some of it with
 * SDL_GetAudioStreamData before this function's return value is no longer
 * clamped.
 *
 * \param stream the audio stream to query.
 * \returns the number of bytes queued or -1 on failure; call SDL_GetError()
 *          for more information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_PutAudioStreamData
 * \sa SDL_ClearAudioStream
 *)
function SDL_GetAudioStreamQueued(stream: SDL_AudioStream): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetAudioStreamQueued';

(**
 * Tell the stream that you're done sending data, and anything being buffered
 * should be converted/resampled and made available immediately.
 *
 * It is legal to add more data to a stream after flushing, but there may be
 * audio gaps in the output. Generally this is intended to signal the end of
 * input, so the complete output becomes available.
 *
 * \param stream the audio stream to flush.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_PutAudioStreamData
 *)
function SDL_FlushAudioStream(stream: SDL_AudioStream): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_FlushAudioStream';

(**
 * Clear any pending data in the stream.
 *
 * This drops any queued data, so there will be nothing to read from the
 * stream until more is added.
 *
 * \param stream the audio stream to clear.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetAudioStreamAvailable
 * \sa SDL_GetAudioStreamData
 * \sa SDL_GetAudioStreamQueued
 * \sa SDL_PutAudioStreamData
 *)
function SDL_ClearAudioStream(stream: SDL_AudioStream): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_ClearAudioStream';

(**
 * Use this function to pause audio playback on the audio device associated
 * with an audio stream.
 *
 * This function pauses audio processing for a given device. Any bound audio
 * streams will not progress, and no audio will be generated. Pausing one
 * device does not prevent other unpaused devices from running.
 *
 * Pausing a device can be useful to halt all audio without unbinding all the
 * audio streams. This might be useful while a game is paused, or a level is
 * loading, etc.
 *
 * \param stream the audio stream associated with the audio device to pause.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_ResumeAudioStreamDevice
 *)
function SDL_PauseAudioStreamDevice(stream: SDL_AudioStream): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_PauseAudioStreamDevice';

(**
 * Use this function to unpause audio playback on the audio device associated
 * with an audio stream.
 *
 * This function unpauses audio processing for a given device that has
 * previously been paused. Once unpaused, any bound audio streams will begin
 * to progress again, and audio can be generated.
 *
 * Remember, SDL_OpenAudioDeviceStream opens device in a paused state, so this
 * function call is required for audio playback to begin on such device.
 *
 * \param stream the audio stream associated with the audio device to resume.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_PauseAudioStreamDevice
 *)
function SDL_ResumeAudioStreamDevice(stream: SDL_AudioStream): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_ResumeAudioStreamDevice';

(**
 * Use this function to query if an audio device associated with a stream is
 * paused.
 *
 * Unlike in SDL2, audio devices start in an _unpaused_ state, since an app
 * has to bind a stream before any audio will flow.
 *
 * \param stream the audio stream associated with the audio device to query.
 * \returns true if device is valid and paused, false otherwise.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_PauseAudioStreamDevice
 * \sa SDL_ResumeAudioStreamDevice
 *)
function SDL_AudioStreamDevicePaused(stream: SDL_AudioStream): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_AudioStreamDevicePaused';

(**
 * Lock an audio stream for serialized access.
 *
 * Each SDL_AudioStream has an internal mutex it uses to protect its data
 * structures from threading conflicts. This function allows an app to lock
 * that mutex, which could be useful if registering callbacks on this stream.
 *
 * One does not need to lock a stream to use in it most cases, as the stream
 * manages this lock internally. However, this lock is held during callbacks,
 * which may run from arbitrary threads at any time, so if an app needs to
 * protect shared data during those callbacks, locking the stream guarantees
 * that the callback is not running while the lock is held.
 *
 * As this is just a wrapper over SDL_LockMutex for an internal lock; it has
 * all the same attributes (recursive locks are allowed, etc).
 *
 * \param stream the audio stream to lock.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_UnlockAudioStream
 *)
function SDL_LockAudioStream(stream: SDL_AudioStream): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_LockAudioStream';

(**
 * Unlock an audio stream for serialized access.
 *
 * This unlocks an audio stream after a call to SDL_LockAudioStream.
 *
 * \param stream the audio stream to unlock.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety You should only call this from the same thread that
 *               previously called SDL_LockAudioStream.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_LockAudioStream
 *)
function SDL_UnlockAudioStream(stream: SDL_AudioStream): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_UnlockAudioStream';

type
  (**
   * A callback that fires when data passes through an SDL_AudioStream.
   *
   * Apps can (optionally) register a callback with an audio stream that is
   * called when data is added with SDL_PutAudioStreamData, or requested with
   * SDL_GetAudioStreamData.
   *
   * Two values are offered here: one is the amount of additional data needed to
   * satisfy the immediate request (which might be zero if the stream already
   * has enough data queued) and the other is the total amount being requested.
   * In a Get call triggering a Put callback, these values can be different. In
   * a Put call triggering a Get callback, these values are always the same.
   *
   * Byte counts might be slightly overestimated due to buffering or resampling,
   * and may change from call to call.
   *
   * This callback is not required to do anything. Generally this is useful for
   * adding/reading data on demand, and the app will often put/get data as
   * appropriate, but the system goes on with the data currently available to it
   * if this callback does nothing.
   *
   * \param stream the SDL audio stream associated with this callback.
   * \param additional_amount the amount of data, in bytes, that is needed right
   *                          now.
   * \param total_amount the total amount of data requested, in bytes, that is
   *                     requested or available.
   * \param userdata an opaque pointer provided by the app for their personal
   *                 use.
   *
   * \threadsafety This callbacks may run from any thread, so if you need to
   *               protect shared data, you should use SDL_LockAudioStream to
   *               serialize access; this lock will be held before your callback
   *               is called, so your callback does not need to manage the lock
   *               explicitly.
   *
   * \since This datatype is available since SDL 3.2.0.
   *
   * \sa SDL_SetAudioStreamGetCallback
   * \sa SDL_SetAudioStreamPutCallback
   *)
  SDL_AudioStreamCallback = procedure(userdata: Pointer; stream: SDL_AudioStream; additional_amount: Integer; total_amount: Integer); cdecl;

(**
 * Set a callback that runs when data is requested from an audio stream.
 *
 * This callback is called _before_ data is obtained from the stream, giving
 * the callback the chance to add more on-demand.
 *
 * The callback can (optionally) call SDL_PutAudioStreamData() to add more
 * audio to the stream during this call; if needed, the request that triggered
 * this callback will obtain the new data immediately.
 *
 * The callback's `approx_request` argument is roughly how many bytes of
 * _unconverted_ data (in the stream's input format) is needed by the caller,
 * although this may overestimate a little for safety. This takes into account
 * how much is already in the stream and only asks for any extra necessary to
 * resolve the request, which means the callback may be asked for zero bytes,
 * and a different amount on each call.
 *
 * The callback is not required to supply exact amounts; it is allowed to
 * supply too much or too little or none at all. The caller will get what's
 * available, up to the amount they requested, regardless of this callback's
 * outcome.
 *
 * Clearing or flushing an audio stream does not call this callback.
 *
 * This function obtains the stream's lock, which means any existing callback
 * (get or put) in progress will finish running before setting the new
 * callback.
 *
 * Setting a NULL function turns off the callback.
 *
 * \param stream the audio stream to set the new callback on.
 * \param callback the new callback function to call when data is requested
 *                 from the stream.
 * \param userdata an opaque pointer provided to the callback for its own
 *                 personal use.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information. This only fails if `stream` is NULL.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetAudioStreamPutCallback
 *)
function SDL_SetAudioStreamGetCallback(stream: SDL_AudioStream; callback: SDL_AudioStreamCallback; userdata: Pointer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetAudioStreamGetCallback';

(**
 * Set a callback that runs when data is added to an audio stream.
 *
 * This callback is called _after_ the data is added to the stream, giving the
 * callback the chance to obtain it immediately.
 *
 * The callback can (optionally) call SDL_GetAudioStreamData() to obtain audio
 * from the stream during this call.
 *
 * The callback's `approx_request` argument is how many bytes of _converted_
 * data (in the stream's output format) was provided by the caller, although
 * this may underestimate a little for safety. This value might be less than
 * what is currently available in the stream, if data was already there, and
 * might be less than the caller provided if the stream needs to keep a buffer
 * to aid in resampling. Which means the callback may be provided with zero
 * bytes, and a different amount on each call.
 *
 * The callback may call SDL_GetAudioStreamAvailable to see the total amount
 * currently available to read from the stream, instead of the total provided
 * by the current call.
 *
 * The callback is not required to obtain all data. It is allowed to read less
 * or none at all. Anything not read now simply remains in the stream for
 * later access.
 *
 * Clearing or flushing an audio stream does not call this callback.
 *
 * This function obtains the stream's lock, which means any existing callback
 * (get or put) in progress will finish running before setting the new
 * callback.
 *
 * Setting a NULL function turns off the callback.
 *
 * \param stream the audio stream to set the new callback on.
 * \param callback the new callback function to call when data is added to the
 *                 stream.
 * \param userdata an opaque pointer provided to the callback for its own
 *                 personal use.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information. This only fails if `stream` is NULL.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetAudioStreamGetCallback
 *)
function SDL_SetAudioStreamPutCallback(stream: SDL_AudioStream; callback: SDL_AudioStreamCallback; userdata: Pointer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetAudioStreamPutCallback';

(**
 * Free an audio stream.
 *
 * This will release all allocated data, including any audio that is still
 * queued. You do not need to manually clear the stream first.
 *
 * If this stream was bound to an audio device, it is unbound during this
 * call. If this stream was created with SDL_OpenAudioDeviceStream, the audio
 * device that was opened alongside this stream's creation will be closed,
 * too.
 *
 * \param stream the audio stream to destroy.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CreateAudioStream
 *)
procedure SDL_DestroyAudioStream(stream: SDL_AudioStream); cdecl;
  external LIB_SDL3 name _PU + 'SDL_DestroyAudioStream';

(**
 * Convenience function for straightforward audio init for the common case.
 *
 * If all your app intends to do is provide a single source of PCM audio, this
 * function allows you to do all your audio setup in a single call.
 *
 * This is also intended to be a clean means to migrate apps from SDL2.
 *
 * This function will open an audio device, create a stream and bind it.
 * Unlike other methods of setup, the audio device will be closed when this
 * stream is destroyed, so the app can treat the returned SDL_AudioStream as
 * the only object needed to manage audio playback.
 *
 * Also unlike other functions, the audio device begins paused. This is to map
 * more closely to SDL2-style behavior, since there is no extra step here to
 * bind a stream to begin audio flowing. The audio device should be resumed
 * with `SDL_ResumeAudioStreamDevice(stream);`
 *
 * This function works with both playback and recording devices.
 *
 * The `spec` parameter represents the app's side of the audio stream. That
 * is, for recording audio, this will be the output format, and for playing
 * audio, this will be the input format. If spec is NULL, the system will
 * choose the format, and the app can use SDL_GetAudioStreamFormat() to obtain
 * this information later.
 *
 * If you don't care about opening a specific audio device, you can (and
 * probably _should_), use SDL_AUDIO_DEVICE_DEFAULT_PLAYBACK for playback and
 * SDL_AUDIO_DEVICE_DEFAULT_RECORDING for recording.
 *
 * One can optionally provide a callback function; if NULL, the app is
 * expected to queue audio data for playback (or unqueue audio data if
 * capturing). Otherwise, the callback will begin to fire once the device is
 * unpaused.
 *
 * Destroying the returned stream with SDL_DestroyAudioStream will also close
 * the audio device associated with this stream.
 *
 * \param devid an audio device to open, or SDL_AUDIO_DEVICE_DEFAULT_PLAYBACK
 *              or SDL_AUDIO_DEVICE_DEFAULT_RECORDING.
 * \param spec the audio stream's data format. Can be NULL.
 * \param callback a callback where the app will provide new data for
 *                 playback, or receive new data for recording. Can be NULL,
 *                 in which case the app will need to call
 *                 SDL_PutAudioStreamData or SDL_GetAudioStreamData as
 *                 necessary.
 * \param userdata app-controlled pointer passed to callback. Can be NULL.
 *                 Ignored if callback is NULL.
 * \returns an audio stream on success, ready to use, or NULL on failure; call
 *          SDL_GetError() for more information. When done with this stream,
 *          call SDL_DestroyAudioStream to free resources and close the
 *          device.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetAudioStreamDevice
 * \sa SDL_ResumeAudioStreamDevice
 *)
function SDL_OpenAudioDeviceStream(devid: SDL_AudioDeviceID; const spec: PSDL_AudioSpec; callback: SDL_AudioStreamCallback; userdata: Pointer): SDL_AudioStream; cdecl;
  external LIB_SDL3 name _PU + 'SDL_OpenAudioDeviceStream';

type
  (**
   * A callback that fires when data is about to be fed to an audio device.
   *
   * This is useful for accessing the final mix, perhaps for writing a
   * visualizer or applying a final effect to the audio data before playback.
   *
   * This callback should run as quickly as possible and not block for any
   * significant time, as this callback delays submission of data to the audio
   * device, which can cause audio playback problems.
   *
   * The postmix callback _must_ be able to handle any audio data format
   * specified in `spec`, which can change between callbacks if the audio device
   * changed. However, this only covers frequency and channel count; data is
   * always provided here in SDL_AUDIO_F32 format.
   *
   * The postmix callback runs _after_ logical device gain and audiostream gain
   * have been applied, which is to say you can make the output data louder at
   * this point than the gain settings would suggest.
   *
   * \param userdata a pointer provided by the app through
   *                 SDL_SetAudioPostmixCallback, for its own use.
   * \param spec the current format of audio that is to be submitted to the
   *             audio device.
   * \param buffer the buffer of audio samples to be submitted. The callback can
   *               inspect and/or modify this data.
   * \param buflen the size of `buffer` in bytes.
   *
   * \threadsafety This will run from a background thread owned by SDL. The
   *               application is responsible for locking resources the callback
   *               touches that need to be protected.
   *
   * \since This datatype is available since SDL 3.2.0.
   *
   * \sa SDL_SetAudioPostmixCallback
   *)
  SDL_AudioPostmixCallback = procedure(userdata: Pointer; const spec: PSDL_AudioSpec; buffer: PSingle; buflen: Integer); cdecl;

(**
 * Set a callback that fires when data is about to be fed to an audio device.
 *
 * This is useful for accessing the final mix, perhaps for writing a
 * visualizer or applying a final effect to the audio data before playback.
 *
 * The buffer is the final mix of all bound audio streams on an opened device;
 * this callback will fire regularly for any device that is both opened and
 * unpaused. If there is no new data to mix, either because no streams are
 * bound to the device or all the streams are empty, this callback will still
 * fire with the entire buffer set to silence.
 *
 * This callback is allowed to make changes to the data; the contents of the
 * buffer after this call is what is ultimately passed along to the hardware.
 *
 * The callback is always provided the data in float format (values from -1.0f
 * to 1.0f), but the number of channels or sample rate may be different than
 * the format the app requested when opening the device; SDL might have had to
 * manage a conversion behind the scenes, or the playback might have jumped to
 * new physical hardware when a system default changed, etc. These details may
 * change between calls. Accordingly, the size of the buffer might change
 * between calls as well.
 *
 * This callback can run at any time, and from any thread; if you need to
 * serialize access to your app's data, you should provide and use a mutex or
 * other synchronization device.
 *
 * All of this to say: there are specific needs this callback can fulfill, but
 * it is not the simplest interface. Apps should generally provide audio in
 * their preferred format through an SDL_AudioStream and let SDL handle the
 * difference.
 *
 * This function is extremely time-sensitive; the callback should do the least
 * amount of work possible and return as quickly as it can. The longer the
 * callback runs, the higher the risk of audio dropouts or other problems.
 *
 * This function will block until the audio device is in between iterations,
 * so any existing callback that might be running will finish before this
 * function sets the new callback and returns.
 *
 * Setting a NULL callback function disables any previously-set callback.
 *
 * \param devid the ID of an opened audio device.
 * \param callback a callback function to be called. Can be NULL.
 * \param userdata app-controlled pointer passed to callback. Can be NULL.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_SetAudioPostmixCallback(devid: SDL_AudioDeviceID; callback: SDL_AudioPostmixCallback; userdata: Pointer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetAudioPostmixCallback';

(**
 * Load the audio data of a WAVE file into memory.
 *
 * Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to
 * be valid pointers. The entire data portion of the file is then loaded into
 * memory and decoded if necessary.
 *
 * Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and
 * 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and
 * A-law and mu-law (8 bits). Other formats are currently unsupported and
 * cause an error.
 *
 * If this function succeeds, the return value is zero and the pointer to the
 * audio data allocated by the function is written to `audio_buf` and its
 * length in bytes to `audio_len`. The SDL_AudioSpec members `freq`,
 * `channels`, and `format` are set to the values of the audio data in the
 * buffer.
 *
 * It's necessary to use SDL_free() to free the audio data returned in
 * `audio_buf` when it is no longer used.
 *
 * Because of the underspecification of the .WAV format, there are many
 * problematic files in the wild that cause issues with strict decoders. To
 * provide compatibility with these files, this decoder is lenient in regards
 * to the truncation of the file, the fact chunk, and the size of the RIFF
 * chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,
 * `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to
 * tune the behavior of the loading process.
 *
 * Any file that is invalid (due to truncation, corruption, or wrong values in
 * the headers), too big, or unsupported causes an error. Additionally, any
 * critical I/O error from the data source will terminate the loading process
 * with an error. The function returns NULL on error and in all cases (with
 * the exception of `src` being NULL), an appropriate error message will be
 * set.
 *
 * It is required that the data source supports seeking.
 *
 * Example:
 *
 * ```c
 * SDL_LoadWAV_IO(SDL_IOFromFile("sample.wav", "rb"), true, &spec, &buf, &len);
 * ```
 *
 * Note that the SDL_LoadWAV function does this same thing for you, but in a
 * less messy way:
 *
 * ```c
 * SDL_LoadWAV("sample.wav", &spec, &buf, &len);
 * ```
 *
 * \param src the data source for the WAVE data.
 * \param closeio if true, calls SDL_CloseIO() on `src` before returning, even
 *                in the case of an error.
 * \param spec a pointer to an SDL_AudioSpec that will be set to the WAVE
 *             data's format details on successful return.
 * \param audio_buf a pointer filled with the audio data, allocated by the
 *                  function.
 * \param audio_len a pointer filled with the length of the audio data buffer
 *                  in bytes.
 * \returns true on success. `audio_buf` will be filled with a pointer to an
 *          allocated buffer containing the audio data, and `audio_len` is
 *          filled with the length of that audio buffer in bytes.
 *
 *          This function returns false if the .WAV file cannot be opened,
 *          uses an unknown data format, or is corrupt; call SDL_GetError()
 *          for more information.
 *
 *          When the application is done with the data returned in
 *          `audio_buf`, it should call SDL_free() to dispose of it.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_free
 * \sa SDL_LoadWAV
 *)
function SDL_LoadWAV_IO(src: SDL_IOStream; closeio: Boolean; spec: PSDL_AudioSpec; audio_buf: PPUint8; audio_len: PUint32): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_LoadWAV_IO';

(**
 * Loads a WAV from a file path.
 *
 * This is a convenience function that is effectively the same as:
 *
 * ```c
 * SDL_LoadWAV_IO(SDL_IOFromFile(path, "rb"), true, spec, audio_buf, audio_len);
 * ```
 *
 * \param path the file path of the WAV file to open.
 * \param spec a pointer to an SDL_AudioSpec that will be set to the WAVE
 *             data's format details on successful return.
 * \param audio_buf a pointer filled with the audio data, allocated by the
 *                  function.
 * \param audio_len a pointer filled with the length of the audio data buffer
 *                  in bytes.
 * \returns true on success. `audio_buf` will be filled with a pointer to an
 *          allocated buffer containing the audio data, and `audio_len` is
 *          filled with the length of that audio buffer in bytes.
 *
 *          This function returns false if the .WAV file cannot be opened,
 *          uses an unknown data format, or is corrupt; call SDL_GetError()
 *          for more information.
 *
 *          When the application is done with the data returned in
 *          `audio_buf`, it should call SDL_free() to dispose of it.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_free
 * \sa SDL_LoadWAV_IO
 *)
function SDL_LoadWAV(const path: PUTF8Char; spec: PSDL_AudioSpec; audio_buf: PPUint8; audio_len: PUint32): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_LoadWAV';

(**
 * Mix audio data in a specified format.
 *
 * This takes an audio buffer `src` of `len` bytes of `format` data and mixes
 * it into `dst`, performing addition, volume adjustment, and overflow
 * clipping. The buffer pointed to by `dst` must also be `len` bytes of
 * `format` data.
 *
 * This is provided for convenience -- you can mix your own audio data.
 *
 * Do not use this function for mixing together more than two streams of
 * sample data. The output from repeated application of this function may be
 * distorted by clipping, because there is no accumulator with greater range
 * than the input (not to mention this being an inefficient way of doing it).
 *
 * It is a common misconception that this function is required to write audio
 * data to an output stream in an audio callback. While you can do that,
 * SDL_MixAudio() is really only needed when you're mixing a single audio
 * stream with a volume adjustment.
 *
 * \param dst the destination for the mixed audio.
 * \param src the source audio buffer to be mixed.
 * \param format the SDL_AudioFormat structure representing the desired audio
 *               format.
 * \param len the length of the audio buffer in bytes.
 * \param volume ranges from 0.0 - 1.0, and should be set to 1.0 for full
 *               audio volume.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_MixAudio(dst: PUint8; const src: PUint8; format: SDL_AudioFormat; len: Uint32; volume: Single): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_MixAudio';

(**
 * Convert some audio data of one format to another format.
 *
 * Please note that this function is for convenience, but should not be used
 * to resample audio in blocks, as it will introduce audio artifacts on the
 * boundaries. You should only use this function if you are converting audio
 * data in its entirety in one call. If you want to convert audio in smaller
 * chunks, use an SDL_AudioStream, which is designed for this situation.
 *
 * Internally, this function creates and destroys an SDL_AudioStream on each
 * use, so it's also less efficient than using one directly, if you need to
 * convert multiple times.
 *
 * \param src_spec the format details of the input audio.
 * \param src_data the audio data to be converted.
 * \param src_len the len of src_data.
 * \param dst_spec the format details of the output audio.
 * \param dst_data will be filled with a pointer to converted audio data,
 *                 which should be freed with SDL_free(). On error, it will be
 *                 NULL.
 * \param dst_len will be filled with the len of dst_data.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_ConvertAudioSamples(const src_spec: PSDL_AudioSpec; const src_data: PUint8; src_len: Integer; const dst_spec: PSDL_AudioSpec; dst_data: PPUint8; dst_len: PInteger): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_ConvertAudioSamples';

(**
 * Get the human readable name of an audio format.
 *
 * \param format the audio format to query.
 * \returns the human readable name of the specified audio format or
 *          "SDL_AUDIO_UNKNOWN" if the format isn't recognized.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetAudioFormatName(format: SDL_AudioFormat): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetAudioFormatName';

(**
 * Get the appropriate memset value for silencing an audio format.
 *
 * The value returned by this function can be used as the second argument to
 * memset (or SDL_memset) to set an audio buffer in a specific format to
 * silence.
 *
 * \param format the audio data format to query.
 * \returns a byte value that can be passed to memset.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetSilenceValueForFormat(format: SDL_AudioFormat): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetSilenceValueForFormat';
{$ENDREGION 'SDL_audio.h'}

{$REGION 'SDL_blendmode.h'}
(**
 * # CategoryBlendmode
 *
 * Blend modes decide how two colors will mix together. There are both
 * standard modes for basic needs and a means to create custom modes,
 * dictating what sort of math to do on what color components.
 *)

type
  (**
   * A set of blend modes used in drawing operations.
   *
   * These predefined blend modes are supported everywhere.
   *
   * Additional values may be obtained from SDL_ComposeCustomBlendMode.
   *
   * \since This datatype is available since SDL 3.2.0.
   *
   * \sa SDL_ComposeCustomBlendMode
   *)
  SDL_BlendMode = Uint32;
  PSDL_BlendMode = ^SDL_BlendMode;

const
  // no blending: dstRGBA = srcRGBA
  SDL_BLENDMODE_NONE                = $00000000;

  // alpha blending: dstRGB = (srcRGB * srcA) + (dstRGB * (1-srcA)), dstA = srcA + (dstA * (1-srcA))
  SDL_BLENDMODE_BLEND               = $00000001;

  // pre-multiplied alpha blending: dstRGBA = srcRGBA + (dstRGBA * (1-srcA))
  SDL_BLENDMODE_BLEND_PREMULTIPLIED = $00000010;

  // additive blending: dstRGB = (srcRGB * srcA) + dstRGB, dstA = dstA
  SDL_BLENDMODE_ADD                 = $00000002;

  // pre-multiplied additive blending: dstRGB = srcRGB + dstRGB, dstA = dstA
  SDL_BLENDMODE_ADD_PREMULTIPLIED   = $00000020;

  // color modulate: dstRGB = srcRGB * dstRGB, dstA = dstA
  SDL_BLENDMODE_MOD                 = $00000004;

  // color multiply: dstRGB = (srcRGB * dstRGB) + (dstRGB * (1-srcA)), dstA = dstA
  SDL_BLENDMODE_MUL                 = $00000008;
  SDL_BLENDMODE_INVALID             = $7FFFFFFF;

(**
 * The blend operation used when combining source and destination pixel
 * components.
 *
 * \since This enum is available since SDL 3.2.0.
 *)
type
  SDL_BlendOperation = Integer;
  PSDL_BlendOperation = ^SDL_BlendOperation;

const
  (** dst + src: supported by all renderers *)
  SDL_BLENDOPERATION_ADD = 1;
  (** src - dst : supported by D3D, OpenGL, OpenGLES, and Vulkan *)
  SDL_BLENDOPERATION_SUBTRACT = 2;
  (** dst - src : supported by D3D, OpenGL, OpenGLES, and Vulkan *)
  SDL_BLENDOPERATION_REV_SUBTRACT = 3;
  (** min(dst, src) : supported by D3D, OpenGL, OpenGLES, and Vulkan *)
  SDL_BLENDOPERATION_MINIMUM = 4;
  (** max(dst, src) : supported by D3D, OpenGL, OpenGLES, and Vulkan *)
  SDL_BLENDOPERATION_MAXIMUM = 5;

(**
 * The normalized factor used to multiply pixel components.
 *
 * The blend factors are multiplied with the pixels from a drawing operation
 * (src) and the pixels from the render target (dst) before the blend
 * operation. The comma-separated factors listed above are always applied in
 * the component order red, green, blue, and alpha.
 *
 * \since This enum is available since SDL 3.2.0.
 *)
type
  SDL_BlendFactor = Integer;
  PSDL_BlendFactor = ^SDL_BlendFactor;

const
  (** 0, 0, 0, 0 *)
  SDL_BLENDFACTOR_ZERO = 1;
  (** 1, 1, 1, 1 *)
  SDL_BLENDFACTOR_ONE = 2;
  (** srcR, srcG, srcB, srcA *)
  SDL_BLENDFACTOR_SRC_COLOR = 3;
  (** 1-srcR, 1-srcG, 1-srcB, 1-srcA *)
  SDL_BLENDFACTOR_ONE_MINUS_SRC_COLOR = 4;
  (** srcA, srcA, srcA, srcA *)
  SDL_BLENDFACTOR_SRC_ALPHA = 5;
  (** 1-srcA, 1-srcA, 1-srcA, 1-srcA *)
  SDL_BLENDFACTOR_ONE_MINUS_SRC_ALPHA = 6;
  (** dstR, dstG, dstB, dstA *)
  SDL_BLENDFACTOR_DST_COLOR = 7;
  (** 1-dstR, 1-dstG, 1-dstB, 1-dstA *)
  SDL_BLENDFACTOR_ONE_MINUS_DST_COLOR = 8;
  (** dstA, dstA, dstA, dstA *)
  SDL_BLENDFACTOR_DST_ALPHA = 9;
  (** 1-dstA, 1-dstA, 1-dstA, 1-dstA *)
  SDL_BLENDFACTOR_ONE_MINUS_DST_ALPHA = 10;

(**
 * Compose a custom blend mode for renderers.
 *
 * The functions SDL_SetRenderDrawBlendMode and SDL_SetTextureBlendMode accept
 * the SDL_BlendMode returned by this function if the renderer supports it.
 *
 * A blend mode controls how the pixels from a drawing operation (source) get
 * combined with the pixels from the render target (destination). First, the
 * components of the source and destination pixels get multiplied with their
 * blend factors. Then, the blend operation takes the two products and
 * calculates the result that will get stored in the render target.
 *
 * Expressed in pseudocode, it would look like this:
 *
 * ```c
 * dstRGB = colorOperation(srcRGB * srcColorFactor, dstRGB * dstColorFactor);
 * dstA = alphaOperation(srcA * srcAlphaFactor, dstA * dstAlphaFactor);
 * ```
 *
 * Where the functions `colorOperation(src, dst)` and `alphaOperation(src,
 * dst)` can return one of the following:
 *
 * - `src + dst`
 * - `src - dst`
 * - `dst - src`
 * - `min(src, dst)`
 * - `max(src, dst)`
 *
 * The red, green, and blue components are always multiplied with the first,
 * second, and third components of the SDL_BlendFactor, respectively. The
 * fourth component is not used.
 *
 * The alpha component is always multiplied with the fourth component of the
 * SDL_BlendFactor. The other components are not used in the alpha
 * calculation.
 *
 * Support for these blend modes varies for each renderer. To check if a
 * specific SDL_BlendMode is supported, create a renderer and pass it to
 * either SDL_SetRenderDrawBlendMode or SDL_SetTextureBlendMode. They will
 * return with an error if the blend mode is not supported.
 *
 * This list describes the support of custom blend modes for each renderer.
 * All renderers support the four blend modes listed in the SDL_BlendMode
 * enumeration.
 *
 * - **direct3d**: Supports all operations with all factors. However, some
 *   factors produce unexpected results with `SDL_BLENDOPERATION_MINIMUM` and
 *   `SDL_BLENDOPERATION_MAXIMUM`.
 * - **direct3d11**: Same as Direct3D 9.
 * - **opengl**: Supports the `SDL_BLENDOPERATION_ADD` operation with all
 *   factors. OpenGL versions 1.1, 1.2, and 1.3 do not work correctly here.
 * - **opengles2**: Supports the `SDL_BLENDOPERATION_ADD`,
 *   `SDL_BLENDOPERATION_SUBTRACT`, `SDL_BLENDOPERATION_REV_SUBTRACT`
 *   operations with all factors.
 * - **psp**: No custom blend mode support.
 * - **software**: No custom blend mode support.
 *
 * Some renderers do not provide an alpha component for the default render
 * target. The `SDL_BLENDFACTOR_DST_ALPHA` and
 * `SDL_BLENDFACTOR_ONE_MINUS_DST_ALPHA` factors do not have an effect in this
 * case.
 *
 * \param srcColorFactor the SDL_BlendFactor applied to the red, green, and
 *                       blue components of the source pixels.
 * \param dstColorFactor the SDL_BlendFactor applied to the red, green, and
 *                       blue components of the destination pixels.
 * \param colorOperation the SDL_BlendOperation used to combine the red,
 *                       green, and blue components of the source and
 *                       destination pixels.
 * \param srcAlphaFactor the SDL_BlendFactor applied to the alpha component of
 *                       the source pixels.
 * \param dstAlphaFactor the SDL_BlendFactor applied to the alpha component of
 *                       the destination pixels.
 * \param alphaOperation the SDL_BlendOperation used to combine the alpha
 *                       component of the source and destination pixels.
 * \returns an SDL_BlendMode that represents the chosen factors and
 *          operations.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetRenderDrawBlendMode
 * \sa SDL_GetRenderDrawBlendMode
 * \sa SDL_SetTextureBlendMode
 * \sa SDL_GetTextureBlendMode
 *)
function SDL_ComposeCustomBlendMode(srcColorFactor: SDL_BlendFactor; dstColorFactor: SDL_BlendFactor; colorOperation: SDL_BlendOperation; srcAlphaFactor: SDL_BlendFactor; dstAlphaFactor: SDL_BlendFactor; alphaOperation: SDL_BlendOperation): SDL_BlendMode; cdecl;
  external LIB_SDL3 name _PU + 'SDL_ComposeCustomBlendMode';
{$ENDREGION 'SDL_blendmode.h'}

{$REGION 'SDL_pixels.h'}
(**
 * # CategoryPixels
 *
 * SDL offers facilities for pixel management.
 *
 * Largely these facilities deal with pixel _format_: what does this set of
 * bits represent?
 *
 * If you mostly want to think of a pixel as some combination of red, green,
 * blue, and maybe alpha intensities, this is all pretty straightforward, and
 * in many cases, is enough information to build a perfectly fine game.
 *
 * However, the actual definition of a pixel is more complex than that:
 *
 * Pixels are a representation of a color in a particular color space.
 *
 * The first characteristic of a color space is the color type. SDL
 * understands two different color types, RGB and YCbCr, or in SDL also
 * referred to as YUV.
 *
 * RGB colors consist of red, green, and blue channels of color that are added
 * together to represent the colors we see on the screen.
 *
 * https://en.wikipedia.org/wiki/RGB_color_model
 *
 * YCbCr colors represent colors as a Y luma brightness component and red and
 * blue chroma color offsets. This color representation takes advantage of the
 * fact that the human eye is more sensitive to brightness than the color in
 * an image. The Cb and Cr components are often compressed and have lower
 * resolution than the luma component.
 *
 * https://en.wikipedia.org/wiki/YCbCr
 *
 * When the color information in YCbCr is compressed, the Y pixels are left at
 * full resolution and each Cr and Cb pixel represents an average of the color
 * information in a block of Y pixels. The chroma location determines where in
 * that block of pixels the color information is coming from.
 *
 * The color range defines how much of the pixel to use when converting a
 * pixel into a color on the display. When the full color range is used, the
 * entire numeric range of the pixel bits is significant. When narrow color
 * range is used, for historical reasons, the pixel uses only a portion of the
 * numeric range to represent colors.
 *
 * The color primaries and white point are a definition of the colors in the
 * color space relative to the standard XYZ color space.
 *
 * https://en.wikipedia.org/wiki/CIE_1931_color_space
 *
 * The transfer characteristic, or opto-electrical transfer function (OETF),
 * is the way a color is converted from mathematically linear space into a
 * non-linear output signals.
 *
 * https://en.wikipedia.org/wiki/Rec._709#Transfer_characteristics
 *
 * The matrix coefficients are used to convert between YCbCr and RGB colors.
 *)

const
  (**
   * A fully opaque 8-bit alpha value.
   *
   * \since This macro is available since SDL 3.2.0.
   *
   * \sa SDL_ALPHA_TRANSPARENT
   *)
  SDL_ALPHA_OPAQUE = 255;

  (**
   * A fully opaque floating point alpha value.
   *
   * \since This macro is available since SDL 3.2.0.
   *
   * \sa SDL_ALPHA_TRANSPARENT_FLOAT
   *)
  SDL_ALPHA_OPAQUE_FLOAT = 1.0;

  (**
   * A fully transparent 8-bit alpha value.
   *
   * \since This macro is available since SDL 3.2.0.
   *
   * \sa SDL_ALPHA_OPAQUE
   *)
  SDL_ALPHA_TRANSPARENT = 0;

  (**
   * A fully transparent floating point alpha value.
   *
   * \since This macro is available since SDL 3.2.0.
   *
   * \sa SDL_ALPHA_OPAQUE_FLOAT
   *)
  SDL_ALPHA_TRANSPARENT_FLOAT = 0.0;

(**
 * Pixel type.
 *
 * \since This enum is available since SDL 3.2.0.
 *)
type
  SDL_PixelType = Integer;
  PSDL_PixelType = ^SDL_PixelType;

const
  SDL_PIXELTYPE_UNKNOWN = 0;
  SDL_PIXELTYPE_INDEX1 = 1;
  SDL_PIXELTYPE_INDEX4 = 2;
  SDL_PIXELTYPE_INDEX8 = 3;
  SDL_PIXELTYPE_PACKED8 = 4;
  SDL_PIXELTYPE_PACKED16 = 5;
  SDL_PIXELTYPE_PACKED32 = 6;
  SDL_PIXELTYPE_ARRAYU8 = 7;
  SDL_PIXELTYPE_ARRAYU16 = 8;
  SDL_PIXELTYPE_ARRAYU32 = 9;
  SDL_PIXELTYPE_ARRAYF16 = 10;
  SDL_PIXELTYPE_ARRAYF32 = 11;
  SDL_PIXELTYPE_INDEX2 = 12;

(**
 * Bitmap pixel order, high bit -> low bit.
 *
 * \since This enum is available since SDL 3.2.0.
 *)
type
  SDL_BitmapOrder = Integer;
  PSDL_BitmapOrder = ^SDL_BitmapOrder;

const
  SDL_BITMAPORDER_NONE = 0;
  SDL_BITMAPORDER_4321 = 1;
  SDL_BITMAPORDER_1234 = 2;

(**
 * Packed component order, high bit -> low bit.
 *
 * \since This enum is available since SDL 3.2.0.
 *)
type
  SDL_PackedOrder = Integer;
  PSDL_PackedOrder = ^SDL_PackedOrder;

const
  SDL_PACKEDORDER_NONE = 0;
  SDL_PACKEDORDER_XRGB = 1;
  SDL_PACKEDORDER_RGBX = 2;
  SDL_PACKEDORDER_ARGB = 3;
  SDL_PACKEDORDER_RGBA = 4;
  SDL_PACKEDORDER_XBGR = 5;
  SDL_PACKEDORDER_BGRX = 6;
  SDL_PACKEDORDER_ABGR = 7;
  SDL_PACKEDORDER_BGRA = 8;

(**
 * Array component order, low byte -> high byte.
 *
 * \since This enum is available since SDL 3.2.0.
 *)
type
  SDL_ArrayOrder = Integer;
  PSDL_ArrayOrder = ^SDL_ArrayOrder;

const
  SDL_ARRAYORDER_NONE = 0;
  SDL_ARRAYORDER_RGB = 1;
  SDL_ARRAYORDER_RGBA = 2;
  SDL_ARRAYORDER_ARGB = 3;
  SDL_ARRAYORDER_BGR = 4;
  SDL_ARRAYORDER_BGRA = 5;
  SDL_ARRAYORDER_ABGR = 6;

(**
 * Packed component layout.
 *
 * \since This enum is available since SDL 3.2.0.
 *)
type
  SDL_PackedLayout = Integer;
  PSDL_PackedLayout = ^SDL_PackedLayout;

const
  SDL_PACKEDLAYOUT_NONE = 0;
  SDL_PACKEDLAYOUT_332 = 1;
  SDL_PACKEDLAYOUT_4444 = 2;
  SDL_PACKEDLAYOUT_1555 = 3;
  SDL_PACKEDLAYOUT_5551 = 4;
  SDL_PACKEDLAYOUT_565 = 5;
  SDL_PACKEDLAYOUT_8888 = 6;
  SDL_PACKEDLAYOUT_2101010 = 7;
  SDL_PACKEDLAYOUT_1010102 = 8;

(**
 * Pixel format.
 *
 * SDL's pixel formats have the following naming convention:
 *
 * - Names with a list of components and a single bit count, such as RGB24 and
 *   ABGR32, define a platform-independent encoding into bytes in the order
 *   specified. For example, in RGB24 data, each pixel is encoded in 3 bytes
 *   (red, green, blue) in that order, and in ABGR32 data, each pixel is
 *   encoded in 4 bytes alpha, blue, green, red) in that order. Use these
 *   names if the property of a format that is important to you is the order
 *   of the bytes in memory or on disk.
 * - Names with a bit count per component, such as ARGB8888 and XRGB1555, are
 *   "packed" into an appropriately-sized integer in the platform's native
 *   endianness. For example, ARGB8888 is a sequence of 32-bit integers; in
 *   each integer, the most significant bits are alpha, and the least
 *   significant bits are blue. On a little-endian CPU such as x86, the least
 *   significant bits of each integer are arranged first in memory, but on a
 *   big-endian CPU such as s390x, the most significant bits are arranged
 *   first. Use these names if the property of a format that is important to
 *   you is the meaning of each bit position within a native-endianness
 *   integer.
 * - In indexed formats such as INDEX4LSB, each pixel is represented by
 *   encoding an index into the palette into the indicated number of bits,
 *   with multiple pixels packed into each byte if appropriate. In LSB
 *   formats, the first (leftmost) pixel is stored in the least-significant
 *   bits of the byte; in MSB formats, it's stored in the most-significant
 *   bits. INDEX8 does not need LSB/MSB variants, because each pixel exactly
 *   fills one byte.
 *
 * The 32-bit byte-array encodings such as RGBA32 are aliases for the
 * appropriate 8888 encoding for the current platform. For example, RGBA32 is
 * an alias for ABGR8888 on little-endian CPUs like x86, or an alias for
 * RGBA8888 on big-endian CPUs.
 *
 * \since This enum is available since SDL 3.2.0.
 *)
type
  SDL_PixelFormat = Integer;

const
  SDL_PIXELFORMAT_UNKNOWN = 0;
  SDL_PIXELFORMAT_INDEX1LSB = 286261504;
  SDL_PIXELFORMAT_INDEX1MSB = 287310080;
  SDL_PIXELFORMAT_INDEX2LSB = 470811136;
  SDL_PIXELFORMAT_INDEX2MSB = 471859712;
  SDL_PIXELFORMAT_INDEX4LSB = 303039488;
  SDL_PIXELFORMAT_INDEX4MSB = 304088064;
  SDL_PIXELFORMAT_INDEX8 = 318769153;
  SDL_PIXELFORMAT_RGB332 = 336660481;
  SDL_PIXELFORMAT_XRGB4444 = 353504258;
  SDL_PIXELFORMAT_XBGR4444 = 357698562;
  SDL_PIXELFORMAT_XRGB1555 = 353570562;
  SDL_PIXELFORMAT_XBGR1555 = 357764866;
  SDL_PIXELFORMAT_ARGB4444 = 355602434;
  SDL_PIXELFORMAT_RGBA4444 = 356651010;
  SDL_PIXELFORMAT_ABGR4444 = 359796738;
  SDL_PIXELFORMAT_BGRA4444 = 360845314;
  SDL_PIXELFORMAT_ARGB1555 = 355667970;
  SDL_PIXELFORMAT_RGBA5551 = 356782082;
  SDL_PIXELFORMAT_ABGR1555 = 359862274;
  SDL_PIXELFORMAT_BGRA5551 = 360976386;
  SDL_PIXELFORMAT_RGB565 = 353701890;
  SDL_PIXELFORMAT_BGR565 = 357896194;
  SDL_PIXELFORMAT_RGB24 = 386930691;
  SDL_PIXELFORMAT_BGR24 = 390076419;
  SDL_PIXELFORMAT_XRGB8888 = 370546692;
  SDL_PIXELFORMAT_RGBX8888 = 371595268;
  SDL_PIXELFORMAT_XBGR8888 = 374740996;
  SDL_PIXELFORMAT_BGRX8888 = 375789572;
  SDL_PIXELFORMAT_ARGB8888 = 372645892;
  SDL_PIXELFORMAT_RGBA8888 = 373694468;
  SDL_PIXELFORMAT_ABGR8888 = 376840196;
  SDL_PIXELFORMAT_BGRA8888 = 377888772;
  SDL_PIXELFORMAT_XRGB2101010 = 370614276;
  SDL_PIXELFORMAT_XBGR2101010 = 374808580;
  SDL_PIXELFORMAT_ARGB2101010 = 372711428;
  SDL_PIXELFORMAT_ABGR2101010 = 376905732;
  SDL_PIXELFORMAT_RGB48 = 403714054;
  SDL_PIXELFORMAT_BGR48 = 406859782;
  SDL_PIXELFORMAT_RGBA64 = 404766728;
  SDL_PIXELFORMAT_ARGB64 = 405815304;
  SDL_PIXELFORMAT_BGRA64 = 407912456;
  SDL_PIXELFORMAT_ABGR64 = 408961032;
  SDL_PIXELFORMAT_RGB48_FLOAT = 437268486;
  SDL_PIXELFORMAT_BGR48_FLOAT = 440414214;
  SDL_PIXELFORMAT_RGBA64_FLOAT = 438321160;
  SDL_PIXELFORMAT_ARGB64_FLOAT = 439369736;
  SDL_PIXELFORMAT_BGRA64_FLOAT = 441466888;
  SDL_PIXELFORMAT_ABGR64_FLOAT = 442515464;
  SDL_PIXELFORMAT_RGB96_FLOAT = 454057996;
  SDL_PIXELFORMAT_BGR96_FLOAT = 457203724;
  SDL_PIXELFORMAT_RGBA128_FLOAT = 455114768;
  SDL_PIXELFORMAT_ARGB128_FLOAT = 456163344;
  SDL_PIXELFORMAT_BGRA128_FLOAT = 458260496;
  SDL_PIXELFORMAT_ABGR128_FLOAT = 459309072;
  (** Planar mode: Y + V + U  (3 planes) *)
  SDL_PIXELFORMAT_YV12 = 842094169;
  (** Planar mode: Y + U + V  (3 planes) *)
  SDL_PIXELFORMAT_IYUV = 1448433993;
  (** Packed mode: Y0+U0+Y1+V0 (1 plane) *)
  SDL_PIXELFORMAT_YUY2 = 844715353;
  (** Packed mode: U0+Y0+V0+Y1 (1 plane) *)
  SDL_PIXELFORMAT_UYVY = 1498831189;
  (** Packed mode: Y0+V0+Y1+U0 (1 plane) *)
  SDL_PIXELFORMAT_YVYU = 1431918169;
  (** Planar mode: Y + U/V interleaved  (2 planes) *)
  SDL_PIXELFORMAT_NV12 = 842094158;
  (** Planar mode: Y + V/U interleaved  (2 planes) *)
  SDL_PIXELFORMAT_NV21 = 825382478;
  (** Planar mode: Y + U/V interleaved  (2 planes) *)
  SDL_PIXELFORMAT_P010 = 808530000;
  (** Android video texture format *)
  SDL_PIXELFORMAT_EXTERNAL_OES = 542328143;
  SDL_PIXELFORMAT_MJPG = 1196444237;
  SDL_PIXELFORMAT_RGBA32 = 376840196;
  SDL_PIXELFORMAT_ARGB32 = 377888772;
  SDL_PIXELFORMAT_BGRA32 = 372645892;
  SDL_PIXELFORMAT_ABGR32 = 373694468;
  SDL_PIXELFORMAT_RGBX32 = 374740996;
  SDL_PIXELFORMAT_XRGB32 = 375789572;
  SDL_PIXELFORMAT_BGRX32 = 370546692;
  SDL_PIXELFORMAT_XBGR32 = 371595268;

(**
 * A macro for defining custom FourCC pixel formats.
 *
 * For example, defining SDL_PIXELFORMAT_YV12 looks like this:
 *
 * ```c
 * SDL_DEFINE_PIXELFOURCC('Y', 'V', '1', '2')
 * ```
 *
 * \param A the first character of the FourCC code.
 * \param B the second character of the FourCC code.
 * \param C the third character of the FourCC code.
 * \param D the fourth character of the FourCC code.
 * \returns a format value in the style of SDL_PixelFormat.
 *
 * \threadsafety It is safe to call this macro from any thread.
 *
 * \since This macro is available since SDL 3.2.0.
 *)
function SDL_DefinePixelFourCC(A, B, C, D: Byte): UInt32; inline;

(**
 * A macro for defining custom non-FourCC pixel formats.
 *
 * For example, defining SDL_PIXELFORMAT_RGBA8888 looks like this:
 *
 * ```c
 * SDL_DEFINE_PIXELFORMAT(SDL_PIXELTYPE_PACKED32, SDL_PACKEDORDER_RGBA, SDL_PACKEDLAYOUT_8888, 32, 4)
 * ```
 *
 * \param type the type of the new format, probably a SDL_PixelType value.
 * \param order the order of the new format, probably a SDL_BitmapOrder,
 *              SDL_PackedOrder, or SDL_ArrayOrder value.
 * \param layout the layout of the new format, probably an SDL_PackedLayout
 *               value or zero.
 * \param bits the number of bits per pixel of the new format.
 * \param bytes the number of bytes per pixel of the new format.
 * \returns a format value in the style of SDL_PixelFormat.
 *
 * \threadsafety It is safe to call this macro from any thread.
 *
 * \since This macro is available since SDL 3.2.0.
 *)
function SDL_DefinePixelFormat(typ: SDL_PixelType; order: Integer;
  layout: SDL_PackedLayout; bits, bytes: Integer): SDL_PixelFormat; inline;

(**
 * A macro to retrieve the flags of an SDL_PixelFormat.
 *
 * This macro is generally not needed directly by an app, which should use
 * specific tests, like SDL_ISPIXELFORMAT_FOURCC, instead.
 *
 * \param format an SDL_PixelFormat to check.
 * \returns the flags of `format`.
 *
 * \threadsafety It is safe to call this macro from any thread.
 *
 * \since This macro is available since SDL 3.2.0.
 *)
function SDL_GetPixelFlag(format: SDL_PixelFormat): Integer; inline;

(**
 * A macro to retrieve the type of an SDL_PixelFormat.
 *
 * This is usually a value from the SDL_PixelType enumeration.
 *
 * \param format an SDL_PixelFormat to check.
 * \returns the type of `format`.
 *
 * \threadsafety It is safe to call this macro from any thread.
 *
 * \since This macro is available since SDL 3.2.0.
 *)
function SDL_GetPixelType(format: SDL_PixelFormat): SDL_PixelType; inline;

(**
 * A macro to retrieve the order of an SDL_PixelFormat.
 *
 * This is usually a value from the SDL_BitmapOrder, SDL_PackedOrder, or
 * SDL_ArrayOrder enumerations, depending on the format type.
 *
 * \param format an SDL_PixelFormat to check.
 * \returns the order of `format`.
 *
 * \threadsafety It is safe to call this macro from any thread.
 *
 * \since This macro is available since SDL 3.2.0.
 *)
function SDL_GetPixelOrder(format: SDL_PixelFormat): Integer; inline;

(**
 * A macro to retrieve the layout of an SDL_PixelFormat.
 *
 * This is usually a value from the SDL_PackedLayout enumeration, or zero if a
 * layout doesn't make sense for the format type.
 *
 * \param format an SDL_PixelFormat to check.
 * \returns the layout of `format`.
 *
 * \threadsafety It is safe to call this macro from any thread.
 *
 * \since This macro is available since SDL 3.2.0.
 *)
function SDL_GetPixelLayout(format: SDL_PixelFormat): SDL_PackedLayout; inline;

(**
 * A macro to determine an SDL_PixelFormat's bits per pixel.
 *
 * Note that this macro double-evaluates its parameter, so do not use
 * expressions with side-effects here.
 *
 * FourCC formats will report zero here, as it rarely makes sense to measure
 * them per-pixel.
 *
 * \param format an SDL_PixelFormat to check.
 * \returns the bits-per-pixel of `format`.
 *
 * \threadsafety It is safe to call this macro from any thread.
 *
 * \since This macro is available since SDL 3.2.0.
 *
 * \sa SDL_BYTESPERPIXEL
 *)
function SDL_GetBitsPerPixel(format: SDL_PixelFormat): Integer; inline;

(**
 * A macro to determine an SDL_PixelFormat's bytes per pixel.
 *
 * Note that this macro double-evaluates its parameter, so do not use
 * expressions with side-effects here.
 *
 * FourCC formats do their best here, but many of them don't have a meaningful
 * measurement of bytes per pixel.
 *
 * \param format an SDL_PixelFormat to check.
 * \returns the bytes-per-pixel of `format`.
 *
 * \threadsafety It is safe to call this macro from any thread.
 *
 * \since This macro is available since SDL 3.2.0.
 *
 * \sa SDL_BITSPERPIXEL
 *)
function SDL_GetBytesPerPixel(format: SDL_PixelFormat): Integer; inline;

(**
 * A macro to determine if an SDL_PixelFormat is an indexed format.
 *
 * Note that this macro double-evaluates its parameter, so do not use
 * expressions with side-effects here.
 *
 * \param format an SDL_PixelFormat to check.
 * \returns true if the format is indexed, false otherwise.
 *
 * \threadsafety It is safe to call this macro from any thread.
 *
 * \since This macro is available since SDL 3.2.0.
 *)
function SDL_IsPixelFormatIndexed(format: SDL_PixelFormat): Boolean; inline;

(**
 * A macro to determine if an SDL_PixelFormat is a packed format.
 *
 * Note that this macro double-evaluates its parameter, so do not use
 * expressions with side-effects here.
 *
 * \param format an SDL_PixelFormat to check.
 * \returns true if the format is packed, false otherwise.
 *
 * \threadsafety It is safe to call this macro from any thread.
 *
 * \since This macro is available since SDL 3.2.0.
 *)
function SDL_IsPixelFormatPacked(format: SDL_PixelFormat): Boolean; inline;

(**
 * A macro to determine if an SDL_PixelFormat is an array format.
 *
 * Note that this macro double-evaluates its parameter, so do not use
 * expressions with side-effects here.
 *
 * \param format an SDL_PixelFormat to check.
 * \returns true if the format is an array, false otherwise.
 *
 * \threadsafety It is safe to call this macro from any thread.
 *
 * \since This macro is available since SDL 3.2.0.
 *)
function SDL_IsPixelFormatArray(format: SDL_PixelFormat): Boolean; inline;

(**
 * A macro to determine if an SDL_PixelFormat is a 10-bit format.
 *
 * Note that this macro double-evaluates its parameter, so do not use
 * expressions with side-effects here.
 *
 * \param format an SDL_PixelFormat to check.
 * \returns true if the format is 10-bit, false otherwise.
 *
 * \threadsafety It is safe to call this macro from any thread.
 *
 * \since This macro is available since SDL 3.2.0.
 *)
function SDL_IsPixelFormat10Bit(format: SDL_PixelFormat): Boolean; inline;

(**
 * A macro to determine if an SDL_PixelFormat is a floating point format.
 *
 * Note that this macro double-evaluates its parameter, so do not use
 * expressions with side-effects here.
 *
 * \param format an SDL_PixelFormat to check.
 * \returns true if the format is 10-bit, false otherwise.
 *
 * \threadsafety It is safe to call this macro from any thread.
 *
 * \since This macro is available since SDL 3.2.0.
 *)
function SDL_IsPixelFormatFloat(format: SDL_PixelFormat): Boolean; inline;

(**
 * A macro to determine if an SDL_PixelFormat has an alpha channel.
 *
 * Note that this macro double-evaluates its parameter, so do not use
 * expressions with side-effects here.
 *
 * \param format an SDL_PixelFormat to check.
 * \returns true if the format has alpha, false otherwise.
 *
 * \threadsafety It is safe to call this macro from any thread.
 *
 * \since This macro is available since SDL 3.2.0.
 *)
function SDL_IsPixelFormatAlpha(format: SDL_PixelFormat): Boolean; inline;

(**
 * A macro to determine if an SDL_PixelFormat is a "FourCC" format.
 *
 * This covers custom and other unusual formats.
 *
 * Note that this macro double-evaluates its parameter, so do not use
 * expressions with side-effects here.
 *
 * \param format an SDL_PixelFormat to check.
 * \returns true if the format has alpha, false otherwise.
 *
 * \threadsafety It is safe to call this macro from any thread.
 *
 * \since This macro is available since SDL 3.2.0.
 *)
function SDL_IsPixelFormatFourCC(format: SDL_PixelFormat): Boolean; inline;

(**
 * Colorspace color type.
 *
 * \since This enum is available since SDL 3.2.0.
 *)
type
  SDL_ColorType = Integer;

const
  SDL_COLOR_TYPE_UNKNOWN = 0;
  SDL_COLOR_TYPE_RGB = 1;
  SDL_COLOR_TYPE_YCBCR = 2;

(**
 * Colorspace color range, as described by
 * https://www.itu.int/rec/R-REC-BT.2100-2-201807-I/en
 *
 * \since This enum is available since SDL 3.2.0.
 *)
type
  SDL_ColorRange = Integer;

const
  SDL_COLOR_RANGE_UNKNOWN = 0;
  (** Narrow range, e.g. 16-235 for 8-bit RGB and luma, and 16-240 for 8-bit chroma *)
  SDL_COLOR_RANGE_LIMITED = 1;
  (** Full range, e.g. 0-255 for 8-bit RGB and luma, and 1-255 for 8-bit chroma *)
  SDL_COLOR_RANGE_FULL = 2;

(**
 * Colorspace color primaries, as described by
 * https://www.itu.int/rec/T-REC-H.273-201612-S/en
 *
 * \since This enum is available since SDL 3.2.0.
 *)
type
  SDL_ColorPrimaries = Integer;

const
  SDL_COLOR_PRIMARIES_UNKNOWN = 0;
  (** ITU-R BT.709-6 *)
  SDL_COLOR_PRIMARIES_BT709 = 1;
  SDL_COLOR_PRIMARIES_UNSPECIFIED = 2;
  (** ITU-R BT.470-6 System M *)
  SDL_COLOR_PRIMARIES_BT470M = 4;
  (** ITU-R BT.470-6 System B, G / ITU-R BT.601-7 625 *)
  SDL_COLOR_PRIMARIES_BT470BG = 5;
  (** ITU-R BT.601-7 525, SMPTE 170M *)
  SDL_COLOR_PRIMARIES_BT601 = 6;
  (** SMPTE 240M, functionally the same as SDL_COLOR_PRIMARIES_BT601 *)
  SDL_COLOR_PRIMARIES_SMPTE240 = 7;
  (** Generic film (color filters using Illuminant C) *)
  SDL_COLOR_PRIMARIES_GENERIC_FILM = 8;
  (** ITU-R BT.2020-2 / ITU-R BT.2100-0 *)
  SDL_COLOR_PRIMARIES_BT2020 = 9;
  (** SMPTE ST 428-1 *)
  SDL_COLOR_PRIMARIES_XYZ = 10;
  (** SMPTE RP 431-2 *)
  SDL_COLOR_PRIMARIES_SMPTE431 = 11;
  (** SMPTE EG 432-1 / DCI P3 *)
  SDL_COLOR_PRIMARIES_SMPTE432 = 12;
  (** EBU Tech. 3213-E *)
  SDL_COLOR_PRIMARIES_EBU3213 = 22;
  SDL_COLOR_PRIMARIES_CUSTOM = 31;

(**
 * Colorspace transfer characteristics.
 *
 * These are as described by https://www.itu.int/rec/T-REC-H.273-201612-S/en
 *
 * \since This enum is available since SDL 3.2.0.
 *)
type
  SDL_TransferCharacteristics = Integer;

const
  SDL_TRANSFER_CHARACTERISTICS_UNKNOWN = 0;
  (** Rec. ITU-R BT.709-6 / ITU-R BT1361 *)
  SDL_TRANSFER_CHARACTERISTICS_BT709 = 1;
  SDL_TRANSFER_CHARACTERISTICS_UNSPECIFIED = 2;
  (** ITU-R BT.470-6 System M / ITU-R BT1700 625 PAL & SECAM *)
  SDL_TRANSFER_CHARACTERISTICS_GAMMA22 = 4;
  (** ITU-R BT.470-6 System B, G *)
  SDL_TRANSFER_CHARACTERISTICS_GAMMA28 = 5;
  (** SMPTE ST 170M / ITU-R BT.601-7 525 or 625 *)
  SDL_TRANSFER_CHARACTERISTICS_BT601 = 6;
  (** SMPTE ST 240M *)
  SDL_TRANSFER_CHARACTERISTICS_SMPTE240 = 7;
  SDL_TRANSFER_CHARACTERISTICS_LINEAR = 8;
  SDL_TRANSFER_CHARACTERISTICS_LOG100 = 9;
  SDL_TRANSFER_CHARACTERISTICS_LOG100_SQRT10 = 10;
  (** IEC 61966-2-4 *)
  SDL_TRANSFER_CHARACTERISTICS_IEC61966 = 11;
  (** ITU-R BT1361 Extended Colour Gamut *)
  SDL_TRANSFER_CHARACTERISTICS_BT1361 = 12;
  (** IEC 61966-2-1 (sRGB or sYCC) *)
  SDL_TRANSFER_CHARACTERISTICS_SRGB = 13;
  (** ITU-R BT2020 for 10-bit system *)
  SDL_TRANSFER_CHARACTERISTICS_BT2020_10BIT = 14;
  (** ITU-R BT2020 for 12-bit system *)
  SDL_TRANSFER_CHARACTERISTICS_BT2020_12BIT = 15;
  (** SMPTE ST 2084 for 10-, 12-, 14- and 16-bit systems *)
  SDL_TRANSFER_CHARACTERISTICS_PQ = 16;
  (** SMPTE ST 428-1 *)
  SDL_TRANSFER_CHARACTERISTICS_SMPTE428 = 17;
  (** ARIB STD-B67, known as "hybrid log-gamma" (HLG) *)
  SDL_TRANSFER_CHARACTERISTICS_HLG = 18;
  SDL_TRANSFER_CHARACTERISTICS_CUSTOM = 31;

(**
 * Colorspace matrix coefficients.
 *
 * These are as described by https://www.itu.int/rec/T-REC-H.273-201612-S/en
 *
 * \since This enum is available since SDL 3.2.0.
 *)
type
  SDL_MatrixCoefficients = Integer;

const
  SDL_MATRIX_COEFFICIENTS_IDENTITY = 0;
  (** ITU-R BT.709-6 *)
  SDL_MATRIX_COEFFICIENTS_BT709 = 1;
  SDL_MATRIX_COEFFICIENTS_UNSPECIFIED = 2;
  (** US FCC Title 47 *)
  SDL_MATRIX_COEFFICIENTS_FCC = 4;
  (** ITU-R BT.470-6 System B, G / ITU-R BT.601-7 625, functionally the same as SDL_MATRIX_COEFFICIENTS_BT601 *)
  SDL_MATRIX_COEFFICIENTS_BT470BG = 5;
  (** ITU-R BT.601-7 525 *)
  SDL_MATRIX_COEFFICIENTS_BT601 = 6;
  (** SMPTE 240M *)
  SDL_MATRIX_COEFFICIENTS_SMPTE240 = 7;
  SDL_MATRIX_COEFFICIENTS_YCGCO = 8;
  (** ITU-R BT.2020-2 non-constant luminance *)
  SDL_MATRIX_COEFFICIENTS_BT2020_NCL = 9;
  (** ITU-R BT.2020-2 constant luminance *)
  SDL_MATRIX_COEFFICIENTS_BT2020_CL = 10;
  (** SMPTE ST 2085 *)
  SDL_MATRIX_COEFFICIENTS_SMPTE2085 = 11;
  SDL_MATRIX_COEFFICIENTS_CHROMA_DERIVED_NCL = 12;
  SDL_MATRIX_COEFFICIENTS_CHROMA_DERIVED_CL = 13;
  (** ITU-R BT.2100-0 ICTCP *)
  SDL_MATRIX_COEFFICIENTS_ICTCP = 14;
  SDL_MATRIX_COEFFICIENTS_CUSTOM = 31;

(**
 * Colorspace chroma sample location.
 *
 * \since This enum is available since SDL 3.2.0.
 *)
type
  SDL_ChromaLocation = Integer;

const
  (** RGB, no chroma sampling *)
  SDL_CHROMA_LOCATION_NONE = 0;
  (** In MPEG-2, MPEG-4, and AVC, Cb and Cr are taken on midpoint of the left-edge of the 2x2 square. In other words, they have the same horizontal location as the top-left pixel, but is shifted one-half pixel down vertically. *)
  SDL_CHROMA_LOCATION_LEFT = 1;
  (** In JPEG/JFIF, H.261, and MPEG-1, Cb and Cr are taken at the center of the 2x2 square. In other words, they are offset one-half pixel to the right and one-half pixel down compared to the top-left pixel. *)
  SDL_CHROMA_LOCATION_CENTER = 2;
  (** In HEVC for BT.2020 and BT.2100 content (in particular on Blu-rays), Cb and Cr are sampled at the same location as the group's top-left Y pixel ("co-sited", "co-located"). *)
  SDL_CHROMA_LOCATION_TOPLEFT = 3;

(**
 * Colorspace definitions.
 *
 * Since similar colorspaces may vary in their details (matrix, transfer
 * function, etc.), this is not an exhaustive list, but rather a
 * representative sample of the kinds of colorspaces supported in SDL.
 *
 * \since This enum is available since SDL 3.2.0.
 *
 * \sa SDL_ColorPrimaries
 * \sa SDL_ColorRange
 * \sa SDL_ColorType
 * \sa SDL_MatrixCoefficients
 * \sa SDL_TransferCharacteristics
 *)
type
  SDL_Colorspace = Integer;

const
  SDL_COLORSPACE_UNKNOWN = 0;
  (** Equivalent to DXGI_COLOR_SPACE_RGB_FULL_G22_NONE_P709 *)
  SDL_COLORSPACE_SRGB = 301991328;
  (** Equivalent to DXGI_COLOR_SPACE_RGB_FULL_G10_NONE_P709  *)
  SDL_COLORSPACE_SRGB_LINEAR = 301991168;
  (** Equivalent to DXGI_COLOR_SPACE_RGB_FULL_G2084_NONE_P2020  *)
  SDL_COLORSPACE_HDR10 = 301999616;
  (** Equivalent to DXGI_COLOR_SPACE_YCBCR_FULL_G22_NONE_P709_X601 *)
  SDL_COLORSPACE_JPEG = 570426566;
  (** Equivalent to DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P601 *)
  SDL_COLORSPACE_BT601_LIMITED = 554703046;
  (** Equivalent to DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P601 *)
  SDL_COLORSPACE_BT601_FULL = 571480262;
  (** Equivalent to DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P709 *)
  SDL_COLORSPACE_BT709_LIMITED = 554697761;
  (** Equivalent to DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P709 *)
  SDL_COLORSPACE_BT709_FULL = 571474977;
  (** Equivalent to DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P2020 *)
  SDL_COLORSPACE_BT2020_LIMITED = 554706441;
  (** Equivalent to DXGI_COLOR_SPACE_YCBCR_FULL_G22_LEFT_P2020 *)
  SDL_COLORSPACE_BT2020_FULL = 571483657;
  (** The default colorspace for RGB surfaces if no colorspace is specified *)
  SDL_COLORSPACE_RGB_DEFAULT = 301991328;
  (** The default colorspace for YUV surfaces if no colorspace is specified *)
  SDL_COLORSPACE_YUV_DEFAULT = 570426566;

(**
 * A macro for defining custom SDL_Colorspace formats.
 *
 * For example, defining SDL_COLORSPACE_SRGB looks like this:
 *
 * ```c
 * SDL_DEFINE_COLORSPACE(SDL_COLOR_TYPE_RGB,
 *                       SDL_COLOR_RANGE_FULL,
 *                       SDL_COLOR_PRIMARIES_BT709,
 *                       SDL_TRANSFER_CHARACTERISTICS_SRGB,
 *                       SDL_MATRIX_COEFFICIENTS_IDENTITY,
 *                       SDL_CHROMA_LOCATION_NONE)
 * ```
 *
 * \param type the type of the new format, probably an SDL_ColorType value.
 * \param range the range of the new format, probably a SDL_ColorRange value.
 * \param primaries the primaries of the new format, probably an
 *                  SDL_ColorPrimaries value.
 * \param transfer the transfer characteristics of the new format, probably an
 *                 SDL_TransferCharacteristics value.
 * \param matrix the matrix coefficients of the new format, probably an
 *               SDL_MatrixCoefficients value.
 * \param chroma the chroma sample location of the new format, probably an
 *               SDL_ChromaLocation value.
 * \returns a format value in the style of SDL_Colorspace.
 *
 * \threadsafety It is safe to call this macro from any thread.
 *
 * \since This macro is available since SDL 3.2.0.
 *)
function SDL_DefineColorspace(typ: SDL_ColorType; range: SDL_ColorRange;
  primaries: SDL_ColorPrimaries; transfer: SDL_TransferCharacteristics;
  matrix: SDL_MatrixCoefficients; chroma: SDL_ChromaLocation): SDL_Colorspace; inline;

(**
 * A macro to retrieve the type of an SDL_Colorspace.
 *
 * \param cspace an SDL_Colorspace to check.
 * \returns the SDL_ColorType for `cspace`.
 *
 * \threadsafety It is safe to call this macro from any thread.
 *
 * \since This macro is available since SDL 3.2.0.
 *)
function SDL_GetColorspaceType(cspace: SDL_Colorspace): SDL_ColorType; inline;

(**
 * A macro to retrieve the range of an SDL_Colorspace.
 *
 * \param cspace an SDL_Colorspace to check.
 * \returns the SDL_ColorRange of `cspace`.
 *
 * \threadsafety It is safe to call this macro from any thread.
 *
 * \since This macro is available since SDL 3.2.0.
 *)
function SDL_GetColorspaceRange(cspace: SDL_Colorspace): SDL_ColorRange; inline;

(**
 * A macro to retrieve the chroma sample location of an SDL_Colorspace.
 *
 * \param cspace an SDL_Colorspace to check.
 * \returns the SDL_ChromaLocation of `cspace`.
 *
 * \threadsafety It is safe to call this macro from any thread.
 *
 * \since This macro is available since SDL 3.2.0.
 *)
function SDL_GetColorspaceChroma(cspace: SDL_Colorspace): SDL_ChromaLocation; inline;

(**
 * A macro to retrieve the primaries of an SDL_Colorspace.
 *
 * \param cspace an SDL_Colorspace to check.
 * \returns the SDL_ColorPrimaries of `cspace`.
 *
 * \threadsafety It is safe to call this macro from any thread.
 *
 * \since This macro is available since SDL 3.2.0.
 *)
function SDL_GetColorspacePrimaries(cspace: SDL_Colorspace): SDL_ColorPrimaries; inline;

(**
 * A macro to retrieve the transfer characteristics of an SDL_Colorspace.
 *
 * \param cspace an SDL_Colorspace to check.
 * \returns the SDL_TransferCharacteristics of `cspace`.
 *
 * \threadsafety It is safe to call this macro from any thread.
 *
 * \since This macro is available since SDL 3.2.0.
 *)
function SDL_GetColorspaceTransfer(cspace: SDL_Colorspace): SDL_TransferCharacteristics; inline;

(**
 * A macro to retrieve the matrix coefficients of an SDL_Colorspace.
 *
 * \param cspace an SDL_Colorspace to check.
 * \returns the SDL_MatrixCoefficients of `cspace`.
 *
 * \threadsafety It is safe to call this macro from any thread.
 *
 * \since This macro is available since SDL 3.2.0.
 *)
function SDL_GetColorspaceMatrix(cspace: SDL_Colorspace): SDL_MatrixCoefficients; inline;

(**
 * A macro to determine if an SDL_Colorspace uses BT601 (or BT470BG) matrix
 * coefficients.
 *
 * Note that this macro double-evaluates its parameter, so do not use
 * expressions with side-effects here.
 *
 * \param cspace an SDL_Colorspace to check.
 * \returns true if BT601 or BT470BG, false otherwise.
 *
 * \threadsafety It is safe to call this macro from any thread.
 *
 * \since This macro is available since SDL 3.2.0.
 *)
function SDL_IsColorspaceMatrixBT601(cspace: SDL_Colorspace): Boolean; inline;

(**
 * A macro to determine if an SDL_Colorspace uses BT709 matrix coefficients.
 *
 * \param cspace an SDL_Colorspace to check.
 * \returns true if BT709, false otherwise.
 *
 * \threadsafety It is safe to call this macro from any thread.
 *
 * \since This macro is available since SDL 3.2.0.
 *)
function SDL_IsColorspaceMatrixBT709(cspace: SDL_Colorspace): Boolean; inline;

(**
 * A macro to determine if an SDL_Colorspace uses BT2020_NCL matrix
 * coefficients.
 *
 * \param cspace an SDL_Colorspace to check.
 * \returns true if BT2020_NCL, false otherwise.
 *
 * \threadsafety It is safe to call this macro from any thread.
 *
 * \since This macro is available since SDL 3.2.0.
 *)
function SDL_IsColorspaceMatrixBT2020Ncl(cspace: SDL_Colorspace): Boolean; inline;

(**
 * A macro to determine if an SDL_Colorspace has a limited range.
 *
 * \param cspace an SDL_Colorspace to check.
 * \returns true if limited range, false otherwise.
 *
 * \threadsafety It is safe to call this macro from any thread.
 *
 * \since This macro is available since SDL 3.2.0.
 *)
function SDL_IsColorspaceLimitedRange(cspace: SDL_Colorspace): Boolean; inline;

(**
 * A macro to determine if an SDL_Colorspace has a full range.
 *
 * \param cspace an SDL_Colorspace to check.
 * \returns true if full range, false otherwise.
 *
 * \threadsafety It is safe to call this macro from any thread.
 *
 * \since This macro is available since SDL 3.2.0.
 *)
function SDL_IsColorspaceFullRange(cspace: SDL_Colorspace): Boolean; inline;

type
  (**
   * A structure that represents a color as RGBA components.
   *
   * The bits of this structure can be directly reinterpreted as an
   * integer-packed color which uses the SDL_PIXELFORMAT_RGBA32 format
   * (SDL_PIXELFORMAT_ABGR8888 on little-endian systems and
   * SDL_PIXELFORMAT_RGBA8888 on big-endian systems).
   *
   * \since This struct is available since SDL 3.2.0.
   *)
  SDL_Color = record
    r: Uint8;
    g: Uint8;
    b: Uint8;
    a: Uint8;
  end;
  PSDL_Color = ^SDL_Color;

  (**
   * The bits of this structure can be directly reinterpreted as a float-packed
   * color which uses the SDL_PIXELFORMAT_RGBA128_FLOAT format
   *
   * \since This struct is available since SDL 3.2.0.
   *)
  SDL_FColor = record
    r: Single;
    g: Single;
    b: Single;
    a: Single;
  end;
  PSDL_FColor = ^SDL_FColor;

  (**
   * A set of indexed colors representing a palette.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_SetPaletteColors
   *)
  SDL_Palette = record
    (** number of elements in `colors`. *)
    ncolors: Integer;
    (** an array of colors, `ncolors` long. *)
    colors: PSDL_Color;
    (** internal use only, do not touch. *)
    version: Uint32;
    (** internal use only, do not touch. *)
    refcount: Integer;
  end;
  PSDL_Palette = ^SDL_Palette;

  (**
   * Details about the format of a pixel.
   *
   * \since This struct is available since SDL 3.2.0.
   *)
  SDL_PixelFormatDetails = record
    format: SDL_PixelFormat;
    bits_per_pixel: Uint8;
    bytes_per_pixel: Uint8;
    padding: array [0..1] of Uint8;
    Rmask: Uint32;
    Gmask: Uint32;
    Bmask: Uint32;
    Amask: Uint32;
    Rbits: Uint8;
    Gbits: Uint8;
    Bbits: Uint8;
    Abits: Uint8;
    Rshift: Uint8;
    Gshift: Uint8;
    Bshift: Uint8;
    Ashift: Uint8;
  end;
  PSDL_PixelFormatDetails = ^SDL_PixelFormatDetails;

(**
 * Get the human readable name of a pixel format.
 *
 * \param format the pixel format to query.
 * \returns the human readable name of the specified pixel format or
 *          "SDL_PIXELFORMAT_UNKNOWN" if the format isn't recognized.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetPixelFormatName(format: SDL_PixelFormat): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetPixelFormatName';

(**
 * Convert one of the enumerated pixel formats to a bpp value and RGBA masks.
 *
 * \param format one of the SDL_PixelFormat values.
 * \param bpp a bits per pixel value; usually 15, 16, or 32.
 * \param Rmask a pointer filled in with the red mask for the format.
 * \param Gmask a pointer filled in with the green mask for the format.
 * \param Bmask a pointer filled in with the blue mask for the format.
 * \param Amask a pointer filled in with the alpha mask for the format.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetPixelFormatForMasks
 *)
function SDL_GetMasksForPixelFormat(format: SDL_PixelFormat; bpp: PInteger; Rmask: PUint32; Gmask: PUint32; Bmask: PUint32; Amask: PUint32): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetMasksForPixelFormat';

(**
 * Convert a bpp value and RGBA masks to an enumerated pixel format.
 *
 * This will return `SDL_PIXELFORMAT_UNKNOWN` if the conversion wasn't
 * possible.
 *
 * \param bpp a bits per pixel value; usually 15, 16, or 32.
 * \param Rmask the red mask for the format.
 * \param Gmask the green mask for the format.
 * \param Bmask the blue mask for the format.
 * \param Amask the alpha mask for the format.
 * \returns the SDL_PixelFormat value corresponding to the format masks, or
 *          SDL_PIXELFORMAT_UNKNOWN if there isn't a match.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetMasksForPixelFormat
 *)
function SDL_GetPixelFormatForMasks(bpp: Integer; Rmask: Uint32; Gmask: Uint32; Bmask: Uint32; Amask: Uint32): SDL_PixelFormat; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetPixelFormatForMasks';

(**
 * Create an SDL_PixelFormatDetails structure corresponding to a pixel format.
 *
 * Returned structure may come from a shared global cache (i.e. not newly
 * allocated), and hence should not be modified, especially the palette. Weird
 * errors such as `Blit combination not supported` may occur.
 *
 * \param format one of the SDL_PixelFormat values.
 * \returns a pointer to a SDL_PixelFormatDetails structure or NULL on
 *          failure; call SDL_GetError() for more information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetPixelFormatDetails(format: SDL_PixelFormat): PSDL_PixelFormatDetails; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetPixelFormatDetails';

(**
 * Create a palette structure with the specified number of color entries.
 *
 * The palette entries are initialized to white.
 *
 * \param ncolors represents the number of color entries in the color palette.
 * \returns a new SDL_Palette structure on success or NULL on failure (e.g. if
 *          there wasn't enough memory); call SDL_GetError() for more
 *          information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_DestroyPalette
 * \sa SDL_SetPaletteColors
 * \sa SDL_SetSurfacePalette
 *)
function SDL_CreatePalette(ncolors: Integer): PSDL_Palette; cdecl;
  external LIB_SDL3 name _PU + 'SDL_CreatePalette';

(**
 * Set a range of colors in a palette.
 *
 * \param palette the SDL_Palette structure to modify.
 * \param colors an array of SDL_Color structures to copy into the palette.
 * \param firstcolor the index of the first palette entry to modify.
 * \param ncolors the number of entries to modify.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety It is safe to call this function from any thread, as long as
 *               the palette is not modified or destroyed in another thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_SetPaletteColors(palette: PSDL_Palette; const colors: PSDL_Color; firstcolor: Integer; ncolors: Integer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetPaletteColors';

(**
 * Free a palette created with SDL_CreatePalette().
 *
 * \param palette the SDL_Palette structure to be freed.
 *
 * \threadsafety It is safe to call this function from any thread, as long as
 *               the palette is not modified or destroyed in another thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CreatePalette
 *)
procedure SDL_DestroyPalette(palette: PSDL_Palette); cdecl;
  external LIB_SDL3 name _PU + 'SDL_DestroyPalette';

(**
 * Map an RGB triple to an opaque pixel value for a given pixel format.
 *
 * This function maps the RGB color value to the specified pixel format and
 * returns the pixel value best approximating the given RGB color value for
 * the given pixel format.
 *
 * If the format has a palette (8-bit) the index of the closest matching color
 * in the palette will be returned.
 *
 * If the specified pixel format has an alpha component it will be returned as
 * all 1 bits (fully opaque).
 *
 * If the pixel format bpp (color depth) is less than 32-bpp then the unused
 * upper bits of the return value can safely be ignored (e.g., with a 16-bpp
 * format the return value can be assigned to a Uint16, and similarly a Uint8
 * for an 8-bpp format).
 *
 * \param format a pointer to SDL_PixelFormatDetails describing the pixel
 *               format.
 * \param palette an optional palette for indexed formats, may be NULL.
 * \param r the red component of the pixel in the range 0-255.
 * \param g the green component of the pixel in the range 0-255.
 * \param b the blue component of the pixel in the range 0-255.
 * \returns a pixel value.
 *
 * \threadsafety It is safe to call this function from any thread, as long as
 *               the palette is not modified.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetPixelFormatDetails
 * \sa SDL_GetRGB
 * \sa SDL_MapRGBA
 * \sa SDL_MapSurfaceRGB
 *)
function SDL_MapRGB(const format: PSDL_PixelFormatDetails; const palette: PSDL_Palette; r: Uint8; g: Uint8; b: Uint8): Uint32; cdecl;
  external LIB_SDL3 name _PU + 'SDL_MapRGB';

(**
 * Map an RGBA quadruple to a pixel value for a given pixel format.
 *
 * This function maps the RGBA color value to the specified pixel format and
 * returns the pixel value best approximating the given RGBA color value for
 * the given pixel format.
 *
 * If the specified pixel format has no alpha component the alpha value will
 * be ignored (as it will be in formats with a palette).
 *
 * If the format has a palette (8-bit) the index of the closest matching color
 * in the palette will be returned.
 *
 * If the pixel format bpp (color depth) is less than 32-bpp then the unused
 * upper bits of the return value can safely be ignored (e.g., with a 16-bpp
 * format the return value can be assigned to a Uint16, and similarly a Uint8
 * for an 8-bpp format).
 *
 * \param format a pointer to SDL_PixelFormatDetails describing the pixel
 *               format.
 * \param palette an optional palette for indexed formats, may be NULL.
 * \param r the red component of the pixel in the range 0-255.
 * \param g the green component of the pixel in the range 0-255.
 * \param b the blue component of the pixel in the range 0-255.
 * \param a the alpha component of the pixel in the range 0-255.
 * \returns a pixel value.
 *
 * \threadsafety It is safe to call this function from any thread, as long as
 *               the palette is not modified.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetPixelFormatDetails
 * \sa SDL_GetRGBA
 * \sa SDL_MapRGB
 * \sa SDL_MapSurfaceRGBA
 *)
function SDL_MapRGBA(const format: PSDL_PixelFormatDetails; const palette: PSDL_Palette; r: Uint8; g: Uint8; b: Uint8; a: Uint8): Uint32; cdecl;
  external LIB_SDL3 name _PU + 'SDL_MapRGBA';

(**
 * Get RGB values from a pixel in the specified format.
 *
 * This function uses the entire 8-bit [0..255] range when converting color
 * components from pixel formats with less than 8-bits per RGB component
 * (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,
 * 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).
 *
 * \param pixel a pixel value.
 * \param format a pointer to SDL_PixelFormatDetails describing the pixel
 *               format.
 * \param palette an optional palette for indexed formats, may be NULL.
 * \param r a pointer filled in with the red component, may be NULL.
 * \param g a pointer filled in with the green component, may be NULL.
 * \param b a pointer filled in with the blue component, may be NULL.
 *
 * \threadsafety It is safe to call this function from any thread, as long as
 *               the palette is not modified.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetPixelFormatDetails
 * \sa SDL_GetRGBA
 * \sa SDL_MapRGB
 * \sa SDL_MapRGBA
 *)
procedure SDL_GetRGB(pixel: Uint32; const format: PSDL_PixelFormatDetails; const palette: PSDL_Palette; r: PUint8; g: PUint8; b: PUint8); cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetRGB';

(**
 * Get RGBA values from a pixel in the specified format.
 *
 * This function uses the entire 8-bit [0..255] range when converting color
 * components from pixel formats with less than 8-bits per RGB component
 * (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,
 * 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).
 *
 * If the surface has no alpha component, the alpha will be returned as 0xff
 * (100% opaque).
 *
 * \param pixel a pixel value.
 * \param format a pointer to SDL_PixelFormatDetails describing the pixel
 *               format.
 * \param palette an optional palette for indexed formats, may be NULL.
 * \param r a pointer filled in with the red component, may be NULL.
 * \param g a pointer filled in with the green component, may be NULL.
 * \param b a pointer filled in with the blue component, may be NULL.
 * \param a a pointer filled in with the alpha component, may be NULL.
 *
 * \threadsafety It is safe to call this function from any thread, as long as
 *               the palette is not modified.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetPixelFormatDetails
 * \sa SDL_GetRGB
 * \sa SDL_MapRGB
 * \sa SDL_MapRGBA
 *)
procedure SDL_GetRGBA(pixel: Uint32; const format: PSDL_PixelFormatDetails; const palette: PSDL_Palette; r: PUint8; g: PUint8; b: PUint8; a: PUint8); cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetRGBA';
{$ENDREGION 'SDL_pixels.h'}

{$REGION 'SDL_rect.h'}
(**
 * # CategoryRect
 *
 * Some helper functions for managing rectangles and 2D points, in both
 * integer and floating point versions.
 *)

type
  (**
   * The structure that defines a point (using integers).
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_GetRectEnclosingPoints
   * \sa SDL_PointInRect
   *)
  SDL_Point = record
    x: Integer;
    y: Integer;
  end;
  PSDL_Point = ^SDL_Point;

  (**
   * The structure that defines a point (using floating point values).
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_GetRectEnclosingPointsFloat
   * \sa SDL_PointInRectFloat
   *)
  SDL_FPoint = record
    x: Single;
    y: Single;
  end;
  PSDL_FPoint = ^SDL_FPoint;

  (**
   * A rectangle, with the origin at the upper left (using integers).
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_RectEmpty
   * \sa SDL_RectsEqual
   * \sa SDL_HasRectIntersection
   * \sa SDL_GetRectIntersection
   * \sa SDL_GetRectAndLineIntersection
   * \sa SDL_GetRectUnion
   * \sa SDL_GetRectEnclosingPoints
   *)
  SDL_Rect = record
    x: Integer;
    y: Integer;
    w: Integer;
    h: Integer;
  end;
  PSDL_Rect = ^SDL_Rect;

  (**
   * A rectangle, with the origin at the upper left (using floating point
   * values).
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_RectEmptyFloat
   * \sa SDL_RectsEqualFloat
   * \sa SDL_RectsEqualEpsilon
   * \sa SDL_HasRectIntersectionFloat
   * \sa SDL_GetRectIntersectionFloat
   * \sa SDL_GetRectAndLineIntersectionFloat
   * \sa SDL_GetRectUnionFloat
   * \sa SDL_GetRectEnclosingPointsFloat
   * \sa SDL_PointInRectFloat
   *)
  SDL_FRect = record
    x: Single;
    y: Single;
    w: Single;
    h: Single;
  end;
  PSDL_FRect = ^SDL_FRect;

(**
 * Convert an SDL_Rect to SDL_FRect
 *
 * \param rect a pointer to an SDL_Rect.
 * \param frect a pointer filled in with the floating point representation of
 *              `rect`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_RectToFRect(const rect: SDL_Rect; out frect: SDL_FRect); inline;

(**
 * Determine whether a point resides inside a rectangle.
 *
 * A point is considered part of a rectangle if both `p` and `r` are not NULL,
 * and `p`'s x and y coordinates are >= to the rectangle's top left corner,
 * and < the rectangle's x+w and y+h. So a 1x1 rectangle considers point (0,0)
 * as "inside" and (0,1) as not.
 *
 * Note that this is a forced-inline function in a header, and not a public
 * API function available in the SDL library (which is to say, the code is
 * embedded in the calling program and the linker and dynamic loader will not
 * be able to find this function inside SDL itself).
 *
 * \param p the point to test.
 * \param r the rectangle to test.
 * \returns true if `p` is contained by `r`, false otherwise.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_PointInRect(const p: SDL_Point; const r: SDL_Rect): Boolean; inline;

(**
 * Determine whether a rectangle has no area.
 *
 * A rectangle is considered "empty" for this function if `r` is NULL, or if
 * `r`'s width and/or height are <= 0.
 *
 * Note that this is a forced-inline function in a header, and not a public
 * API function available in the SDL library (which is to say, the code is
 * embedded in the calling program and the linker and dynamic loader will not
 * be able to find this function inside SDL itself).
 *
 * \param r the rectangle to test.
 * \returns true if the rectangle is "empty", false otherwise.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_RectEmpty(const r: SDL_Rect): Boolean; inline;

(**
 * Determine whether two rectangles are equal.
 *
 * Rectangles are considered equal if both are not NULL and each of their x,
 * y, width and height match.
 *
 * Note that this is a forced-inline function in a header, and not a public
 * API function available in the SDL library (which is to say, the code is
 * embedded in the calling program and the linker and dynamic loader will not
 * be able to find this function inside SDL itself).
 *
 * \param a the first rectangle to test.
 * \param b the second rectangle to test.
 * \returns true if the rectangles are equal, false otherwise.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_RectsEqual(const a, b: SDL_Rect): Boolean; inline;

(**
 * Determine whether two rectangles intersect.
 *
 * If either pointer is NULL the function will return false.
 *
 * \param A an SDL_Rect structure representing the first rectangle.
 * \param B an SDL_Rect structure representing the second rectangle.
 * \returns true if there is an intersection, false otherwise.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetRectIntersection
 *)
function SDL_HasRectIntersection(const A: PSDL_Rect; const B: PSDL_Rect): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_HasRectIntersection';

(**
 * Calculate the intersection of two rectangles.
 *
 * If `result` is NULL then this function will return false.
 *
 * \param A an SDL_Rect structure representing the first rectangle.
 * \param B an SDL_Rect structure representing the second rectangle.
 * \param result an SDL_Rect structure filled in with the intersection of
 *               rectangles `A` and `B`.
 * \returns true if there is an intersection, false otherwise.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_HasRectIntersection
 *)
function SDL_GetRectIntersection(const A: PSDL_Rect; const B: PSDL_Rect; result: PSDL_Rect): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetRectIntersection';

(**
 * Calculate the union of two rectangles.
 *
 * \param A an SDL_Rect structure representing the first rectangle.
 * \param B an SDL_Rect structure representing the second rectangle.
 * \param result an SDL_Rect structure filled in with the union of rectangles
 *               `A` and `B`.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetRectUnion(const A: PSDL_Rect; const B: PSDL_Rect; result: PSDL_Rect): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetRectUnion';

(**
 * Calculate a minimal rectangle enclosing a set of points.
 *
 * If `clip` is not NULL then only points inside of the clipping rectangle are
 * considered.
 *
 * \param points an array of SDL_Point structures representing points to be
 *               enclosed.
 * \param count the number of structures in the `points` array.
 * \param clip an SDL_Rect used for clipping or NULL to enclose all points.
 * \param result an SDL_Rect structure filled in with the minimal enclosing
 *               rectangle.
 * \returns true if any points were enclosed or false if all the points were
 *          outside of the clipping rectangle.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetRectEnclosingPoints(const points: PSDL_Point; count: Integer; const clip: PSDL_Rect; result: PSDL_Rect): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetRectEnclosingPoints';

(**
 * Calculate the intersection of a rectangle and line segment.
 *
 * This function is used to clip a line segment to a rectangle. A line segment
 * contained entirely within the rectangle or that does not intersect will
 * remain unchanged. A line segment that crosses the rectangle at either or
 * both ends will be clipped to the boundary of the rectangle and the new
 * coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.
 *
 * \param rect an SDL_Rect structure representing the rectangle to intersect.
 * \param X1 a pointer to the starting X-coordinate of the line.
 * \param Y1 a pointer to the starting Y-coordinate of the line.
 * \param X2 a pointer to the ending X-coordinate of the line.
 * \param Y2 a pointer to the ending Y-coordinate of the line.
 * \returns true if there is an intersection, false otherwise.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetRectAndLineIntersection(const rect: PSDL_Rect; X1: PInteger; Y1: PInteger; X2: PInteger; Y2: PInteger): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetRectAndLineIntersection';

(**
 * Determine whether a point resides inside a floating point rectangle.
 *
 * A point is considered part of a rectangle if both `p` and `r` are not NULL,
 * and `p`'s x and y coordinates are >= to the rectangle's top left corner,
 * and <= the rectangle's x+w and y+h. So a 1x1 rectangle considers point
 * (0,0) and (0,1) as "inside" and (0,2) as not.
 *
 * Note that this is a forced-inline function in a header, and not a public
 * API function available in the SDL library (which is to say, the code is
 * embedded in the calling program and the linker and dynamic loader will not
 * be able to find this function inside SDL itself).
 *
 * \param p the point to test.
 * \param r the rectangle to test.
 * \returns true if `p` is contained by `r`, false otherwise.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_PointInRectFloat(const p: SDL_FPoint; const r: SDL_FRect): Boolean; inline;

(**
 * Determine whether a floating point rectangle can contain any point.
 *
 * A rectangle is considered "empty" for this function if `r` is NULL, or if
 * `r`'s width and/or height are < 0.0f.
 *
 * Note that this is a forced-inline function in a header, and not a public
 * API function available in the SDL library (which is to say, the code is
 * embedded in the calling program and the linker and dynamic loader will not
 * be able to find this function inside SDL itself).
 *
 * \param r the rectangle to test.
 * \returns true if the rectangle is "empty", false otherwise.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_RectEmptyFloat(const r: SDL_FRect): Boolean; inline;

(**
 * Determine whether two floating point rectangles are equal, within some
 * given epsilon.
 *
 * Rectangles are considered equal if both are not NULL and each of their x,
 * y, width and height are within `epsilon` of each other. If you don't know
 * what value to use for `epsilon`, you should call the SDL_RectsEqualFloat
 * function instead.
 *
 * Note that this is a forced-inline function in a header, and not a public
 * API function available in the SDL library (which is to say, the code is
 * embedded in the calling program and the linker and dynamic loader will not
 * be able to find this function inside SDL itself).
 *
 * \param a the first rectangle to test.
 * \param b the second rectangle to test.
 * \param epsilon the epsilon value for comparison.
 * \returns true if the rectangles are equal, false otherwise.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_RectsEqualFloat
 *)
function SDL_RectsEqualEpsilon(const a, b: SDL_FRect; const epsilon: Single): Boolean; inline;

(**
 * Determine whether two floating point rectangles are equal, within a default
 * epsilon.
 *
 * Rectangles are considered equal if both are not NULL and each of their x,
 * y, width and height are within SDL_FLT_EPSILON of each other. This is often
 * a reasonable way to compare two floating point rectangles and deal with the
 * slight precision variations in floating point calculations that tend to pop
 * up.
 *
 * Note that this is a forced-inline function in a header, and not a public
 * API function available in the SDL library (which is to say, the code is
 * embedded in the calling program and the linker and dynamic loader will not
 * be able to find this function inside SDL itself).
 *
 * \param a the first rectangle to test.
 * \param b the second rectangle to test.
 * \returns true if the rectangles are equal, false otherwise.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_RectsEqualEpsilon
 *)
function SDL_RectsEqualFloat(const a, b: SDL_FRect): Boolean; inline;

(**
 * Determine whether two rectangles intersect with float precision.
 *
 * If either pointer is NULL the function will return false.
 *
 * \param A an SDL_FRect structure representing the first rectangle.
 * \param B an SDL_FRect structure representing the second rectangle.
 * \returns true if there is an intersection, false otherwise.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetRectIntersection
 *)
function SDL_HasRectIntersectionFloat(const A: PSDL_FRect; const B: PSDL_FRect): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_HasRectIntersectionFloat';

(**
 * Calculate the intersection of two rectangles with float precision.
 *
 * If `result` is NULL then this function will return false.
 *
 * \param A an SDL_FRect structure representing the first rectangle.
 * \param B an SDL_FRect structure representing the second rectangle.
 * \param result an SDL_FRect structure filled in with the intersection of
 *               rectangles `A` and `B`.
 * \returns true if there is an intersection, false otherwise.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_HasRectIntersectionFloat
 *)
function SDL_GetRectIntersectionFloat(const A: PSDL_FRect; const B: PSDL_FRect; result: PSDL_FRect): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetRectIntersectionFloat';

(**
 * Calculate the union of two rectangles with float precision.
 *
 * \param A an SDL_FRect structure representing the first rectangle.
 * \param B an SDL_FRect structure representing the second rectangle.
 * \param result an SDL_FRect structure filled in with the union of rectangles
 *               `A` and `B`.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetRectUnionFloat(const A: PSDL_FRect; const B: PSDL_FRect; result: PSDL_FRect): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetRectUnionFloat';

(**
 * Calculate a minimal rectangle enclosing a set of points with float
 * precision.
 *
 * If `clip` is not NULL then only points inside of the clipping rectangle are
 * considered.
 *
 * \param points an array of SDL_FPoint structures representing points to be
 *               enclosed.
 * \param count the number of structures in the `points` array.
 * \param clip an SDL_FRect used for clipping or NULL to enclose all points.
 * \param result an SDL_FRect structure filled in with the minimal enclosing
 *               rectangle.
 * \returns true if any points were enclosed or false if all the points were
 *          outside of the clipping rectangle.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetRectEnclosingPointsFloat(const points: PSDL_FPoint; count: Integer; const clip: PSDL_FRect; result: PSDL_FRect): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetRectEnclosingPointsFloat';

(**
 * Calculate the intersection of a rectangle and line segment with float
 * precision.
 *
 * This function is used to clip a line segment to a rectangle. A line segment
 * contained entirely within the rectangle or that does not intersect will
 * remain unchanged. A line segment that crosses the rectangle at either or
 * both ends will be clipped to the boundary of the rectangle and the new
 * coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.
 *
 * \param rect an SDL_FRect structure representing the rectangle to intersect.
 * \param X1 a pointer to the starting X-coordinate of the line.
 * \param Y1 a pointer to the starting Y-coordinate of the line.
 * \param X2 a pointer to the ending X-coordinate of the line.
 * \param Y2 a pointer to the ending Y-coordinate of the line.
 * \returns true if there is an intersection, false otherwise.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetRectAndLineIntersectionFloat(const rect: PSDL_FRect; X1: PSingle; Y1: PSingle; X2: PSingle; Y2: PSingle): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetRectAndLineIntersectionFloat';
{$ENDREGION 'SDL_rect.h'}

{$REGION 'SDL_surface.h'}
(**
 * # CategorySurface
 *
 * SDL surfaces are buffers of pixels in system RAM. These are useful for
 * passing around and manipulating images that are not stored in GPU memory.
 *
 * SDL_Surface makes serious efforts to manage images in various formats, and
 * provides a reasonable toolbox for transforming the data, including copying
 * between surfaces, filling rectangles in the image data, etc.
 *
 * There is also a simple .bmp loader, SDL_LoadBMP(). SDL itself does not
 * provide loaders for various other file formats, but there are several
 * excellent external libraries that do, including its own satellite library,
 * SDL_image:
 *
 * https://github.com/libsdl-org/SDL_image
 *)

type
 (**
   * The flags on an SDL_Surface.
   *
   * These are generally considered read-only.
   *
   * \since This datatype is available since SDL 3.2.0.
   *)
  SDL_SurfaceFlags = Uint32;

const
  // Surface uses preallocated pixel memory
  SDL_SURFACE_PREALLOCATED = $00000001;

  // Surface needs to be locked to access pixels
  SDL_SURFACE_LOCK_NEEDED = $00000002;

  // Surface is currently locked
  SDL_SURFACE_LOCKED = $00000004;

  // Surface uses pixel memory allocated with SDL_aligned_alloc()
  SDL_SURFACE_SIMD_ALIGNED = $00000008;

(**
 * The scaling mode.
 *
 * \since This enum is available since SDL 3.2.0.
 *)
type
  SDL_ScaleMode = Integer;
  PSDL_ScaleMode = ^SDL_ScaleMode;

const
  (** nearest pixel sampling *)
  SDL_SCALEMODE_NEAREST = 0;
  (** linear filtering *)
  SDL_SCALEMODE_LINEAR = 1;

(**
 * The flip mode.
 *
 * \since This enum is available since SDL 3.2.0.
 *)
type
  SDL_FlipMode = Integer;

const
  (** Do not flip *)
  SDL_FLIP_NONE = 0;
  (** flip horizontally *)
  SDL_FLIP_HORIZONTAL = 1;
  (** flip vertically *)
  SDL_FLIP_VERTICAL = 2;

type
  (**
   * A collection of pixels used in software blitting.
   *
   * Pixels are arranged in memory in rows, with the top row first. Each row
   * occupies an amount of memory given by the pitch (sometimes known as the row
   * stride in non-SDL APIs).
   *
   * Within each row, pixels are arranged from left to right until the width is
   * reached. Each pixel occupies a number of bits appropriate for its format,
   * with most formats representing each pixel as one or more whole bytes (in
   * some indexed formats, instead multiple pixels are packed into each byte),
   * and a byte order given by the format. After encoding all pixels, any
   * remaining bytes to reach the pitch are used as padding to reach a desired
   * alignment, and have undefined contents.
   *
   * When a surface holds YUV format data, the planes are assumed to be
   * contiguous without padding between them, e.g. a 32x32 surface in NV12
   * format with a pitch of 32 would consist of 32x32 bytes of Y plane followed
   * by 32x16 bytes of UV plane.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_CreateSurface
   * \sa SDL_DestroySurface
   *)
  SDL_Surface = record
    (** The flags of the surface, read-only *)
    flags: SDL_SurfaceFlags;
    (** The format of the surface, read-only *)
    format: SDL_PixelFormat;
    (** The width of the surface, read-only. *)
    w: Integer;
    (** The height of the surface, read-only. *)
    h: Integer;
    (** The distance in bytes between rows of pixels, read-only *)
    pitch: Integer;
    (** A pointer to the pixels of the surface, the pixels are writeable if non-NULL *)
    pixels: Pointer;
    (** Application reference count, used when freeing surface *)
    refcount: Integer;
    (** Reserved for internal use *)
    reserved: Pointer;
  end;
  PSDL_Surface = ^SDL_Surface;
  PPSDL_Surface = ^PSDL_Surface;

(**
 * Evaluates to true if the surface needs to be locked before access.
 *
 * \since This macro is available since SDL 3.2.0.
 *)
function SDL_MustLock(S: SDL_Surface): Boolean; inline;

(**
 * Allocate a new surface with a specific pixel format.
 *
 * The pixels of the new surface are initialized to zero.
 *
 * \param width the width of the surface.
 * \param height the height of the surface.
 * \param format the SDL_PixelFormat for the new surface's pixel format.
 * \returns the new SDL_Surface structure that is created or NULL on failure;
 *          call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CreateSurfaceFrom
 * \sa SDL_DestroySurface
 *)
function SDL_CreateSurface(width: Integer; height: Integer; format: SDL_PixelFormat): PSDL_Surface; cdecl;
  external LIB_SDL3 name _PU + 'SDL_CreateSurface';

(**
 * Allocate a new surface with a specific pixel format and existing pixel
 * data.
 *
 * No copy is made of the pixel data. Pixel data is not managed automatically;
 * you must free the surface before you free the pixel data.
 *
 * Pitch is the offset in bytes from one row of pixels to the next, e.g.
 * `width*4` for `SDL_PIXELFORMAT_RGBA8888`.
 *
 * You may pass NULL for pixels and 0 for pitch to create a surface that you
 * will fill in with valid values later.
 *
 * \param width the width of the surface.
 * \param height the height of the surface.
 * \param format the SDL_PixelFormat for the new surface's pixel format.
 * \param pixels a pointer to existing pixel data.
 * \param pitch the number of bytes between each row, including padding.
 * \returns the new SDL_Surface structure that is created or NULL on failure;
 *          call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CreateSurface
 * \sa SDL_DestroySurface
 *)
function SDL_CreateSurfaceFrom(width: Integer; height: Integer; format: SDL_PixelFormat; pixels: Pointer; pitch: Integer): PSDL_Surface; cdecl;
  external LIB_SDL3 name _PU + 'SDL_CreateSurfaceFrom';

(**
 * Free a surface.
 *
 * It is safe to pass NULL to this function.
 *
 * \param surface the SDL_Surface to free.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CreateSurface
 * \sa SDL_CreateSurfaceFrom
 *)
procedure SDL_DestroySurface(surface: PSDL_Surface); cdecl;
  external LIB_SDL3 name _PU + 'SDL_DestroySurface';

(**
 * Get the properties associated with a surface.
 *
 * The following properties are understood by SDL:
 *
 * - `SDL_PROP_SURFACE_SDR_WHITE_POINT_FLOAT`: for HDR10 and floating point
 *   surfaces, this defines the value of 100% diffuse white, with higher
 *   values being displayed in the High Dynamic Range headroom. This defaults
 *   to 203 for HDR10 surfaces and 1.0 for floating point surfaces.
 * - `SDL_PROP_SURFACE_HDR_HEADROOM_FLOAT`: for HDR10 and floating point
 *   surfaces, this defines the maximum dynamic range used by the content, in
 *   terms of the SDR white point. This defaults to 0.0, which disables tone
 *   mapping.
 * - `SDL_PROP_SURFACE_TONEMAP_OPERATOR_STRING`: the tone mapping operator
 *   used when compressing from a surface with high dynamic range to another
 *   with lower dynamic range. Currently this supports "chrome", which uses
 *   the same tone mapping that Chrome uses for HDR content, the form "*=N",
 *   where N is a floating point scale factor applied in linear space, and
 *   "none", which disables tone mapping. This defaults to "chrome".
 *
 * \param surface the SDL_Surface structure to query.
 * \returns a valid property ID on success or 0 on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetSurfaceProperties(surface: PSDL_Surface): SDL_PropertiesID; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetSurfaceProperties';

const
  SDL_PROP_SURFACE_SDR_WHITE_POINT_FLOAT = 'SDL.surface.SDR_white_point';
  SDL_PROP_SURFACE_HDR_HEADROOM_FLOAT = 'SDL.surface.HDR_headroom';
  SDL_PROP_SURFACE_TONEMAP_OPERATOR_STRING = 'SDL.surface.tonemap';
  SDL_PROP_SURFACE_HOTSPOT_X_NUMBER = 'SDL.surface.hotspot.x';
  SDL_PROP_SURFACE_HOTSPOT_Y_NUMBER = 'SDL.surface.hotspot.y';


(**
 * Set the colorspace used by a surface.
 *
 * Setting the colorspace doesn't change the pixels, only how they are
 * interpreted in color operations.
 *
 * \param surface the SDL_Surface structure to update.
 * \param colorspace an SDL_Colorspace value describing the surface
 *                   colorspace.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetSurfaceColorspace
 *)
function SDL_SetSurfaceColorspace(surface: PSDL_Surface; colorspace: SDL_Colorspace): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetSurfaceColorspace';

(**
 * Get the colorspace used by a surface.
 *
 * The colorspace defaults to SDL_COLORSPACE_SRGB_LINEAR for floating point
 * formats, SDL_COLORSPACE_HDR10 for 10-bit formats, SDL_COLORSPACE_SRGB for
 * other RGB surfaces and SDL_COLORSPACE_BT709_FULL for YUV textures.
 *
 * \param surface the SDL_Surface structure to query.
 * \returns the colorspace used by the surface, or SDL_COLORSPACE_UNKNOWN if
 *          the surface is NULL.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetSurfaceColorspace
 *)
function SDL_GetSurfaceColorspace(surface: PSDL_Surface): SDL_Colorspace; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetSurfaceColorspace';

(**
 * Create a palette and associate it with a surface.
 *
 * This function creates a palette compatible with the provided surface. The
 * palette is then returned for you to modify, and the surface will
 * automatically use the new palette in future operations. You do not need to
 * destroy the returned palette, it will be freed when the reference count
 * reaches 0, usually when the surface is destroyed.
 *
 * Bitmap surfaces (with format SDL_PIXELFORMAT_INDEX1LSB or
 * SDL_PIXELFORMAT_INDEX1MSB) will have the palette initialized with 0 as
 * white and 1 as black. Other surfaces will get a palette initialized with
 * white in every entry.
 *
 * If this function is called for a surface that already has a palette, a new
 * palette will be created to replace it.
 *
 * \param surface the SDL_Surface structure to update.
 * \returns a new SDL_Palette structure on success or NULL on failure (e.g. if
 *          the surface didn't have an index format); call SDL_GetError() for
 *          more information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetPaletteColors
 *)
function SDL_CreateSurfacePalette(surface: PSDL_Surface): PSDL_Palette; cdecl;
  external LIB_SDL3 name _PU + 'SDL_CreateSurfacePalette';

(**
 * Set the palette used by a surface.
 *
 * A single palette can be shared with many surfaces.
 *
 * \param surface the SDL_Surface structure to update.
 * \param palette the SDL_Palette structure to use.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CreatePalette
 * \sa SDL_GetSurfacePalette
 *)
function SDL_SetSurfacePalette(surface: PSDL_Surface; palette: PSDL_Palette): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetSurfacePalette';

(**
 * Get the palette used by a surface.
 *
 * \param surface the SDL_Surface structure to query.
 * \returns a pointer to the palette used by the surface, or NULL if there is
 *          no palette used.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetSurfacePalette
 *)
function SDL_GetSurfacePalette(surface: PSDL_Surface): PSDL_Palette; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetSurfacePalette';

(**
 * Add an alternate version of a surface.
 *
 * This function adds an alternate version of this surface, usually used for
 * content with high DPI representations like cursors or icons. The size,
 * format, and content do not need to match the original surface, and these
 * alternate versions will not be updated when the original surface changes.
 *
 * This function adds a reference to the alternate version, so you should call
 * SDL_DestroySurface() on the image after this call.
 *
 * \param surface the SDL_Surface structure to update.
 * \param image a pointer to an alternate SDL_Surface to associate with this
 *              surface.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_RemoveSurfaceAlternateImages
 * \sa SDL_GetSurfaceImages
 * \sa SDL_SurfaceHasAlternateImages
 *)
function SDL_AddSurfaceAlternateImage(surface: PSDL_Surface; image: PSDL_Surface): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_AddSurfaceAlternateImage';

(**
 * Return whether a surface has alternate versions available.
 *
 * \param surface the SDL_Surface structure to query.
 * \returns true if alternate versions are available or false otherwise.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_AddSurfaceAlternateImage
 * \sa SDL_RemoveSurfaceAlternateImages
 * \sa SDL_GetSurfaceImages
 *)
function SDL_SurfaceHasAlternateImages(surface: PSDL_Surface): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SurfaceHasAlternateImages';

(**
 * Get an array including all versions of a surface.
 *
 * This returns all versions of a surface, with the surface being queried as
 * the first element in the returned array.
 *
 * Freeing the array of surfaces does not affect the surfaces in the array.
 * They are still referenced by the surface being queried and will be cleaned
 * up normally.
 *
 * \param surface the SDL_Surface structure to query.
 * \param count a pointer filled in with the number of surface pointers
 *              returned, may be NULL.
 * \returns a NULL terminated array of SDL_Surface pointers or NULL on
 *          failure; call SDL_GetError() for more information. This should be
 *          freed with SDL_free() when it is no longer needed.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_AddSurfaceAlternateImage
 * \sa SDL_RemoveSurfaceAlternateImages
 * \sa SDL_SurfaceHasAlternateImages
 *)
function SDL_GetSurfaceImages(surface: PSDL_Surface; count: PInteger): PPSDL_Surface; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetSurfaceImages';

(**
 * Remove all alternate versions of a surface.
 *
 * This function removes a reference from all the alternative versions,
 * destroying them if this is the last reference to them.
 *
 * \param surface the SDL_Surface structure to update.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_AddSurfaceAlternateImage
 * \sa SDL_GetSurfaceImages
 * \sa SDL_SurfaceHasAlternateImages
 *)
procedure SDL_RemoveSurfaceAlternateImages(surface: PSDL_Surface); cdecl;
  external LIB_SDL3 name _PU + 'SDL_RemoveSurfaceAlternateImages';

(**
 * Set up a surface for directly accessing the pixels.
 *
 * Between calls to SDL_LockSurface() / SDL_UnlockSurface(), you can write to
 * and read from `surface->pixels`, using the pixel format stored in
 * `surface->format`. Once you are done accessing the surface, you should use
 * SDL_UnlockSurface() to release it.
 *
 * Not all surfaces require locking. If `SDL_MUSTLOCK(surface)` evaluates to
 * 0, then you can read and write to the surface at any time, and the pixel
 * format of the surface will not change.
 *
 * \param surface the SDL_Surface structure to be locked.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_MUSTLOCK
 * \sa SDL_UnlockSurface
 *)
function SDL_LockSurface(surface: PSDL_Surface): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_LockSurface';

(**
 * Release a surface after directly accessing the pixels.
 *
 * \param surface the SDL_Surface structure to be unlocked.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_LockSurface
 *)
procedure SDL_UnlockSurface(surface: PSDL_Surface); cdecl;
  external LIB_SDL3 name _PU + 'SDL_UnlockSurface';

(**
 * Load a BMP image from a seekable SDL data stream.
 *
 * The new surface should be freed with SDL_DestroySurface(). Not doing so
 * will result in a memory leak.
 *
 * \param src the data stream for the surface.
 * \param closeio if true, calls SDL_CloseIO() on `src` before returning, even
 *                in the case of an error.
 * \returns a pointer to a new SDL_Surface structure or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_DestroySurface
 * \sa SDL_LoadBMP
 * \sa SDL_SaveBMP_IO
 *)
function SDL_LoadBMP_IO(src: SDL_IOStream; closeio: Boolean): PSDL_Surface; cdecl;
  external LIB_SDL3 name _PU + 'SDL_LoadBMP_IO';

(**
 * Load a BMP image from a file.
 *
 * The new surface should be freed with SDL_DestroySurface(). Not doing so
 * will result in a memory leak.
 *
 * \param file the BMP file to load.
 * \returns a pointer to a new SDL_Surface structure or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_DestroySurface
 * \sa SDL_LoadBMP_IO
 * \sa SDL_SaveBMP
 *)
function SDL_LoadBMP(const &file: PUTF8Char): PSDL_Surface; cdecl;
  external LIB_SDL3 name _PU + 'SDL_LoadBMP';

(**
 * Save a surface to a seekable SDL data stream in BMP format.
 *
 * Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the
 * BMP directly. Other RGB formats with 8-bit or higher get converted to a
 * 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit
 * surface before they are saved. YUV and paletted 1-bit and 4-bit formats are
 * not supported.
 *
 * \param surface the SDL_Surface structure containing the image to be saved.
 * \param dst a data stream to save to.
 * \param closeio if true, calls SDL_CloseIO() on `dst` before returning, even
 *                in the case of an error.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_LoadBMP_IO
 * \sa SDL_SaveBMP
 *)
function SDL_SaveBMP_IO(surface: PSDL_Surface; dst: SDL_IOStream; closeio: Boolean): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SaveBMP_IO';

(**
 * Save a surface to a file.
 *
 * Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the
 * BMP directly. Other RGB formats with 8-bit or higher get converted to a
 * 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit
 * surface before they are saved. YUV and paletted 1-bit and 4-bit formats are
 * not supported.
 *
 * \param surface the SDL_Surface structure containing the image to be saved.
 * \param file a file to save to.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_LoadBMP
 * \sa SDL_SaveBMP_IO
 *)
function SDL_SaveBMP(surface: PSDL_Surface; const &file: PUTF8Char): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SaveBMP';

(**
 * Set the RLE acceleration hint for a surface.
 *
 * If RLE is enabled, color key and alpha blending blits are much faster, but
 * the surface must be locked before directly accessing the pixels.
 *
 * \param surface the SDL_Surface structure to optimize.
 * \param enabled true to enable RLE acceleration, false to disable it.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_BlitSurface
 * \sa SDL_LockSurface
 * \sa SDL_UnlockSurface
 *)
function SDL_SetSurfaceRLE(surface: PSDL_Surface; enabled: Boolean): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetSurfaceRLE';

(**
 * Returns whether the surface is RLE enabled.
 *
 * It is safe to pass a NULL `surface` here; it will return false.
 *
 * \param surface the SDL_Surface structure to query.
 * \returns true if the surface is RLE enabled, false otherwise.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetSurfaceRLE
 *)
function SDL_SurfaceHasRLE(surface: PSDL_Surface): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SurfaceHasRLE';

(**
 * Set the color key (transparent pixel) in a surface.
 *
 * The color key defines a pixel value that will be treated as transparent in
 * a blit. For example, one can use this to specify that cyan pixels should be
 * considered transparent, and therefore not rendered.
 *
 * It is a pixel of the format used by the surface, as generated by
 * SDL_MapRGB().
 *
 * \param surface the SDL_Surface structure to update.
 * \param enabled true to enable color key, false to disable color key.
 * \param key the transparent pixel.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetSurfaceColorKey
 * \sa SDL_SetSurfaceRLE
 * \sa SDL_SurfaceHasColorKey
 *)
function SDL_SetSurfaceColorKey(surface: PSDL_Surface; enabled: Boolean; key: Uint32): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetSurfaceColorKey';

(**
 * Returns whether the surface has a color key.
 *
 * It is safe to pass a NULL `surface` here; it will return false.
 *
 * \param surface the SDL_Surface structure to query.
 * \returns true if the surface has a color key, false otherwise.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetSurfaceColorKey
 * \sa SDL_GetSurfaceColorKey
 *)
function SDL_SurfaceHasColorKey(surface: PSDL_Surface): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SurfaceHasColorKey';

(**
 * Get the color key (transparent pixel) for a surface.
 *
 * The color key is a pixel of the format used by the surface, as generated by
 * SDL_MapRGB().
 *
 * If the surface doesn't have color key enabled this function returns false.
 *
 * \param surface the SDL_Surface structure to query.
 * \param key a pointer filled in with the transparent pixel.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetSurfaceColorKey
 * \sa SDL_SurfaceHasColorKey
 *)
function SDL_GetSurfaceColorKey(surface: PSDL_Surface; key: PUint32): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetSurfaceColorKey';

(**
 * Set an additional color value multiplied into blit operations.
 *
 * When this surface is blitted, during the blit operation each source color
 * channel is modulated by the appropriate color value according to the
 * following formula:
 *
 * `srcC = srcC * (color / 255)`
 *
 * \param surface the SDL_Surface structure to update.
 * \param r the red color value multiplied into blit operations.
 * \param g the green color value multiplied into blit operations.
 * \param b the blue color value multiplied into blit operations.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetSurfaceColorMod
 * \sa SDL_SetSurfaceAlphaMod
 *)
function SDL_SetSurfaceColorMod(surface: PSDL_Surface; r: Uint8; g: Uint8; b: Uint8): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetSurfaceColorMod';

(**
 * Get the additional color value multiplied into blit operations.
 *
 * \param surface the SDL_Surface structure to query.
 * \param r a pointer filled in with the current red color value.
 * \param g a pointer filled in with the current green color value.
 * \param b a pointer filled in with the current blue color value.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetSurfaceAlphaMod
 * \sa SDL_SetSurfaceColorMod
 *)
function SDL_GetSurfaceColorMod(surface: PSDL_Surface; r: PUint8; g: PUint8; b: PUint8): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetSurfaceColorMod';

(**
 * Set an additional alpha value used in blit operations.
 *
 * When this surface is blitted, during the blit operation the source alpha
 * value is modulated by this alpha value according to the following formula:
 *
 * `srcA = srcA * (alpha / 255)`
 *
 * \param surface the SDL_Surface structure to update.
 * \param alpha the alpha value multiplied into blit operations.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetSurfaceAlphaMod
 * \sa SDL_SetSurfaceColorMod
 *)
function SDL_SetSurfaceAlphaMod(surface: PSDL_Surface; alpha: Uint8): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetSurfaceAlphaMod';

(**
 * Get the additional alpha value used in blit operations.
 *
 * \param surface the SDL_Surface structure to query.
 * \param alpha a pointer filled in with the current alpha value.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetSurfaceColorMod
 * \sa SDL_SetSurfaceAlphaMod
 *)
function SDL_GetSurfaceAlphaMod(surface: PSDL_Surface; alpha: PUint8): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetSurfaceAlphaMod';

(**
 * Set the blend mode used for blit operations.
 *
 * To copy a surface to another surface (or texture) without blending with the
 * existing data, the blendmode of the SOURCE surface should be set to
 * `SDL_BLENDMODE_NONE`.
 *
 * \param surface the SDL_Surface structure to update.
 * \param blendMode the SDL_BlendMode to use for blit blending.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetSurfaceBlendMode
 *)
function SDL_SetSurfaceBlendMode(surface: PSDL_Surface; blendMode: SDL_BlendMode): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetSurfaceBlendMode';

(**
 * Get the blend mode used for blit operations.
 *
 * \param surface the SDL_Surface structure to query.
 * \param blendMode a pointer filled in with the current SDL_BlendMode.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetSurfaceBlendMode
 *)
function SDL_GetSurfaceBlendMode(surface: PSDL_Surface; blendMode: PSDL_BlendMode): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetSurfaceBlendMode';

(**
 * Set the clipping rectangle for a surface.
 *
 * When `surface` is the destination of a blit, only the area within the clip
 * rectangle is drawn into.
 *
 * Note that blits are automatically clipped to the edges of the source and
 * destination surfaces.
 *
 * \param surface the SDL_Surface structure to be clipped.
 * \param rect the SDL_Rect structure representing the clipping rectangle, or
 *             NULL to disable clipping.
 * \returns true if the rectangle intersects the surface, otherwise false and
 *          blits will be completely clipped.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetSurfaceClipRect
 *)
function SDL_SetSurfaceClipRect(surface: PSDL_Surface; const rect: PSDL_Rect): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetSurfaceClipRect';

(**
 * Get the clipping rectangle for a surface.
 *
 * When `surface` is the destination of a blit, only the area within the clip
 * rectangle is drawn into.
 *
 * \param surface the SDL_Surface structure representing the surface to be
 *                clipped.
 * \param rect an SDL_Rect structure filled in with the clipping rectangle for
 *             the surface.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetSurfaceClipRect
 *)
function SDL_GetSurfaceClipRect(surface: PSDL_Surface; rect: PSDL_Rect): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetSurfaceClipRect';

(**
 * Flip a surface vertically or horizontally.
 *
 * \param surface the surface to flip.
 * \param flip the direction to flip.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_FlipSurface(surface: PSDL_Surface; flip: SDL_FlipMode): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_FlipSurface';

(**
 * Creates a new surface identical to the existing surface.
 *
 * If the original surface has alternate images, the new surface will have a
 * reference to them as well.
 *
 * The returned surface should be freed with SDL_DestroySurface().
 *
 * \param surface the surface to duplicate.
 * \returns a copy of the surface or NULL on failure; call SDL_GetError() for
 *          more information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_DestroySurface
 *)
function SDL_DuplicateSurface(surface: PSDL_Surface): PSDL_Surface; cdecl;
  external LIB_SDL3 name _PU + 'SDL_DuplicateSurface';

(**
 * Creates a new surface identical to the existing surface, scaled to the
 * desired size.
 *
 * The returned surface should be freed with SDL_DestroySurface().
 *
 * \param surface the surface to duplicate and scale.
 * \param width the width of the new surface.
 * \param height the height of the new surface.
 * \param scaleMode the SDL_ScaleMode to be used.
 * \returns a copy of the surface or NULL on failure; call SDL_GetError() for
 *          more information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_DestroySurface
 *)
function SDL_ScaleSurface(surface: PSDL_Surface; width: Integer; height: Integer; scaleMode: SDL_ScaleMode): PSDL_Surface; cdecl;
  external LIB_SDL3 name _PU + 'SDL_ScaleSurface';

(**
 * Copy an existing surface to a new surface of the specified format.
 *
 * This function is used to optimize images for faster *repeat* blitting. This
 * is accomplished by converting the original and storing the result as a new
 * surface. The new, optimized surface can then be used as the source for
 * future blits, making them faster.
 *
 * If you are converting to an indexed surface and want to map colors to a
 * palette, you can use SDL_ConvertSurfaceAndColorspace() instead.
 *
 * If the original surface has alternate images, the new surface will have a
 * reference to them as well.
 *
 * \param surface the existing SDL_Surface structure to convert.
 * \param format the new pixel format.
 * \returns the new SDL_Surface structure that is created or NULL on failure;
 *          call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_ConvertSurfaceAndColorspace
 * \sa SDL_DestroySurface
 *)
function SDL_ConvertSurface(surface: PSDL_Surface; format: SDL_PixelFormat): PSDL_Surface; cdecl;
  external LIB_SDL3 name _PU + 'SDL_ConvertSurface';

(**
 * Copy an existing surface to a new surface of the specified format and
 * colorspace.
 *
 * This function converts an existing surface to a new format and colorspace
 * and returns the new surface. This will perform any pixel format and
 * colorspace conversion needed.
 *
 * If the original surface has alternate images, the new surface will have a
 * reference to them as well.
 *
 * \param surface the existing SDL_Surface structure to convert.
 * \param format the new pixel format.
 * \param palette an optional palette to use for indexed formats, may be NULL.
 * \param colorspace the new colorspace.
 * \param props an SDL_PropertiesID with additional color properties, or 0.
 * \returns the new SDL_Surface structure that is created or NULL on failure;
 *          call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_ConvertSurface
 * \sa SDL_DestroySurface
 *)
function SDL_ConvertSurfaceAndColorspace(surface: PSDL_Surface; format: SDL_PixelFormat; palette: PSDL_Palette; colorspace: SDL_Colorspace; props: SDL_PropertiesID): PSDL_Surface; cdecl;
  external LIB_SDL3 name _PU + 'SDL_ConvertSurfaceAndColorspace';

(**
 * Copy a block of pixels of one format to another format.
 *
 * \param width the width of the block to copy, in pixels.
 * \param height the height of the block to copy, in pixels.
 * \param src_format an SDL_PixelFormat value of the `src` pixels format.
 * \param src a pointer to the source pixels.
 * \param src_pitch the pitch of the source pixels, in bytes.
 * \param dst_format an SDL_PixelFormat value of the `dst` pixels format.
 * \param dst a pointer to be filled in with new pixel data.
 * \param dst_pitch the pitch of the destination pixels, in bytes.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_ConvertPixelsAndColorspace
 *)
function SDL_ConvertPixels(width: Integer; height: Integer; src_format: SDL_PixelFormat; const src: Pointer; src_pitch: Integer; dst_format: SDL_PixelFormat; dst: Pointer; dst_pitch: Integer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_ConvertPixels';

(**
 * Copy a block of pixels of one format and colorspace to another format and
 * colorspace.
 *
 * \param width the width of the block to copy, in pixels.
 * \param height the height of the block to copy, in pixels.
 * \param src_format an SDL_PixelFormat value of the `src` pixels format.
 * \param src_colorspace an SDL_Colorspace value describing the colorspace of
 *                       the `src` pixels.
 * \param src_properties an SDL_PropertiesID with additional source color
 *                       properties, or 0.
 * \param src a pointer to the source pixels.
 * \param src_pitch the pitch of the source pixels, in bytes.
 * \param dst_format an SDL_PixelFormat value of the `dst` pixels format.
 * \param dst_colorspace an SDL_Colorspace value describing the colorspace of
 *                       the `dst` pixels.
 * \param dst_properties an SDL_PropertiesID with additional destination color
 *                       properties, or 0.
 * \param dst a pointer to be filled in with new pixel data.
 * \param dst_pitch the pitch of the destination pixels, in bytes.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_ConvertPixels
 *)
function SDL_ConvertPixelsAndColorspace(width: Integer; height: Integer; src_format: SDL_PixelFormat; src_colorspace: SDL_Colorspace; src_properties: SDL_PropertiesID; const src: Pointer; src_pitch: Integer; dst_format: SDL_PixelFormat; dst_colorspace: SDL_Colorspace; dst_properties: SDL_PropertiesID; dst: Pointer; dst_pitch: Integer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_ConvertPixelsAndColorspace';

(**
 * Premultiply the alpha on a block of pixels.
 *
 * This is safe to use with src == dst, but not for other overlapping areas.
 *
 * \param width the width of the block to convert, in pixels.
 * \param height the height of the block to convert, in pixels.
 * \param src_format an SDL_PixelFormat value of the `src` pixels format.
 * \param src a pointer to the source pixels.
 * \param src_pitch the pitch of the source pixels, in bytes.
 * \param dst_format an SDL_PixelFormat value of the `dst` pixels format.
 * \param dst a pointer to be filled in with premultiplied pixel data.
 * \param dst_pitch the pitch of the destination pixels, in bytes.
 * \param linear true to convert from sRGB to linear space for the alpha
 *               multiplication, false to do multiplication in sRGB space.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_PremultiplyAlpha(width: Integer; height: Integer; src_format: SDL_PixelFormat; const src: Pointer; src_pitch: Integer; dst_format: SDL_PixelFormat; dst: Pointer; dst_pitch: Integer; linear: Boolean): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_PremultiplyAlpha';

(**
 * Premultiply the alpha in a surface.
 *
 * This is safe to use with src == dst, but not for other overlapping areas.
 *
 * \param surface the surface to modify.
 * \param linear true to convert from sRGB to linear space for the alpha
 *               multiplication, false to do multiplication in sRGB space.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_PremultiplySurfaceAlpha(surface: PSDL_Surface; linear: Boolean): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_PremultiplySurfaceAlpha';

(**
 * Clear a surface with a specific color, with floating point precision.
 *
 * This function handles all surface formats, and ignores any clip rectangle.
 *
 * If the surface is YUV, the color is assumed to be in the sRGB colorspace,
 * otherwise the color is assumed to be in the colorspace of the suface.
 *
 * \param surface the SDL_Surface to clear.
 * \param r the red component of the pixel, normally in the range 0-1.
 * \param g the green component of the pixel, normally in the range 0-1.
 * \param b the blue component of the pixel, normally in the range 0-1.
 * \param a the alpha component of the pixel, normally in the range 0-1.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_ClearSurface(surface: PSDL_Surface; r: Single; g: Single; b: Single; a: Single): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_ClearSurface';

(**
 * Perform a fast fill of a rectangle with a specific color.
 *
 * `color` should be a pixel of the format used by the surface, and can be
 * generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an
 * alpha component then the destination is simply filled with that alpha
 * information, no blending takes place.
 *
 * If there is a clip rectangle set on the destination (set via
 * SDL_SetSurfaceClipRect()), then this function will fill based on the
 * intersection of the clip rectangle and `rect`.
 *
 * \param dst the SDL_Surface structure that is the drawing target.
 * \param rect the SDL_Rect structure representing the rectangle to fill, or
 *             NULL to fill the entire surface.
 * \param color the color to fill with.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_FillSurfaceRects
 *)
function SDL_FillSurfaceRect(dst: PSDL_Surface; const rect: PSDL_Rect; color: Uint32): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_FillSurfaceRect';

(**
 * Perform a fast fill of a set of rectangles with a specific color.
 *
 * `color` should be a pixel of the format used by the surface, and can be
 * generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an
 * alpha component then the destination is simply filled with that alpha
 * information, no blending takes place.
 *
 * If there is a clip rectangle set on the destination (set via
 * SDL_SetSurfaceClipRect()), then this function will fill based on the
 * intersection of the clip rectangle and `rect`.
 *
 * \param dst the SDL_Surface structure that is the drawing target.
 * \param rects an array of SDL_Rects representing the rectangles to fill.
 * \param count the number of rectangles in the array.
 * \param color the color to fill with.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_FillSurfaceRect
 *)
function SDL_FillSurfaceRects(dst: PSDL_Surface; const rects: PSDL_Rect; count: Integer; color: Uint32): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_FillSurfaceRects';

(**
 * Performs a fast blit from the source surface to the destination surface
 * with clipping.
 *
 * If either `srcrect` or `dstrect` are NULL, the entire surface (`src` or
 * `dst`) is copied while ensuring clipping to `dst->clip_rect`.
 *
 * The final blit rectangles are saved in `srcrect` and `dstrect` after all
 * clipping is performed.
 *
 * The blit function should not be called on a locked surface.
 *
 * The blit semantics for surfaces with and without blending and colorkey are
 * defined as follows:
 *
 * ```
 *    RGBA->RGB:
 *      Source surface blend mode set to SDL_BLENDMODE_BLEND:
 *       alpha-blend (using the source alpha-channel and per-surface alpha)
 *       SDL_SRCCOLORKEY ignored.
 *     Source surface blend mode set to SDL_BLENDMODE_NONE:
 *       copy RGB.
 *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
 *       RGB values of the source color key, ignoring alpha in the
 *       comparison.
 *
 *   RGB->RGBA:
 *     Source surface blend mode set to SDL_BLENDMODE_BLEND:
 *       alpha-blend (using the source per-surface alpha)
 *     Source surface blend mode set to SDL_BLENDMODE_NONE:
 *       copy RGB, set destination alpha to source per-surface alpha value.
 *     both:
 *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
 *       source color key.
 *
 *   RGBA->RGBA:
 *     Source surface blend mode set to SDL_BLENDMODE_BLEND:
 *       alpha-blend (using the source alpha-channel and per-surface alpha)
 *       SDL_SRCCOLORKEY ignored.
 *     Source surface blend mode set to SDL_BLENDMODE_NONE:
 *       copy all of RGBA to the destination.
 *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
 *       RGB values of the source color key, ignoring alpha in the
 *       comparison.
 *
 *   RGB->RGB:
 *     Source surface blend mode set to SDL_BLENDMODE_BLEND:
 *       alpha-blend (using the source per-surface alpha)
 *     Source surface blend mode set to SDL_BLENDMODE_NONE:
 *       copy RGB.
 *     both:
 *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
 *       source color key.
 * ```
 *
 * \param src the SDL_Surface structure to be copied from.
 * \param srcrect the SDL_Rect structure representing the rectangle to be
 *                copied, or NULL to copy the entire surface.
 * \param dst the SDL_Surface structure that is the blit target.
 * \param dstrect the SDL_Rect structure representing the x and y position in
 *                the destination surface, or NULL for (0,0). The width and
 *                height are ignored, and are copied from `srcrect`. If you
 *                want a specific width and height, you should use
 *                SDL_BlitSurfaceScaled().
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety The same destination surface should not be used from two
 *               threads at once. It is safe to use the same source surface
 *               from multiple threads.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_BlitSurfaceScaled
 *)
function SDL_BlitSurface(src: PSDL_Surface; const srcrect: PSDL_Rect; dst: PSDL_Surface; const dstrect: PSDL_Rect): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_BlitSurface';

(**
 * Perform low-level surface blitting only.
 *
 * This is a semi-private blit function and it performs low-level surface
 * blitting, assuming the input rectangles have already been clipped.
 *
 * \param src the SDL_Surface structure to be copied from.
 * \param srcrect the SDL_Rect structure representing the rectangle to be
 *                copied, may not be NULL.
 * \param dst the SDL_Surface structure that is the blit target.
 * \param dstrect the SDL_Rect structure representing the target rectangle in
 *                the destination surface, may not be NULL.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety The same destination surface should not be used from two
 *               threads at once. It is safe to use the same source surface
 *               from multiple threads.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_BlitSurface
 *)
function SDL_BlitSurfaceUnchecked(src: PSDL_Surface; const srcrect: PSDL_Rect; dst: PSDL_Surface; const dstrect: PSDL_Rect): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_BlitSurfaceUnchecked';

(**
 * Perform a scaled blit to a destination surface, which may be of a different
 * format.
 *
 * \param src the SDL_Surface structure to be copied from.
 * \param srcrect the SDL_Rect structure representing the rectangle to be
 *                copied, or NULL to copy the entire surface.
 * \param dst the SDL_Surface structure that is the blit target.
 * \param dstrect the SDL_Rect structure representing the target rectangle in
 *                the destination surface, or NULL to fill the entire
 *                destination surface.
 * \param scaleMode the SDL_ScaleMode to be used.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety The same destination surface should not be used from two
 *               threads at once. It is safe to use the same source surface
 *               from multiple threads.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_BlitSurface
 *)
function SDL_BlitSurfaceScaled(src: PSDL_Surface; const srcrect: PSDL_Rect; dst: PSDL_Surface; const dstrect: PSDL_Rect; scaleMode: SDL_ScaleMode): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_BlitSurfaceScaled';

(**
 * Perform low-level surface scaled blitting only.
 *
 * This is a semi-private function and it performs low-level surface blitting,
 * assuming the input rectangles have already been clipped.
 *
 * \param src the SDL_Surface structure to be copied from.
 * \param srcrect the SDL_Rect structure representing the rectangle to be
 *                copied, may not be NULL.
 * \param dst the SDL_Surface structure that is the blit target.
 * \param dstrect the SDL_Rect structure representing the target rectangle in
 *                the destination surface, may not be NULL.
 * \param scaleMode the SDL_ScaleMode to be used.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety The same destination surface should not be used from two
 *               threads at once. It is safe to use the same source surface
 *               from multiple threads.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_BlitSurfaceScaled
 *)
function SDL_BlitSurfaceUncheckedScaled(src: PSDL_Surface; const srcrect: PSDL_Rect; dst: PSDL_Surface; const dstrect: PSDL_Rect; scaleMode: SDL_ScaleMode): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_BlitSurfaceUncheckedScaled';

(**
 * Perform a stretched pixel copy from one surface to another.
 *
 * \param src the SDL_Surface structure to be copied from.
 * \param srcrect the SDL_Rect structure representing the rectangle to be
 *                copied, may not be NULL.
 * \param dst the SDL_Surface structure that is the blit target.
 * \param dstrect the SDL_Rect structure representing the target rectangle in
 *                the destination surface, may not be NULL.
 * \param scaleMode the SDL_ScaleMode to be used.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety The same destination surface should not be used from two
 *               threads at once. It is safe to use the same source surface
 *               from multiple threads.
 *
 * \since This function is available since SDL 3.4.0.
 *
 * \sa SDL_BlitSurfaceScaled
 *)
function SDL_StretchSurface(src: PSDL_Surface; const srcrect: PSDL_Rect; dst: PSDL_Surface; const dstrect: PSDL_Rect; scaleMode: SDL_ScaleMode): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_StretchSurface';

(**
 * Perform a tiled blit to a destination surface, which may be of a different
 * format.
 *
 * The pixels in `srcrect` will be repeated as many times as needed to
 * completely fill `dstrect`.
 *
 * \param src the SDL_Surface structure to be copied from.
 * \param srcrect the SDL_Rect structure representing the rectangle to be
 *                copied, or NULL to copy the entire surface.
 * \param dst the SDL_Surface structure that is the blit target.
 * \param dstrect the SDL_Rect structure representing the target rectangle in
 *                the destination surface, or NULL to fill the entire surface.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety The same destination surface should not be used from two
 *               threads at once. It is safe to use the same source surface
 *               from multiple threads.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_BlitSurface
 *)
function SDL_BlitSurfaceTiled(src: PSDL_Surface; const srcrect: PSDL_Rect; dst: PSDL_Surface; const dstrect: PSDL_Rect): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_BlitSurfaceTiled';

(**
 * Perform a scaled and tiled blit to a destination surface, which may be of a
 * different format.
 *
 * The pixels in `srcrect` will be scaled and repeated as many times as needed
 * to completely fill `dstrect`.
 *
 * \param src the SDL_Surface structure to be copied from.
 * \param srcrect the SDL_Rect structure representing the rectangle to be
 *                copied, or NULL to copy the entire surface.
 * \param scale the scale used to transform srcrect into the destination
 *              rectangle, e.g. a 32x32 texture with a scale of 2 would fill
 *              64x64 tiles.
 * \param scaleMode scale algorithm to be used.
 * \param dst the SDL_Surface structure that is the blit target.
 * \param dstrect the SDL_Rect structure representing the target rectangle in
 *                the destination surface, or NULL to fill the entire surface.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety The same destination surface should not be used from two
 *               threads at once. It is safe to use the same source surface
 *               from multiple threads.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_BlitSurface
 *)
function SDL_BlitSurfaceTiledWithScale(src: PSDL_Surface; const srcrect: PSDL_Rect; scale: Single; scaleMode: SDL_ScaleMode; dst: PSDL_Surface; const dstrect: PSDL_Rect): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_BlitSurfaceTiledWithScale';

(**
 * Perform a scaled blit using the 9-grid algorithm to a destination surface,
 * which may be of a different format.
 *
 * The pixels in the source surface are split into a 3x3 grid, using the
 * different corner sizes for each corner, and the sides and center making up
 * the remaining pixels. The corners are then scaled using `scale` and fit
 * into the corners of the destination rectangle. The sides and center are
 * then stretched into place to cover the remaining destination rectangle.
 *
 * \param src the SDL_Surface structure to be copied from.
 * \param srcrect the SDL_Rect structure representing the rectangle to be used
 *                for the 9-grid, or NULL to use the entire surface.
 * \param left_width the width, in pixels, of the left corners in `srcrect`.
 * \param right_width the width, in pixels, of the right corners in `srcrect`.
 * \param top_height the height, in pixels, of the top corners in `srcrect`.
 * \param bottom_height the height, in pixels, of the bottom corners in
 *                      `srcrect`.
 * \param scale the scale used to transform the corner of `srcrect` into the
 *              corner of `dstrect`, or 0.0f for an unscaled blit.
 * \param scaleMode scale algorithm to be used.
 * \param dst the SDL_Surface structure that is the blit target.
 * \param dstrect the SDL_Rect structure representing the target rectangle in
 *                the destination surface, or NULL to fill the entire surface.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety The same destination surface should not be used from two
 *               threads at once. It is safe to use the same source surface
 *               from multiple threads.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_BlitSurface
 *)
function SDL_BlitSurface9Grid(src: PSDL_Surface; const srcrect: PSDL_Rect; left_width: Integer; right_width: Integer; top_height: Integer; bottom_height: Integer; scale: Single; scaleMode: SDL_ScaleMode; dst: PSDL_Surface; const dstrect: PSDL_Rect): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_BlitSurface9Grid';

(**
 * Map an RGB triple to an opaque pixel value for a surface.
 *
 * This function maps the RGB color value to the specified pixel format and
 * returns the pixel value best approximating the given RGB color value for
 * the given pixel format.
 *
 * If the surface has a palette, the index of the closest matching color in
 * the palette will be returned.
 *
 * If the surface pixel format has an alpha component it will be returned as
 * all 1 bits (fully opaque).
 *
 * If the pixel format bpp (color depth) is less than 32-bpp then the unused
 * upper bits of the return value can safely be ignored (e.g., with a 16-bpp
 * format the return value can be assigned to a Uint16, and similarly a Uint8
 * for an 8-bpp format).
 *
 * \param surface the surface to use for the pixel format and palette.
 * \param r the red component of the pixel in the range 0-255.
 * \param g the green component of the pixel in the range 0-255.
 * \param b the blue component of the pixel in the range 0-255.
 * \returns a pixel value.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_MapSurfaceRGBA
 *)
function SDL_MapSurfaceRGB(surface: PSDL_Surface; r: Uint8; g: Uint8; b: Uint8): Uint32; cdecl;
  external LIB_SDL3 name _PU + 'SDL_MapSurfaceRGB';

(**
 * Map an RGBA quadruple to a pixel value for a surface.
 *
 * This function maps the RGBA color value to the specified pixel format and
 * returns the pixel value best approximating the given RGBA color value for
 * the given pixel format.
 *
 * If the surface pixel format has no alpha component the alpha value will be
 * ignored (as it will be in formats with a palette).
 *
 * If the surface has a palette, the index of the closest matching color in
 * the palette will be returned.
 *
 * If the pixel format bpp (color depth) is less than 32-bpp then the unused
 * upper bits of the return value can safely be ignored (e.g., with a 16-bpp
 * format the return value can be assigned to a Uint16, and similarly a Uint8
 * for an 8-bpp format).
 *
 * \param surface the surface to use for the pixel format and palette.
 * \param r the red component of the pixel in the range 0-255.
 * \param g the green component of the pixel in the range 0-255.
 * \param b the blue component of the pixel in the range 0-255.
 * \param a the alpha component of the pixel in the range 0-255.
 * \returns a pixel value.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_MapSurfaceRGB
 *)
function SDL_MapSurfaceRGBA(surface: PSDL_Surface; r: Uint8; g: Uint8; b: Uint8; a: Uint8): Uint32; cdecl;
  external LIB_SDL3 name _PU + 'SDL_MapSurfaceRGBA';

(**
 * Retrieves a single pixel from a surface.
 *
 * This function prioritizes correctness over speed: it is suitable for unit
 * tests, but is not intended for use in a game engine.
 *
 * Like SDL_GetRGBA, this uses the entire 0..255 range when converting color
 * components from pixel formats with less than 8 bits per RGB component.
 *
 * \param surface the surface to read.
 * \param x the horizontal coordinate, 0 <= x < width.
 * \param y the vertical coordinate, 0 <= y < height.
 * \param r a pointer filled in with the red channel, 0-255, or NULL to ignore
 *          this channel.
 * \param g a pointer filled in with the green channel, 0-255, or NULL to
 *          ignore this channel.
 * \param b a pointer filled in with the blue channel, 0-255, or NULL to
 *          ignore this channel.
 * \param a a pointer filled in with the alpha channel, 0-255, or NULL to
 *          ignore this channel.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_ReadSurfacePixel(surface: PSDL_Surface; x: Integer; y: Integer; r: PUint8; g: PUint8; b: PUint8; a: PUint8): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_ReadSurfacePixel';

(**
 * Retrieves a single pixel from a surface.
 *
 * This function prioritizes correctness over speed: it is suitable for unit
 * tests, but is not intended for use in a game engine.
 *
 * \param surface the surface to read.
 * \param x the horizontal coordinate, 0 <= x < width.
 * \param y the vertical coordinate, 0 <= y < height.
 * \param r a pointer filled in with the red channel, normally in the range
 *          0-1, or NULL to ignore this channel.
 * \param g a pointer filled in with the green channel, normally in the range
 *          0-1, or NULL to ignore this channel.
 * \param b a pointer filled in with the blue channel, normally in the range
 *          0-1, or NULL to ignore this channel.
 * \param a a pointer filled in with the alpha channel, normally in the range
 *          0-1, or NULL to ignore this channel.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_ReadSurfacePixelFloat(surface: PSDL_Surface; x: Integer; y: Integer; r: PSingle; g: PSingle; b: PSingle; a: PSingle): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_ReadSurfacePixelFloat';

(**
 * Writes a single pixel to a surface.
 *
 * This function prioritizes correctness over speed: it is suitable for unit
 * tests, but is not intended for use in a game engine.
 *
 * Like SDL_MapRGBA, this uses the entire 0..255 range when converting color
 * components from pixel formats with less than 8 bits per RGB component.
 *
 * \param surface the surface to write.
 * \param x the horizontal coordinate, 0 <= x < width.
 * \param y the vertical coordinate, 0 <= y < height.
 * \param r the red channel value, 0-255.
 * \param g the green channel value, 0-255.
 * \param b the blue channel value, 0-255.
 * \param a the alpha channel value, 0-255.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_WriteSurfacePixel(surface: PSDL_Surface; x: Integer; y: Integer; r: Uint8; g: Uint8; b: Uint8; a: Uint8): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_WriteSurfacePixel';

(**
 * Writes a single pixel to a surface.
 *
 * This function prioritizes correctness over speed: it is suitable for unit
 * tests, but is not intended for use in a game engine.
 *
 * \param surface the surface to write.
 * \param x the horizontal coordinate, 0 <= x < width.
 * \param y the vertical coordinate, 0 <= y < height.
 * \param r the red channel value, normally in the range 0-1.
 * \param g the green channel value, normally in the range 0-1.
 * \param b the blue channel value, normally in the range 0-1.
 * \param a the alpha channel value, normally in the range 0-1.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_WriteSurfacePixelFloat(surface: PSDL_Surface; x: Integer; y: Integer; r: Single; g: Single; b: Single; a: Single): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_WriteSurfacePixelFloat';
{$ENDREGION 'SDL_surface.h'}

{$REGION 'SDL_camera.h'}
(**
 * # CategoryCamera
 *
 * Video capture for the SDL library.
 *
 * This API lets apps read input from video sources, like webcams. Camera
 * devices can be enumerated, queried, and opened. Once opened, it will
 * provide SDL_Surface objects as new frames of video come in. These surfaces
 * can be uploaded to an SDL_Texture or processed as pixels in memory.
 *
 * Several platforms will alert the user if an app tries to access a camera,
 * and some will present a UI asking the user if your application should be
 * allowed to obtain images at all, which they can deny. A successfully opened
 * camera will not provide images until permission is granted. Applications,
 * after opening a camera device, can see if they were granted access by
 * either polling with the SDL_GetCameraPermissionState() function, or waiting
 * for an SDL_EVENT_CAMERA_DEVICE_APPROVED or SDL_EVENT_CAMERA_DEVICE_DENIED
 * event. Platforms that don't have any user approval process will report
 * approval immediately.
 *
 * Note that SDL cameras only provide video as individual frames; they will
 * not provide full-motion video encoded in a movie file format, although an
 * app is free to encode the acquired frames into any format it likes. It also
 * does not provide audio from the camera hardware through this API; not only
 * do many webcams not have microphones at all, many people--from streamers to
 * people on Zoom calls--will want to use a separate microphone regardless of
 * the camera. In any case, recorded audio will be available through SDL's
 * audio API no matter what hardware provides the microphone.
 *
 * ## Camera gotchas
 *
 * Consumer-level camera hardware tends to take a little while to warm up,
 * once the device has been opened. Generally most camera apps have some sort
 * of UI to take a picture (a button to snap a pic while a preview is showing,
 * some sort of multi-second countdown for the user to pose, like a photo
 * booth), which puts control in the users' hands, or they are intended to
 * stay on for long times (Pokemon Go, etc).
 *
 * It's not uncommon that a newly-opened camera will provide a couple of
 * completely black frames, maybe followed by some under-exposed images. If
 * taking a single frame automatically, or recording video from a camera's
 * input without the user initiating it from a preview, it could be wise to
 * drop the first several frames (if not the first several _seconds_ worth of
 * frames!) before using images from a camera.
 *)

type
  (**
   * This is a unique ID for a camera device for the time it is connected to the
   * system, and is never reused for the lifetime of the application.
   *
   * If the device is disconnected and reconnected, it will get a new ID.
   *
   * The value 0 is an invalid ID.
   *
   * \since This datatype is available since SDL 3.2.0.
   *
   * \sa SDL_GetCameras
   *)
  SDL_CameraID = Uint32;
  PSDL_CameraID = ^SDL_CameraID;
  SDL_Camera = THandle;

  (**
   * The details of an output format for a camera device.
   *
   * Cameras often support multiple formats; each one will be encapsulated in
   * this struct.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_GetCameraSupportedFormats
   * \sa SDL_GetCameraFormat
   *)
  SDL_CameraSpec = record
    (** Frame format *)
    format: SDL_PixelFormat;
    (** Frame colorspace *)
    colorspace: SDL_Colorspace;
    (** Frame width *)
    width: Integer;
    (** Frame height *)
    height: Integer;
    (** Frame rate numerator ((num / denom) == FPS, (denom / num) == duration in seconds) *)
    framerate_numerator: Integer;
    (** Frame rate demoninator ((num / denom) == FPS, (denom / num) == duration in seconds) *)
    framerate_denominator: Integer;
  end;
  PSDL_CameraSpec = ^SDL_CameraSpec;
  PPSDL_CameraSpec = ^PSDL_CameraSpec;

(**
 * The position of camera in relation to system device.
 *
 * \since This enum is available since SDL 3.2.0.
 *
 * \sa SDL_GetCameraPosition
 *)
type
  SDL_CameraPosition = Integer;

const
  SDL_CAMERA_POSITION_UNKNOWN = 0;
  SDL_CAMERA_POSITION_FRONT_FACING = 1;
  SDL_CAMERA_POSITION_BACK_FACING = 2;

(**
 * Use this function to get the number of built-in camera drivers.
 *
 * This function returns a hardcoded number. This never returns a negative
 * value; if there are no drivers compiled into this build of SDL, this
 * function returns zero. The presence of a driver in this list does not mean
 * it will function, it just means SDL is capable of interacting with that
 * interface. For example, a build of SDL might have v4l2 support, but if
 * there's no kernel support available, SDL's v4l2 driver would fail if used.
 *
 * By default, SDL tries all drivers, in its preferred order, until one is
 * found to be usable.
 *
 * \returns the number of built-in camera drivers.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetCameraDriver
 *)
function SDL_GetNumCameraDrivers(): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetNumCameraDrivers';

(**
 * Use this function to get the name of a built in camera driver.
 *
 * The list of camera drivers is given in the order that they are normally
 * initialized by default; the drivers that seem more reasonable to choose
 * first (as far as the SDL developers believe) are earlier in the list.
 *
 * The names of drivers are all simple, low-ASCII identifiers, like "v4l2",
 * "coremedia" or "android". These never have Unicode characters, and are not
 * meant to be proper names.
 *
 * \param index the index of the camera driver; the value ranges from 0 to
 *              SDL_GetNumCameraDrivers() - 1.
 * \returns the name of the camera driver at the requested index, or NULL if
 *          an invalid index was specified.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetNumCameraDrivers
 *)
function SDL_GetCameraDriver(index: Integer): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetCameraDriver';

(**
 * Get the name of the current camera driver.
 *
 * The names of drivers are all simple, low-ASCII identifiers, like "v4l2",
 * "coremedia" or "android". These never have Unicode characters, and are not
 * meant to be proper names.
 *
 * \returns the name of the current camera driver or NULL if no driver has
 *          been initialized.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetCurrentCameraDriver(): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetCurrentCameraDriver';

(**
 * Get a list of currently connected camera devices.
 *
 * \param count a pointer filled in with the number of cameras returned, may
 *              be NULL.
 * \returns a 0 terminated array of camera instance IDs or NULL on failure;
 *          call SDL_GetError() for more information. This should be freed
 *          with SDL_free() when it is no longer needed.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_OpenCamera
 *)
function SDL_GetCameras(count: PInteger): PSDL_CameraID; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetCameras';

(**
 * Get the list of native formats/sizes a camera supports.
 *
 * This returns a list of all formats and frame sizes that a specific camera
 * can offer. This is useful if your app can accept a variety of image formats
 * and sizes and so want to find the optimal spec that doesn't require
 * conversion.
 *
 * This function isn't strictly required; if you call SDL_OpenCamera with a
 * NULL spec, SDL will choose a native format for you, and if you instead
 * specify a desired format, it will transparently convert to the requested
 * format on your behalf.
 *
 * If `count` is not NULL, it will be filled with the number of elements in
 * the returned array.
 *
 * Note that it's legal for a camera to supply an empty list. This is what
 * will happen on Emscripten builds, since that platform won't tell _anything_
 * about available cameras until you've opened one, and won't even tell if
 * there _is_ a camera until the user has given you permission to check
 * through a scary warning popup.
 *
 * \param instance_id the camera device instance ID.
 * \param count a pointer filled in with the number of elements in the list,
 *              may be NULL.
 * \returns a NULL terminated array of pointers to SDL_CameraSpec or NULL on
 *          failure; call SDL_GetError() for more information. This is a
 *          single allocation that should be freed with SDL_free() when it is
 *          no longer needed.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetCameras
 * \sa SDL_OpenCamera
 *)
function SDL_GetCameraSupportedFormats(instance_id: SDL_CameraID; count: PInteger): PPSDL_CameraSpec; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetCameraSupportedFormats';

(**
 * Get the human-readable device name for a camera.
 *
 * \param instance_id the camera device instance ID.
 * \returns a human-readable device name or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetCameras
 *)
function SDL_GetCameraName(instance_id: SDL_CameraID): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetCameraName';

(**
 * Get the position of the camera in relation to the system.
 *
 * Most platforms will report UNKNOWN, but mobile devices, like phones, can
 * often make a distinction between cameras on the front of the device (that
 * points towards the user, for taking "selfies") and cameras on the back (for
 * filming in the direction the user is facing).
 *
 * \param instance_id the camera device instance ID.
 * \returns the position of the camera on the system hardware.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetCameras
 *)
function SDL_GetCameraPosition(instance_id: SDL_CameraID): SDL_CameraPosition; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetCameraPosition';

(**
 * Open a video recording device (a "camera").
 *
 * You can open the device with any reasonable spec, and if the hardware can't
 * directly support it, it will convert data seamlessly to the requested
 * format. This might incur overhead, including scaling of image data.
 *
 * If you would rather accept whatever format the device offers, you can pass
 * a NULL spec here and it will choose one for you (and you can use
 * SDL_Surface's conversion/scaling functions directly if necessary).
 *
 * You can call SDL_GetCameraFormat() to get the actual data format if passing
 * a NULL spec here. You can see the exact specs a device can support without
 * conversion with SDL_GetCameraSupportedFormats().
 *
 * SDL will not attempt to emulate framerate; it will try to set the hardware
 * to the rate closest to the requested speed, but it won't attempt to limit
 * or duplicate frames artificially; call SDL_GetCameraFormat() to see the
 * actual framerate of the opened the device, and check your timestamps if
 * this is crucial to your app!
 *
 * Note that the camera is not usable until the user approves its use! On some
 * platforms, the operating system will prompt the user to permit access to
 * the camera, and they can choose Yes or No at that point. Until they do, the
 * camera will not be usable. The app should either wait for an
 * SDL_EVENT_CAMERA_DEVICE_APPROVED (or SDL_EVENT_CAMERA_DEVICE_DENIED) event,
 * or poll SDL_GetCameraPermissionState() occasionally until it returns
 * non-zero. On platforms that don't require explicit user approval (and
 * perhaps in places where the user previously permitted access), the approval
 * event might come immediately, but it might come seconds, minutes, or hours
 * later!
 *
 * \param instance_id the camera device instance ID.
 * \param spec the desired format for data the device will provide. Can be
 *             NULL.
 * \returns an SDL_Camera object or NULL on failure; call SDL_GetError() for
 *          more information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetCameras
 * \sa SDL_GetCameraFormat
 *)
function SDL_OpenCamera(instance_id: SDL_CameraID; const spec: PSDL_CameraSpec): SDL_Camera; cdecl;
  external LIB_SDL3 name _PU + 'SDL_OpenCamera';

(**
 * Query if camera access has been approved by the user.
 *
 * Cameras will not function between when the device is opened by the app and
 * when the user permits access to the hardware. On some platforms, this
 * presents as a popup dialog where the user has to explicitly approve access;
 * on others the approval might be implicit and not alert the user at all.
 *
 * This function can be used to check the status of that approval. It will
 * return 0 if still waiting for user response, 1 if the camera is approved
 * for use, and -1 if the user denied access.
 *
 * Instead of polling with this function, you can wait for a
 * SDL_EVENT_CAMERA_DEVICE_APPROVED (or SDL_EVENT_CAMERA_DEVICE_DENIED) event
 * in the standard SDL event loop, which is guaranteed to be sent once when
 * permission to use the camera is decided.
 *
 * If a camera is declined, there's nothing to be done but call
 * SDL_CloseCamera() to dispose of it.
 *
 * \param camera the opened camera device to query.
 * \returns -1 if user denied access to the camera, 1 if user approved access,
 *          0 if no decision has been made yet.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_OpenCamera
 * \sa SDL_CloseCamera
 *)
function SDL_GetCameraPermissionState(camera: SDL_Camera): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetCameraPermissionState';

(**
 * Get the instance ID of an opened camera.
 *
 * \param camera an SDL_Camera to query.
 * \returns the instance ID of the specified camera on success or 0 on
 *          failure; call SDL_GetError() for more information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_OpenCamera
 *)
function SDL_GetCameraID(camera: SDL_Camera): SDL_CameraID; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetCameraID';

(**
 * Get the properties associated with an opened camera.
 *
 * \param camera the SDL_Camera obtained from SDL_OpenCamera().
 * \returns a valid property ID on success or 0 on failure; call
 *          SDL_GetError() for more information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetCameraProperties(camera: SDL_Camera): SDL_PropertiesID; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetCameraProperties';

(**
 * Get the spec that a camera is using when generating images.
 *
 * Note that this might not be the native format of the hardware, as SDL might
 * be converting to this format behind the scenes.
 *
 * If the system is waiting for the user to approve access to the camera, as
 * some platforms require, this will return false, but this isn't necessarily
 * a fatal error; you should either wait for an
 * SDL_EVENT_CAMERA_DEVICE_APPROVED (or SDL_EVENT_CAMERA_DEVICE_DENIED) event,
 * or poll SDL_GetCameraPermissionState() occasionally until it returns
 * non-zero.
 *
 * \param camera opened camera device.
 * \param spec the SDL_CameraSpec to be initialized by this function.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_OpenCamera
 *)
function SDL_GetCameraFormat(camera: SDL_Camera; spec: PSDL_CameraSpec): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetCameraFormat';

(**
 * Acquire a frame.
 *
 * The frame is a memory pointer to the image data, whose size and format are
 * given by the spec requested when opening the device.
 *
 * This is a non blocking API. If there is a frame available, a non-NULL
 * surface is returned, and timestampNS will be filled with a non-zero value.
 *
 * Note that an error case can also return NULL, but a NULL by itself is
 * normal and just signifies that a new frame is not yet available. Note that
 * even if a camera device fails outright (a USB camera is unplugged while in
 * use, etc), SDL will send an event separately to notify the app, but
 * continue to provide blank frames at ongoing intervals until
 * SDL_CloseCamera() is called, so real failure here is almost always an out
 * of memory condition.
 *
 * After use, the frame should be released with SDL_ReleaseCameraFrame(). If
 * you don't do this, the system may stop providing more video!
 *
 * Do not call SDL_DestroySurface() on the returned surface! It must be given
 * back to the camera subsystem with SDL_ReleaseCameraFrame!
 *
 * If the system is waiting for the user to approve access to the camera, as
 * some platforms require, this will return NULL (no frames available); you
 * should either wait for an SDL_EVENT_CAMERA_DEVICE_APPROVED (or
 * SDL_EVENT_CAMERA_DEVICE_DENIED) event, or poll
 * SDL_GetCameraPermissionState() occasionally until it returns non-zero.
 *
 * \param camera opened camera device.
 * \param timestampNS a pointer filled in with the frame's timestamp, or 0 on
 *                    error. Can be NULL.
 * \returns a new frame of video on success, NULL if none is currently
 *          available.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_ReleaseCameraFrame
 *)
function SDL_AcquireCameraFrame(camera: SDL_Camera; timestampNS: PUint64): PSDL_Surface; cdecl;
  external LIB_SDL3 name _PU + 'SDL_AcquireCameraFrame';

(**
 * Release a frame of video acquired from a camera.
 *
 * Let the back-end re-use the internal buffer for camera.
 *
 * This function _must_ be called only on surface objects returned by
 * SDL_AcquireCameraFrame(). This function should be called as quickly as
 * possible after acquisition, as SDL keeps a small FIFO queue of surfaces for
 * video frames; if surfaces aren't released in a timely manner, SDL may drop
 * upcoming video frames from the camera.
 *
 * If the app needs to keep the surface for a significant time, they should
 * make a copy of it and release the original.
 *
 * The app should not use the surface again after calling this function;
 * assume the surface is freed and the pointer is invalid.
 *
 * \param camera opened camera device.
 * \param frame the video frame surface to release.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_AcquireCameraFrame
 *)
procedure SDL_ReleaseCameraFrame(camera: SDL_Camera; frame: PSDL_Surface); cdecl;
  external LIB_SDL3 name _PU + 'SDL_ReleaseCameraFrame';

(**
 * Use this function to shut down camera processing and close the camera
 * device.
 *
 * \param camera opened camera device.
 *
 * \threadsafety It is safe to call this function from any thread, but no
 *               thread may reference `device` once this function is called.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_OpenCamera
 *)
procedure SDL_CloseCamera(camera: SDL_Camera); cdecl;
  external LIB_SDL3 name _PU + 'SDL_CloseCamera';
{$ENDREGION 'SDL_camera.h'}

{$REGION 'SDL_clipboard.h'}
(**
 * # CategoryClipboard
 *
 * SDL provides access to the system clipboard, both for reading information
 * from other processes and publishing information of its own.
 *
 * This is not just text! SDL apps can access and publish data by mimetype.
 *
 * ## Basic use (text)
 *
 * Obtaining and publishing simple text to the system clipboard is as easy as
 * calling SDL_GetClipboardText() and SDL_SetClipboardText(), respectively.
 * These deal with C strings in UTF-8 encoding. Data transmission and encoding
 * conversion is completely managed by SDL.
 *
 * ## Clipboard callbacks (data other than text)
 *
 * Things get more complicated when the clipboard contains something other
 * than text. Not only can the system clipboard contain data of any type, in
 * some cases it can contain the same data in different formats! For example,
 * an image painting app might let the user copy a graphic to the clipboard,
 * and offers it in .BMP, .JPG, or .PNG format for other apps to consume.
 *
 * Obtaining clipboard data ("pasting") like this is a matter of calling
 * SDL_GetClipboardData() and telling it the mimetype of the data you want.
 * But how does one know if that format is available? SDL_HasClipboardData()
 * can report if a specific mimetype is offered, and
 * SDL_GetClipboardMimeTypes() can provide the entire list of mimetypes
 * available, so the app can decide what to do with the data and what formats
 * it can support.
 *
 * Setting the clipboard ("copying") to arbitrary data is done with
 * SDL_SetClipboardData. The app does not provide the data in this call, but
 * rather the mimetypes it is willing to provide and a callback function.
 * During the callback, the app will generate the data. This allows massive
 * data sets to be provided to the clipboard, without any data being copied
 * before it is explicitly requested. More specifically, it allows an app to
 * offer data in multiple formats without providing a copy of all of them
 * upfront. If the app has an image that it could provide in PNG or JPG
 * format, it doesn't have to encode it to either of those unless and until
 * something tries to paste it.
 *
 * ## Primary Selection
 *
 * The X11 and Wayland video targets have a concept of the "primary selection"
 * in addition to the usual clipboard. This is generally highlighted (but not
 * explicitly copied) text from various apps. SDL offers APIs for this through
 * SDL_GetPrimarySelectionText() and SDL_SetPrimarySelectionText(). SDL offers
 * these APIs on platforms without this concept, too, but only so far that it
 * will keep a copy of a string that the app sets for later retrieval; the
 * operating system will not ever attempt to change the string externally if
 * it doesn't support a primary selection.
 *)

(**
 * Put UTF-8 text into the clipboard.
 *
 * \param text the text to store in the clipboard.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetClipboardText
 * \sa SDL_HasClipboardText
 *)
function SDL_SetClipboardText(const text: PUTF8Char): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetClipboardText';

(**
 * Get UTF-8 text from the clipboard.
 *
 * This functions returns an empty string if there was not enough memory left
 * for a copy of the clipboard's content.
 *
 * \returns the clipboard text on success or an empty string on failure; call
 *          SDL_GetError() for more information. This should be freed with
 *          SDL_free() when it is no longer needed.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_HasClipboardText
 * \sa SDL_SetClipboardText
 *)
function SDL_GetClipboardText(): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetClipboardText';

(**
 * Query whether the clipboard exists and contains a non-empty text string.
 *
 * \returns true if the clipboard has text, or false if it does not.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetClipboardText
 * \sa SDL_SetClipboardText
 *)
function SDL_HasClipboardText(): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_HasClipboardText';

(**
 * Put UTF-8 text into the primary selection.
 *
 * \param text the text to store in the primary selection.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetPrimarySelectionText
 * \sa SDL_HasPrimarySelectionText
 *)
function SDL_SetPrimarySelectionText(const text: PUTF8Char): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetPrimarySelectionText';

(**
 * Get UTF-8 text from the primary selection.
 *
 * This functions returns an empty string if there was not enough memory left
 * for a copy of the primary selection's content.
 *
 * \returns the primary selection text on success or an empty string on
 *          failure; call SDL_GetError() for more information. This should be
 *          freed with SDL_free() when it is no longer needed.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_HasPrimarySelectionText
 * \sa SDL_SetPrimarySelectionText
 *)
function SDL_GetPrimarySelectionText(): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetPrimarySelectionText';

(**
 * Query whether the primary selection exists and contains a non-empty text
 * string.
 *
 * \returns true if the primary selection has text, or false if it does not.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetPrimarySelectionText
 * \sa SDL_SetPrimarySelectionText
 *)
function SDL_HasPrimarySelectionText(): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_HasPrimarySelectionText';

type
  (**
   * Callback function that will be called when data for the specified mime-type
   * is requested by the OS.
   *
   * The callback function is called with NULL as the mime_type when the
   * clipboard is cleared or new data is set. The clipboard is automatically
   * cleared in SDL_Quit().
   *
   * \param userdata a pointer to provided user data.
   * \param mime_type the requested mime-type.
   * \param size a pointer filled in with the length of the returned data.
   * \returns a pointer to the data for the provided mime-type. Returning NULL
   *          or setting length to 0 will cause no data to be sent to the
   *          "receiver". It is up to the receiver to handle this. Essentially
   *          returning no data is more or less undefined behavior and may cause
   *          breakage in receiving applications. The returned data will not be
   *          freed so it needs to be retained and dealt with internally.
   *
   * \since This function is available since SDL 3.2.0.
   *
   * \sa SDL_SetClipboardData
   *)
  SDL_ClipboardDataCallback = function(userdata: Pointer; const mime_type: PUTF8Char; size: PNativeUInt): Pointer; cdecl;

  (**
   * Callback function that will be called when the clipboard is cleared, or new
   * data is set.
   *
   * \param userdata a pointer to provided user data.
   *
   * \since This function is available since SDL 3.2.0.
   *
   * \sa SDL_SetClipboardData
   *)
  SDL_ClipboardCleanupCallback = procedure(userdata: Pointer); cdecl;

(**
 * Offer clipboard data to the OS.
 *
 * Tell the operating system that the application is offering clipboard data
 * for each of the provided mime-types. Once another application requests the
 * data the callback function will be called, allowing it to generate and
 * respond with the data for the requested mime-type.
 *
 * The size of text data does not include any terminator, and the text does
 * not need to be null terminated (e.g. you can directly copy a portion of a
 * document).
 *
 * \param callback a function pointer to the function that provides the
 *                 clipboard data.
 * \param cleanup a function pointer to the function that cleans up the
 *                clipboard data.
 * \param userdata an opaque pointer that will be forwarded to the callbacks.
 * \param mime_types a list of mime-types that are being offered.
 * \param num_mime_types the number of mime-types in the mime_types list.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_ClearClipboardData
 * \sa SDL_GetClipboardData
 * \sa SDL_HasClipboardData
 *)
function SDL_SetClipboardData(callback: SDL_ClipboardDataCallback; cleanup: SDL_ClipboardCleanupCallback; userdata: Pointer; mime_types: PPUTF8Char; num_mime_types: NativeUInt): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetClipboardData';

(**
 * Clear the clipboard data.
 *
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetClipboardData
 *)
function SDL_ClearClipboardData(): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_ClearClipboardData';

(**
 * Get the data from clipboard for a given mime type.
 *
 * The size of text data does not include the terminator, but the text is
 * guaranteed to be null terminated.
 *
 * \param mime_type the mime type to read from the clipboard.
 * \param size a pointer filled in with the length of the returned data.
 * \returns the retrieved data buffer or NULL on failure; call SDL_GetError()
 *          for more information. This should be freed with SDL_free() when it
 *          is no longer needed.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_HasClipboardData
 * \sa SDL_SetClipboardData
 *)
function SDL_GetClipboardData(const mime_type: PUTF8Char; size: PNativeUInt): Pointer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetClipboardData';

(**
 * Query whether there is data in the clipboard for the provided mime type.
 *
 * \param mime_type the mime type to check for data for.
 * \returns true if there exists data in clipboard for the provided mime type,
 *          false if it does not.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetClipboardData
 * \sa SDL_GetClipboardData
 *)
function SDL_HasClipboardData(const mime_type: PUTF8Char): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_HasClipboardData';

(**
 * Retrieve the list of mime types available in the clipboard.
 *
 * \param num_mime_types a pointer filled with the number of mime types, may
 *                       be NULL.
 * \returns a null terminated array of strings with mime types, or NULL on
 *          failure; call SDL_GetError() for more information. This should be
 *          freed with SDL_free() when it is no longer needed.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetClipboardData
 *)
function SDL_GetClipboardMimeTypes(num_mime_types: PNativeUInt): PPUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetClipboardMimeTypes';
{$ENDREGION 'SDL_clipboard.h'}

{$REGION 'SDL_cpuinfo.h'}
(**
 * # CategoryCPUInfo
 *
 * CPU feature detection for SDL.
 *
 * These functions are largely concerned with reporting if the system has
 * access to various SIMD instruction sets, but also has other important info
 * to share, such as system RAM size and number of logical CPU cores.
 *
 * CPU instruction set checks, like SDL_HasSSE() and SDL_HasNEON(), are
 * available on all platforms, even if they don't make sense (an ARM processor
 * will never have SSE and an x86 processor will never have NEON, for example,
 * but these functions still exist and will simply return false in these
 * cases).
 *)

const
  (**
   * A guess for the cacheline size used for padding.
   *
   * Most x86 processors have a 64 byte cache line. The 64-bit PowerPC
   * processors have a 128 byte cache line. We use the larger value to be
   * generally safe.
   *
   * \since This macro is available since SDL 3.2.0.
   *)
  SDL_CACHELINE_SIZE = 128;

(**
 * Get the number of logical CPU cores available.
 *
 * \returns the total number of logical CPU cores. On CPUs that include
 *          technologies such as hyperthreading, the number of logical cores
 *          may be more than the number of physical cores.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetNumLogicalCPUCores(): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetNumLogicalCPUCores';

(**
 * Determine the L1 cache line size of the CPU.
 *
 * This is useful for determining multi-threaded structure padding or SIMD
 * prefetch sizes.
 *
 * \returns the L1 cache line size of the CPU, in bytes.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetCPUCacheLineSize(): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetCPUCacheLineSize';

(**
 * Determine whether the CPU has AltiVec features.
 *
 * This always returns false on CPUs that aren't using PowerPC instruction
 * sets.
 *
 * \returns true if the CPU has AltiVec features or false if not.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_HasAltiVec(): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_HasAltiVec';

(**
 * Determine whether the CPU has MMX features.
 *
 * This always returns false on CPUs that aren't using Intel instruction sets.
 *
 * \returns true if the CPU has MMX features or false if not.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_HasMMX(): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_HasMMX';

(**
 * Determine whether the CPU has SSE features.
 *
 * This always returns false on CPUs that aren't using Intel instruction sets.
 *
 * \returns true if the CPU has SSE features or false if not.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_HasSSE2
 * \sa SDL_HasSSE3
 * \sa SDL_HasSSE41
 * \sa SDL_HasSSE42
 *)
function SDL_HasSSE(): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_HasSSE';

(**
 * Determine whether the CPU has SSE2 features.
 *
 * This always returns false on CPUs that aren't using Intel instruction sets.
 *
 * \returns true if the CPU has SSE2 features or false if not.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_HasSSE
 * \sa SDL_HasSSE3
 * \sa SDL_HasSSE41
 * \sa SDL_HasSSE42
 *)
function SDL_HasSSE2(): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_HasSSE2';

(**
 * Determine whether the CPU has SSE3 features.
 *
 * This always returns false on CPUs that aren't using Intel instruction sets.
 *
 * \returns true if the CPU has SSE3 features or false if not.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_HasSSE
 * \sa SDL_HasSSE2
 * \sa SDL_HasSSE41
 * \sa SDL_HasSSE42
 *)
function SDL_HasSSE3(): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_HasSSE3';

(**
 * Determine whether the CPU has SSE4.1 features.
 *
 * This always returns false on CPUs that aren't using Intel instruction sets.
 *
 * \returns true if the CPU has SSE4.1 features or false if not.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_HasSSE
 * \sa SDL_HasSSE2
 * \sa SDL_HasSSE3
 * \sa SDL_HasSSE42
 *)
function SDL_HasSSE41(): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_HasSSE41';

(**
 * Determine whether the CPU has SSE4.2 features.
 *
 * This always returns false on CPUs that aren't using Intel instruction sets.
 *
 * \returns true if the CPU has SSE4.2 features or false if not.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_HasSSE
 * \sa SDL_HasSSE2
 * \sa SDL_HasSSE3
 * \sa SDL_HasSSE41
 *)
function SDL_HasSSE42(): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_HasSSE42';

(**
 * Determine whether the CPU has AVX features.
 *
 * This always returns false on CPUs that aren't using Intel instruction sets.
 *
 * \returns true if the CPU has AVX features or false if not.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_HasAVX2
 * \sa SDL_HasAVX512F
 *)
function SDL_HasAVX(): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_HasAVX';

(**
 * Determine whether the CPU has AVX2 features.
 *
 * This always returns false on CPUs that aren't using Intel instruction sets.
 *
 * \returns true if the CPU has AVX2 features or false if not.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_HasAVX
 * \sa SDL_HasAVX512F
 *)
function SDL_HasAVX2(): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_HasAVX2';

(**
 * Determine whether the CPU has AVX-512F (foundation) features.
 *
 * This always returns false on CPUs that aren't using Intel instruction sets.
 *
 * \returns true if the CPU has AVX-512F features or false if not.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_HasAVX
 * \sa SDL_HasAVX2
 *)
function SDL_HasAVX512F(): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_HasAVX512F';

(**
 * Determine whether the CPU has ARM SIMD (ARMv6) features.
 *
 * This is different from ARM NEON, which is a different instruction set.
 *
 * This always returns false on CPUs that aren't using ARM instruction sets.
 *
 * \returns true if the CPU has ARM SIMD features or false if not.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_HasNEON
 *)
function SDL_HasARMSIMD(): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_HasARMSIMD';

(**
 * Determine whether the CPU has NEON (ARM SIMD) features.
 *
 * This always returns false on CPUs that aren't using ARM instruction sets.
 *
 * \returns true if the CPU has ARM NEON features or false if not.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_HasNEON(): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_HasNEON';

(**
 * Determine whether the CPU has LSX (LOONGARCH SIMD) features.
 *
 * This always returns false on CPUs that aren't using LOONGARCH instruction
 * sets.
 *
 * \returns true if the CPU has LOONGARCH LSX features or false if not.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_HasLSX(): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_HasLSX';

(**
 * Determine whether the CPU has LASX (LOONGARCH SIMD) features.
 *
 * This always returns false on CPUs that aren't using LOONGARCH instruction
 * sets.
 *
 * \returns true if the CPU has LOONGARCH LASX features or false if not.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_HasLASX(): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_HasLASX';

(**
 * Get the amount of RAM configured in the system.
 *
 * \returns the amount of RAM configured in the system in MiB.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetSystemRAM(): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetSystemRAM';

(**
 * Report the alignment this system needs for SIMD allocations.
 *
 * This will return the minimum number of bytes to which a pointer must be
 * aligned to be compatible with SIMD instructions on the current machine. For
 * example, if the machine supports SSE only, it will return 16, but if it
 * supports AVX-512F, it'll return 64 (etc). This only reports values for
 * instruction sets SDL knows about, so if your SDL build doesn't have
 * SDL_HasAVX512F(), then it might return 16 for the SSE support it sees and
 * not 64 for the AVX-512 instructions that exist but SDL doesn't know about.
 * Plan accordingly.
 *
 * \returns the alignment in bytes needed for available, known SIMD
 *          instructions.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_aligned_alloc
 * \sa SDL_aligned_free
 *)
function SDL_GetSIMDAlignment(): NativeUInt; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetSIMDAlignment';
{$ENDREGION 'SDL_cpuinfo.h'}

{$REGION 'SDL_video.h'}
(**
 * # CategoryVideo
 *
 * SDL's video subsystem is largely interested in abstracting window
 * management from the underlying operating system. You can create windows,
 * manage them in various ways, set them fullscreen, and get events when
 * interesting things happen with them, such as the mouse or keyboard
 * interacting with a window.
 *
 * The video subsystem is also interested in abstracting away some
 * platform-specific differences in OpenGL: context creation, swapping
 * buffers, etc. This may be crucial to your app, but also you are not
 * required to use OpenGL at all. In fact, SDL can provide rendering to those
 * windows as well, either with an easy-to-use
 * [2D API](https://wiki.libsdl.org/SDL3/CategoryRender)
 * or with a more-powerful
 * [GPU API](https://wiki.libsdl.org/SDL3/CategoryGPU)
 * . Of course, it can simply get out of your way and give you the window
 * handles you need to use Vulkan, Direct3D, Metal, or whatever else you like
 * directly, too.
 *
 * The video subsystem covers a lot of functionality, out of necessity, so it
 * is worth perusing the list of functions just to see what's available, but
 * most apps can get by with simply creating a window and listening for
 * events, so start with SDL_CreateWindow() and SDL_PollEvent().
 *)

type
  (**
   * This is a unique ID for a display for the time it is connected to the
   * system, and is never reused for the lifetime of the application.
   *
   * If the display is disconnected and reconnected, it will get a new ID.
   *
   * The value 0 is an invalid ID.
   *
   * \since This datatype is available since SDL 3.2.0.
   *)
  SDL_DisplayID = Uint32;
  PSDL_DisplayID = ^SDL_DisplayID;

  (**
   * This is a unique ID for a window.
   *
   * The value 0 is an invalid ID.
   *
   * \since This datatype is available since SDL 3.2.0.
   *)
  SDL_WindowID = Uint32;

const
  (**
   * The pointer to the global `wl_display` object used by the Wayland video
   * backend.
   *
   * Can be set before the video subsystem is initialized to import an external
   * `wl_display` object from an application or toolkit for use in SDL, or read
   * after initialization to export the `wl_display` used by the Wayland video
   * backend. Setting this property after the video subsystem has been
   * initialized has no effect, and reading it when the video subsystem is
   * uninitialized will either return the user provided value, if one was set
   * prior to initialization, or NULL. See docs/README-wayland.md for more
   * information.
   *)
  SDL_PROP_GLOBAL_VIDEO_WAYLAND_WL_DISPLAY_POINTER = 'SDL.video.wayland.wl_display';

(**
 * System theme.
 *
 * \since This enum is available since SDL 3.2.0.
 *)
type
  SDL_SystemTheme = Integer;

const
  (** Unknown system theme *)
  SDL_SYSTEM_THEME_UNKNOWN = 0;
  (** Light colored system theme *)
  SDL_SYSTEM_THEME_LIGHT = 1;
  (** Dark colored system theme *)
  SDL_SYSTEM_THEME_DARK = 2;

type
  (**
   * Internal display mode data.
   *
   * This lives as a field in SDL_DisplayMode, as opaque data.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_DisplayMode
   *)
  SDL_DisplayModeData = THandle;

type
  (**
   * The structure that defines a display mode.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_GetFullscreenDisplayModes
   * \sa SDL_GetDesktopDisplayMode
   * \sa SDL_GetCurrentDisplayMode
   * \sa SDL_SetWindowFullscreenMode
   * \sa SDL_GetWindowFullscreenMode
   *)
  SDL_DisplayMode = record
    (** the display this mode is associated with *)
    displayID: SDL_DisplayID;
    (** pixel format *)
    format: SDL_PixelFormat;
    (** width *)
    w: Integer;
    (** height *)
    h: Integer;
    (** scale converting size to pixels (e.g. a 1920x1080 mode with 2.0 scale would have 3840x2160 pixels) *)
    pixel_density: Single;
    (** refresh rate (or 0.0f for unspecified) *)
    refresh_rate: Single;
    (** precise refresh rate numerator (or 0 for unspecified) *)
    refresh_rate_numerator: Integer;
    (** precise refresh rate denominator *)
    refresh_rate_denominator: Integer;
    (** Private *)
    internal: SDL_DisplayModeData;
  end;
  PSDL_DisplayMode = ^SDL_DisplayMode;
  PPSDL_DisplayMode = ^PSDL_DisplayMode;

(**
 * Display orientation values; the way a display is rotated.
 *
 * \since This enum is available since SDL 3.2.0.
 *)
type
  SDL_DisplayOrientation = Integer;

const
  (** The display orientation can't be determined *)
  SDL_ORIENTATION_UNKNOWN = 0;
  (** The display is in landscape mode, with the right side up, relative to portrait mode *)
  SDL_ORIENTATION_LANDSCAPE = 1;
  (** The display is in landscape mode, with the left side up, relative to portrait mode *)
  SDL_ORIENTATION_LANDSCAPE_FLIPPED = 2;
  (** The display is in portrait mode *)
  SDL_ORIENTATION_PORTRAIT = 3;
  (** The display is in portrait mode, upside down *)
  SDL_ORIENTATION_PORTRAIT_FLIPPED = 4;

type
  (**
   * The struct used as an opaque handle to a window.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_CreateWindow
   *)
  SDL_Window = THandle;
  PSDL_Window = ^SDL_Window;

type
  (**
   * The flags on a window.
   *
   * These cover a lot of true/false, or on/off, window state. Some of it is
   * immutable after being set through SDL_CreateWindow(), some of it can be
   * changed on existing windows by the app, and some of it might be altered by
   * the user or system outside of the app's control.
   *
   * \since This datatype is available since SDL 3.2.0.
   *
   * \sa SDL_GetWindowFlags
   *)
  SDL_WindowFlags = Uint64;

const
  SDL_WINDOW_FULLSCREEN           = $0000000000000001; // window is in fullscreen mode
  SDL_WINDOW_OPENGL               = $0000000000000002; // window usable with OpenGL context
  SDL_WINDOW_OCCLUDED             = $0000000000000004; // window is occluded
  SDL_WINDOW_HIDDEN               = $0000000000000008; // window is neither mapped onto the desktop nor shown in the taskbar/dock/window list; SDL_ShowWindow() is required for it to become visible
  SDL_WINDOW_BORDERLESS           = $0000000000000010; // no window decoration
  SDL_WINDOW_RESIZABLE            = $0000000000000020; // window can be resized
  SDL_WINDOW_MINIMIZED            = $0000000000000040; // window is minimized
  SDL_WINDOW_MAXIMIZED            = $0000000000000080; // window is maximized
  SDL_WINDOW_MOUSE_GRABBED        = $0000000000000100; // window has grabbed mouse input
  SDL_WINDOW_INPUT_FOCUS          = $0000000000000200; // window has input focus
  SDL_WINDOW_MOUSE_FOCUS          = $0000000000000400; // window has mouse focus
  SDL_WINDOW_EXTERNAL             = $0000000000000800; // window not created by SDL
  SDL_WINDOW_MODAL                = $0000000000001000; // window is modal
  SDL_WINDOW_HIGH_PIXEL_DENSITY   = $0000000000002000; // window uses high pixel density back buffer if possible
  SDL_WINDOW_MOUSE_CAPTURE        = $0000000000004000; // window has mouse captured (unrelated to MOUSE_GRABBED)
  SDL_WINDOW_MOUSE_RELATIVE_MODE  = $0000000000008000; // window has relative mode enabled
  SDL_WINDOW_ALWAYS_ON_TOP        = $0000000000010000; // window should always be above others
  SDL_WINDOW_UTILITY              = $0000000000020000; // window should be treated as a utility window, not showing in the task bar and window list
  SDL_WINDOW_TOOLTIP              = $0000000000040000; // window should be treated as a tooltip and does not get mouse or keyboard focus, requires a parent window
  SDL_WINDOW_POPUP_MENU           = $0000000000080000; // window should be treated as a popup menu, requires a parent window
  SDL_WINDOW_KEYBOARD_GRABBED     = $0000000000100000; // window has grabbed keyboard input
  SDL_WINDOW_VULKAN               = $0000000010000000; // window usable for Vulkan surface
  SDL_WINDOW_METAL                = $0000000020000000; // window usable for Metal view
  SDL_WINDOW_TRANSPARENT          = $0000000040000000; // window with transparent buffer
  SDL_WINDOW_NOT_FOCUSABLE        = $0000000080000000; // window should not be focusable

const
  (**
   * A magic value used with SDL_WINDOWPOS_UNDEFINED.
   *
   * Generally this macro isn't used directly, but rather through
   * SDL_WINDOWPOS_UNDEFINED or SDL_WINDOWPOS_UNDEFINED_DISPLAY.
   *
   * \since This macro is available since SDL 3.2.0.
   *)
  SDL_WINDOWPOS_UNDEFINED_MASK = $1FFF0000;

(**
 * Used to indicate that you don't care what the window position is.
 *
 * If you _really_ don't care, SDL_WINDOWPOS_UNDEFINED is the same, but always
 * uses the primary display instead of specifying one.
 *
 * \param X the SDL_DisplayID of the display to use.
 *
 * \since This macro is available since SDL 3.2.0.
 *)
function SDL_WindowPosUndefinedDisplay(X: UInt32): UInt32; inline;

const
  (**
   * Used to indicate that you don't care what the window position/display is.
   *
   * This always uses the primary display.
   *
   * \since This macro is available since SDL 3.2.0.
   *)
  SDL_WINDOWPOS_UNDEFINED = SDL_WINDOWPOS_UNDEFINED_MASK;

(**
 * A macro to test if the window position is marked as "undefined."
 *
 * \param X the window position value.
 *
 * \since This macro is available since SDL 3.2.0.
 *)
function SDL_WindowPosIsUndefined(X: UInt32): Boolean; inline;

const
  (**
   * A magic value used with SDL_WINDOWPOS_CENTERED.
   *
   * Generally this macro isn't used directly, but rather through
   * SDL_WINDOWPOS_CENTERED or SDL_WINDOWPOS_CENTERED_DISPLAY.
   *
   * \since This macro is available since SDL 3.2.0.
   *)
 SDL_WINDOWPOS_CENTERED_MASK = $2FFF0000;

(**
 * Used to indicate that the window position should be centered.
 *
 * SDL_WINDOWPOS_CENTERED is the same, but always uses the primary display
 * instead of specifying one.
 *
 * \param X the SDL_DisplayID of the display to use.
 *
 * \since This macro is available since SDL 3.2.0.
 *)
function SDL_WindowPosCenteredDisplay(X: UInt32): UInt32; inline;

const
  (**
   * Used to indicate that the window position should be centered.
   *
   * This always uses the primary display.
   *
   * \since This macro is available since SDL 3.2.0.
   *)
  SDL_WINDOWPOS_CENTERED = SDL_WINDOWPOS_CENTERED_MASK;

(**
 * A macro to test if the window position is marked as "centered."
 *
 * \param X the window position value.
 *
 * \since This macro is available since SDL 3.2.0.
 *)
function SDL_WindowPosIsCentered(X: UInt32): Boolean; inline;

(**
 * Window flash operation.
 *
 * \since This enum is available since SDL 3.2.0.
 *)
type
  SDL_FlashOperation = Integer;

const
  (** Cancel any window flash state *)
  SDL_FLASH_CANCEL = 0;
  (** Flash the window briefly to get attention *)
  SDL_FLASH_BRIEFLY = 1;
  (** Flash the window until it gets focus *)
  SDL_FLASH_UNTIL_FOCUSED = 2;

type
  (**
   * An opaque handle to an OpenGL context.
   *
   * \since This datatype is available since SDL 3.2.0.
   *
   * \sa SDL_GL_CreateContext
   *)
  SDL_GLContext = THandle;

  (**
   * Opaque type for an EGL display.
   *
   * \since This datatype is available since SDL 3.2.0.
   *)
  SDL_EGLDisplay = THandle;

  (**
   * Opaque type for an EGL config.
   *
   * \since This datatype is available since SDL 3.2.0.
   *)
  SDL_EGLConfig = THandle;

  (**
   * Opaque type for an EGL surface.
   *
   * \since This datatype is available since SDL 3.2.0.
   *)
  SDL_EGLSurface = THandle;

  (**
   * An EGL attribute, used when creating an EGL context.
   *
   * \since This datatype is available since SDL 3.2.0.
   *)
  SDL_EGLAttrib = IntPtr;
  PSDL_EGLAttrib = ^SDL_EGLAttrib;

  (**
   * An EGL integer attribute, used when creating an EGL surface.
   *
   * \since This datatype is available since SDL 3.2.0.
   *)
  SDL_EGLint = Integer;
  PSDL_EGLint = ^SDL_EGLint;

  (**
   * EGL platform attribute initialization callback.
   *
   * This is called when SDL is attempting to create an EGL context, to let the
   * app add extra attributes to its eglGetPlatformDisplay() call.
   *
   * The callback should return a pointer to an EGL attribute array terminated
   * with `EGL_NONE`. If this function returns NULL, the SDL_CreateWindow
   * process will fail gracefully.
   *
   * The returned pointer should be allocated with SDL_malloc() and will be
   * passed to SDL_free().
   *
   * The arrays returned by each callback will be appended to the existing
   * attribute arrays defined by SDL.
   *
   * \param userdata an app-controlled pointer that is passed to the callback.
   * \returns a newly-allocated array of attributes, terminated with `EGL_NONE`.
   *
   * \since This datatype is available since SDL 3.2.0.
   *
   * \sa SDL_EGL_SetAttributeCallbacks
   *)
  SDL_EGLAttribArrayCallback = function(userdata: Pointer): PSDL_EGLAttrib; cdecl;

  (**
   * EGL surface/context attribute initialization callback types.
   *
   * This is called when SDL is attempting to create an EGL surface, to let the
   * app add extra attributes to its eglCreateWindowSurface() or
   * eglCreateContext calls.
   *
   * For convenience, the EGLDisplay and EGLConfig to use are provided to the
   * callback.
   *
   * The callback should return a pointer to an EGL attribute array terminated
   * with `EGL_NONE`. If this function returns NULL, the SDL_CreateWindow
   * process will fail gracefully.
   *
   * The returned pointer should be allocated with SDL_malloc() and will be
   * passed to SDL_free().
   *
   * The arrays returned by each callback will be appended to the existing
   * attribute arrays defined by SDL.
   *
   * \param userdata an app-controlled pointer that is passed to the callback.
   * \param display the EGL display to be used.
   * \param config the EGL config to be used.
   * \returns a newly-allocated array of attributes, terminated with `EGL_NONE`.
   *
   * \since This datatype is available since SDL 3.2.0.
   *
   * \sa SDL_EGL_SetAttributeCallbacks
   *)
  SDL_EGLIntArrayCallback = function(userdata: Pointer; display: SDL_EGLDisplay; config: SDL_EGLConfig): PSDL_EGLint; cdecl;

(**
 * An enumeration of OpenGL configuration attributes.
 *
 * While you can set most OpenGL attributes normally, the attributes listed
 * above must be known before SDL creates the window that will be used with
 * the OpenGL context. These attributes are set and read with
 * SDL_GL_SetAttribute() and SDL_GL_GetAttribute().
 *
 * In some cases, these attributes are minimum requests; the GL does not
 * promise to give you exactly what you asked for. It's possible to ask for a
 * 16-bit depth buffer and get a 24-bit one instead, for example, or to ask
 * for no stencil buffer and still have one available. Context creation should
 * fail if the GL can't provide your requested attributes at a minimum, but
 * you should check to see exactly what you got.
 *
 * \since This enum is available since SDL 3.2.0.
 *)
type
  SDL_GLAttr = Integer;

const
  (** the minimum number of bits for the red channel of the color buffer; defaults to 3. *)
  SDL_GL_RED_SIZE = 0;
  (** the minimum number of bits for the green channel of the color buffer; defaults to 3. *)
  SDL_GL_GREEN_SIZE = 1;
  (** the minimum number of bits for the blue channel of the color buffer; defaults to 2. *)
  SDL_GL_BLUE_SIZE = 2;
  (** the minimum number of bits for the alpha channel of the color buffer; defaults to 0. *)
  SDL_GL_ALPHA_SIZE = 3;
  (** the minimum number of bits for frame buffer size; defaults to 0. *)
  SDL_GL_BUFFER_SIZE = 4;
  (** whether the output is single or double buffered; defaults to double buffering on. *)
  SDL_GL_DOUBLEBUFFER = 5;
  (** the minimum number of bits in the depth buffer; defaults to 16. *)
  SDL_GL_DEPTH_SIZE = 6;
  (** the minimum number of bits in the stencil buffer; defaults to 0. *)
  SDL_GL_STENCIL_SIZE = 7;
  (** the minimum number of bits for the red channel of the accumulation buffer; defaults to 0. *)
  SDL_GL_ACCUM_RED_SIZE = 8;
  (** the minimum number of bits for the green channel of the accumulation buffer; defaults to 0. *)
  SDL_GL_ACCUM_GREEN_SIZE = 9;
  (** the minimum number of bits for the blue channel of the accumulation buffer; defaults to 0. *)
  SDL_GL_ACCUM_BLUE_SIZE = 10;
  (** the minimum number of bits for the alpha channel of the accumulation buffer; defaults to 0. *)
  SDL_GL_ACCUM_ALPHA_SIZE = 11;
  (** whether the output is stereo 3D; defaults to off. *)
  SDL_GL_STEREO = 12;
  (** the number of buffers used for multisample anti-aliasing; defaults to 0. *)
  SDL_GL_MULTISAMPLEBUFFERS = 13;
  (** the number of samples used around the current pixel used for multisample anti-aliasing. *)
  SDL_GL_MULTISAMPLESAMPLES = 14;
  (** set to 1 to require hardware acceleration, set to 0 to force software rendering; defaults to allow either. *)
  SDL_GL_ACCELERATED_VISUAL = 15;
  (** not used (deprecated). *)
  SDL_GL_RETAINED_BACKING = 16;
  (** OpenGL context major version. *)
  SDL_GL_CONTEXT_MAJOR_VERSION = 17;
  (** OpenGL context minor version. *)
  SDL_GL_CONTEXT_MINOR_VERSION = 18;
  (** some combination of 0 or more of elements of the SDL_GLContextFlag enumeration; defaults to 0. *)
  SDL_GL_CONTEXT_FLAGS = 19;
  (** type of GL context (Core, Compatibility, ES). See SDL_GLProfile; default value depends on platform. *)
  SDL_GL_CONTEXT_PROFILE_MASK = 20;
  (** OpenGL context sharing; defaults to 0. *)
  SDL_GL_SHARE_WITH_CURRENT_CONTEXT = 21;
  (** requests sRGB capable visual; defaults to 0. *)
  SDL_GL_FRAMEBUFFER_SRGB_CAPABLE = 22;
  (** sets context the release behavior. See SDL_GLContextReleaseFlag; defaults to FLUSH. *)
  SDL_GL_CONTEXT_RELEASE_BEHAVIOR = 23;
  (** set context reset notification. See SDL_GLContextResetNotification; defaults to NO_NOTIFICATION. *)
  SDL_GL_CONTEXT_RESET_NOTIFICATION = 24;
  SDL_GL_CONTEXT_NO_ERROR = 25;
  SDL_GL_FLOATBUFFERS = 26;
  SDL_GL_EGL_PLATFORM = 27;

type
  (**
   * Possible values to be set for the SDL_GL_CONTEXT_PROFILE_MASK attribute.
   *
   * \since This datatype is available since SDL 3.2.0.
   *)
  SDL_GLProfile = Uint32;

const
  SDL_GL_CONTEXT_PROFILE_CORE = $0001;          // OpenGL Core Profile context
  SDL_GL_CONTEXT_PROFILE_COMPATIBILITY = $0002; // OpenGL Compatibility Profile context
  SDL_GL_CONTEXT_PROFILE_ES = $0004;            // GLX_CONTEXT_ES2_PROFILE_BIT_EXT

type
  (**
   * Possible flags to be set for the SDL_GL_CONTEXT_FLAGS attribute.
   *
   * \since This datatype is available since SDL 3.2.0.
   *)
  SDL_GLContextFlag = Uint32;

const
  SDL_GL_CONTEXT_DEBUG_FLAG = $0001;
  SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG = $0002;
  SDL_GL_CONTEXT_ROBUST_ACCESS_FLAG = $0004;
  SDL_GL_CONTEXT_RESET_ISOLATION_FLAG = $0008;

type
  (**
   * Possible values to be set for the SDL_GL_CONTEXT_RELEASE_BEHAVIOR
   * attribute.
   *
   * \since This datatype is available since SDL 3.2.0.
   *)
  SDL_GLContextReleaseFlag = Uint32;

const
  SDL_GL_CONTEXT_RELEASE_BEHAVIOR_NONE = $0000;
  SDL_GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH = $0001;

type
  (**
   * Possible values to be set SDL_GL_CONTEXT_RESET_NOTIFICATION attribute.
   *
   * \since This datatype is available since SDL 3.2.0.
   *)
  SDL_GLContextResetNotification = Uint32;

const
  SDL_GL_CONTEXT_RESET_NO_NOTIFICATION = $0000;
  SDL_GL_CONTEXT_RESET_LOSE_CONTEXT = $0001;

(**
 * Get the number of video drivers compiled into SDL.
 *
 * \returns the number of built in video drivers.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetVideoDriver
 *)
function SDL_GetNumVideoDrivers(): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetNumVideoDrivers';

(**
 * Get the name of a built in video driver.
 *
 * The video drivers are presented in the order in which they are normally
 * checked during initialization.
 *
 * The names of drivers are all simple, low-ASCII identifiers, like "cocoa",
 * "x11" or "windows". These never have Unicode characters, and are not meant
 * to be proper names.
 *
 * \param index the index of a video driver.
 * \returns the name of the video driver with the given **index**.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetNumVideoDrivers
 *)
function SDL_GetVideoDriver(index: Integer): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetVideoDriver';

(**
 * Get the name of the currently initialized video driver.
 *
 * The names of drivers are all simple, low-ASCII identifiers, like "cocoa",
 * "x11" or "windows". These never have Unicode characters, and are not meant
 * to be proper names.
 *
 * \returns the name of the current video driver or NULL if no driver has been
 *          initialized.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetNumVideoDrivers
 * \sa SDL_GetVideoDriver
 *)
function SDL_GetCurrentVideoDriver(): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetCurrentVideoDriver';

(**
 * Get the current system theme.
 *
 * \returns the current system theme, light, dark, or unknown.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetSystemTheme(): SDL_SystemTheme; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetSystemTheme';

(**
 * Get a list of currently connected displays.
 *
 * \param count a pointer filled in with the number of displays returned, may
 *              be NULL.
 * \returns a 0 terminated array of display instance IDs or NULL on failure;
 *          call SDL_GetError() for more information. This should be freed
 *          with SDL_free() when it is no longer needed.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetDisplays(count: PInteger): PSDL_DisplayID; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetDisplays';

(**
 * Return the primary display.
 *
 * \returns the instance ID of the primary display on success or 0 on failure;
 *          call SDL_GetError() for more information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetDisplays
 *)
function SDL_GetPrimaryDisplay(): SDL_DisplayID; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetPrimaryDisplay';

(**
 * Get the properties associated with a display.
 *
 * The following read-only properties are provided by SDL:
 *
 * - `SDL_PROP_DISPLAY_HDR_ENABLED_BOOLEAN`: true if the display has HDR
 *   headroom above the SDR white point. This is for informational and
 *   diagnostic purposes only, as not all platforms provide this information
 *   at the display level.
 *
 * On KMS/DRM:
 *
 * - `SDL_PROP_DISPLAY_KMSDRM_PANEL_ORIENTATION_NUMBER`: the "panel
 *   orientation" property for the display in degrees of clockwise rotation.
 *   Note that this is provided only as a hint, and the application is
 *   responsible for any coordinate transformations needed to conform to the
 *   requested display orientation.
 *
 * \param displayID the instance ID of the display to query.
 * \returns a valid property ID on success or 0 on failure; call
 *          SDL_GetError() for more information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetDisplayProperties(displayID: SDL_DisplayID): SDL_PropertiesID; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetDisplayProperties';

const
  SDL_PROP_DISPLAY_HDR_ENABLED_BOOLEAN = 'SDL.display.HDR_enabled';
  SDL_PROP_DISPLAY_KMSDRM_PANEL_ORIENTATION_NUMBER = 'SDL.display.KMSDRM.panel_orientation';

(**
 * Get the name of a display in UTF-8 encoding.
 *
 * \param displayID the instance ID of the display to query.
 * \returns the name of a display or NULL on failure; call SDL_GetError() for
 *          more information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetDisplays
 *)
function SDL_GetDisplayName(displayID: SDL_DisplayID): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetDisplayName';

(**
 * Get the desktop area represented by a display.
 *
 * The primary display is often located at (0,0), but may be placed at a
 * different location depending on monitor layout.
 *
 * \param displayID the instance ID of the display to query.
 * \param rect the SDL_Rect structure filled in with the display bounds.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetDisplayUsableBounds
 * \sa SDL_GetDisplays
 *)
function SDL_GetDisplayBounds(displayID: SDL_DisplayID; rect: PSDL_Rect): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetDisplayBounds';

(**
 * Get the usable desktop area represented by a display, in screen
 * coordinates.
 *
 * This is the same area as SDL_GetDisplayBounds() reports, but with portions
 * reserved by the system removed. For example, on Apple's macOS, this
 * subtracts the area occupied by the menu bar and dock.
 *
 * Setting a window to be fullscreen generally bypasses these unusable areas,
 * so these are good guidelines for the maximum space available to a
 * non-fullscreen window.
 *
 * \param displayID the instance ID of the display to query.
 * \param rect the SDL_Rect structure filled in with the display bounds.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetDisplayBounds
 * \sa SDL_GetDisplays
 *)
function SDL_GetDisplayUsableBounds(displayID: SDL_DisplayID; rect: PSDL_Rect): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetDisplayUsableBounds';

(**
 * Get the orientation of a display when it is unrotated.
 *
 * \param displayID the instance ID of the display to query.
 * \returns the SDL_DisplayOrientation enum value of the display, or
 *          `SDL_ORIENTATION_UNKNOWN` if it isn't available.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetDisplays
 *)
function SDL_GetNaturalDisplayOrientation(displayID: SDL_DisplayID): SDL_DisplayOrientation; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetNaturalDisplayOrientation';

(**
 * Get the orientation of a display.
 *
 * \param displayID the instance ID of the display to query.
 * \returns the SDL_DisplayOrientation enum value of the display, or
 *          `SDL_ORIENTATION_UNKNOWN` if it isn't available.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetDisplays
 *)
function SDL_GetCurrentDisplayOrientation(displayID: SDL_DisplayID): SDL_DisplayOrientation; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetCurrentDisplayOrientation';

(**
 * Get the content scale of a display.
 *
 * The content scale is the expected scale for content based on the DPI
 * settings of the display. For example, a 4K display might have a 2.0 (200%)
 * display scale, which means that the user expects UI elements to be twice as
 * big on this display, to aid in readability.
 *
 * After window creation, SDL_GetWindowDisplayScale() should be used to query
 * the content scale factor for individual windows instead of querying the
 * display for a window and calling this function, as the per-window content
 * scale factor may differ from the base value of the display it is on,
 * particularly on high-DPI and/or multi-monitor desktop configurations.
 *
 * \param displayID the instance ID of the display to query.
 * \returns the content scale of the display, or 0.0f on failure; call
 *          SDL_GetError() for more information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetWindowDisplayScale
 * \sa SDL_GetDisplays
 *)
function SDL_GetDisplayContentScale(displayID: SDL_DisplayID): Single; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetDisplayContentScale';

(**
 * Get a list of fullscreen display modes available on a display.
 *
 * The display modes are sorted in this priority:
 *
 * - w -> largest to smallest
 * - h -> largest to smallest
 * - bits per pixel -> more colors to fewer colors
 * - packed pixel layout -> largest to smallest
 * - refresh rate -> highest to lowest
 * - pixel density -> lowest to highest
 *
 * \param displayID the instance ID of the display to query.
 * \param count a pointer filled in with the number of display modes returned,
 *              may be NULL.
 * \returns a NULL terminated array of display mode pointers or NULL on
 *          failure; call SDL_GetError() for more information. This is a
 *          single allocation that should be freed with SDL_free() when it is
 *          no longer needed.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetDisplays
 *)
function SDL_GetFullscreenDisplayModes(displayID: SDL_DisplayID; count: PInteger): PPSDL_DisplayMode; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetFullscreenDisplayModes';

(**
 * Get the closest match to the requested display mode.
 *
 * The available display modes are scanned and `closest` is filled in with the
 * closest mode matching the requested mode and returned. The mode format and
 * refresh rate default to the desktop mode if they are set to 0. The modes
 * are scanned with size being first priority, format being second priority,
 * and finally checking the refresh rate. If all the available modes are too
 * small, then false is returned.
 *
 * \param displayID the instance ID of the display to query.
 * \param w the width in pixels of the desired display mode.
 * \param h the height in pixels of the desired display mode.
 * \param refresh_rate the refresh rate of the desired display mode, or 0.0f
 *                     for the desktop refresh rate.
 * \param include_high_density_modes boolean to include high density modes in
 *                                   the search.
 * \param closest a pointer filled in with the closest display mode equal to
 *                or larger than the desired mode.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetDisplays
 * \sa SDL_GetFullscreenDisplayModes
 *)
function SDL_GetClosestFullscreenDisplayMode(displayID: SDL_DisplayID; w: Integer; h: Integer; refresh_rate: Single; include_high_density_modes: Boolean; closest: PSDL_DisplayMode): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetClosestFullscreenDisplayMode';

(**
 * Get information about the desktop's display mode.
 *
 * There's a difference between this function and SDL_GetCurrentDisplayMode()
 * when SDL runs fullscreen and has changed the resolution. In that case this
 * function will return the previous native display mode, and not the current
 * display mode.
 *
 * \param displayID the instance ID of the display to query.
 * \returns a pointer to the desktop display mode or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetCurrentDisplayMode
 * \sa SDL_GetDisplays
 *)
function SDL_GetDesktopDisplayMode(displayID: SDL_DisplayID): PSDL_DisplayMode; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetDesktopDisplayMode';

(**
 * Get information about the current display mode.
 *
 * There's a difference between this function and SDL_GetDesktopDisplayMode()
 * when SDL runs fullscreen and has changed the resolution. In that case this
 * function will return the current display mode, and not the previous native
 * display mode.
 *
 * \param displayID the instance ID of the display to query.
 * \returns a pointer to the desktop display mode or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetDesktopDisplayMode
 * \sa SDL_GetDisplays
 *)
function SDL_GetCurrentDisplayMode(displayID: SDL_DisplayID): PSDL_DisplayMode; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetCurrentDisplayMode';

(**
 * Get the display containing a point.
 *
 * \param point the point to query.
 * \returns the instance ID of the display containing the point or 0 on
 *          failure; call SDL_GetError() for more information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetDisplayBounds
 * \sa SDL_GetDisplays
 *)
function SDL_GetDisplayForPoint(const point: PSDL_Point): SDL_DisplayID; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetDisplayForPoint';

(**
 * Get the display primarily containing a rect.
 *
 * \param rect the rect to query.
 * \returns the instance ID of the display entirely containing the rect or
 *          closest to the center of the rect on success or 0 on failure; call
 *          SDL_GetError() for more information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetDisplayBounds
 * \sa SDL_GetDisplays
 *)
function SDL_GetDisplayForRect(const rect: PSDL_Rect): SDL_DisplayID; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetDisplayForRect';

(**
 * Get the display associated with a window.
 *
 * \param window the window to query.
 * \returns the instance ID of the display containing the center of the window
 *          on success or 0 on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetDisplayBounds
 * \sa SDL_GetDisplays
 *)
function SDL_GetDisplayForWindow(window: SDL_Window): SDL_DisplayID; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetDisplayForWindow';

(**
 * Get the pixel density of a window.
 *
 * This is a ratio of pixel size to window size. For example, if the window is
 * 1920x1080 and it has a high density back buffer of 3840x2160 pixels, it
 * would have a pixel density of 2.0.
 *
 * \param window the window to query.
 * \returns the pixel density or 0.0f on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetWindowDisplayScale
 *)
function SDL_GetWindowPixelDensity(window: SDL_Window): Single; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetWindowPixelDensity';

(**
 * Get the content display scale relative to a window's pixel size.
 *
 * This is a combination of the window pixel density and the display content
 * scale, and is the expected scale for displaying content in this window. For
 * example, if a 3840x2160 window had a display scale of 2.0, the user expects
 * the content to take twice as many pixels and be the same physical size as
 * if it were being displayed in a 1920x1080 window with a display scale of
 * 1.0.
 *
 * Conceptually this value corresponds to the scale display setting, and is
 * updated when that setting is changed, or the window moves to a display with
 * a different scale setting.
 *
 * \param window the window to query.
 * \returns the display scale, or 0.0f on failure; call SDL_GetError() for
 *          more information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetWindowDisplayScale(window: SDL_Window): Single; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetWindowDisplayScale';

(**
 * Set the display mode to use when a window is visible and fullscreen.
 *
 * This only affects the display mode used when the window is fullscreen. To
 * change the window size when the window is not fullscreen, use
 * SDL_SetWindowSize().
 *
 * If the window is currently in the fullscreen state, this request is
 * asynchronous on some windowing systems and the new mode dimensions may not
 * be applied immediately upon the return of this function. If an immediate
 * change is required, call SDL_SyncWindow() to block until the changes have
 * taken effect.
 *
 * When the new mode takes effect, an SDL_EVENT_WINDOW_RESIZED and/or an
 * SDL_EVENT_WINDOW_PIXEL_SIZE_CHANGED event will be emitted with the new mode
 * dimensions.
 *
 * \param window the window to affect.
 * \param mode a pointer to the display mode to use, which can be NULL for
 *             borderless fullscreen desktop mode, or one of the fullscreen
 *             modes returned by SDL_GetFullscreenDisplayModes() to set an
 *             exclusive fullscreen mode.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetWindowFullscreenMode
 * \sa SDL_SetWindowFullscreen
 * \sa SDL_SyncWindow
 *)
function SDL_SetWindowFullscreenMode(window: SDL_Window; const mode: PSDL_DisplayMode): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetWindowFullscreenMode';

(**
 * Query the display mode to use when a window is visible at fullscreen.
 *
 * \param window the window to query.
 * \returns a pointer to the exclusive fullscreen mode to use or NULL for
 *          borderless fullscreen desktop mode.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetWindowFullscreenMode
 * \sa SDL_SetWindowFullscreen
 *)
function SDL_GetWindowFullscreenMode(window: SDL_Window): PSDL_DisplayMode; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetWindowFullscreenMode';

(**
 * Get the raw ICC profile data for the screen the window is currently on.
 *
 * \param window the window to query.
 * \param size the size of the ICC profile.
 * \returns the raw ICC profile data on success or NULL on failure; call
 *          SDL_GetError() for more information. This should be freed with
 *          SDL_free() when it is no longer needed.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetWindowICCProfile(window: SDL_Window; size: PNativeUInt): Pointer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetWindowICCProfile';

(**
 * Get the pixel format associated with the window.
 *
 * \param window the window to query.
 * \returns the pixel format of the window on success or
 *          SDL_PIXELFORMAT_UNKNOWN on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetWindowPixelFormat(window: SDL_Window): SDL_PixelFormat; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetWindowPixelFormat';

(**
 * Get a list of valid windows.
 *
 * \param count a pointer filled in with the number of windows returned, may
 *              be NULL.
 * \returns a NULL terminated array of SDL_Window pointers or NULL on failure;
 *          call SDL_GetError() for more information. This is a single
 *          allocation that should be freed with SDL_free() when it is no
 *          longer needed.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetWindows(count: PInteger): PSDL_Window; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetWindows';

(**
 * Create a window with the specified dimensions and flags.
 *
 * `flags` may be any of the following OR'd together:
 *
 * - `SDL_WINDOW_FULLSCREEN`: fullscreen window at desktop resolution
 * - `SDL_WINDOW_OPENGL`: window usable with an OpenGL context
 * - `SDL_WINDOW_OCCLUDED`: window partially or completely obscured by another
 *   window
 * - `SDL_WINDOW_HIDDEN`: window is not visible
 * - `SDL_WINDOW_BORDERLESS`: no window decoration
 * - `SDL_WINDOW_RESIZABLE`: window can be resized
 * - `SDL_WINDOW_MINIMIZED`: window is minimized
 * - `SDL_WINDOW_MAXIMIZED`: window is maximized
 * - `SDL_WINDOW_MOUSE_GRABBED`: window has grabbed mouse focus
 * - `SDL_WINDOW_INPUT_FOCUS`: window has input focus
 * - `SDL_WINDOW_MOUSE_FOCUS`: window has mouse focus
 * - `SDL_WINDOW_EXTERNAL`: window not created by SDL
 * - `SDL_WINDOW_MODAL`: window is modal
 * - `SDL_WINDOW_HIGH_PIXEL_DENSITY`: window uses high pixel density back
 *   buffer if possible
 * - `SDL_WINDOW_MOUSE_CAPTURE`: window has mouse captured (unrelated to
 *   MOUSE_GRABBED)
 * - `SDL_WINDOW_ALWAYS_ON_TOP`: window should always be above others
 * - `SDL_WINDOW_UTILITY`: window should be treated as a utility window, not
 *   showing in the task bar and window list
 * - `SDL_WINDOW_TOOLTIP`: window should be treated as a tooltip and does not
 *   get mouse or keyboard focus, requires a parent window
 * - `SDL_WINDOW_POPUP_MENU`: window should be treated as a popup menu,
 *   requires a parent window
 * - `SDL_WINDOW_KEYBOARD_GRABBED`: window has grabbed keyboard input
 * - `SDL_WINDOW_VULKAN`: window usable with a Vulkan instance
 * - `SDL_WINDOW_METAL`: window usable with a Metal instance
 * - `SDL_WINDOW_TRANSPARENT`: window with transparent buffer
 * - `SDL_WINDOW_NOT_FOCUSABLE`: window should not be focusable
 *
 * The SDL_Window is implicitly shown if SDL_WINDOW_HIDDEN is not set.
 *
 * On Apple's macOS, you **must** set the NSHighResolutionCapable Info.plist
 * property to YES, otherwise you will not receive a High-DPI OpenGL canvas.
 *
 * The window pixel size may differ from its window coordinate size if the
 * window is on a high pixel density display. Use SDL_GetWindowSize() to query
 * the client area's size in window coordinates, and
 * SDL_GetWindowSizeInPixels() or SDL_GetRenderOutputSize() to query the
 * drawable size in pixels. Note that the drawable size can vary after the
 * window is created and should be queried again if you get an
 * SDL_EVENT_WINDOW_PIXEL_SIZE_CHANGED event.
 *
 * If the window is created with any of the SDL_WINDOW_OPENGL or
 * SDL_WINDOW_VULKAN flags, then the corresponding LoadLibrary function
 * (SDL_GL_LoadLibrary or SDL_Vulkan_LoadLibrary) is called and the
 * corresponding UnloadLibrary function is called by SDL_DestroyWindow().
 *
 * If SDL_WINDOW_VULKAN is specified and there isn't a working Vulkan driver,
 * SDL_CreateWindow() will fail, because SDL_Vulkan_LoadLibrary() will fail.
 *
 * If SDL_WINDOW_METAL is specified on an OS that does not support Metal,
 * SDL_CreateWindow() will fail.
 *
 * If you intend to use this window with an SDL_Renderer, you should use
 * SDL_CreateWindowAndRenderer() instead of this function, to avoid window
 * flicker.
 *
 * On non-Apple devices, SDL requires you to either not link to the Vulkan
 * loader or link to a dynamic library version. This limitation may be removed
 * in a future version of SDL.
 *
 * \param title the title of the window, in UTF-8 encoding.
 * \param w the width of the window.
 * \param h the height of the window.
 * \param flags 0, or one or more SDL_WindowFlags OR'd together.
 * \returns the window that was created or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CreateWindowAndRenderer
 * \sa SDL_CreatePopupWindow
 * \sa SDL_CreateWindowWithProperties
 * \sa SDL_DestroyWindow
 *)
function SDL_CreateWindow(const title: PUTF8Char; w: Integer; h: Integer; flags: SDL_WindowFlags): SDL_Window; cdecl;
  external LIB_SDL3 name _PU + 'SDL_CreateWindow';

(**
 * Create a child popup window of the specified parent window.
 *
 * The flags parameter **must** contain at least one of the following:
 *
 * - `SDL_WINDOW_TOOLTIP`: The popup window is a tooltip and will not pass any
 *   input events.
 * - `SDL_WINDOW_POPUP_MENU`: The popup window is a popup menu. The topmost
 *   popup menu will implicitly gain the keyboard focus.
 *
 * The following flags are not relevant to popup window creation and will be
 * ignored:
 *
 * - `SDL_WINDOW_MINIMIZED`
 * - `SDL_WINDOW_MAXIMIZED`
 * - `SDL_WINDOW_FULLSCREEN`
 * - `SDL_WINDOW_BORDERLESS`
 *
 * The following flags are incompatible with popup window creation and will
 * cause it to fail:
 *
 * - `SDL_WINDOW_UTILITY`
 * - `SDL_WINDOW_MODAL`
 *
 * The parent parameter **must** be non-null and a valid window. The parent of
 * a popup window can be either a regular, toplevel window, or another popup
 * window.
 *
 * Popup windows cannot be minimized, maximized, made fullscreen, raised,
 * flash, be made a modal window, be the parent of a toplevel window, or grab
 * the mouse and/or keyboard. Attempts to do so will fail.
 *
 * Popup windows implicitly do not have a border/decorations and do not appear
 * on the taskbar/dock or in lists of windows such as alt-tab menus.
 *
 * If a parent window is hidden or destroyed, any child popup windows will be
 * recursively hidden or destroyed as well. Child popup windows not explicitly
 * hidden will be restored when the parent is shown.
 *
 * \param parent the parent of the window, must not be NULL.
 * \param offset_x the x position of the popup window relative to the origin
 *                 of the parent.
 * \param offset_y the y position of the popup window relative to the origin
 *                 of the parent window.
 * \param w the width of the window.
 * \param h the height of the window.
 * \param flags SDL_WINDOW_TOOLTIP or SDL_WINDOW_POPUP_MENU, and zero or more
 *              additional SDL_WindowFlags OR'd together.
 * \returns the window that was created or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CreateWindow
 * \sa SDL_CreateWindowWithProperties
 * \sa SDL_DestroyWindow
 * \sa SDL_GetWindowParent
 *)
function SDL_CreatePopupWindow(parent: SDL_Window; offset_x: Integer; offset_y: Integer; w: Integer; h: Integer; flags: SDL_WindowFlags): SDL_Window; cdecl;
  external LIB_SDL3 name _PU + 'SDL_CreatePopupWindow';

(**
 * Create a window with the specified properties.
 *
 * These are the supported properties:
 *
 * - `SDL_PROP_WINDOW_CREATE_ALWAYS_ON_TOP_BOOLEAN`: true if the window should
 *   be always on top
 * - `SDL_PROP_WINDOW_CREATE_BORDERLESS_BOOLEAN`: true if the window has no
 *   window decoration
 * - `SDL_PROP_WINDOW_CREATE_EXTERNAL_GRAPHICS_CONTEXT_BOOLEAN`: true if the
 *   window will be used with an externally managed graphics context.
 * - `SDL_PROP_WINDOW_CREATE_FOCUSABLE_BOOLEAN`: true if the window should
 *   accept keyboard input (defaults true)
 * - `SDL_PROP_WINDOW_CREATE_FULLSCREEN_BOOLEAN`: true if the window should
 *   start in fullscreen mode at desktop resolution
 * - `SDL_PROP_WINDOW_CREATE_HEIGHT_NUMBER`: the height of the window
 * - `SDL_PROP_WINDOW_CREATE_HIDDEN_BOOLEAN`: true if the window should start
 *   hidden
 * - `SDL_PROP_WINDOW_CREATE_HIGH_PIXEL_DENSITY_BOOLEAN`: true if the window
 *   uses a high pixel density buffer if possible
 * - `SDL_PROP_WINDOW_CREATE_MAXIMIZED_BOOLEAN`: true if the window should
 *   start maximized
 * - `SDL_PROP_WINDOW_CREATE_MENU_BOOLEAN`: true if the window is a popup menu
 * - `SDL_PROP_WINDOW_CREATE_METAL_BOOLEAN`: true if the window will be used
 *   with Metal rendering
 * - `SDL_PROP_WINDOW_CREATE_MINIMIZED_BOOLEAN`: true if the window should
 *   start minimized
 * - `SDL_PROP_WINDOW_CREATE_MODAL_BOOLEAN`: true if the window is modal to
 *   its parent
 * - `SDL_PROP_WINDOW_CREATE_MOUSE_GRABBED_BOOLEAN`: true if the window starts
 *   with grabbed mouse focus
 * - `SDL_PROP_WINDOW_CREATE_OPENGL_BOOLEAN`: true if the window will be used
 *   with OpenGL rendering
 * - `SDL_PROP_WINDOW_CREATE_PARENT_POINTER`: an SDL_Window that will be the
 *   parent of this window, required for windows with the "tooltip", "menu",
 *   and "modal" properties
 * - `SDL_PROP_WINDOW_CREATE_RESIZABLE_BOOLEAN`: true if the window should be
 *   resizable
 * - `SDL_PROP_WINDOW_CREATE_TITLE_STRING`: the title of the window, in UTF-8
 *   encoding
 * - `SDL_PROP_WINDOW_CREATE_TRANSPARENT_BOOLEAN`: true if the window show
 *   transparent in the areas with alpha of 0
 * - `SDL_PROP_WINDOW_CREATE_TOOLTIP_BOOLEAN`: true if the window is a tooltip
 * - `SDL_PROP_WINDOW_CREATE_UTILITY_BOOLEAN`: true if the window is a utility
 *   window, not showing in the task bar and window list
 * - `SDL_PROP_WINDOW_CREATE_VULKAN_BOOLEAN`: true if the window will be used
 *   with Vulkan rendering
 * - `SDL_PROP_WINDOW_CREATE_WIDTH_NUMBER`: the width of the window
 * - `SDL_PROP_WINDOW_CREATE_X_NUMBER`: the x position of the window, or
 *   `SDL_WINDOWPOS_CENTERED`, defaults to `SDL_WINDOWPOS_UNDEFINED`. This is
 *   relative to the parent for windows with the "tooltip" or "menu" property
 *   set.
 * - `SDL_PROP_WINDOW_CREATE_Y_NUMBER`: the y position of the window, or
 *   `SDL_WINDOWPOS_CENTERED`, defaults to `SDL_WINDOWPOS_UNDEFINED`. This is
 *   relative to the parent for windows with the "tooltip" or "menu" property
 *   set.
 *
 * These are additional supported properties on macOS:
 *
 * - `SDL_PROP_WINDOW_CREATE_COCOA_WINDOW_POINTER`: the
 *   `(__unsafe_unretained)` NSWindow associated with the window, if you want
 *   to wrap an existing window.
 * - `SDL_PROP_WINDOW_CREATE_COCOA_VIEW_POINTER`: the `(__unsafe_unretained)`
 *   NSView associated with the window, defaults to `[window contentView]`
 *
 * These are additional supported properties on Wayland:
 *
 * - `SDL_PROP_WINDOW_CREATE_WAYLAND_SURFACE_ROLE_CUSTOM_BOOLEAN` - true if
 *   the application wants to use the Wayland surface for a custom role and
 *   does not want it attached to an XDG toplevel window. See
 *   [README/wayland](README/wayland) for more information on using custom
 *   surfaces.
 * - `SDL_PROP_WINDOW_CREATE_WAYLAND_CREATE_EGL_WINDOW_BOOLEAN` - true if the
 *   application wants an associated `wl_egl_window` object to be created and
 *   attached to the window, even if the window does not have the OpenGL
 *   property or `SDL_WINDOW_OPENGL` flag set.
 * - `SDL_PROP_WINDOW_CREATE_WAYLAND_WL_SURFACE_POINTER` - the wl_surface
 *   associated with the window, if you want to wrap an existing window. See
 *   [README/wayland](README/wayland) for more information.
 *
 * These are additional supported properties on Windows:
 *
 * - `SDL_PROP_WINDOW_CREATE_WIN32_HWND_POINTER`: the HWND associated with the
 *   window, if you want to wrap an existing window.
 * - `SDL_PROP_WINDOW_CREATE_WIN32_PIXEL_FORMAT_HWND_POINTER`: optional,
 *   another window to share pixel format with, useful for OpenGL windows
 *
 * These are additional supported properties with X11:
 *
 * - `SDL_PROP_WINDOW_CREATE_X11_WINDOW_NUMBER`: the X11 Window associated
 *   with the window, if you want to wrap an existing window.
 *
 * The window is implicitly shown if the "hidden" property is not set.
 *
 * Windows with the "tooltip" and "menu" properties are popup windows and have
 * the behaviors and guidelines outlined in SDL_CreatePopupWindow().
 *
 * If this window is being created to be used with an SDL_Renderer, you should
 * not add a graphics API specific property
 * (`SDL_PROP_WINDOW_CREATE_OPENGL_BOOLEAN`, etc), as SDL will handle that
 * internally when it chooses a renderer. However, SDL might need to recreate
 * your window at that point, which may cause the window to appear briefly,
 * and then flicker as it is recreated. The correct approach to this is to
 * create the window with the `SDL_PROP_WINDOW_CREATE_HIDDEN_BOOLEAN` property
 * set to true, then create the renderer, then show the window with
 * SDL_ShowWindow().
 *
 * \param props the properties to use.
 * \returns the window that was created or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CreateProperties
 * \sa SDL_CreateWindow
 * \sa SDL_DestroyWindow
 *)
function SDL_CreateWindowWithProperties(props: SDL_PropertiesID): SDL_Window; cdecl;
  external LIB_SDL3 name _PU + 'SDL_CreateWindowWithProperties';

const
  SDL_PROP_WINDOW_CREATE_ALWAYS_ON_TOP_BOOLEAN = 'SDL.window.create.always_on_top';
  SDL_PROP_WINDOW_CREATE_BORDERLESS_BOOLEAN = 'SDL.window.create.borderless';
  SDL_PROP_WINDOW_CREATE_FOCUSABLE_BOOLEAN = 'SDL.window.create.focusable';
  SDL_PROP_WINDOW_CREATE_EXTERNAL_GRAPHICS_CONTEXT_BOOLEAN = 'SDL.window.create.external_graphics_context';
  SDL_PROP_WINDOW_CREATE_FLAGS_NUMBER = 'SDL.window.create.flags';
  SDL_PROP_WINDOW_CREATE_FULLSCREEN_BOOLEAN = 'SDL.window.create.fullscreen';
  SDL_PROP_WINDOW_CREATE_HEIGHT_NUMBER = 'SDL.window.create.height';
  SDL_PROP_WINDOW_CREATE_HIDDEN_BOOLEAN = 'SDL.window.create.hidden';
  SDL_PROP_WINDOW_CREATE_HIGH_PIXEL_DENSITY_BOOLEAN = 'SDL.window.create.high_pixel_density';
  SDL_PROP_WINDOW_CREATE_MAXIMIZED_BOOLEAN = 'SDL.window.create.maximized';
  SDL_PROP_WINDOW_CREATE_MENU_BOOLEAN = 'SDL.window.create.menu';
  SDL_PROP_WINDOW_CREATE_METAL_BOOLEAN = 'SDL.window.create.metal';
  SDL_PROP_WINDOW_CREATE_MINIMIZED_BOOLEAN = 'SDL.window.create.minimized';
  SDL_PROP_WINDOW_CREATE_MODAL_BOOLEAN = 'SDL.window.create.modal';
  SDL_PROP_WINDOW_CREATE_MOUSE_GRABBED_BOOLEAN = 'SDL.window.create.mouse_grabbed';
  SDL_PROP_WINDOW_CREATE_OPENGL_BOOLEAN = 'SDL.window.create.opengl';
  SDL_PROP_WINDOW_CREATE_PARENT_POINTER = 'SDL.window.create.parent';
  SDL_PROP_WINDOW_CREATE_RESIZABLE_BOOLEAN = 'SDL.window.create.resizable';
  SDL_PROP_WINDOW_CREATE_TITLE_STRING = 'SDL.window.create.title';
  SDL_PROP_WINDOW_CREATE_TRANSPARENT_BOOLEAN = 'SDL.window.create.transparent';
  SDL_PROP_WINDOW_CREATE_TOOLTIP_BOOLEAN = 'SDL.window.create.tooltip';
  SDL_PROP_WINDOW_CREATE_UTILITY_BOOLEAN = 'SDL.window.create.utility';
  SDL_PROP_WINDOW_CREATE_VULKAN_BOOLEAN = 'SDL.window.create.vulkan';
  SDL_PROP_WINDOW_CREATE_WIDTH_NUMBER = 'SDL.window.create.width';
  SDL_PROP_WINDOW_CREATE_X_NUMBER = 'SDL.window.create.x';
  SDL_PROP_WINDOW_CREATE_Y_NUMBER = 'SDL.window.create.y';
  SDL_PROP_WINDOW_CREATE_COCOA_WINDOW_POINTER = 'SDL.window.create.cocoa.window';
  SDL_PROP_WINDOW_CREATE_COCOA_VIEW_POINTER = 'SDL.window.create.cocoa.view';
  SDL_PROP_WINDOW_CREATE_WAYLAND_SURFACE_ROLE_CUSTOM_BOOLEAN = 'SDL.window.create.wayland.surface_role_custom';
  SDL_PROP_WINDOW_CREATE_WAYLAND_CREATE_EGL_WINDOW_BOOLEAN = 'SDL.window.create.wayland.create_egl_window';
  SDL_PROP_WINDOW_CREATE_WAYLAND_WL_SURFACE_POINTER = 'SDL.window.create.wayland.wl_surface';
  SDL_PROP_WINDOW_CREATE_WIN32_HWND_POINTER = 'SDL.window.create.win32.hwnd';
  SDL_PROP_WINDOW_CREATE_WIN32_PIXEL_FORMAT_HWND_POINTER = 'SDL.window.create.win32.pixel_format_hwnd';
  SDL_PROP_WINDOW_CREATE_X11_WINDOW_NUMBER = 'SDL.window.create.x11.window';

(**
 * Get the numeric ID of a window.
 *
 * The numeric ID is what SDL_WindowEvent references, and is necessary to map
 * these events to specific SDL_Window objects.
 *
 * \param window the window to query.
 * \returns the ID of the window on success or 0 on failure; call
 *          SDL_GetError() for more information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetWindowFromID
 *)
function SDL_GetWindowID(window: SDL_Window): SDL_WindowID; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetWindowID';

(**
 * Get a window from a stored ID.
 *
 * The numeric ID is what SDL_WindowEvent references, and is necessary to map
 * these events to specific SDL_Window objects.
 *
 * \param id the ID of the window.
 * \returns the window associated with `id` or NULL if it doesn't exist; call
 *          SDL_GetError() for more information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetWindowID
 *)
function SDL_GetWindowFromID(id: SDL_WindowID): SDL_Window; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetWindowFromID';

(**
 * Get parent of a window.
 *
 * \param window the window to query.
 * \returns the parent of the window on success or NULL if the window has no
 *          parent.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CreatePopupWindow
 *)
function SDL_GetWindowParent(window: SDL_Window): SDL_Window; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetWindowParent';

(**
 * Get the properties associated with a window.
 *
 * The following read-only properties are provided by SDL:
 *
 * - `SDL_PROP_WINDOW_SHAPE_POINTER`: the surface associated with a shaped
 *   window
 * - `SDL_PROP_WINDOW_HDR_ENABLED_BOOLEAN`: true if the window has HDR
 *   headroom above the SDR white point. This property can change dynamically
 *   when SDL_EVENT_WINDOW_HDR_STATE_CHANGED is sent.
 * - `SDL_PROP_WINDOW_SDR_WHITE_LEVEL_FLOAT`: the value of SDR white in the
 *   SDL_COLORSPACE_SRGB_LINEAR colorspace. On Windows this corresponds to the
 *   SDR white level in scRGB colorspace, and on Apple platforms this is
 *   always 1.0 for EDR content. This property can change dynamically when
 *   SDL_EVENT_WINDOW_HDR_STATE_CHANGED is sent.
 * - `SDL_PROP_WINDOW_HDR_HEADROOM_FLOAT`: the additional high dynamic range
 *   that can be displayed, in terms of the SDR white point. When HDR is not
 *   enabled, this will be 1.0. This property can change dynamically when
 *   SDL_EVENT_WINDOW_HDR_STATE_CHANGED is sent.
 *
 * On Android:
 *
 * - `SDL_PROP_WINDOW_ANDROID_WINDOW_POINTER`: the ANativeWindow associated
 *   with the window
 * - `SDL_PROP_WINDOW_ANDROID_SURFACE_POINTER`: the EGLSurface associated with
 *   the window
 *
 * On iOS:
 *
 * - `SDL_PROP_WINDOW_UIKIT_WINDOW_POINTER`: the `(__unsafe_unretained)`
 *   UIWindow associated with the window
 * - `SDL_PROP_WINDOW_UIKIT_METAL_VIEW_TAG_NUMBER`: the NSInteger tag
 *   associated with metal views on the window
 * - `SDL_PROP_WINDOW_UIKIT_OPENGL_FRAMEBUFFER_NUMBER`: the OpenGL view's
 *   framebuffer object. It must be bound when rendering to the screen using
 *   OpenGL.
 * - `SDL_PROP_WINDOW_UIKIT_OPENGL_RENDERBUFFER_NUMBER`: the OpenGL view's
 *   renderbuffer object. It must be bound when SDL_GL_SwapWindow is called.
 * - `SDL_PROP_WINDOW_UIKIT_OPENGL_RESOLVE_FRAMEBUFFER_NUMBER`: the OpenGL
 *   view's resolve framebuffer, when MSAA is used.
 *
 * On KMS/DRM:
 *
 * - `SDL_PROP_WINDOW_KMSDRM_DEVICE_INDEX_NUMBER`: the device index associated
 *   with the window (e.g. the X in /dev/dri/cardX)
 * - `SDL_PROP_WINDOW_KMSDRM_DRM_FD_NUMBER`: the DRM FD associated with the
 *   window
 * - `SDL_PROP_WINDOW_KMSDRM_GBM_DEVICE_POINTER`: the GBM device associated
 *   with the window
 *
 * On macOS:
 *
 * - `SDL_PROP_WINDOW_COCOA_WINDOW_POINTER`: the `(__unsafe_unretained)`
 *   NSWindow associated with the window
 * - `SDL_PROP_WINDOW_COCOA_METAL_VIEW_TAG_NUMBER`: the NSInteger tag
 *   assocated with metal views on the window
 *
 * On OpenVR:
 *
 * - `SDL_PROP_WINDOW_OPENVR_OVERLAY_ID`: the OpenVR Overlay Handle ID for the
 *   associated overlay window.
 *
 * On Vivante:
 *
 * - `SDL_PROP_WINDOW_VIVANTE_DISPLAY_POINTER`: the EGLNativeDisplayType
 *   associated with the window
 * - `SDL_PROP_WINDOW_VIVANTE_WINDOW_POINTER`: the EGLNativeWindowType
 *   associated with the window
 * - `SDL_PROP_WINDOW_VIVANTE_SURFACE_POINTER`: the EGLSurface associated with
 *   the window
 *
 * On Windows:
 *
 * - `SDL_PROP_WINDOW_WIN32_HWND_POINTER`: the HWND associated with the window
 * - `SDL_PROP_WINDOW_WIN32_HDC_POINTER`: the HDC associated with the window
 * - `SDL_PROP_WINDOW_WIN32_INSTANCE_POINTER`: the HINSTANCE associated with
 *   the window
 *
 * On Wayland:
 *
 * Note: The `xdg_*` window objects do not internally persist across window
 * show/hide calls. They will be null if the window is hidden and must be
 * queried each time it is shown.
 *
 * - `SDL_PROP_WINDOW_WAYLAND_DISPLAY_POINTER`: the wl_display associated with
 *   the window
 * - `SDL_PROP_WINDOW_WAYLAND_SURFACE_POINTER`: the wl_surface associated with
 *   the window
 * - `SDL_PROP_WINDOW_WAYLAND_VIEWPORT_POINTER`: the wp_viewport associated
 *   with the window
 * - `SDL_PROP_WINDOW_WAYLAND_EGL_WINDOW_POINTER`: the wl_egl_window
 *   associated with the window
 * - `SDL_PROP_WINDOW_WAYLAND_XDG_SURFACE_POINTER`: the xdg_surface associated
 *   with the window
 * - `SDL_PROP_WINDOW_WAYLAND_XDG_TOPLEVEL_POINTER`: the xdg_toplevel role
 *   associated with the window
 * - 'SDL_PROP_WINDOW_WAYLAND_XDG_TOPLEVEL_EXPORT_HANDLE_STRING': the export
 *   handle associated with the window
 * - `SDL_PROP_WINDOW_WAYLAND_XDG_POPUP_POINTER`: the xdg_popup role
 *   associated with the window
 * - `SDL_PROP_WINDOW_WAYLAND_XDG_POSITIONER_POINTER`: the xdg_positioner
 *   associated with the window, in popup mode
 *
 * On X11:
 *
 * - `SDL_PROP_WINDOW_X11_DISPLAY_POINTER`: the X11 Display associated with
 *   the window
 * - `SDL_PROP_WINDOW_X11_SCREEN_NUMBER`: the screen number associated with
 *   the window
 * - `SDL_PROP_WINDOW_X11_WINDOW_NUMBER`: the X11 Window associated with the
 *   window
 *
 * \param window the window to query.
 * \returns a valid property ID on success or 0 on failure; call
 *          SDL_GetError() for more information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetWindowProperties(window: SDL_Window): SDL_PropertiesID; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetWindowProperties';

const
  SDL_PROP_WINDOW_SHAPE_POINTER = 'SDL.window.shape';
  SDL_PROP_WINDOW_HDR_ENABLED_BOOLEAN = 'SDL.window.HDR_enabled';
  SDL_PROP_WINDOW_SDR_WHITE_LEVEL_FLOAT = 'SDL.window.SDR_white_level';
  SDL_PROP_WINDOW_HDR_HEADROOM_FLOAT = 'SDL.window.HDR_headroom';
  SDL_PROP_WINDOW_ANDROID_WINDOW_POINTER = 'SDL.window.android.window';
  SDL_PROP_WINDOW_ANDROID_SURFACE_POINTER = 'SDL.window.android.surface';
  SDL_PROP_WINDOW_UIKIT_WINDOW_POINTER = 'SDL.window.uikit.window';
  SDL_PROP_WINDOW_UIKIT_METAL_VIEW_TAG_NUMBER = 'SDL.window.uikit.metal_view_tag';
  SDL_PROP_WINDOW_UIKIT_OPENGL_FRAMEBUFFER_NUMBER = 'SDL.window.uikit.opengl.framebuffer';
  SDL_PROP_WINDOW_UIKIT_OPENGL_RENDERBUFFER_NUMBER = 'SDL.window.uikit.opengl.renderbuffer';
  SDL_PROP_WINDOW_UIKIT_OPENGL_RESOLVE_FRAMEBUFFER_NUMBER = 'SDL.window.uikit.opengl.resolve_framebuffer';
  SDL_PROP_WINDOW_KMSDRM_DEVICE_INDEX_NUMBER = 'SDL.window.kmsdrm.dev_index';
  SDL_PROP_WINDOW_KMSDRM_DRM_FD_NUMBER = 'SDL.window.kmsdrm.drm_fd';
  SDL_PROP_WINDOW_KMSDRM_GBM_DEVICE_POINTER = 'SDL.window.kmsdrm.gbm_dev';
  SDL_PROP_WINDOW_COCOA_WINDOW_POINTER = 'SDL.window.cocoa.window';
  SDL_PROP_WINDOW_COCOA_METAL_VIEW_TAG_NUMBER = 'SDL.window.cocoa.metal_view_tag';
  SDL_PROP_WINDOW_OPENVR_OVERLAY_ID = 'SDL.window.openvr.overlay_id';
  SDL_PROP_WINDOW_VIVANTE_DISPLAY_POINTER = 'SDL.window.vivante.display';
  SDL_PROP_WINDOW_VIVANTE_WINDOW_POINTER = 'SDL.window.vivante.window';
  SDL_PROP_WINDOW_VIVANTE_SURFACE_POINTER = 'SDL.window.vivante.surface';
  SDL_PROP_WINDOW_WIN32_HWND_POINTER = 'SDL.window.win32.hwnd';
  SDL_PROP_WINDOW_WIN32_HDC_POINTER = 'SDL.window.win32.hdc';
  SDL_PROP_WINDOW_WIN32_INSTANCE_POINTER = 'SDL.window.win32.instance';
  SDL_PROP_WINDOW_WAYLAND_DISPLAY_POINTER = 'SDL.window.wayland.display';
  SDL_PROP_WINDOW_WAYLAND_SURFACE_POINTER = 'SDL.window.wayland.surface';
  SDL_PROP_WINDOW_WAYLAND_VIEWPORT_POINTER = 'SDL.window.wayland.viewport';
  SDL_PROP_WINDOW_WAYLAND_EGL_WINDOW_POINTER = 'SDL.window.wayland.egl_window';
  SDL_PROP_WINDOW_WAYLAND_XDG_SURFACE_POINTER = 'SDL.window.wayland.xdg_surface';
  SDL_PROP_WINDOW_WAYLAND_XDG_TOPLEVEL_POINTER = 'SDL.window.wayland.xdg_toplevel';
  SDL_PROP_WINDOW_WAYLAND_XDG_TOPLEVEL_EXPORT_HANDLE_STRING = 'SDL.window.wayland.xdg_toplevel_export_handle';
  SDL_PROP_WINDOW_WAYLAND_XDG_POPUP_POINTER = 'SDL.window.wayland.xdg_popup';
  SDL_PROP_WINDOW_WAYLAND_XDG_POSITIONER_POINTER = 'SDL.window.wayland.xdg_positioner';
  SDL_PROP_WINDOW_X11_DISPLAY_POINTER = 'SDL.window.x11.display';
  SDL_PROP_WINDOW_X11_SCREEN_NUMBER = 'SDL.window.x11.screen';
  SDL_PROP_WINDOW_X11_WINDOW_NUMBER = 'SDL.window.x11.window';

(**
 * Get the window flags.
 *
 * \param window the window to query.
 * \returns a mask of the SDL_WindowFlags associated with `window`.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CreateWindow
 * \sa SDL_HideWindow
 * \sa SDL_MaximizeWindow
 * \sa SDL_MinimizeWindow
 * \sa SDL_SetWindowFullscreen
 * \sa SDL_SetWindowMouseGrab
 * \sa SDL_ShowWindow
 *)
function SDL_GetWindowFlags(window: SDL_Window): SDL_WindowFlags; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetWindowFlags';

(**
 * Set the title of a window.
 *
 * This string is expected to be in UTF-8 encoding.
 *
 * \param window the window to change.
 * \param title the desired window title in UTF-8 format.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetWindowTitle
 *)
function SDL_SetWindowTitle(window: SDL_Window; const title: PUTF8Char): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetWindowTitle';

(**
 * Get the title of a window.
 *
 * \param window the window to query.
 * \returns the title of the window in UTF-8 format or "" if there is no
 *          title.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetWindowTitle
 *)
function SDL_GetWindowTitle(window: SDL_Window): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetWindowTitle';

(**
 * Set the icon for a window.
 *
 * If this function is passed a surface with alternate representations, the
 * surface will be interpreted as the content to be used for 100% display
 * scale, and the alternate representations will be used for high DPI
 * situations. For example, if the original surface is 32x32, then on a 2x
 * macOS display or 200% display scale on Windows, a 64x64 version of the
 * image will be used, if available. If a matching version of the image isn't
 * available, the closest larger size image will be downscaled to the
 * appropriate size and be used instead, if available. Otherwise, the closest
 * smaller image will be upscaled and be used instead.
 *
 * \param window the window to change.
 * \param icon an SDL_Surface structure containing the icon for the window.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_SetWindowIcon(window: SDL_Window; icon: PSDL_Surface): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetWindowIcon';

(**
 * Request that the window's position be set.
 *
 * If the window is in an exclusive fullscreen or maximized state, this
 * request has no effect.
 *
 * This can be used to reposition fullscreen-desktop windows onto a different
 * display, however, as exclusive fullscreen windows are locked to a specific
 * display, they can only be repositioned programmatically via
 * SDL_SetWindowFullscreenMode().
 *
 * On some windowing systems this request is asynchronous and the new
 * coordinates may not have have been applied immediately upon the return of
 * this function. If an immediate change is required, call SDL_SyncWindow() to
 * block until the changes have taken effect.
 *
 * When the window position changes, an SDL_EVENT_WINDOW_MOVED event will be
 * emitted with the window's new coordinates. Note that the new coordinates
 * may not match the exact coordinates requested, as some windowing systems
 * can restrict the position of the window in certain scenarios (e.g.
 * constraining the position so the window is always within desktop bounds).
 * Additionally, as this is just a request, it can be denied by the windowing
 * system.
 *
 * \param window the window to reposition.
 * \param x the x coordinate of the window, or `SDL_WINDOWPOS_CENTERED` or
 *          `SDL_WINDOWPOS_UNDEFINED`.
 * \param y the y coordinate of the window, or `SDL_WINDOWPOS_CENTERED` or
 *          `SDL_WINDOWPOS_UNDEFINED`.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetWindowPosition
 * \sa SDL_SyncWindow
 *)
function SDL_SetWindowPosition(window: SDL_Window; x: Integer; y: Integer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetWindowPosition';

(**
 * Get the position of a window.
 *
 * This is the current position of the window as last reported by the
 * windowing system.
 *
 * If you do not need the value for one of the positions a NULL may be passed
 * in the `x` or `y` parameter.
 *
 * \param window the window to query.
 * \param x a pointer filled in with the x position of the window, may be
 *          NULL.
 * \param y a pointer filled in with the y position of the window, may be
 *          NULL.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetWindowPosition
 *)
function SDL_GetWindowPosition(window: SDL_Window; x: PInteger; y: PInteger): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetWindowPosition';

(**
 * Request that the size of a window's client area be set.
 *
 * If the window is in a fullscreen or maximized state, this request has no
 * effect.
 *
 * To change the exclusive fullscreen mode of a window, use
 * SDL_SetWindowFullscreenMode().
 *
 * On some windowing systems, this request is asynchronous and the new window
 * size may not have have been applied immediately upon the return of this
 * function. If an immediate change is required, call SDL_SyncWindow() to
 * block until the changes have taken effect.
 *
 * When the window size changes, an SDL_EVENT_WINDOW_RESIZED event will be
 * emitted with the new window dimensions. Note that the new dimensions may
 * not match the exact size requested, as some windowing systems can restrict
 * the window size in certain scenarios (e.g. constraining the size of the
 * content area to remain within the usable desktop bounds). Additionally, as
 * this is just a request, it can be denied by the windowing system.
 *
 * \param window the window to change.
 * \param w the width of the window, must be > 0.
 * \param h the height of the window, must be > 0.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetWindowSize
 * \sa SDL_SetWindowFullscreenMode
 * \sa SDL_SyncWindow
 *)
function SDL_SetWindowSize(window: SDL_Window; w: Integer; h: Integer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetWindowSize';

(**
 * Get the size of a window's client area.
 *
 * The window pixel size may differ from its window coordinate size if the
 * window is on a high pixel density display. Use SDL_GetWindowSizeInPixels()
 * or SDL_GetRenderOutputSize() to get the real client area size in pixels.
 *
 * \param window the window to query the width and height from.
 * \param w a pointer filled in with the width of the window, may be NULL.
 * \param h a pointer filled in with the height of the window, may be NULL.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetRenderOutputSize
 * \sa SDL_GetWindowSizeInPixels
 * \sa SDL_SetWindowSize
 *)
function SDL_GetWindowSize(window: SDL_Window; w: PInteger; h: PInteger): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetWindowSize';

(**
 * Get the safe area for this window.
 *
 * Some devices have portions of the screen which are partially obscured or
 * not interactive, possibly due to on-screen controls, curved edges, camera
 * notches, TV overscan, etc. This function provides the area of the window
 * which is safe to have interactable content. You should continue rendering
 * into the rest of the window, but it should not contain visually important
 * or interactible content.
 *
 * \param window the window to query.
 * \param rect a pointer filled in with the client area that is safe for
 *             interactive content.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetWindowSafeArea(window: SDL_Window; rect: PSDL_Rect): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetWindowSafeArea';

(**
 * Request that the aspect ratio of a window's client area be set.
 *
 * The aspect ratio is the ratio of width divided by height, e.g. 2560x1600
 * would be 1.6. Larger aspect ratios are wider and smaller aspect ratios are
 * narrower.
 *
 * If, at the time of this request, the window in a fixed-size state, such as
 * maximized or fullscreen, the request will be deferred until the window
 * exits this state and becomes resizable again.
 *
 * On some windowing systems, this request is asynchronous and the new window
 * aspect ratio may not have have been applied immediately upon the return of
 * this function. If an immediate change is required, call SDL_SyncWindow() to
 * block until the changes have taken effect.
 *
 * When the window size changes, an SDL_EVENT_WINDOW_RESIZED event will be
 * emitted with the new window dimensions. Note that the new dimensions may
 * not match the exact aspect ratio requested, as some windowing systems can
 * restrict the window size in certain scenarios (e.g. constraining the size
 * of the content area to remain within the usable desktop bounds).
 * Additionally, as this is just a request, it can be denied by the windowing
 * system.
 *
 * \param window the window to change.
 * \param min_aspect the minimum aspect ratio of the window, or 0.0f for no
 *                   limit.
 * \param max_aspect the maximum aspect ratio of the window, or 0.0f for no
 *                   limit.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetWindowAspectRatio
 * \sa SDL_SyncWindow
 *)
function SDL_SetWindowAspectRatio(window: SDL_Window; min_aspect: Single; max_aspect: Single): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetWindowAspectRatio';

(**
 * Get the size of a window's client area.
 *
 * \param window the window to query the width and height from.
 * \param min_aspect a pointer filled in with the minimum aspect ratio of the
 *                   window, may be NULL.
 * \param max_aspect a pointer filled in with the maximum aspect ratio of the
 *                   window, may be NULL.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetWindowAspectRatio
 *)
function SDL_GetWindowAspectRatio(window: SDL_Window; min_aspect: PSingle; max_aspect: PSingle): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetWindowAspectRatio';

(**
 * Get the size of a window's borders (decorations) around the client area.
 *
 * Note: If this function fails (returns false), the size values will be
 * initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the
 * window in question was borderless.
 *
 * Note: This function may fail on systems where the window has not yet been
 * decorated by the display server (for example, immediately after calling
 * SDL_CreateWindow). It is recommended that you wait at least until the
 * window has been presented and composited, so that the window system has a
 * chance to decorate the window and provide the border dimensions to SDL.
 *
 * This function also returns false if getting the information is not
 * supported.
 *
 * \param window the window to query the size values of the border
 *               (decorations) from.
 * \param top pointer to variable for storing the size of the top border; NULL
 *            is permitted.
 * \param left pointer to variable for storing the size of the left border;
 *             NULL is permitted.
 * \param bottom pointer to variable for storing the size of the bottom
 *               border; NULL is permitted.
 * \param right pointer to variable for storing the size of the right border;
 *              NULL is permitted.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetWindowSize
 *)
function SDL_GetWindowBordersSize(window: SDL_Window; top: PInteger; left: PInteger; bottom: PInteger; right: PInteger): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetWindowBordersSize';

(**
 * Get the size of a window's client area, in pixels.
 *
 * \param window the window from which the drawable size should be queried.
 * \param w a pointer to variable for storing the width in pixels, may be
 *          NULL.
 * \param h a pointer to variable for storing the height in pixels, may be
 *          NULL.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CreateWindow
 * \sa SDL_GetWindowSize
 *)
function SDL_GetWindowSizeInPixels(window: SDL_Window; w: PInteger; h: PInteger): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetWindowSizeInPixels';

(**
 * Set the minimum size of a window's client area.
 *
 * \param window the window to change.
 * \param min_w the minimum width of the window, or 0 for no limit.
 * \param min_h the minimum height of the window, or 0 for no limit.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetWindowMinimumSize
 * \sa SDL_SetWindowMaximumSize
 *)
function SDL_SetWindowMinimumSize(window: SDL_Window; min_w: Integer; min_h: Integer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetWindowMinimumSize';

(**
 * Get the minimum size of a window's client area.
 *
 * \param window the window to query.
 * \param w a pointer filled in with the minimum width of the window, may be
 *          NULL.
 * \param h a pointer filled in with the minimum height of the window, may be
 *          NULL.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetWindowMaximumSize
 * \sa SDL_SetWindowMinimumSize
 *)
function SDL_GetWindowMinimumSize(window: SDL_Window; w: PInteger; h: PInteger): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetWindowMinimumSize';

(**
 * Set the maximum size of a window's client area.
 *
 * \param window the window to change.
 * \param max_w the maximum width of the window, or 0 for no limit.
 * \param max_h the maximum height of the window, or 0 for no limit.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetWindowMaximumSize
 * \sa SDL_SetWindowMinimumSize
 *)
function SDL_SetWindowMaximumSize(window: SDL_Window; max_w: Integer; max_h: Integer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetWindowMaximumSize';

(**
 * Get the maximum size of a window's client area.
 *
 * \param window the window to query.
 * \param w a pointer filled in with the maximum width of the window, may be
 *          NULL.
 * \param h a pointer filled in with the maximum height of the window, may be
 *          NULL.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetWindowMinimumSize
 * \sa SDL_SetWindowMaximumSize
 *)
function SDL_GetWindowMaximumSize(window: SDL_Window; w: PInteger; h: PInteger): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetWindowMaximumSize';

(**
 * Set the border state of a window.
 *
 * This will add or remove the window's `SDL_WINDOW_BORDERLESS` flag and add
 * or remove the border from the actual window. This is a no-op if the
 * window's border already matches the requested state.
 *
 * You can't change the border state of a fullscreen window.
 *
 * \param window the window of which to change the border state.
 * \param bordered false to remove border, true to add border.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetWindowFlags
 *)
function SDL_SetWindowBordered(window: SDL_Window; bordered: Boolean): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetWindowBordered';

(**
 * Set the user-resizable state of a window.
 *
 * This will add or remove the window's `SDL_WINDOW_RESIZABLE` flag and
 * allow/disallow user resizing of the window. This is a no-op if the window's
 * resizable state already matches the requested state.
 *
 * You can't change the resizable state of a fullscreen window.
 *
 * \param window the window of which to change the resizable state.
 * \param resizable true to allow resizing, false to disallow.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetWindowFlags
 *)
function SDL_SetWindowResizable(window: SDL_Window; resizable: Boolean): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetWindowResizable';

(**
 * Set the window to always be above the others.
 *
 * This will add or remove the window's `SDL_WINDOW_ALWAYS_ON_TOP` flag. This
 * will bring the window to the front and keep the window above the rest.
 *
 * \param window the window of which to change the always on top state.
 * \param on_top true to set the window always on top, false to disable.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetWindowFlags
 *)
function SDL_SetWindowAlwaysOnTop(window: SDL_Window; on_top: Boolean): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetWindowAlwaysOnTop';

(**
 * Show a window.
 *
 * \param window the window to show.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_HideWindow
 * \sa SDL_RaiseWindow
 *)
function SDL_ShowWindow(window: SDL_Window): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_ShowWindow';

(**
 * Hide a window.
 *
 * \param window the window to hide.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_ShowWindow
 * \sa SDL_WINDOW_HIDDEN
 *)
function SDL_HideWindow(window: SDL_Window): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_HideWindow';

(**
 * Request that a window be raised above other windows and gain the input
 * focus.
 *
 * The result of this request is subject to desktop window manager policy,
 * particularly if raising the requested window would result in stealing focus
 * from another application. If the window is successfully raised and gains
 * input focus, an SDL_EVENT_WINDOW_FOCUS_GAINED event will be emitted, and
 * the window will have the SDL_WINDOW_INPUT_FOCUS flag set.
 *
 * \param window the window to raise.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_RaiseWindow(window: SDL_Window): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_RaiseWindow';

(**
 * Request that the window be made as large as possible.
 *
 * Non-resizable windows can't be maximized. The window must have the
 * SDL_WINDOW_RESIZABLE flag set, or this will have no effect.
 *
 * On some windowing systems this request is asynchronous and the new window
 * state may not have have been applied immediately upon the return of this
 * function. If an immediate change is required, call SDL_SyncWindow() to
 * block until the changes have taken effect.
 *
 * When the window state changes, an SDL_EVENT_WINDOW_MAXIMIZED event will be
 * emitted. Note that, as this is just a request, the windowing system can
 * deny the state change.
 *
 * When maximizing a window, whether the constraints set via
 * SDL_SetWindowMaximumSize() are honored depends on the policy of the window
 * manager. Win32 and macOS enforce the constraints when maximizing, while X11
 * and Wayland window managers may vary.
 *
 * \param window the window to maximize.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_MinimizeWindow
 * \sa SDL_RestoreWindow
 * \sa SDL_SyncWindow
 *)
function SDL_MaximizeWindow(window: SDL_Window): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_MaximizeWindow';

(**
 * Request that the window be minimized to an iconic representation.
 *
 * If the window is in a fullscreen state, this request has no direct effect.
 * It may alter the state the window is returned to when leaving fullscreen.
 *
 * On some windowing systems this request is asynchronous and the new window
 * state may not have been applied immediately upon the return of this
 * function. If an immediate change is required, call SDL_SyncWindow() to
 * block until the changes have taken effect.
 *
 * When the window state changes, an SDL_EVENT_WINDOW_MINIMIZED event will be
 * emitted. Note that, as this is just a request, the windowing system can
 * deny the state change.
 *
 * \param window the window to minimize.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_MaximizeWindow
 * \sa SDL_RestoreWindow
 * \sa SDL_SyncWindow
 *)
function SDL_MinimizeWindow(window: SDL_Window): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_MinimizeWindow';

(**
 * Request that the size and position of a minimized or maximized window be
 * restored.
 *
 * If the window is in a fullscreen state, this request has no direct effect.
 * It may alter the state the window is returned to when leaving fullscreen.
 *
 * On some windowing systems this request is asynchronous and the new window
 * state may not have have been applied immediately upon the return of this
 * function. If an immediate change is required, call SDL_SyncWindow() to
 * block until the changes have taken effect.
 *
 * When the window state changes, an SDL_EVENT_WINDOW_RESTORED event will be
 * emitted. Note that, as this is just a request, the windowing system can
 * deny the state change.
 *
 * \param window the window to restore.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_MaximizeWindow
 * \sa SDL_MinimizeWindow
 * \sa SDL_SyncWindow
 *)
function SDL_RestoreWindow(window: SDL_Window): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_RestoreWindow';

(**
 * Request that the window's fullscreen state be changed.
 *
 * By default a window in fullscreen state uses borderless fullscreen desktop
 * mode, but a specific exclusive display mode can be set using
 * SDL_SetWindowFullscreenMode().
 *
 * On some windowing systems this request is asynchronous and the new
 * fullscreen state may not have have been applied immediately upon the return
 * of this function. If an immediate change is required, call SDL_SyncWindow()
 * to block until the changes have taken effect.
 *
 * When the window state changes, an SDL_EVENT_WINDOW_ENTER_FULLSCREEN or
 * SDL_EVENT_WINDOW_LEAVE_FULLSCREEN event will be emitted. Note that, as this
 * is just a request, it can be denied by the windowing system.
 *
 * \param window the window to change.
 * \param fullscreen true for fullscreen mode, false for windowed mode.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetWindowFullscreenMode
 * \sa SDL_SetWindowFullscreenMode
 * \sa SDL_SyncWindow
 * \sa SDL_WINDOW_FULLSCREEN
 *)
function SDL_SetWindowFullscreen(window: SDL_Window; fullscreen: Boolean): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetWindowFullscreen';

(**
 * Block until any pending window state is finalized.
 *
 * On asynchronous windowing systems, this acts as a synchronization barrier
 * for pending window state. It will attempt to wait until any pending window
 * state has been applied and is guaranteed to return within finite time. Note
 * that for how long it can potentially block depends on the underlying window
 * system, as window state changes may involve somewhat lengthy animations
 * that must complete before the window is in its final requested state.
 *
 * On windowing systems where changes are immediate, this does nothing.
 *
 * \param window the window for which to wait for the pending state to be
 *               applied.
 * \returns true on success or false if the operation timed out before the
 *          window was in the requested state.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetWindowSize
 * \sa SDL_SetWindowPosition
 * \sa SDL_SetWindowFullscreen
 * \sa SDL_MinimizeWindow
 * \sa SDL_MaximizeWindow
 * \sa SDL_RestoreWindow
 * \sa SDL_HINT_VIDEO_SYNC_WINDOW_OPERATIONS
 *)
function SDL_SyncWindow(window: SDL_Window): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SyncWindow';

(**
 * Return whether the window has a surface associated with it.
 *
 * \param window the window to query.
 * \returns true if there is a surface associated with the window, or false
 *          otherwise.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetWindowSurface
 *)
function SDL_WindowHasSurface(window: SDL_Window): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_WindowHasSurface';

(**
 * Get the SDL surface associated with the window.
 *
 * A new surface will be created with the optimal format for the window, if
 * necessary. This surface will be freed when the window is destroyed. Do not
 * free this surface.
 *
 * This surface will be invalidated if the window is resized. After resizing a
 * window this function must be called again to return a valid surface.
 *
 * You may not combine this with 3D or the rendering API on this window.
 *
 * This function is affected by `SDL_HINT_FRAMEBUFFER_ACCELERATION`.
 *
 * \param window the window to query.
 * \returns the surface associated with the window, or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_DestroyWindowSurface
 * \sa SDL_WindowHasSurface
 * \sa SDL_UpdateWindowSurface
 * \sa SDL_UpdateWindowSurfaceRects
 *)
function SDL_GetWindowSurface(window: SDL_Window): PSDL_Surface; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetWindowSurface';

(**
 * Toggle VSync for the window surface.
 *
 * When a window surface is created, vsync defaults to
 * SDL_WINDOW_SURFACE_VSYNC_DISABLED.
 *
 * The `vsync` parameter can be 1 to synchronize present with every vertical
 * refresh, 2 to synchronize present with every second vertical refresh, etc.,
 * SDL_WINDOW_SURFACE_VSYNC_ADAPTIVE for late swap tearing (adaptive vsync),
 * or SDL_WINDOW_SURFACE_VSYNC_DISABLED to disable. Not every value is
 * supported by every driver, so you should check the return value to see
 * whether the requested setting is supported.
 *
 * \param window the window.
 * \param vsync the vertical refresh sync interval.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetWindowSurfaceVSync
 *)
function SDL_SetWindowSurfaceVSync(window: SDL_Window; vsync: Integer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetWindowSurfaceVSync';

const
  SDL_WINDOW_SURFACE_VSYNC_DISABLED = 0;
  SDL_WINDOW_SURFACE_VSYNC_ADAPTIVE = -1;

(**
 * Get VSync for the window surface.
 *
 * \param window the window to query.
 * \param vsync an int filled with the current vertical refresh sync interval.
 *              See SDL_SetWindowSurfaceVSync() for the meaning of the value.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetWindowSurfaceVSync
 *)
function SDL_GetWindowSurfaceVSync(window: SDL_Window; vsync: PInteger): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetWindowSurfaceVSync';

(**
 * Copy the window surface to the screen.
 *
 * This is the function you use to reflect any changes to the surface on the
 * screen.
 *
 * This function is equivalent to the SDL 1.2 API SDL_Flip().
 *
 * \param window the window to update.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetWindowSurface
 * \sa SDL_UpdateWindowSurfaceRects
 *)
function SDL_UpdateWindowSurface(window: SDL_Window): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_UpdateWindowSurface';

(**
 * Copy areas of the window surface to the screen.
 *
 * This is the function you use to reflect changes to portions of the surface
 * on the screen.
 *
 * This function is equivalent to the SDL 1.2 API SDL_UpdateRects().
 *
 * Note that this function will update _at least_ the rectangles specified,
 * but this is only intended as an optimization; in practice, this might
 * update more of the screen (or all of the screen!), depending on what method
 * SDL uses to send pixels to the system.
 *
 * \param window the window to update.
 * \param rects an array of SDL_Rect structures representing areas of the
 *              surface to copy, in pixels.
 * \param numrects the number of rectangles.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetWindowSurface
 * \sa SDL_UpdateWindowSurface
 *)
function SDL_UpdateWindowSurfaceRects(window: SDL_Window; const rects: PSDL_Rect; numrects: Integer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_UpdateWindowSurfaceRects';

(**
 * Destroy the surface associated with the window.
 *
 * \param window the window to update.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetWindowSurface
 * \sa SDL_WindowHasSurface
 *)
function SDL_DestroyWindowSurface(window: SDL_Window): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_DestroyWindowSurface';

(**
 * Set a window's keyboard grab mode.
 *
 * Keyboard grab enables capture of system keyboard shortcuts like Alt+Tab or
 * the Meta/Super key. Note that not all system keyboard shortcuts can be
 * captured by applications (one example is Ctrl+Alt+Del on Windows).
 *
 * This is primarily intended for specialized applications such as VNC clients
 * or VM frontends. Normal games should not use keyboard grab.
 *
 * When keyboard grab is enabled, SDL will continue to handle Alt+Tab when the
 * window is full-screen to ensure the user is not trapped in your
 * application. If you have a custom keyboard shortcut to exit fullscreen
 * mode, you may suppress this behavior with
 * `SDL_HINT_ALLOW_ALT_TAB_WHILE_GRABBED`.
 *
 * If the caller enables a grab while another window is currently grabbed, the
 * other window loses its grab in favor of the caller's window.
 *
 * \param window the window for which the keyboard grab mode should be set.
 * \param grabbed this is true to grab keyboard, and false to release.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetWindowKeyboardGrab
 * \sa SDL_SetWindowMouseGrab
 *)
function SDL_SetWindowKeyboardGrab(window: SDL_Window; grabbed: Boolean): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetWindowKeyboardGrab';

(**
 * Set a window's mouse grab mode.
 *
 * Mouse grab confines the mouse cursor to the window.
 *
 * \param window the window for which the mouse grab mode should be set.
 * \param grabbed this is true to grab mouse, and false to release.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetWindowMouseRect
 * \sa SDL_SetWindowMouseRect
 * \sa SDL_SetWindowMouseGrab
 * \sa SDL_SetWindowKeyboardGrab
 *)
function SDL_SetWindowMouseGrab(window: SDL_Window; grabbed: Boolean): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetWindowMouseGrab';

(**
 * Get a window's keyboard grab mode.
 *
 * \param window the window to query.
 * \returns true if keyboard is grabbed, and false otherwise.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetWindowKeyboardGrab
 *)
function SDL_GetWindowKeyboardGrab(window: SDL_Window): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetWindowKeyboardGrab';

(**
 * Get a window's mouse grab mode.
 *
 * \param window the window to query.
 * \returns true if mouse is grabbed, and false otherwise.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetWindowMouseRect
 * \sa SDL_SetWindowMouseRect
 * \sa SDL_SetWindowMouseGrab
 * \sa SDL_SetWindowKeyboardGrab
 *)
function SDL_GetWindowMouseGrab(window: SDL_Window): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetWindowMouseGrab';

(**
 * Get the window that currently has an input grab enabled.
 *
 * \returns the window if input is grabbed or NULL otherwise.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetWindowMouseGrab
 * \sa SDL_SetWindowKeyboardGrab
 *)
function SDL_GetGrabbedWindow(): SDL_Window; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetGrabbedWindow';

(**
 * Confines the cursor to the specified area of a window.
 *
 * Note that this does NOT grab the cursor, it only defines the area a cursor
 * is restricted to when the window has mouse focus.
 *
 * \param window the window that will be associated with the barrier.
 * \param rect a rectangle area in window-relative coordinates. If NULL the
 *             barrier for the specified window will be destroyed.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetWindowMouseRect
 * \sa SDL_GetWindowMouseGrab
 * \sa SDL_SetWindowMouseGrab
 *)
function SDL_SetWindowMouseRect(window: SDL_Window; const rect: PSDL_Rect): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetWindowMouseRect';

(**
 * Get the mouse confinement rectangle of a window.
 *
 * \param window the window to query.
 * \returns a pointer to the mouse confinement rectangle of a window, or NULL
 *          if there isn't one.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetWindowMouseRect
 * \sa SDL_GetWindowMouseGrab
 * \sa SDL_SetWindowMouseGrab
 *)
function SDL_GetWindowMouseRect(window: SDL_Window): PSDL_Rect; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetWindowMouseRect';

(**
 * Set the opacity for a window.
 *
 * The parameter `opacity` will be clamped internally between 0.0f
 * (transparent) and 1.0f (opaque).
 *
 * This function also returns false if setting the opacity isn't supported.
 *
 * \param window the window which will be made transparent or opaque.
 * \param opacity the opacity value (0.0f - transparent, 1.0f - opaque).
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetWindowOpacity
 *)
function SDL_SetWindowOpacity(window: SDL_Window; opacity: Single): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetWindowOpacity';

(**
 * Get the opacity of a window.
 *
 * If transparency isn't supported on this platform, opacity will be returned
 * as 1.0f without error.
 *
 * \param window the window to get the current opacity value from.
 * \returns the opacity, (0.0f - transparent, 1.0f - opaque), or -1.0f on
 *          failure; call SDL_GetError() for more information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetWindowOpacity
 *)
function SDL_GetWindowOpacity(window: SDL_Window): Single; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetWindowOpacity';

(**
 * Set the window as a child of a parent window.
 *
 * If the window is already the child of an existing window, it will be
 * reparented to the new owner. Setting the parent window to NULL unparents
 * the window and removes child window status.
 *
 * If a parent window is hidden or destroyed, the operation will be
 * recursively applied to child windows. Child windows hidden with the parent
 * that did not have their hidden status explicitly set will be restored when
 * the parent is shown.
 *
 * Attempting to set the parent of a window that is currently in the modal
 * state will fail. Use SDL_SetWindowModal() to cancel the modal status before
 * attempting to change the parent.
 *
 * Popup windows cannot change parents and attempts to do so will fail.
 *
 * Setting a parent window that is currently the sibling or descendent of the
 * child window results in undefined behavior.
 *
 * \param window the window that should become the child of a parent.
 * \param parent the new parent window for the child window.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetWindowModal
 *)
function SDL_SetWindowParent(window: SDL_Window; parent: SDL_Window): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetWindowParent';

(**
 * Toggle the state of the window as modal.
 *
 * To enable modal status on a window, the window must currently be the child
 * window of a parent, or toggling modal status on will fail.
 *
 * \param window the window on which to set the modal state.
 * \param modal true to toggle modal status on, false to toggle it off.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetWindowParent
 * \sa SDL_WINDOW_MODAL
 *)
function SDL_SetWindowModal(window: SDL_Window; modal: Boolean): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetWindowModal';

(**
 * Set whether the window may have input focus.
 *
 * \param window the window to set focusable state.
 * \param focusable true to allow input focus, false to not allow input focus.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_SetWindowFocusable(window: SDL_Window; focusable: Boolean): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetWindowFocusable';

(**
 * Display the system-level window menu.
 *
 * This default window menu is provided by the system and on some platforms
 * provides functionality for setting or changing privileged state on the
 * window, such as moving it between workspaces or displays, or toggling the
 * always-on-top property.
 *
 * On platforms or desktops where this is unsupported, this function does
 * nothing.
 *
 * \param window the window for which the menu will be displayed.
 * \param x the x coordinate of the menu, relative to the origin (top-left) of
 *          the client area.
 * \param y the y coordinate of the menu, relative to the origin (top-left) of
 *          the client area.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_ShowWindowSystemMenu(window: SDL_Window; x: Integer; y: Integer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_ShowWindowSystemMenu';

(**
 * Possible return values from the SDL_HitTest callback.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This enum is available since SDL 3.2.0.
 *
 * \sa SDL_HitTest
 *)
type
  SDL_HitTestResult = Integer;

const
  (** Region is normal. No special properties. *)
  SDL_HITTEST_NORMAL = 0;
  (** Region can drag entire window. *)
  SDL_HITTEST_DRAGGABLE = 1;
  (** Region is the resizable top-left corner border. *)
  SDL_HITTEST_RESIZE_TOPLEFT = 2;
  (** Region is the resizable top border. *)
  SDL_HITTEST_RESIZE_TOP = 3;
  (** Region is the resizable top-right corner border. *)
  SDL_HITTEST_RESIZE_TOPRIGHT = 4;
  (** Region is the resizable right border. *)
  SDL_HITTEST_RESIZE_RIGHT = 5;
  (** Region is the resizable bottom-right corner border. *)
  SDL_HITTEST_RESIZE_BOTTOMRIGHT = 6;
  (** Region is the resizable bottom border. *)
  SDL_HITTEST_RESIZE_BOTTOM = 7;
  (** Region is the resizable bottom-left corner border. *)
  SDL_HITTEST_RESIZE_BOTTOMLEFT = 8;
  (** Region is the resizable left border. *)
  SDL_HITTEST_RESIZE_LEFT = 9;

type
  (**
   * Callback used for hit-testing.
   *
   * \param win the SDL_Window where hit-testing was set on.
   * \param area an SDL_Point which should be hit-tested.
   * \param data what was passed as `callback_data` to SDL_SetWindowHitTest().
   * \returns an SDL_HitTestResult value.
   *
   * \sa SDL_SetWindowHitTest
   *)
  SDL_HitTest = function(win: SDL_Window; const area: PSDL_Point; data: Pointer): SDL_HitTestResult; cdecl;

(**
 * Provide a callback that decides if a window region has special properties.
 *
 * Normally windows are dragged and resized by decorations provided by the
 * system window manager (a title bar, borders, etc), but for some apps, it
 * makes sense to drag them from somewhere else inside the window itself; for
 * example, one might have a borderless window that wants to be draggable from
 * any part, or simulate its own title bar, etc.
 *
 * This function lets the app provide a callback that designates pieces of a
 * given window as special. This callback is run during event processing if we
 * need to tell the OS to treat a region of the window specially; the use of
 * this callback is known as "hit testing."
 *
 * Mouse input may not be delivered to your application if it is within a
 * special area; the OS will often apply that input to moving the window or
 * resizing the window and not deliver it to the application.
 *
 * Specifying NULL for a callback disables hit-testing. Hit-testing is
 * disabled by default.
 *
 * Platforms that don't support this functionality will return false
 * unconditionally, even if you're attempting to disable hit-testing.
 *
 * Your callback may fire at any time, and its firing does not indicate any
 * specific behavior (for example, on Windows, this certainly might fire when
 * the OS is deciding whether to drag your window, but it fires for lots of
 * other reasons, too, some unrelated to anything you probably care about _and
 * when the mouse isn't actually at the location it is testing_). Since this
 * can fire at any time, you should try to keep your callback efficient,
 * devoid of allocations, etc.
 *
 * \param window the window to set hit-testing on.
 * \param callback the function to call when doing a hit-test.
 * \param callback_data an app-defined void pointer passed to **callback**.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_SetWindowHitTest(window: SDL_Window; callback: SDL_HitTest; callback_data: Pointer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetWindowHitTest';

(**
 * Set the shape of a transparent window.
 *
 * This sets the alpha channel of a transparent window and any fully
 * transparent areas are also transparent to mouse clicks. If you are using
 * something besides the SDL render API, then you are responsible for drawing
 * the alpha channel of the window to match the shape alpha channel to get
 * consistent cross-platform results.
 *
 * The shape is copied inside this function, so you can free it afterwards. If
 * your shape surface changes, you should call SDL_SetWindowShape() again to
 * update the window. This is an expensive operation, so should be done
 * sparingly.
 *
 * The window must have been created with the SDL_WINDOW_TRANSPARENT flag.
 *
 * \param window the window.
 * \param shape the surface representing the shape of the window, or NULL to
 *              remove any current shape.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_SetWindowShape(window: SDL_Window; shape: PSDL_Surface): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetWindowShape';

(**
 * Request a window to demand attention from the user.
 *
 * \param window the window to be flashed.
 * \param operation the operation to perform.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_FlashWindow(window: SDL_Window; operation: SDL_FlashOperation): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_FlashWindow';

(**
 * Destroy a window.
 *
 * Any child windows owned by the window will be recursively destroyed as
 * well.
 *
 * Note that on some platforms, the visible window may not actually be removed
 * from the screen until the SDL event loop is pumped again, even though the
 * SDL_Window is no longer valid after this call.
 *
 * \param window the window to destroy.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CreatePopupWindow
 * \sa SDL_CreateWindow
 * \sa SDL_CreateWindowWithProperties
 *)
procedure SDL_DestroyWindow(window: SDL_Window); cdecl;
  external LIB_SDL3 name _PU + 'SDL_DestroyWindow';

(**
 * Check whether the screensaver is currently enabled.
 *
 * The screensaver is disabled by default.
 *
 * The default can also be changed using `SDL_HINT_VIDEO_ALLOW_SCREENSAVER`.
 *
 * \returns true if the screensaver is enabled, false if it is disabled.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_DisableScreenSaver
 * \sa SDL_EnableScreenSaver
 *)
function SDL_ScreenSaverEnabled(): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_ScreenSaverEnabled';

(**
 * Allow the screen to be blanked by a screen saver.
 *
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_DisableScreenSaver
 * \sa SDL_ScreenSaverEnabled
 *)
function SDL_EnableScreenSaver(): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_EnableScreenSaver';

(**
 * Prevent the screen from being blanked by a screen saver.
 *
 * If you disable the screensaver, it is automatically re-enabled when SDL
 * quits.
 *
 * The screensaver is disabled by default, but this may by changed by
 * SDL_HINT_VIDEO_ALLOW_SCREENSAVER.
 *
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_EnableScreenSaver
 * \sa SDL_ScreenSaverEnabled
 *)
function SDL_DisableScreenSaver(): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_DisableScreenSaver';

(**
 * Dynamically load an OpenGL library.
 *
 * This should be done after initializing the video driver, but before
 * creating any OpenGL windows. If no OpenGL library is loaded, the default
 * library will be loaded upon creation of the first OpenGL window.
 *
 * If you do this, you need to retrieve all of the GL functions used in your
 * program from the dynamic library using SDL_GL_GetProcAddress().
 *
 * \param path the platform dependent OpenGL library name, or NULL to open the
 *             default OpenGL library.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GL_GetProcAddress
 * \sa SDL_GL_UnloadLibrary
 *)
function SDL_GL_LoadLibrary(const path: PUTF8Char): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GL_LoadLibrary';

(**
 * Get an OpenGL function by name.
 *
 * If the GL library is loaded at runtime with SDL_GL_LoadLibrary(), then all
 * GL functions must be retrieved this way. Usually this is used to retrieve
 * function pointers to OpenGL extensions.
 *
 * There are some quirks to looking up OpenGL functions that require some
 * extra care from the application. If you code carefully, you can handle
 * these quirks without any platform-specific code, though:
 *
 * - On Windows, function pointers are specific to the current GL context;
 *   this means you need to have created a GL context and made it current
 *   before calling SDL_GL_GetProcAddress(). If you recreate your context or
 *   create a second context, you should assume that any existing function
 *   pointers aren't valid to use with it. This is (currently) a
 *   Windows-specific limitation, and in practice lots of drivers don't suffer
 *   this limitation, but it is still the way the wgl API is documented to
 *   work and you should expect crashes if you don't respect it. Store a copy
 *   of the function pointers that comes and goes with context lifespan.
 * - On X11, function pointers returned by this function are valid for any
 *   context, and can even be looked up before a context is created at all.
 *   This means that, for at least some common OpenGL implementations, if you
 *   look up a function that doesn't exist, you'll get a non-NULL result that
 *   is _NOT_ safe to call. You must always make sure the function is actually
 *   available for a given GL context before calling it, by checking for the
 *   existence of the appropriate extension with SDL_GL_ExtensionSupported(),
 *   or verifying that the version of OpenGL you're using offers the function
 *   as core functionality.
 * - Some OpenGL drivers, on all platforms, *will* return NULL if a function
 *   isn't supported, but you can't count on this behavior. Check for
 *   extensions you use, and if you get a NULL anyway, act as if that
 *   extension wasn't available. This is probably a bug in the driver, but you
 *   can code defensively for this scenario anyhow.
 * - Just because you're on Linux/Unix, don't assume you'll be using X11.
 *   Next-gen display servers are waiting to replace it, and may or may not
 *   make the same promises about function pointers.
 * - OpenGL function pointers must be declared `APIENTRY` as in the example
 *   code. This will ensure the proper calling convention is followed on
 *   platforms where this matters (Win32) thereby avoiding stack corruption.
 *
 * \param proc the name of an OpenGL function.
 * \returns a pointer to the named OpenGL function. The returned pointer
 *          should be cast to the appropriate function signature.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GL_ExtensionSupported
 * \sa SDL_GL_LoadLibrary
 * \sa SDL_GL_UnloadLibrary
 *)
function SDL_GL_GetProcAddress(const proc: PUTF8Char): Pointer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GL_GetProcAddress';

(**
 * Get an EGL library function by name.
 *
 * If an EGL library is loaded, this function allows applications to get entry
 * points for EGL functions. This is useful to provide to an EGL API and
 * extension loader.
 *
 * \param proc the name of an EGL function.
 * \returns a pointer to the named EGL function. The returned pointer should
 *          be cast to the appropriate function signature.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_EGL_GetCurrentDisplay
 *)
function SDL_EGL_GetProcAddress(const proc: PUTF8Char): Pointer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_EGL_GetProcAddress';

(**
 * Unload the OpenGL library previously loaded by SDL_GL_LoadLibrary().
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GL_LoadLibrary
 *)
procedure SDL_GL_UnloadLibrary(); cdecl;
  external LIB_SDL3 name _PU + 'SDL_GL_UnloadLibrary';

(**
 * Check if an OpenGL extension is supported for the current context.
 *
 * This function operates on the current GL context; you must have created a
 * context and it must be current before calling this function. Do not assume
 * that all contexts you create will have the same set of extensions
 * available, or that recreating an existing context will offer the same
 * extensions again.
 *
 * While it's probably not a massive overhead, this function is not an O(1)
 * operation. Check the extensions you care about after creating the GL
 * context and save that information somewhere instead of calling the function
 * every time you need to know.
 *
 * \param extension the name of the extension to check.
 * \returns true if the extension is supported, false otherwise.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GL_ExtensionSupported(const extension: PUTF8Char): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GL_ExtensionSupported';

(**
 * Reset all previously set OpenGL context attributes to their default values.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GL_GetAttribute
 * \sa SDL_GL_SetAttribute
 *)
procedure SDL_GL_ResetAttributes(); cdecl;
  external LIB_SDL3 name _PU + 'SDL_GL_ResetAttributes';

(**
 * Set an OpenGL window attribute before window creation.
 *
 * This function sets the OpenGL attribute `attr` to `value`. The requested
 * attributes should be set before creating an OpenGL window. You should use
 * SDL_GL_GetAttribute() to check the values after creating the OpenGL
 * context, since the values obtained can differ from the requested ones.
 *
 * \param attr an SDL_GLAttr enum value specifying the OpenGL attribute to
 *             set.
 * \param value the desired value for the attribute.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GL_GetAttribute
 * \sa SDL_GL_ResetAttributes
 *)
function SDL_GL_SetAttribute(attr: SDL_GLAttr; value: Integer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GL_SetAttribute';

(**
 * Get the actual value for an attribute from the current context.
 *
 * \param attr an SDL_GLAttr enum value specifying the OpenGL attribute to
 *             get.
 * \param value a pointer filled in with the current value of `attr`.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GL_ResetAttributes
 * \sa SDL_GL_SetAttribute
 *)
function SDL_GL_GetAttribute(attr: SDL_GLAttr; value: PInteger): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GL_GetAttribute';

(**
 * Create an OpenGL context for an OpenGL window, and make it current.
 *
 * Windows users new to OpenGL should note that, for historical reasons, GL
 * functions added after OpenGL version 1.1 are not available by default.
 * Those functions must be loaded at run-time, either with an OpenGL
 * extension-handling library or with SDL_GL_GetProcAddress() and its related
 * functions.
 *
 * SDL_GLContext is opaque to the application.
 *
 * \param window the window to associate with the context.
 * \returns the OpenGL context associated with `window` or NULL on failure;
 *          call SDL_GetError() for more information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GL_DestroyContext
 * \sa SDL_GL_MakeCurrent
 *)
function SDL_GL_CreateContext(window: SDL_Window): SDL_GLContext; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GL_CreateContext';

(**
 * Set up an OpenGL context for rendering into an OpenGL window.
 *
 * The context must have been created with a compatible window.
 *
 * \param window the window to associate with the context.
 * \param context the OpenGL context to associate with the window.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GL_CreateContext
 *)
function SDL_GL_MakeCurrent(window: SDL_Window; context: SDL_GLContext): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GL_MakeCurrent';

(**
 * Get the currently active OpenGL window.
 *
 * \returns the currently active OpenGL window on success or NULL on failure;
 *          call SDL_GetError() for more information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GL_GetCurrentWindow(): SDL_Window; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GL_GetCurrentWindow';

(**
 * Get the currently active OpenGL context.
 *
 * \returns the currently active OpenGL context or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GL_MakeCurrent
 *)
function SDL_GL_GetCurrentContext(): SDL_GLContext; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GL_GetCurrentContext';

(**
 * Get the currently active EGL display.
 *
 * \returns the currently active EGL display or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_EGL_GetCurrentDisplay(): SDL_EGLDisplay; cdecl;
  external LIB_SDL3 name _PU + 'SDL_EGL_GetCurrentDisplay';

(**
 * Get the currently active EGL config.
 *
 * \returns the currently active EGL config or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_EGL_GetCurrentConfig(): SDL_EGLConfig; cdecl;
  external LIB_SDL3 name _PU + 'SDL_EGL_GetCurrentConfig';

(**
 * Get the EGL surface associated with the window.
 *
 * \param window the window to query.
 * \returns the EGLSurface pointer associated with the window, or NULL on
 *          failure.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_EGL_GetWindowSurface(window: SDL_Window): SDL_EGLSurface; cdecl;
  external LIB_SDL3 name _PU + 'SDL_EGL_GetWindowSurface';

(**
 * Sets the callbacks for defining custom EGLAttrib arrays for EGL
 * initialization.
 *
 * Callbacks that aren't needed can be set to NULL.
 *
 * NOTE: These callback pointers will be reset after SDL_GL_ResetAttributes.
 *
 * \param platformAttribCallback callback for attributes to pass to
 *                               eglGetPlatformDisplay. May be NULL.
 * \param surfaceAttribCallback callback for attributes to pass to
 *                              eglCreateSurface. May be NULL.
 * \param contextAttribCallback callback for attributes to pass to
 *                              eglCreateContext. May be NULL.
 * \param userdata a pointer that is passed to the callbacks.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_EGL_SetAttributeCallbacks(platformAttribCallback: SDL_EGLAttribArrayCallback; surfaceAttribCallback: SDL_EGLIntArrayCallback; contextAttribCallback: SDL_EGLIntArrayCallback; userdata: Pointer); cdecl;
  external LIB_SDL3 name _PU + 'SDL_EGL_SetAttributeCallbacks';

(**
 * Set the swap interval for the current OpenGL context.
 *
 * Some systems allow specifying -1 for the interval, to enable adaptive
 * vsync. Adaptive vsync works the same as vsync, but if you've already missed
 * the vertical retrace for a given frame, it swaps buffers immediately, which
 * might be less jarring for the user during occasional framerate drops. If an
 * application requests adaptive vsync and the system does not support it,
 * this function will fail and return false. In such a case, you should
 * probably retry the call with 1 for the interval.
 *
 * Adaptive vsync is implemented for some glX drivers with
 * GLX_EXT_swap_control_tear, and for some Windows drivers with
 * WGL_EXT_swap_control_tear.
 *
 * Read more on the Khronos wiki:
 * https://www.khronos.org/opengl/wiki/Swap_Interval#Adaptive_Vsync
 *
 * \param interval 0 for immediate updates, 1 for updates synchronized with
 *                 the vertical retrace, -1 for adaptive vsync.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GL_GetSwapInterval
 *)
function SDL_GL_SetSwapInterval(interval: Integer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GL_SetSwapInterval';

(**
 * Get the swap interval for the current OpenGL context.
 *
 * If the system can't determine the swap interval, or there isn't a valid
 * current context, this function will set *interval to 0 as a safe default.
 *
 * \param interval output interval value. 0 if there is no vertical retrace
 *                 synchronization, 1 if the buffer swap is synchronized with
 *                 the vertical retrace, and -1 if late swaps happen
 *                 immediately instead of waiting for the next retrace.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GL_SetSwapInterval
 *)
function SDL_GL_GetSwapInterval(interval: PInteger): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GL_GetSwapInterval';

(**
 * Update a window with OpenGL rendering.
 *
 * This is used with double-buffered OpenGL contexts, which are the default.
 *
 * On macOS, make sure you bind 0 to the draw framebuffer before swapping the
 * window, otherwise nothing will happen. If you aren't using
 * glBindFramebuffer(), this is the default and you won't have to do anything
 * extra.
 *
 * \param window the window to change.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GL_SwapWindow(window: SDL_Window): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GL_SwapWindow';

(**
 * Delete an OpenGL context.
 *
 * \param context the OpenGL context to be deleted.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GL_CreateContext
 *)
function SDL_GL_DestroyContext(context: SDL_GLContext): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GL_DestroyContext';
{$ENDREGION 'SDL_video.h'}

{$REGION 'SDL_dialog.h'}
(**
 * # CategoryDialog
 *
 * File dialog support.
 *
 * SDL offers file dialogs, to let users select files with native GUI
 * interfaces. There are "open" dialogs, "save" dialogs, and folder selection
 * dialogs. The app can control some details, such as filtering to specific
 * files, or whether multiple files can be selected by the user.
 *
 * Note that launching a file dialog is a non-blocking operation; control
 * returns to the app immediately, and a callback is called later (possibly in
 * another thread) when the user makes a choice.
 *)

type
  (**
   * An entry for filters for file dialogs.
   *
   * `name` is a user-readable label for the filter (for example, "Office
   * document").
   *
   * `pattern` is a semicolon-separated list of file extensions (for example,
   * "doc;docx"). File extensions may only contain alphanumeric characters,
   * hyphens, underscores and periods. Alternatively, the whole string can be a
   * single asterisk ("*"), which serves as an "All files" filter.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_DialogFileCallback
   * \sa SDL_ShowOpenFileDialog
   * \sa SDL_ShowSaveFileDialog
   * \sa SDL_ShowOpenFolderDialog
   * \sa SDL_ShowFileDialogWithProperties
   *)
  SDL_DialogFileFilter = record
    name: PUTF8Char;
    pattern: PUTF8Char;
  end;
  PSDL_DialogFileFilter = ^SDL_DialogFileFilter;

  (**
   * Callback used by file dialog functions.
   *
   * The specific usage is described in each function.
   *
   * If `filelist` is:
   *
   * - NULL, an error occurred. Details can be obtained with SDL_GetError().
   * - A pointer to NULL, the user either didn't choose any file or canceled the
   *   dialog.
   * - A pointer to non-`NULL`, the user chose one or more files. The argument
   *   is a null-terminated list of pointers to C strings, each containing a
   *   path.
   *
   * The filelist argument should not be freed; it will automatically be freed
   * when the callback returns.
   *
   * The filter argument is the index of the filter that was selected, or -1 if
   * no filter was selected or if the platform or method doesn't support
   * fetching the selected filter.
   *
   * In Android, the `filelist` are `content://` URIs. They should be opened
   * using SDL_IOFromFile() with appropriate modes. This applies both to open
   * and save file dialog.
   *
   * \param userdata an app-provided pointer, for the callback's use.
   * \param filelist the file(s) chosen by the user.
   * \param filter index of the selected filter.
   *
   * \since This datatype is available since SDL 3.2.0.
   *
   * \sa SDL_DialogFileFilter
   * \sa SDL_ShowOpenFileDialog
   * \sa SDL_ShowSaveFileDialog
   * \sa SDL_ShowOpenFolderDialog
   * \sa SDL_ShowFileDialogWithProperties
   *)
  SDL_DialogFileCallback = procedure(userdata: Pointer; const filelist: PPUTF8Char; filter: Integer); cdecl;

(**
 * Displays a dialog that lets the user select a file on their filesystem.
 *
 * This is an asynchronous function; it will return immediately, and the
 * result will be passed to the callback.
 *
 * The callback will be invoked with a null-terminated list of files the user
 * chose. The list will be empty if the user canceled the dialog, and it will
 * be NULL if an error occurred.
 *
 * Note that the callback may be called from a different thread than the one
 * the function was invoked on.
 *
 * Depending on the platform, the user may be allowed to input paths that
 * don't yet exist.
 *
 * On Linux, dialogs may require XDG Portals, which requires DBus, which
 * requires an event-handling loop. Apps that do not use SDL to handle events
 * should add a call to SDL_PumpEvents in their main loop.
 *
 * \param callback a function pointer to be invoked when the user selects a
 *                 file and accepts, or cancels the dialog, or an error
 *                 occurs.
 * \param userdata an optional pointer to pass extra data to the callback when
 *                 it will be invoked.
 * \param window the window that the dialog should be modal for, may be NULL.
 *               Not all platforms support this option.
 * \param filters a list of filters, may be NULL. Not all platforms support
 *                this option, and platforms that do support it may allow the
 *                user to ignore the filters. If non-NULL, it must remain
 *                valid at least until the callback is invoked.
 * \param nfilters the number of filters. Ignored if filters is NULL.
 * \param default_location the default folder or file to start the dialog at,
 *                         may be NULL. Not all platforms support this option.
 * \param allow_many if non-zero, the user will be allowed to select multiple
 *                   entries. Not all platforms support this option.
 *
 * \threadsafety This function should be called only from the main thread. The
 *               callback may be invoked from the same thread or from a
 *               different one, depending on the OS's constraints.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_DialogFileCallback
 * \sa SDL_DialogFileFilter
 * \sa SDL_ShowSaveFileDialog
 * \sa SDL_ShowOpenFolderDialog
 * \sa SDL_ShowFileDialogWithProperties
 *)
procedure SDL_ShowOpenFileDialog(callback: SDL_DialogFileCallback; userdata: Pointer; window: SDL_Window; const filters: PSDL_DialogFileFilter; nfilters: Integer; const default_location: PUTF8Char; allow_many: Boolean); cdecl;
  external LIB_SDL3 name _PU + 'SDL_ShowOpenFileDialog';

(**
 * Displays a dialog that lets the user choose a new or existing file on their
 * filesystem.
 *
 * This is an asynchronous function; it will return immediately, and the
 * result will be passed to the callback.
 *
 * The callback will be invoked with a null-terminated list of files the user
 * chose. The list will be empty if the user canceled the dialog, and it will
 * be NULL if an error occurred.
 *
 * Note that the callback may be called from a different thread than the one
 * the function was invoked on.
 *
 * The chosen file may or may not already exist.
 *
 * On Linux, dialogs may require XDG Portals, which requires DBus, which
 * requires an event-handling loop. Apps that do not use SDL to handle events
 * should add a call to SDL_PumpEvents in their main loop.
 *
 * \param callback a function pointer to be invoked when the user selects a
 *                 file and accepts, or cancels the dialog, or an error
 *                 occurs.
 * \param userdata an optional pointer to pass extra data to the callback when
 *                 it will be invoked.
 * \param window the window that the dialog should be modal for, may be NULL.
 *               Not all platforms support this option.
 * \param filters a list of filters, may be NULL. Not all platforms support
 *                this option, and platforms that do support it may allow the
 *                user to ignore the filters. If non-NULL, it must remain
 *                valid at least until the callback is invoked.
 * \param nfilters the number of filters. Ignored if filters is NULL.
 * \param default_location the default folder or file to start the dialog at,
 *                         may be NULL. Not all platforms support this option.
 *
 * \threadsafety This function should be called only from the main thread. The
 *               callback may be invoked from the same thread or from a
 *               different one, depending on the OS's constraints.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_DialogFileCallback
 * \sa SDL_DialogFileFilter
 * \sa SDL_ShowOpenFileDialog
 * \sa SDL_ShowOpenFolderDialog
 * \sa SDL_ShowFileDialogWithProperties
 *)
procedure SDL_ShowSaveFileDialog(callback: SDL_DialogFileCallback; userdata: Pointer; window: SDL_Window; const filters: PSDL_DialogFileFilter; nfilters: Integer; const default_location: PUTF8Char); cdecl;
  external LIB_SDL3 name _PU + 'SDL_ShowSaveFileDialog';

(**
 * Displays a dialog that lets the user select a folder on their filesystem.
 *
 * This is an asynchronous function; it will return immediately, and the
 * result will be passed to the callback.
 *
 * The callback will be invoked with a null-terminated list of files the user
 * chose. The list will be empty if the user canceled the dialog, and it will
 * be NULL if an error occurred.
 *
 * Note that the callback may be called from a different thread than the one
 * the function was invoked on.
 *
 * Depending on the platform, the user may be allowed to input paths that
 * don't yet exist.
 *
 * On Linux, dialogs may require XDG Portals, which requires DBus, which
 * requires an event-handling loop. Apps that do not use SDL to handle events
 * should add a call to SDL_PumpEvents in their main loop.
 *
 * \param callback a function pointer to be invoked when the user selects a
 *                 file and accepts, or cancels the dialog, or an error
 *                 occurs.
 * \param userdata an optional pointer to pass extra data to the callback when
 *                 it will be invoked.
 * \param window the window that the dialog should be modal for, may be NULL.
 *               Not all platforms support this option.
 * \param default_location the default folder or file to start the dialog at,
 *                         may be NULL. Not all platforms support this option.
 * \param allow_many if non-zero, the user will be allowed to select multiple
 *                   entries. Not all platforms support this option.
 *
 * \threadsafety This function should be called only from the main thread. The
 *               callback may be invoked from the same thread or from a
 *               different one, depending on the OS's constraints.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_DialogFileCallback
 * \sa SDL_ShowOpenFileDialog
 * \sa SDL_ShowSaveFileDialog
 * \sa SDL_ShowFileDialogWithProperties
 *)
procedure SDL_ShowOpenFolderDialog(callback: SDL_DialogFileCallback; userdata: Pointer; window: SDL_Window; const default_location: PUTF8Char; allow_many: Boolean); cdecl;
  external LIB_SDL3 name _PU + 'SDL_ShowOpenFolderDialog';

(**
 * Various types of file dialogs.
 *
 * This is used by SDL_ShowFileDialogWithProperties() to decide what kind of
 * dialog to present to the user.
 *
 * \since This enum is available since SDL 3.2.0.
 *
 * \sa SDL_ShowFileDialogWithProperties
 *)
type
  SDL_FileDialogType = Integer;

const
  SDL_FILEDIALOG_OPENFILE = 0;
  SDL_FILEDIALOG_SAVEFILE = 1;
  SDL_FILEDIALOG_OPENFOLDER = 2;

(**
 * Create and launch a file dialog with the specified properties.
 *
 * These are the supported properties:
 *
 * - `SDL_PROP_FILE_DIALOG_FILTERS_POINTER`: a pointer to a list of
 *   SDL_DialogFileFilter structs, which will be used as filters for
 *   file-based selections. Ignored if the dialog is an "Open Folder" dialog.
 *   If non-NULL, the array of filters must remain valid at least until the
 *   callback is invoked.
 * - `SDL_PROP_FILE_DIALOG_NFILTERS_NUMBER`: the number of filters in the
 *   array of filters, if it exists.
 * - `SDL_PROP_FILE_DIALOG_WINDOW_POINTER`: the window that the dialog should
 *   be modal for.
 * - `SDL_PROP_FILE_DIALOG_LOCATION_STRING`: the default folder or file to
 *   start the dialog at.
 * - `SDL_PROP_FILE_DIALOG_MANY_BOOLEAN`: true to allow the user to select
 *   more than one entry.
 * - `SDL_PROP_FILE_DIALOG_TITLE_STRING`: the title for the dialog.
 * - `SDL_PROP_FILE_DIALOG_ACCEPT_STRING`: the label that the accept button
 *   should have.
 * - `SDL_PROP_FILE_DIALOG_CANCEL_STRING`: the label that the cancel button
 *   should have.
 *
 * Note that each platform may or may not support any of the properties.
 *
 * \param type the type of file dialog.
 * \param callback a function pointer to be invoked when the user selects a
 *                 file and accepts, or cancels the dialog, or an error
 *                 occurs.
 * \param userdata an optional pointer to pass extra data to the callback when
 *                 it will be invoked.
 * \param props the properties to use.
 *
 * \threadsafety This function should be called only from the main thread. The
 *               callback may be invoked from the same thread or from a
 *               different one, depending on the OS's constraints.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_FileDialogType
 * \sa SDL_DialogFileCallback
 * \sa SDL_DialogFileFilter
 * \sa SDL_ShowOpenFileDialog
 * \sa SDL_ShowSaveFileDialog
 * \sa SDL_ShowOpenFolderDialog
 *)
procedure SDL_ShowFileDialogWithProperties(&type: SDL_FileDialogType; callback: SDL_DialogFileCallback; userdata: Pointer; props: SDL_PropertiesID); cdecl;
  external LIB_SDL3 name _PU + 'SDL_ShowFileDialogWithProperties';

const
  SDL_PROP_FILE_DIALOG_FILTERS_POINTER = 'SDL.filedialog.filters';
  SDL_PROP_FILE_DIALOG_NFILTERS_NUMBER = 'SDL.filedialog.nfilters';
  SDL_PROP_FILE_DIALOG_WINDOW_POINTER = 'SDL.filedialog.window';
  SDL_PROP_FILE_DIALOG_LOCATION_STRING = 'SDL.filedialog.location';
  SDL_PROP_FILE_DIALOG_MANY_BOOLEAN = 'SDL.filedialog.many';
  SDL_PROP_FILE_DIALOG_TITLE_STRING = 'SDL.filedialog.title';
  SDL_PROP_FILE_DIALOG_ACCEPT_STRING = 'SDL.filedialog.accept';
  SDL_PROP_FILE_DIALOG_CANCEL_STRING = 'SDL.filedialog.cancel';
{$ENDREGION 'SDL_dialog.h'}

{$REGION 'SDL_endian.h'}
(**
 * # CategoryEndian
 *
 * Functions converting endian-specific values to different byte orders.
 *
 * These functions either unconditionally swap byte order (SDL_Swap16,
 * SDL_Swap32, SDL_Swap64, SDL_SwapFloat), or they swap to/from the system's
 * native byte order (SDL_Swap16LE, SDL_Swap16BE, SDL_Swap32LE, SDL_Swap32BE,
 * SDL_Swap32LE, SDL_Swap32BE, SDL_SwapFloatLE, SDL_SwapFloatBE). In the
 * latter case, the functionality is provided by macros that become no-ops if
 * a swap isn't necessary: on an x86 (littleendian) processor, SDL_Swap32LE
 * does nothing, but SDL_Swap32BE reverses the bytes of the data. On a PowerPC
 * processor (bigendian), the macros behavior is reversed.
 *
 * The swap routines are inline functions, and attempt to use compiler
 * intrinsics, inline assembly, and other magic to make byteswapping
 * efficient.
 *)

const
  (**
   * A value to represent littleendian byteorder.
   *
   * This is used with the preprocessor macro SDL_BYTEORDER, to determine a
   * platform's byte ordering:
   *
   * ```c
   * #if SDL_BYTEORDER == SDL_LIL_ENDIAN
   * SDL_Log("This system is littleendian.");
   * #endif
   * ```
   *
   * \since This macro is available since SDL 3.2.0.
   *
   * \sa SDL_BYTEORDER
   * \sa SDL_BIG_ENDIAN
   *)
  SDL_LIL_ENDIAN = 1234;

  (**
   * A value to represent bigendian byteorder.
   *
   * This is used with the preprocessor macro SDL_BYTEORDER, to determine a
   * platform's byte ordering:
   *
   * ```c
   * #if SDL_BYTEORDER == SDL_BIG_ENDIAN
   * SDL_Log("This system is bigendian.");
   * #endif
   * ```
   *
   * \since This macro is available since SDL 3.2.0.
   *
   * \sa SDL_BYTEORDER
   * \sa SDL_LIL_ENDIAN
   *)
  SDL_BIG_ENDIAN = 4321;

  (**
   * A macro that reports the target system's byte order.
   *
   * This is set to either SDL_LIL_ENDIAN or SDL_BIG_ENDIAN (and maybe other
   * values in the future, if something else becomes popular). This can be
   * tested with the preprocessor, so decisions can be made at compile time.
   *
   * ```c
   * #if SDL_BYTEORDER == SDL_BIG_ENDIAN
   * SDL_Log("This system is bigendian.");
   * #endif
   * ```
   *
   * \since This macro is available since SDL 3.2.0.
   *
   * \sa SDL_LIL_ENDIAN
   * \sa SDL_BIG_ENDIAN
   *)
  SDL_BYTEORDER = SDL_LIL_ENDIAN;

  (**
   * A macro that reports the target system's floating point word order.
   *
   * This is set to either SDL_LIL_ENDIAN or SDL_BIG_ENDIAN (and maybe other
   * values in the future, if something else becomes popular). This can be
   * tested with the preprocessor, so decisions can be made at compile time.
   *
   * ```c
   * #if SDL_FLOATWORDORDER == SDL_BIG_ENDIAN
   * SDL_Log("This system's floats are bigendian.");
   * #endif
   * ```
   *
   * \since This macro is available since SDL 3.2.0.
   *
   * \sa SDL_LIL_ENDIAN
   * \sa SDL_BIG_ENDIAN
   *)
  SDL_FLOATWORDORDER = SDL_BYTEORDER;

(* Byte swap 16-bit integer. *)
function SDL_Swap16(x: UInt16): UInt16; inline;

(* Byte swap 32-bit integer. *)
function SDL_Swap32(x: UInt32): UInt32; inline;

(* Byte swap 64-bit integer. *)
function SDL_Swap64(x: UInt64): UInt64; inline;

(**
 * Byte-swap a floating point number.
 *
 * This will always byte-swap the value, whether it's currently in the native
 * byteorder of the system or not. You should use SDL_SwapFloatLE or
 * SDL_SwapFloatBE instead, in most cases.
 *
 * Note that this is a forced-inline function in a header, and not a public
 * API function available in the SDL library (which is to say, the code is
 * embedded in the calling program and the linker and dynamic loader will not
 * be able to find this function inside SDL itself).
 *
 * \param x the value to byte-swap.
 * \returns x, with its bytes in the opposite endian order.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_SwapFloat(x: Single): Single; inline;
{$ENDREGION 'SDL_endian.h'}

{$REGION 'SDL_error.h'}
(**
 * # CategoryError
 *
 * Simple error message routines for SDL.
 *
 * Most apps will interface with these APIs in exactly one function: when
 * almost any SDL function call reports failure, you can get a human-readable
 * string of the problem from SDL_GetError().
 *
 * These strings are maintained per-thread, and apps are welcome to set their
 * own errors, which is popular when building libraries on top of SDL for
 * other apps to consume. These strings are set by calling SDL_SetError().
 *
 * A common usage pattern is to have a function that returns true for success
 * and false for failure, and do this when something fails:
 *
 * ```c
 * if (something_went_wrong) {
 *    return SDL_SetError("The thing broke in this specific way: %d", errcode);
 * }
 * ```
 *
 * It's also common to just return `false` in this case if the failing thing
 * is known to call SDL_SetError(), so errors simply propagate through.
 *)

(**
 * Set the SDL error message for the current thread.
 *
 * Calling this function will replace any previous error message that was set.
 *
 * This function always returns false, since SDL frequently uses false to
 * signify a failing result, leading to this idiom:
 *
 * ```c
 * if (error_code) {
 *     return SDL_SetError("This operation has failed: %d", error_code);
 * }
 * ```
 *
 * \param fmt a printf()-style message format string.
 * \param ... additional parameters matching % tokens in the `fmt` string, if
 *            any.
 * \returns false.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_ClearError
 * \sa SDL_GetError
 * \sa SDL_SetErrorV
 *)
function SDL_SetError(const fmt: PUTF8Char): Boolean varargs; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetError';

(**
 * Set the SDL error message for the current thread.
 *
 * Calling this function will replace any previous error message that was set.
 *
 * \param fmt a printf()-style message format string.
 * \param ap a variable argument list.
 * \returns false.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_ClearError
 * \sa SDL_GetError
 * \sa SDL_SetError
 *)
function SDL_SetErrorV(const fmt: PUTF8Char; ap: Pointer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetErrorV';

(**
 * Set an error indicating that memory allocation failed.
 *
 * This function does not do any memory allocation.
 *
 * \returns false.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_OutOfMemory(): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_OutOfMemory';

(**
 * Retrieve a message about the last error that occurred on the current
 * thread.
 *
 * It is possible for multiple errors to occur before calling SDL_GetError().
 * Only the last error is returned.
 *
 * The message is only applicable when an SDL function has signaled an error.
 * You must check the return values of SDL function calls to determine when to
 * appropriately call SDL_GetError(). You should *not* use the results of
 * SDL_GetError() to decide if an error has occurred! Sometimes SDL will set
 * an error string even when reporting success.
 *
 * SDL will *not* clear the error string for successful API calls. You *must*
 * check return values for failure cases before you can assume the error
 * string applies.
 *
 * Error strings are set per-thread, so an error set in a different thread
 * will not interfere with the current thread's operation.
 *
 * The returned value is a thread-local string which will remain valid until
 * the current thread's error string is changed. The caller should make a copy
 * if the value is needed after the next SDL API call.
 *
 * \returns a message with information about the specific error that occurred,
 *          or an empty string if there hasn't been an error message set since
 *          the last call to SDL_ClearError().
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_ClearError
 * \sa SDL_SetError
 *)
function SDL_GetError(): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetError';

(**
 * Clear any previous error message for this thread.
 *
 * \returns true.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetError
 * \sa SDL_SetError
 *)
function SDL_ClearError(): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_ClearError';
{$ENDREGION 'SDL_error.h'}

{$REGION 'SDL_filesystem.h'}
(**
 * # CategoryFilesystem
 *
 * SDL offers an API for examining and manipulating the system's filesystem.
 * This covers most things one would need to do with directories, except for
 * actual file I/O (which is covered by [CategoryIOStream](CategoryIOStream)
 * and [CategoryAsyncIO](CategoryAsyncIO) instead).
 *
 * There are functions to answer necessary path questions:
 *
 * - Where is my app's data? SDL_GetBasePath().
 * - Where can I safely write files? SDL_GetPrefPath().
 * - Where are paths like Downloads, Desktop, Music? SDL_GetUserFolder().
 * - What is this thing at this location? SDL_GetPathInfo().
 * - What items live in this folder? SDL_EnumerateDirectory().
 * - What items live in this folder by wildcard? SDL_GlobDirectory().
 * - What is my current working directory? SDL_GetCurrentDirectory().
 *
 * SDL also offers functions to manipulate the directory tree: renaming,
 * removing, copying files.
 *)

 (**
 * Get the directory where the application was run from.
 *
 * SDL caches the result of this call internally, but the first call to this
 * function is not necessarily fast, so plan accordingly.
 *
 * **macOS and iOS Specific Functionality**: If the application is in a ".app"
 * bundle, this function returns the Resource directory (e.g.
 * MyApp.app/Contents/Resources/). This behaviour can be overridden by adding
 * a property to the Info.plist file. Adding a string key with the name
 * SDL_FILESYSTEM_BASE_DIR_TYPE with a supported value will change the
 * behaviour.
 *
 * Supported values for the SDL_FILESYSTEM_BASE_DIR_TYPE property (Given an
 * application in /Applications/SDLApp/MyApp.app):
 *
 * - `resource`: bundle resource directory (the default). For example:
 *   `/Applications/SDLApp/MyApp.app/Contents/Resources`
 * - `bundle`: the Bundle directory. For example:
 *   `/Applications/SDLApp/MyApp.app/`
 * - `parent`: the containing directory of the bundle. For example:
 *   `/Applications/SDLApp/`
 *
 * **Nintendo 3DS Specific Functionality**: This function returns "romfs"
 * directory of the application as it is uncommon to store resources outside
 * the executable. As such it is not a writable directory.
 *
 * The returned path is guaranteed to end with a path separator ('\\' on
 * Windows, '/' on most other platforms).
 *
 * \returns an absolute path in UTF-8 encoding to the application data
 *          directory. NULL will be returned on error or when the platform
 *          doesn't implement this functionality, call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetPrefPath
 *)
function SDL_GetBasePath(): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetBasePath';

(**
 * Get the user-and-app-specific path where files can be written.
 *
 * Get the "pref dir". This is meant to be where users can write personal
 * files (preferences and save games, etc) that are specific to your
 * application. This directory is unique per user, per application.
 *
 * This function will decide the appropriate location in the native
 * filesystem, create the directory if necessary, and return a string of the
 * absolute path to the directory in UTF-8 encoding.
 *
 * On Windows, the string might look like:
 *
 * `C:\\Users\\bob\\AppData\\Roaming\\My Company\\My Program Name\\`
 *
 * On Linux, the string might look like:
 *
 * `/home/bob/.local/share/My Program Name/`
 *
 * On macOS, the string might look like:
 *
 * `/Users/bob/Library/Application Support/My Program Name/`
 *
 * You should assume the path returned by this function is the only safe place
 * to write files (and that SDL_GetBasePath(), while it might be writable, or
 * even the parent of the returned path, isn't where you should be writing
 * things).
 *
 * Both the org and app strings may become part of a directory name, so please
 * follow these rules:
 *
 * - Try to use the same org string (_including case-sensitivity_) for all
 *   your applications that use this function.
 * - Always use a unique app string for each one, and make sure it never
 *   changes for an app once you've decided on it.
 * - Unicode characters are legal, as long as they are UTF-8 encoded, but...
 * - ...only use letters, numbers, and spaces. Avoid punctuation like "Game
 *   Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.
 *
 * The returned path is guaranteed to end with a path separator ('\\' on
 * Windows, '/' on most other platforms).
 *
 * \param org the name of your organization.
 * \param app the name of your application.
 * \returns a UTF-8 string of the user directory in platform-dependent
 *          notation. NULL if there's a problem (creating directory failed,
 *          etc.). This should be freed with SDL_free() when it is no longer
 *          needed.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetBasePath
 *)
function SDL_GetPrefPath(const org: PUTF8Char; const app: PUTF8Char): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetPrefPath';

(**
 * The type of the OS-provided default folder for a specific purpose.
 *
 * Note that the Trash folder isn't included here, because trashing files
 * usually involves extra OS-specific functionality to remember the file's
 * original location.
 *
 * The folders supported per platform are:
 *
 * |             | Windows | macOS/iOS | tvOS | Unix (XDG) | Haiku | Emscripten |
 * | ----------- | ------- | --------- | ---- | ---------- | ----- | ---------- |
 * | HOME        | X       | X         |      | X          | X     | X          |
 * | DESKTOP     | X       | X         |      | X          | X     |            |
 * | DOCUMENTS   | X       | X         |      | X          |       |            |
 * | DOWNLOADS   | Vista+  | X         |      | X          |       |            |
 * | MUSIC       | X       | X         |      | X          |       |            |
 * | PICTURES    | X       | X         |      | X          |       |            |
 * | PUBLICSHARE |         | X         |      | X          |       |            |
 * | SAVEDGAMES  | Vista+  |           |      |            |       |            |
 * | SCREENSHOTS | Vista+  |           |      |            |       |            |
 * | TEMPLATES   | X       | X         |      | X          |       |            |
 * | VIDEOS      | X       | X*        |      | X          |       |            |
 *
 * Note that on macOS/iOS, the Videos folder is called "Movies".
 *
 * \since This enum is available since SDL 3.2.0.
 *
 * \sa SDL_GetUserFolder
 *)
type
  SDL_Folder = Integer;

const
  (** The folder which contains all of the current user's data, preferences, and documents. It usually contains most of the other folders. If a requested folder does not exist, the home folder can be considered a safe fallback to store a user's documents. *)
  SDL_FOLDER_HOME = 0;
  (** The folder of files that are displayed on the desktop. Note that the existence of a desktop folder does not guarantee that the system does show icons on its desktop; certain GNU/Linux distros with a graphical environment may not have desktop icons. *)
  SDL_FOLDER_DESKTOP = 1;
  (** User document files, possibly application-specific. This is a good place to save a user's projects. *)
  SDL_FOLDER_DOCUMENTS = 2;
  (** Standard folder for user files downloaded from the internet. *)
  SDL_FOLDER_DOWNLOADS = 3;
  (** Music files that can be played using a standard music player (mp3, ogg...). *)
  SDL_FOLDER_MUSIC = 4;
  (** Image files that can be displayed using a standard viewer (png, jpg...). *)
  SDL_FOLDER_PICTURES = 5;
  (** Files that are meant to be shared with other users on the same computer. *)
  SDL_FOLDER_PUBLICSHARE = 6;
  (** Save files for games. *)
  SDL_FOLDER_SAVEDGAMES = 7;
  (** Application screenshots. *)
  SDL_FOLDER_SCREENSHOTS = 8;
  (** Template files to be used when the user requests the desktop environment to create a new file in a certain folder, such as "New Text File.txt".  Any file in the Templates folder can be used as a starting point for a new file. *)
  SDL_FOLDER_TEMPLATES = 9;
  (** Video files that can be played using a standard video player (mp4, webm...). *)
  SDL_FOLDER_VIDEOS = 10;
  (** Total number of types in this enum, not a folder type by itself. *)
  SDL_FOLDER_COUNT = 11;

(**
 * Finds the most suitable user folder for a specific purpose.
 *
 * Many OSes provide certain standard folders for certain purposes, such as
 * storing pictures, music or videos for a certain user. This function gives
 * the path for many of those special locations.
 *
 * This function is specifically for _user_ folders, which are meant for the
 * user to access and manage. For application-specific folders, meant to hold
 * data for the application to manage, see SDL_GetBasePath() and
 * SDL_GetPrefPath().
 *
 * The returned path is guaranteed to end with a path separator ('\\' on
 * Windows, '/' on most other platforms).
 *
 * If NULL is returned, the error may be obtained with SDL_GetError().
 *
 * \param folder the type of folder to find.
 * \returns either a null-terminated C string containing the full path to the
 *          folder, or NULL if an error happened.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetUserFolder(folder: SDL_Folder): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetUserFolder';

(**
 * Types of filesystem entries.
 *
 * Note that there may be other sorts of items on a filesystem: devices,
 * symlinks, named pipes, etc. They are currently reported as
 * SDL_PATHTYPE_OTHER.
 *
 * \since This enum is available since SDL 3.2.0.
 *
 * \sa SDL_PathInfo
 *)
type
  SDL_PathType = Integer;

const
  (** path does not exist *)
  SDL_PATHTYPE_NONE = 0;
  (** a normal file *)
  SDL_PATHTYPE_FILE = 1;
  (** a directory *)
  SDL_PATHTYPE_DIRECTORY = 2;
  (** something completely different like a device node (not a symlink, those are always followed) *)
  SDL_PATHTYPE_OTHER = 3;

type
  (**
   * Information about a path on the filesystem.
   *
   * \since This datatype is available since SDL 3.2.0.
   *
   * \sa SDL_GetPathInfo
   * \sa SDL_GetStoragePathInfo
   *)
  SDL_PathInfo = record
    (** the path type *)
    &type: SDL_PathType;
    (** the file size in bytes *)
    size: Uint64;
    (** the time when the path was created *)
    create_time: SDL_Time;
    (** the last time the path was modified *)
    modify_time: SDL_Time;
    (** the last time the path was read *)
    access_time: SDL_Time;
  end;
  PSDL_PathInfo = ^SDL_PathInfo;

  (**
   * Flags for path matching.
   *
   * \since This datatype is available since SDL 3.2.0.
   *
   * \sa SDL_GlobDirectory
   * \sa SDL_GlobStorageDirectory
   *)
  SDL_GlobFlags = Uint32;

const
  SDL_GLOB_CASEINSENSITIVE = (1 shl 0);

(**
 * Create a directory, and any missing parent directories.
 *
 * This reports success if `path` already exists as a directory.
 *
 * If parent directories are missing, it will also create them. Note that if
 * this fails, it will not remove any parent directories it already made.
 *
 * \param path the path of the directory to create.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_CreateDirectory(const path: PUTF8Char): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_CreateDirectory';

(**
 * Possible results from an enumeration callback.
 *
 * \since This enum is available since SDL 3.2.0.
 *
 * \sa SDL_EnumerateDirectoryCallback
 *)
type
  SDL_EnumerationResult = Integer;

const
  (** Value that requests that enumeration continue. *)
  SDL_ENUM_CONTINUE = 0;
  (** Value that requests that enumeration stop, successfully. *)
  SDL_ENUM_SUCCESS = 1;
  (** Value that requests that enumeration stop, as a failure. *)
  SDL_ENUM_FAILURE = 2;

type
  (**
   * Callback for directory enumeration.
   *
   * Enumeration of directory entries will continue until either all entries
   * have been provided to the callback, or the callback has requested a stop
   * through its return value.
   *
   * Returning SDL_ENUM_CONTINUE will let enumeration proceed, calling the
   * callback with further entries. SDL_ENUM_SUCCESS and SDL_ENUM_FAILURE will
   * terminate the enumeration early, and dictate the return value of the
   * enumeration function itself.
   *
   * `dirname` is guaranteed to end with a path separator ('\\' on Windows, '/'
   * on most other platforms).
   *
   * \param userdata an app-controlled pointer that is passed to the callback.
   * \param dirname the directory that is being enumerated.
   * \param fname the next entry in the enumeration.
   * \returns how the enumeration should proceed.
   *
   * \since This datatype is available since SDL 3.2.0.
   *
   * \sa SDL_EnumerateDirectory
   *)
  SDL_EnumerateDirectoryCallback = function(userdata: Pointer; const dirname: PUTF8Char; const fname: PUTF8Char): SDL_EnumerationResult; cdecl;

(**
 * Enumerate a directory through a callback function.
 *
 * This function provides every directory entry through an app-provided
 * callback, called once for each directory entry, until all results have been
 * provided or the callback returns either SDL_ENUM_SUCCESS or
 * SDL_ENUM_FAILURE.
 *
 * This will return false if there was a system problem in general, or if a
 * callback returns SDL_ENUM_FAILURE. A successful return means a callback
 * returned SDL_ENUM_SUCCESS to halt enumeration, or all directory entries
 * were enumerated.
 *
 * \param path the path of the directory to enumerate.
 * \param callback a function that is called for each entry in the directory.
 * \param userdata a pointer that is passed to `callback`.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_EnumerateDirectory(const path: PUTF8Char; callback: SDL_EnumerateDirectoryCallback; userdata: Pointer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_EnumerateDirectory';

(**
 * Remove a file or an empty directory.
 *
 * Directories that are not empty will fail; this function will not recursely
 * delete directory trees.
 *
 * \param path the path to remove from the filesystem.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_RemovePath(const path: PUTF8Char): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_RemovePath';

(**
 * Rename a file or directory.
 *
 * If the file at `newpath` already exists, it will replaced.
 *
 * Note that this will not copy files across filesystems/drives/volumes, as
 * that is a much more complicated (and possibly time-consuming) operation.
 *
 * Which is to say, if this function fails, SDL_CopyFile() to a temporary file
 * in the same directory as `newpath`, then SDL_RenamePath() from the
 * temporary file to `newpath` and SDL_RemovePath() on `oldpath` might work
 * for files. Renaming a non-empty directory across filesystems is
 * dramatically more complex, however.
 *
 * \param oldpath the old path.
 * \param newpath the new path.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_RenamePath(const oldpath: PUTF8Char; const newpath: PUTF8Char): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_RenamePath';

(**
 * Copy a file.
 *
 * If the file at `newpath` already exists, it will be overwritten with the
 * contents of the file at `oldpath`.
 *
 * This function will block until the copy is complete, which might be a
 * significant time for large files on slow disks. On some platforms, the copy
 * can be handed off to the OS itself, but on others SDL might just open both
 * paths, and read from one and write to the other.
 *
 * Note that this is not an atomic operation! If something tries to read from
 * `newpath` while the copy is in progress, it will see an incomplete copy of
 * the data, and if the calling thread terminates (or the power goes out)
 * during the copy, `newpath`'s previous contents will be gone, replaced with
 * an incomplete copy of the data. To avoid this risk, it is recommended that
 * the app copy to a temporary file in the same directory as `newpath`, and if
 * the copy is successful, use SDL_RenamePath() to replace `newpath` with the
 * temporary file. This will ensure that reads of `newpath` will either see a
 * complete copy of the data, or it will see the pre-copy state of `newpath`.
 *
 * This function attempts to synchronize the newly-copied data to disk before
 * returning, if the platform allows it, so that the renaming trick will not
 * have a problem in a system crash or power failure, where the file could be
 * renamed but the contents never made it from the system file cache to the
 * physical disk.
 *
 * If the copy fails for any reason, the state of `newpath` is undefined. It
 * might be half a copy, it might be the untouched data of what was already
 * there, or it might be a zero-byte file, etc.
 *
 * \param oldpath the old path.
 * \param newpath the new path.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_CopyFile(const oldpath: PUTF8Char; const newpath: PUTF8Char): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_CopyFile';

(**
 * Get information about a filesystem path.
 *
 * \param path the path to query.
 * \param info a pointer filled in with information about the path, or NULL to
 *             check for the existence of a file.
 * \returns true on success or false if the file doesn't exist, or another
 *          failure; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetPathInfo(const path: PUTF8Char; info: PSDL_PathInfo): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetPathInfo';

(**
 * Enumerate a directory tree, filtered by pattern, and return a list.
 *
 * Files are filtered out if they don't match the string in `pattern`, which
 * may contain wildcard characters '\*' (match everything) and '?' (match one
 * character). If pattern is NULL, no filtering is done and all results are
 * returned. Subdirectories are permitted, and are specified with a path
 * separator of '/'. Wildcard characters '\*' and '?' never match a path
 * separator.
 *
 * `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching
 * case-insensitive.
 *
 * The returned array is always NULL-terminated, for your iterating
 * convenience, but if `count` is non-NULL, on return it will contain the
 * number of items in the array, not counting the NULL terminator.
 *
 * \param path the path of the directory to enumerate.
 * \param pattern the pattern that files in the directory must match. Can be
 *                NULL.
 * \param flags `SDL_GLOB_*` bitflags that affect this search.
 * \param count on return, will be set to the number of items in the returned
 *              array. Can be NULL.
 * \returns an array of strings on success or NULL on failure; call
 *          SDL_GetError() for more information. This is a single allocation
 *          that should be freed with SDL_free() when it is no longer needed.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GlobDirectory(const path: PUTF8Char; const pattern: PUTF8Char; flags: SDL_GlobFlags; count: PInteger): PPUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GlobDirectory';

(**
 * Get what the system believes is the "current working directory."
 *
 * For systems without a concept of a current working directory, this will
 * still attempt to provide something reasonable.
 *
 * SDL does not provide a means to _change_ the current working directory; for
 * platforms without this concept, this would cause surprises with file access
 * outside of SDL.
 *
 * The returned path is guaranteed to end with a path separator ('\\' on
 * Windows, '/' on most other platforms).
 *
 * \returns a UTF-8 string of the current working directory in
 *          platform-dependent notation. NULL if there's a problem. This
 *          should be freed with SDL_free() when it is no longer needed.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetCurrentDirectory(): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetCurrentDirectory';
{$ENDREGION 'SDL_filesystem.h'}

{$REGION 'SDL_guid.h'}
(**
 * # CategoryGUID
 *
 * A GUID is a 128-bit value that represents something that is uniquely
 * identifiable by this value: "globally unique."
 *
 * SDL provides functions to convert a GUID to/from a string.
 *)

type
  (**
   * An SDL_GUID is a 128-bit identifier for an input device that identifies
   * that device across runs of SDL programs on the same platform.
   *
   * If the device is detached and then re-attached to a different port, or if
   * the base system is rebooted, the device should still report the same GUID.
   *
   * GUIDs are as precise as possible but are not guaranteed to distinguish
   * physically distinct but equivalent devices. For example, two game
   * controllers from the same vendor with the same product ID and revision may
   * have the same GUID.
   *
   * GUIDs may be platform-dependent (i.e., the same device may report different
   * GUIDs on different operating systems).
   *
   * \since This struct is available since SDL 3.2.0.
   *)
  SDL_GUID = record
    data: array [0..15] of Uint8;
  end;

(**
 * Get an ASCII string representation for a given SDL_GUID.
 *
 * \param guid the SDL_GUID you wish to convert to string.
 * \param pszGUID buffer in which to write the ASCII string.
 * \param cbGUID the size of pszGUID, should be at least 33 bytes.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_StringToGUID
 *)
procedure SDL_GUIDToString(guid: SDL_GUID; pszGUID: PUTF8Char; cbGUID: Integer); cdecl;
  external LIB_SDL3 name _PU + 'SDL_GUIDToString';

(**
 * Convert a GUID string into a SDL_GUID structure.
 *
 * Performs no error checking. If this function is given a string containing
 * an invalid GUID, the function will silently succeed, but the GUID generated
 * will not be useful.
 *
 * \param pchGUID string containing an ASCII representation of a GUID.
 * \returns a SDL_GUID structure.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GUIDToString
 *)
function SDL_StringToGUID(const pchGUID: PUTF8Char): SDL_GUID; cdecl;
  external LIB_SDL3 name _PU + 'SDL_StringToGUID';
{$ENDREGION 'SDL_guid.h'}

{$REGION 'SDL_sensor.h'}
(**
 * # CategorySensor
 *
 * SDL sensor management.
 *
 * These APIs grant access to gyros and accelerometers on various platforms.
 *
 * In order to use these functions, SDL_Init() must have been called with the
 * SDL_INIT_SENSOR flag. This causes SDL to scan the system for sensors, and
 * load appropriate drivers.
 *)

type
  (**
   * The opaque structure used to identify an opened SDL sensor.
   *
   * \since This struct is available since SDL 3.2.0.
   *)
  SDL_Sensor = THandle;

type
  (**
   * This is a unique ID for a sensor for the time it is connected to the
   * system, and is never reused for the lifetime of the application.
   *
   * The value 0 is an invalid ID.
   *
   * \since This datatype is available since SDL 3.2.0.
   *)
  SDL_SensorID = Uint32;
  PSDL_SensorID = ^SDL_SensorID;

const
  (**
   * A constant to represent standard gravity for accelerometer sensors.
   *
   * The accelerometer returns the current acceleration in SI meters per second
   * squared. This measurement includes the force of gravity, so a device at
   * rest will have an value of SDL_STANDARD_GRAVITY away from the center of the
   * earth, which is a positive Y value.
   *
   * \since This macro is available since SDL 3.2.0.
   *)
  SDL_STANDARD_GRAVITY = 9.80665;

(**
 * The different sensors defined by SDL.
 *
 * Additional sensors may be available, using platform dependent semantics.
 *
 * Here are the additional Android sensors:
 *
 * https://developer.android.com/reference/android/hardware/SensorEvent.html#values
 *
 * Accelerometer sensor notes:
 *
 * The accelerometer returns the current acceleration in SI meters per second
 * squared. This measurement includes the force of gravity, so a device at
 * rest will have an value of SDL_STANDARD_GRAVITY away from the center of the
 * earth, which is a positive Y value.
 *
 * - `values[0]`: Acceleration on the x axis
 * - `values[1]`: Acceleration on the y axis
 * - `values[2]`: Acceleration on the z axis
 *
 * For phones and tablets held in natural orientation and game controllers
 * held in front of you, the axes are defined as follows:
 *
 * - -X ... +X : left ... right
 * - -Y ... +Y : bottom ... top
 * - -Z ... +Z : farther ... closer
 *
 * The accelerometer axis data is not changed when the device is rotated.
 *
 * Gyroscope sensor notes:
 *
 * The gyroscope returns the current rate of rotation in radians per second.
 * The rotation is positive in the counter-clockwise direction. That is, an
 * observer looking from a positive location on one of the axes would see
 * positive rotation on that axis when it appeared to be rotating
 * counter-clockwise.
 *
 * - `values[0]`: Angular speed around the x axis (pitch)
 * - `values[1]`: Angular speed around the y axis (yaw)
 * - `values[2]`: Angular speed around the z axis (roll)
 *
 * For phones and tablets held in natural orientation and game controllers
 * held in front of you, the axes are defined as follows:
 *
 * - -X ... +X : left ... right
 * - -Y ... +Y : bottom ... top
 * - -Z ... +Z : farther ... closer
 *
 * The gyroscope axis data is not changed when the device is rotated.
 *
 * \since This enum is available since SDL 3.2.0.
 *
 * \sa SDL_GetCurrentDisplayOrientation
 *)
type
  SDL_SensorType = Integer;

const
  (** Returned for an invalid sensor *)
  SDL_SENSOR_INVALID = -1;
  (** Unknown sensor type *)
  SDL_SENSOR_UNKNOWN = 0;
  (** Accelerometer *)
  SDL_SENSOR_ACCEL = 1;
  (** Gyroscope *)
  SDL_SENSOR_GYRO = 2;
  (** Accelerometer for left Joy-Con controller and Wii nunchuk *)
  SDL_SENSOR_ACCEL_L = 3;
  (** Gyroscope for left Joy-Con controller *)
  SDL_SENSOR_GYRO_L = 4;
  (** Accelerometer for right Joy-Con controller *)
  SDL_SENSOR_ACCEL_R = 5;
  (** Gyroscope for right Joy-Con controller *)
  SDL_SENSOR_GYRO_R = 6;

(**
 * Get a list of currently connected sensors.
 *
 * \param count a pointer filled in with the number of sensors returned, may
 *              be NULL.
 * \returns a 0 terminated array of sensor instance IDs or NULL on failure;
 *          call SDL_GetError() for more information. This should be freed
 *          with SDL_free() when it is no longer needed.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetSensors(count: PInteger): PSDL_SensorID; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetSensors';

(**
 * Get the implementation dependent name of a sensor.
 *
 * This can be called before any sensors are opened.
 *
 * \param instance_id the sensor instance ID.
 * \returns the sensor name, or NULL if `instance_id` is not valid.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetSensorNameForID(instance_id: SDL_SensorID): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetSensorNameForID';

(**
 * Get the type of a sensor.
 *
 * This can be called before any sensors are opened.
 *
 * \param instance_id the sensor instance ID.
 * \returns the SDL_SensorType, or `SDL_SENSOR_INVALID` if `instance_id` is
 *          not valid.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetSensorTypeForID(instance_id: SDL_SensorID): SDL_SensorType; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetSensorTypeForID';

(**
 * Get the platform dependent type of a sensor.
 *
 * This can be called before any sensors are opened.
 *
 * \param instance_id the sensor instance ID.
 * \returns the sensor platform dependent type, or -1 if `instance_id` is not
 *          valid.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetSensorNonPortableTypeForID(instance_id: SDL_SensorID): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetSensorNonPortableTypeForID';

(**
 * Open a sensor for use.
 *
 * \param instance_id the sensor instance ID.
 * \returns an SDL_Sensor object or NULL on failure; call SDL_GetError() for
 *          more information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_OpenSensor(instance_id: SDL_SensorID): SDL_Sensor; cdecl;
  external LIB_SDL3 name _PU + 'SDL_OpenSensor';

(**
 * Return the SDL_Sensor associated with an instance ID.
 *
 * \param instance_id the sensor instance ID.
 * \returns an SDL_Sensor object or NULL on failure; call SDL_GetError() for
 *          more information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetSensorFromID(instance_id: SDL_SensorID): SDL_Sensor; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetSensorFromID';

(**
 * Get the properties associated with a sensor.
 *
 * \param sensor the SDL_Sensor object.
 * \returns a valid property ID on success or 0 on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetSensorProperties(sensor: SDL_Sensor): SDL_PropertiesID; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetSensorProperties';

(**
 * Get the implementation dependent name of a sensor.
 *
 * \param sensor the SDL_Sensor object.
 * \returns the sensor name or NULL on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetSensorName(sensor: SDL_Sensor): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetSensorName';

(**
 * Get the type of a sensor.
 *
 * \param sensor the SDL_Sensor object to inspect.
 * \returns the SDL_SensorType type, or `SDL_SENSOR_INVALID` if `sensor` is
 *          NULL.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetSensorType(sensor: SDL_Sensor): SDL_SensorType; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetSensorType';

(**
 * Get the platform dependent type of a sensor.
 *
 * \param sensor the SDL_Sensor object to inspect.
 * \returns the sensor platform dependent type, or -1 if `sensor` is NULL.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetSensorNonPortableType(sensor: SDL_Sensor): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetSensorNonPortableType';

(**
 * Get the instance ID of a sensor.
 *
 * \param sensor the SDL_Sensor object to inspect.
 * \returns the sensor instance ID, or 0 on failure; call SDL_GetError() for
 *          more information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetSensorID(sensor: SDL_Sensor): SDL_SensorID; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetSensorID';

(**
 * Get the current state of an opened sensor.
 *
 * The number of values and interpretation of the data is sensor dependent.
 *
 * \param sensor the SDL_Sensor object to query.
 * \param data a pointer filled with the current sensor state.
 * \param num_values the number of values to write to data.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetSensorData(sensor: SDL_Sensor; data: PSingle; num_values: Integer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetSensorData';

(**
 * Close a sensor previously opened with SDL_OpenSensor().
 *
 * \param sensor the SDL_Sensor object to close.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_CloseSensor(sensor: SDL_Sensor); cdecl;
  external LIB_SDL3 name _PU + 'SDL_CloseSensor';

(**
 * Update the current state of the open sensors.
 *
 * This is called automatically by the event loop if sensor events are
 * enabled.
 *
 * This needs to be called from the thread that initialized the sensor
 * subsystem.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_UpdateSensors(); cdecl;
  external LIB_SDL3 name _PU + 'SDL_UpdateSensors';
{$ENDREGION 'SDL_sensor.h'}

{$REGION 'SDL_power.h'}
(**
 * # CategoryPower
 *
 * SDL power management routines.
 *
 * There is a single function in this category: SDL_GetPowerInfo().
 *
 * This function is useful for games on the go. This allows an app to know if
 * it's running on a draining battery, which can be useful if the app wants to
 * reduce processing, or perhaps framerate, to extend the duration of the
 * battery's charge. Perhaps the app just wants to show a battery meter when
 * fullscreen, or alert the user when the power is getting extremely low, so
 * they can save their game.
 *)
(**
 * The basic state for the system's power supply.
 *
 * These are results returned by SDL_GetPowerInfo().
 *
 * \since This enum is available since SDL 3.2.0.
 *)
type
  SDL_PowerState = Integer;

const
  (** error determining power status *)
  SDL_POWERSTATE_ERROR = -1;
  (** cannot determine power status *)
  SDL_POWERSTATE_UNKNOWN = 0;
  (** Not plugged in, running on the battery *)
  SDL_POWERSTATE_ON_BATTERY = 1;
  (** Plugged in, no battery available *)
  SDL_POWERSTATE_NO_BATTERY = 2;
  (** Plugged in, charging battery *)
  SDL_POWERSTATE_CHARGING = 3;
  (** Plugged in, battery charged *)
  SDL_POWERSTATE_CHARGED = 4;

(**
 * Get the current power supply details.
 *
 * You should never take a battery status as absolute truth. Batteries
 * (especially failing batteries) are delicate hardware, and the values
 * reported here are best estimates based on what that hardware reports. It's
 * not uncommon for older batteries to lose stored power much faster than it
 * reports, or completely drain when reporting it has 20 percent left, etc.
 *
 * Battery status can change at any time; if you are concerned with power
 * state, you should call this function frequently, and perhaps ignore changes
 * until they seem to be stable for a few seconds.
 *
 * It's possible a platform can only report battery percentage or time left
 * but not both.
 *
 * \param seconds a pointer filled in with the seconds of battery life left,
 *                or NULL to ignore. This will be filled in with -1 if we
 *                can't determine a value or there is no battery.
 * \param percent a pointer filled in with the percentage of battery life
 *                left, between 0 and 100, or NULL to ignore. This will be
 *                filled in with -1 we can't determine a value or there is no
 *                battery.
 * \returns the current battery state or `SDL_POWERSTATE_ERROR` on failure;
 *          call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetPowerInfo(seconds: PInteger; percent: PInteger): SDL_PowerState; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetPowerInfo';
{$ENDREGION 'SDL_power.h'}

{$REGION 'SDL_joystick.h'}
(**
 * # CategoryJoystick
 *
 * SDL joystick support.
 *
 * This is the lower-level joystick handling. If you want the simpler option,
 * where what each button does is well-defined, you should use the gamepad API
 * instead.
 *
 * The term "instance_id" is the current instantiation of a joystick device in
 * the system, if the joystick is removed and then re-inserted then it will
 * get a new instance_id, instance_id's are monotonically increasing
 * identifiers of a joystick plugged in.
 *
 * The term "player_index" is the number assigned to a player on a specific
 * controller. For XInput controllers this returns the XInput user index. Many
 * joysticks will not be able to supply this information.
 *
 * SDL_GUID is used as a stable 128-bit identifier for a joystick device that
 * does not change over time. It identifies class of the device (a X360 wired
 * controller for example). This identifier is platform dependent.
 *
 * In order to use these functions, SDL_Init() must have been called with the
 * SDL_INIT_JOYSTICK flag. This causes SDL to scan the system for joysticks,
 * and load appropriate drivers.
 *
 * If you would like to receive joystick updates while the application is in
 * the background, you should set the following hint before calling
 * SDL_Init(): SDL_HINT_JOYSTICK_ALLOW_BACKGROUND_EVENTS
 *)

type
  (**
   * The joystick structure used to identify an SDL joystick.
   *
   * This is opaque data.
   *
   * \since This struct is available since SDL 3.2.0.
   *)
  SDL_Joystick = THandle;

type
  (**
   * This is a unique ID for a joystick for the time it is connected to the
   * system, and is never reused for the lifetime of the application.
   *
   * If the joystick is disconnected and reconnected, it will get a new ID.
   *
   * The value 0 is an invalid ID.
   *
   * \since This datatype is available since SDL 3.2.0.
   *)
  SDL_JoystickID = Uint32;
  PSDL_JoystickID = ^SDL_JoystickID;

(**
 * An enum of some common joystick types.
 *
 * In some cases, SDL can identify a low-level joystick as being a certain
 * type of device, and will report it through SDL_GetJoystickType (or
 * SDL_GetJoystickTypeForID).
 *
 * This is by no means a complete list of everything that can be plugged into
 * a computer.
 *
 * \since This enum is available since SDL 3.2.0.
 *)
type
  SDL_JoystickType = Integer;

const
  SDL_JOYSTICK_TYPE_UNKNOWN = 0;
  SDL_JOYSTICK_TYPE_GAMEPAD = 1;
  SDL_JOYSTICK_TYPE_WHEEL = 2;
  SDL_JOYSTICK_TYPE_ARCADE_STICK = 3;
  SDL_JOYSTICK_TYPE_FLIGHT_STICK = 4;
  SDL_JOYSTICK_TYPE_DANCE_PAD = 5;
  SDL_JOYSTICK_TYPE_GUITAR = 6;
  SDL_JOYSTICK_TYPE_DRUM_KIT = 7;
  SDL_JOYSTICK_TYPE_ARCADE_PAD = 8;
  SDL_JOYSTICK_TYPE_THROTTLE = 9;
  SDL_JOYSTICK_TYPE_COUNT = 10;

(**
 * Possible connection states for a joystick device.
 *
 * This is used by SDL_GetJoystickConnectionState to report how a device is
 * connected to the system.
 *
 * \since This enum is available since SDL 3.2.0.
 *)
type
  SDL_JoystickConnectionState = Integer;

const
  SDL_JOYSTICK_CONNECTION_INVALID = -1;
  SDL_JOYSTICK_CONNECTION_UNKNOWN = 0;
  SDL_JOYSTICK_CONNECTION_WIRED = 1;
  SDL_JOYSTICK_CONNECTION_WIRELESS = 2;

const
  (**
   * The largest value an SDL_Joystick's axis can report.
   *
   * \since This macro is available since SDL 3.2.0.
   *
   * \sa SDL_JOYSTICK_AXIS_MIN
   *)
  SDL_JOYSTICK_AXIS_MAX = 32767;

const
  (**
   * The smallest value an SDL_Joystick's axis can report.
   *
   * This is a negative number!
   *
   * \since This macro is available since SDL 3.2.0.
   *
   * \sa SDL_JOYSTICK_AXIS_MAX
   *)
  SDL_JOYSTICK_AXIS_MIN = -32768;

(**
 * Locking for atomic access to the joystick API.
 *
 * The SDL joystick functions are thread-safe, however you can lock the
 * joysticks while processing to guarantee that the joystick list won't change
 * and joystick and gamepad events will not be delivered.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_LockJoysticks(); cdecl;
  external LIB_SDL3 name _PU + 'SDL_LockJoysticks';

(**
 * Unlocking for atomic access to the joystick API.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_UnlockJoysticks(); cdecl;
  external LIB_SDL3 name _PU + 'SDL_UnlockJoysticks';

(**
 * Return whether a joystick is currently connected.
 *
 * \returns true if a joystick is connected, false otherwise.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetJoysticks
 *)
function SDL_HasJoystick(): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_HasJoystick';

(**
 * Get a list of currently connected joysticks.
 *
 * \param count a pointer filled in with the number of joysticks returned, may
 *              be NULL.
 * \returns a 0 terminated array of joystick instance IDs or NULL on failure;
 *          call SDL_GetError() for more information. This should be freed
 *          with SDL_free() when it is no longer needed.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_HasJoystick
 * \sa SDL_OpenJoystick
 *)
function SDL_GetJoysticks(count: PInteger): PSDL_JoystickID; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetJoysticks';

(**
 * Get the implementation dependent name of a joystick.
 *
 * This can be called before any joysticks are opened.
 *
 * \param instance_id the joystick instance ID.
 * \returns the name of the selected joystick. If no name can be found, this
 *          function returns NULL; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetJoystickName
 * \sa SDL_GetJoysticks
 *)
function SDL_GetJoystickNameForID(instance_id: SDL_JoystickID): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetJoystickNameForID';

(**
 * Get the implementation dependent path of a joystick.
 *
 * This can be called before any joysticks are opened.
 *
 * \param instance_id the joystick instance ID.
 * \returns the path of the selected joystick. If no path can be found, this
 *          function returns NULL; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetJoystickPath
 * \sa SDL_GetJoysticks
 *)
function SDL_GetJoystickPathForID(instance_id: SDL_JoystickID): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetJoystickPathForID';

(**
 * Get the player index of a joystick.
 *
 * This can be called before any joysticks are opened.
 *
 * \param instance_id the joystick instance ID.
 * \returns the player index of a joystick, or -1 if it's not available.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetJoystickPlayerIndex
 * \sa SDL_GetJoysticks
 *)
function SDL_GetJoystickPlayerIndexForID(instance_id: SDL_JoystickID): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetJoystickPlayerIndexForID';

(**
 * Get the implementation-dependent GUID of a joystick.
 *
 * This can be called before any joysticks are opened.
 *
 * \param instance_id the joystick instance ID.
 * \returns the GUID of the selected joystick. If called with an invalid
 *          instance_id, this function returns a zero GUID.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetJoystickGUID
 * \sa SDL_GUIDToString
 *)
function SDL_GetJoystickGUIDForID(instance_id: SDL_JoystickID): SDL_GUID; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetJoystickGUIDForID';

(**
 * Get the USB vendor ID of a joystick, if available.
 *
 * This can be called before any joysticks are opened. If the vendor ID isn't
 * available this function returns 0.
 *
 * \param instance_id the joystick instance ID.
 * \returns the USB vendor ID of the selected joystick. If called with an
 *          invalid instance_id, this function returns 0.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetJoystickVendor
 * \sa SDL_GetJoysticks
 *)
function SDL_GetJoystickVendorForID(instance_id: SDL_JoystickID): Uint16; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetJoystickVendorForID';

(**
 * Get the USB product ID of a joystick, if available.
 *
 * This can be called before any joysticks are opened. If the product ID isn't
 * available this function returns 0.
 *
 * \param instance_id the joystick instance ID.
 * \returns the USB product ID of the selected joystick. If called with an
 *          invalid instance_id, this function returns 0.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetJoystickProduct
 * \sa SDL_GetJoysticks
 *)
function SDL_GetJoystickProductForID(instance_id: SDL_JoystickID): Uint16; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetJoystickProductForID';

(**
 * Get the product version of a joystick, if available.
 *
 * This can be called before any joysticks are opened. If the product version
 * isn't available this function returns 0.
 *
 * \param instance_id the joystick instance ID.
 * \returns the product version of the selected joystick. If called with an
 *          invalid instance_id, this function returns 0.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetJoystickProductVersion
 * \sa SDL_GetJoysticks
 *)
function SDL_GetJoystickProductVersionForID(instance_id: SDL_JoystickID): Uint16; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetJoystickProductVersionForID';

(**
 * Get the type of a joystick, if available.
 *
 * This can be called before any joysticks are opened.
 *
 * \param instance_id the joystick instance ID.
 * \returns the SDL_JoystickType of the selected joystick. If called with an
 *          invalid instance_id, this function returns
 *          `SDL_JOYSTICK_TYPE_UNKNOWN`.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetJoystickType
 * \sa SDL_GetJoysticks
 *)
function SDL_GetJoystickTypeForID(instance_id: SDL_JoystickID): SDL_JoystickType; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetJoystickTypeForID';

(**
 * Open a joystick for use.
 *
 * The joystick subsystem must be initialized before a joystick can be opened
 * for use.
 *
 * \param instance_id the joystick instance ID.
 * \returns a joystick identifier or NULL on failure; call SDL_GetError() for
 *          more information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CloseJoystick
 *)
function SDL_OpenJoystick(instance_id: SDL_JoystickID): SDL_Joystick; cdecl;
  external LIB_SDL3 name _PU + 'SDL_OpenJoystick';

(**
 * Get the SDL_Joystick associated with an instance ID, if it has been opened.
 *
 * \param instance_id the instance ID to get the SDL_Joystick for.
 * \returns an SDL_Joystick on success or NULL on failure or if it hasn't been
 *          opened yet; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetJoystickFromID(instance_id: SDL_JoystickID): SDL_Joystick; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetJoystickFromID';

(**
 * Get the SDL_Joystick associated with a player index.
 *
 * \param player_index the player index to get the SDL_Joystick for.
 * \returns an SDL_Joystick on success or NULL on failure; call SDL_GetError()
 *          for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetJoystickPlayerIndex
 * \sa SDL_SetJoystickPlayerIndex
 *)
function SDL_GetJoystickFromPlayerIndex(player_index: Integer): SDL_Joystick; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetJoystickFromPlayerIndex';

type
  (**
   * The structure that describes a virtual joystick touchpad.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_VirtualJoystickDesc
   *)
  SDL_VirtualJoystickTouchpadDesc = record
    (** the number of simultaneous fingers on this touchpad *)
    nfingers: int16;
    padding: array [0..2] of Uint16;
  end;
  PSDL_VirtualJoystickTouchpadDesc = ^SDL_VirtualJoystickTouchpadDesc;

  (**
   * The structure that describes a virtual joystick sensor.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_VirtualJoystickDesc
   *)
  SDL_VirtualJoystickSensorDesc = record
    (** the type of this sensor *)
    &type: SDL_SensorType;
    (** the update frequency of this sensor, may be 0.0f *)
    rate: Single;
  end;
  PSDL_VirtualJoystickSensorDesc = ^SDL_VirtualJoystickSensorDesc;

  (**
   * The structure that describes a virtual joystick.
   *
   * This structure should be initialized using SDL_INIT_INTERFACE(). All
   * elements of this structure are optional.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_AttachVirtualJoystick
   * \sa SDL_INIT_INTERFACE
   * \sa SDL_VirtualJoystickSensorDesc
   * \sa SDL_VirtualJoystickTouchpadDesc
   *)
  SDL_VirtualJoystickDesc = record
    (** the version of this interface *)
    version: Uint32;
    (** `SDL_JoystickType` *)
    &type: Uint16;
    (** unused *)
    padding: Uint16;
    (** the USB vendor ID of this joystick *)
    vendor_id: Uint16;
    (** the USB product ID of this joystick *)
    product_id: Uint16;
    (** the number of axes on this joystick *)
    naxes: int16;
    (** the number of buttons on this joystick *)
    nbuttons: int16;
    (** the number of balls on this joystick *)
    nballs: int16;
    (** the number of hats on this joystick *)
    nhats: int16;
    (** the number of touchpads on this joystick, requires `touchpads` to point at valid descriptions *)
    ntouchpads: int16;
    (** the number of sensors on this joystick, requires `sensors` to point at valid descriptions *)
    nsensors: int16;
    (** unused *)
    padding2: array [0..1] of Uint16;
    (** A mask of which buttons are valid for this controller
                                 e.g. (1 << SDL_GAMEPAD_BUTTON_SOUTH) *)
    button_mask: Uint32;
    (** A mask of which axes are valid for this controller
                                 e.g. (1 << SDL_GAMEPAD_AXIS_LEFTX) *)
    axis_mask: Uint32;
    (** the name of the joystick *)
    name: PUTF8Char;
    (** A pointer to an array of touchpad descriptions, required if `ntouchpads` is > 0 *)
    touchpads: PSDL_VirtualJoystickTouchpadDesc;
    (** A pointer to an array of sensor descriptions, required if `nsensors` is > 0 *)
    sensors: PSDL_VirtualJoystickSensorDesc;
    (** User data pointer passed to callbacks *)
    userdata: Pointer;
    (** Called when the joystick state should be updated *)
    Update: procedure(userdata: Pointer); cdecl;
    (** Called when the player index is set *)
    SetPlayerIndex: procedure(userdata: Pointer; player_index: Integer); cdecl;
    (** Implements SDL_RumbleJoystick() *)
    Rumble: function(userdata: Pointer; low_frequency_rumble: Uint16; high_frequency_rumble: Uint16): Boolean; cdecl;
    (** Implements SDL_RumbleJoystickTriggers() *)
    RumbleTriggers: function(userdata: Pointer; left_rumble: Uint16; right_rumble: Uint16): Boolean; cdecl;
    (** Implements SDL_SetJoystickLED() *)
    SetLED: function(userdata: Pointer; red: Uint8; green: Uint8; blue: Uint8): Boolean; cdecl;
    (** Implements SDL_SendJoystickEffect() *)
    SendEffect: function(userdata: Pointer; const data: Pointer; size: Integer): Boolean; cdecl;
    (** Implements SDL_SetGamepadSensorEnabled() *)
    SetSensorsEnabled: function(userdata: Pointer; enabled: Boolean): Boolean; cdecl;
    (** Cleans up the userdata when the joystick is detached *)
    Cleanup: procedure(userdata: Pointer); cdecl;
  end;
  PSDL_VirtualJoystickDesc = ^SDL_VirtualJoystickDesc;

(**
 * Attach a new virtual joystick.
 *
 * \param desc joystick description, initialized using SDL_INIT_INTERFACE().
 * \returns the joystick instance ID, or 0 on failure; call SDL_GetError() for
 *          more information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_DetachVirtualJoystick
 *)
function SDL_AttachVirtualJoystick(const desc: PSDL_VirtualJoystickDesc): SDL_JoystickID; cdecl;
  external LIB_SDL3 name _PU + 'SDL_AttachVirtualJoystick';

(**
 * Detach a virtual joystick.
 *
 * \param instance_id the joystick instance ID, previously returned from
 *                    SDL_AttachVirtualJoystick().
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_AttachVirtualJoystick
 *)
function SDL_DetachVirtualJoystick(instance_id: SDL_JoystickID): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_DetachVirtualJoystick';

(**
 * Query whether or not a joystick is virtual.
 *
 * \param instance_id the joystick instance ID.
 * \returns true if the joystick is virtual, false otherwise.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_IsJoystickVirtual(instance_id: SDL_JoystickID): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_IsJoystickVirtual';

(**
 * Set the state of an axis on an opened virtual joystick.
 *
 * Please note that values set here will not be applied until the next call to
 * SDL_UpdateJoysticks, which can either be called directly, or can be called
 * indirectly through various other SDL APIs, including, but not limited to
 * the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,
 * SDL_WaitEvent.
 *
 * Note that when sending trigger axes, you should scale the value to the full
 * range of Sint16. For example, a trigger at rest would have the value of
 * `SDL_JOYSTICK_AXIS_MIN`.
 *
 * \param joystick the virtual joystick on which to set state.
 * \param axis the index of the axis on the virtual joystick to update.
 * \param value the new value for the specified axis.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_SetJoystickVirtualAxis(joystick: SDL_Joystick; axis: Integer; value: Sint16): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetJoystickVirtualAxis';

(**
 * Generate ball motion on an opened virtual joystick.
 *
 * Please note that values set here will not be applied until the next call to
 * SDL_UpdateJoysticks, which can either be called directly, or can be called
 * indirectly through various other SDL APIs, including, but not limited to
 * the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,
 * SDL_WaitEvent.
 *
 * \param joystick the virtual joystick on which to set state.
 * \param ball the index of the ball on the virtual joystick to update.
 * \param xrel the relative motion on the X axis.
 * \param yrel the relative motion on the Y axis.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_SetJoystickVirtualBall(joystick: SDL_Joystick; ball: Integer; xrel: Sint16; yrel: Sint16): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetJoystickVirtualBall';

(**
 * Set the state of a button on an opened virtual joystick.
 *
 * Please note that values set here will not be applied until the next call to
 * SDL_UpdateJoysticks, which can either be called directly, or can be called
 * indirectly through various other SDL APIs, including, but not limited to
 * the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,
 * SDL_WaitEvent.
 *
 * \param joystick the virtual joystick on which to set state.
 * \param button the index of the button on the virtual joystick to update.
 * \param down true if the button is pressed, false otherwise.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_SetJoystickVirtualButton(joystick: SDL_Joystick; button: Integer; down: Boolean): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetJoystickVirtualButton';

(**
 * Set the state of a hat on an opened virtual joystick.
 *
 * Please note that values set here will not be applied until the next call to
 * SDL_UpdateJoysticks, which can either be called directly, or can be called
 * indirectly through various other SDL APIs, including, but not limited to
 * the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,
 * SDL_WaitEvent.
 *
 * \param joystick the virtual joystick on which to set state.
 * \param hat the index of the hat on the virtual joystick to update.
 * \param value the new value for the specified hat.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_SetJoystickVirtualHat(joystick: SDL_Joystick; hat: Integer; value: Uint8): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetJoystickVirtualHat';

(**
 * Set touchpad finger state on an opened virtual joystick.
 *
 * Please note that values set here will not be applied until the next call to
 * SDL_UpdateJoysticks, which can either be called directly, or can be called
 * indirectly through various other SDL APIs, including, but not limited to
 * the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,
 * SDL_WaitEvent.
 *
 * \param joystick the virtual joystick on which to set state.
 * \param touchpad the index of the touchpad on the virtual joystick to
 *                 update.
 * \param finger the index of the finger on the touchpad to set.
 * \param down true if the finger is pressed, false if the finger is released.
 * \param x the x coordinate of the finger on the touchpad, normalized 0 to 1,
 *          with the origin in the upper left.
 * \param y the y coordinate of the finger on the touchpad, normalized 0 to 1,
 *          with the origin in the upper left.
 * \param pressure the pressure of the finger.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_SetJoystickVirtualTouchpad(joystick: SDL_Joystick; touchpad: Integer; finger: Integer; down: Boolean; x: Single; y: Single; pressure: Single): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetJoystickVirtualTouchpad';

(**
 * Send a sensor update for an opened virtual joystick.
 *
 * Please note that values set here will not be applied until the next call to
 * SDL_UpdateJoysticks, which can either be called directly, or can be called
 * indirectly through various other SDL APIs, including, but not limited to
 * the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,
 * SDL_WaitEvent.
 *
 * \param joystick the virtual joystick on which to set state.
 * \param type the type of the sensor on the virtual joystick to update.
 * \param sensor_timestamp a 64-bit timestamp in nanoseconds associated with
 *                         the sensor reading.
 * \param data the data associated with the sensor reading.
 * \param num_values the number of values pointed to by `data`.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_SendJoystickVirtualSensorData(joystick: SDL_Joystick; &type: SDL_SensorType; sensor_timestamp: Uint64; const data: PSingle; num_values: Integer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SendJoystickVirtualSensorData';

(**
 * Get the properties associated with a joystick.
 *
 * The following read-only properties are provided by SDL:
 *
 * - `SDL_PROP_JOYSTICK_CAP_MONO_LED_BOOLEAN`: true if this joystick has an
 *   LED that has adjustable brightness
 * - `SDL_PROP_JOYSTICK_CAP_RGB_LED_BOOLEAN`: true if this joystick has an LED
 *   that has adjustable color
 * - `SDL_PROP_JOYSTICK_CAP_PLAYER_LED_BOOLEAN`: true if this joystick has a
 *   player LED
 * - `SDL_PROP_JOYSTICK_CAP_RUMBLE_BOOLEAN`: true if this joystick has
 *   left/right rumble
 * - `SDL_PROP_JOYSTICK_CAP_TRIGGER_RUMBLE_BOOLEAN`: true if this joystick has
 *   simple trigger rumble
 *
 * \param joystick the SDL_Joystick obtained from SDL_OpenJoystick().
 * \returns a valid property ID on success or 0 on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetJoystickProperties(joystick: SDL_Joystick): SDL_PropertiesID; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetJoystickProperties';

const
  SDL_PROP_JOYSTICK_CAP_MONO_LED_BOOLEAN = 'SDL.joystick.cap.mono_led';
  SDL_PROP_JOYSTICK_CAP_RGB_LED_BOOLEAN = 'SDL.joystick.cap.rgb_led';
  SDL_PROP_JOYSTICK_CAP_PLAYER_LED_BOOLEAN = 'SDL.joystick.cap.player_led';
  SDL_PROP_JOYSTICK_CAP_RUMBLE_BOOLEAN = 'SDL.joystick.cap.rumble';
  SDL_PROP_JOYSTICK_CAP_TRIGGER_RUMBLE_BOOLEAN = 'SDL.joystick.cap.trigger_rumble';

(**
 * Get the implementation dependent name of a joystick.
 *
 * \param joystick the SDL_Joystick obtained from SDL_OpenJoystick().
 * \returns the name of the selected joystick. If no name can be found, this
 *          function returns NULL; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetJoystickNameForID
 *)
function SDL_GetJoystickName(joystick: SDL_Joystick): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetJoystickName';

(**
 * Get the implementation dependent path of a joystick.
 *
 * \param joystick the SDL_Joystick obtained from SDL_OpenJoystick().
 * \returns the path of the selected joystick. If no path can be found, this
 *          function returns NULL; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetJoystickPathForID
 *)
function SDL_GetJoystickPath(joystick: SDL_Joystick): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetJoystickPath';

(**
 * Get the player index of an opened joystick.
 *
 * For XInput controllers this returns the XInput user index. Many joysticks
 * will not be able to supply this information.
 *
 * \param joystick the SDL_Joystick obtained from SDL_OpenJoystick().
 * \returns the player index, or -1 if it's not available.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetJoystickPlayerIndex
 *)
function SDL_GetJoystickPlayerIndex(joystick: SDL_Joystick): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetJoystickPlayerIndex';

(**
 * Set the player index of an opened joystick.
 *
 * \param joystick the SDL_Joystick obtained from SDL_OpenJoystick().
 * \param player_index player index to assign to this joystick, or -1 to clear
 *                     the player index and turn off player LEDs.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetJoystickPlayerIndex
 *)
function SDL_SetJoystickPlayerIndex(joystick: SDL_Joystick; player_index: Integer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetJoystickPlayerIndex';

(**
 * Get the implementation-dependent GUID for the joystick.
 *
 * This function requires an open joystick.
 *
 * \param joystick the SDL_Joystick obtained from SDL_OpenJoystick().
 * \returns the GUID of the given joystick. If called on an invalid index,
 *          this function returns a zero GUID; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetJoystickGUIDForID
 * \sa SDL_GUIDToString
 *)
function SDL_GetJoystickGUID(joystick: SDL_Joystick): SDL_GUID; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetJoystickGUID';

(**
 * Get the USB vendor ID of an opened joystick, if available.
 *
 * If the vendor ID isn't available this function returns 0.
 *
 * \param joystick the SDL_Joystick obtained from SDL_OpenJoystick().
 * \returns the USB vendor ID of the selected joystick, or 0 if unavailable.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetJoystickVendorForID
 *)
function SDL_GetJoystickVendor(joystick: SDL_Joystick): Uint16; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetJoystickVendor';

(**
 * Get the USB product ID of an opened joystick, if available.
 *
 * If the product ID isn't available this function returns 0.
 *
 * \param joystick the SDL_Joystick obtained from SDL_OpenJoystick().
 * \returns the USB product ID of the selected joystick, or 0 if unavailable.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetJoystickProductForID
 *)
function SDL_GetJoystickProduct(joystick: SDL_Joystick): Uint16; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetJoystickProduct';

(**
 * Get the product version of an opened joystick, if available.
 *
 * If the product version isn't available this function returns 0.
 *
 * \param joystick the SDL_Joystick obtained from SDL_OpenJoystick().
 * \returns the product version of the selected joystick, or 0 if unavailable.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetJoystickProductVersionForID
 *)
function SDL_GetJoystickProductVersion(joystick: SDL_Joystick): Uint16; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetJoystickProductVersion';

(**
 * Get the firmware version of an opened joystick, if available.
 *
 * If the firmware version isn't available this function returns 0.
 *
 * \param joystick the SDL_Joystick obtained from SDL_OpenJoystick().
 * \returns the firmware version of the selected joystick, or 0 if
 *          unavailable.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetJoystickFirmwareVersion(joystick: SDL_Joystick): Uint16; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetJoystickFirmwareVersion';

(**
 * Get the serial number of an opened joystick, if available.
 *
 * Returns the serial number of the joystick, or NULL if it is not available.
 *
 * \param joystick the SDL_Joystick obtained from SDL_OpenJoystick().
 * \returns the serial number of the selected joystick, or NULL if
 *          unavailable.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetJoystickSerial(joystick: SDL_Joystick): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetJoystickSerial';

(**
 * Get the type of an opened joystick.
 *
 * \param joystick the SDL_Joystick obtained from SDL_OpenJoystick().
 * \returns the SDL_JoystickType of the selected joystick.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetJoystickTypeForID
 *)
function SDL_GetJoystickType(joystick: SDL_Joystick): SDL_JoystickType; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetJoystickType';

(**
 * Get the device information encoded in a SDL_GUID structure.
 *
 * \param guid the SDL_GUID you wish to get info about.
 * \param vendor a pointer filled in with the device VID, or 0 if not
 *               available.
 * \param product a pointer filled in with the device PID, or 0 if not
 *                available.
 * \param version a pointer filled in with the device version, or 0 if not
 *                available.
 * \param crc16 a pointer filled in with a CRC used to distinguish different
 *              products with the same VID/PID, or 0 if not available.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetJoystickGUIDForID
 *)
procedure SDL_GetJoystickGUIDInfo(guid: SDL_GUID; vendor: PUint16; product: PUint16; version: PUint16; crc16: PUint16); cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetJoystickGUIDInfo';

(**
 * Get the status of a specified joystick.
 *
 * \param joystick the joystick to query.
 * \returns true if the joystick has been opened, false if it has not; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_JoystickConnected(joystick: SDL_Joystick): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_JoystickConnected';

(**
 * Get the instance ID of an opened joystick.
 *
 * \param joystick an SDL_Joystick structure containing joystick information.
 * \returns the instance ID of the specified joystick on success or 0 on
 *          failure; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetJoystickID(joystick: SDL_Joystick): SDL_JoystickID; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetJoystickID';

(**
 * Get the number of general axis controls on a joystick.
 *
 * Often, the directional pad on a game controller will either look like 4
 * separate buttons or a POV hat, and not axes, but all of this is up to the
 * device and platform.
 *
 * \param joystick an SDL_Joystick structure containing joystick information.
 * \returns the number of axis controls/number of axes on success or -1 on
 *          failure; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetJoystickAxis
 * \sa SDL_GetNumJoystickBalls
 * \sa SDL_GetNumJoystickButtons
 * \sa SDL_GetNumJoystickHats
 *)
function SDL_GetNumJoystickAxes(joystick: SDL_Joystick): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetNumJoystickAxes';

(**
 * Get the number of trackballs on a joystick.
 *
 * Joystick trackballs have only relative motion events associated with them
 * and their state cannot be polled.
 *
 * Most joysticks do not have trackballs.
 *
 * \param joystick an SDL_Joystick structure containing joystick information.
 * \returns the number of trackballs on success or -1 on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetJoystickBall
 * \sa SDL_GetNumJoystickAxes
 * \sa SDL_GetNumJoystickButtons
 * \sa SDL_GetNumJoystickHats
 *)
function SDL_GetNumJoystickBalls(joystick: SDL_Joystick): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetNumJoystickBalls';

(**
 * Get the number of POV hats on a joystick.
 *
 * \param joystick an SDL_Joystick structure containing joystick information.
 * \returns the number of POV hats on success or -1 on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetJoystickHat
 * \sa SDL_GetNumJoystickAxes
 * \sa SDL_GetNumJoystickBalls
 * \sa SDL_GetNumJoystickButtons
 *)
function SDL_GetNumJoystickHats(joystick: SDL_Joystick): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetNumJoystickHats';

(**
 * Get the number of buttons on a joystick.
 *
 * \param joystick an SDL_Joystick structure containing joystick information.
 * \returns the number of buttons on success or -1 on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetJoystickButton
 * \sa SDL_GetNumJoystickAxes
 * \sa SDL_GetNumJoystickBalls
 * \sa SDL_GetNumJoystickHats
 *)
function SDL_GetNumJoystickButtons(joystick: SDL_Joystick): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetNumJoystickButtons';

(**
 * Set the state of joystick event processing.
 *
 * If joystick events are disabled, you must call SDL_UpdateJoysticks()
 * yourself and check the state of the joystick when you want joystick
 * information.
 *
 * \param enabled whether to process joystick events or not.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_JoystickEventsEnabled
 * \sa SDL_UpdateJoysticks
 *)
procedure SDL_SetJoystickEventsEnabled(enabled: Boolean); cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetJoystickEventsEnabled';

(**
 * Query the state of joystick event processing.
 *
 * If joystick events are disabled, you must call SDL_UpdateJoysticks()
 * yourself and check the state of the joystick when you want joystick
 * information.
 *
 * \returns true if joystick events are being processed, false otherwise.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetJoystickEventsEnabled
 *)
function SDL_JoystickEventsEnabled(): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_JoystickEventsEnabled';

(**
 * Update the current state of the open joysticks.
 *
 * This is called automatically by the event loop if any joystick events are
 * enabled.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_UpdateJoysticks(); cdecl;
  external LIB_SDL3 name _PU + 'SDL_UpdateJoysticks';

(**
 * Get the current state of an axis control on a joystick.
 *
 * SDL makes no promises about what part of the joystick any given axis refers
 * to. Your game should have some sort of configuration UI to let users
 * specify what each axis should be bound to. Alternately, SDL's higher-level
 * Game Controller API makes a great effort to apply order to this lower-level
 * interface, so you know that a specific axis is the "left thumb stick," etc.
 *
 * The value returned by SDL_GetJoystickAxis() is a signed integer (-32768 to
 * 32767) representing the current position of the axis. It may be necessary
 * to impose certain tolerances on these values to account for jitter.
 *
 * \param joystick an SDL_Joystick structure containing joystick information.
 * \param axis the axis to query; the axis indices start at index 0.
 * \returns a 16-bit signed integer representing the current position of the
 *          axis or 0 on failure; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetNumJoystickAxes
 *)
function SDL_GetJoystickAxis(joystick: SDL_Joystick; axis: Integer): Sint16; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetJoystickAxis';

(**
 * Get the initial state of an axis control on a joystick.
 *
 * The state is a value ranging from -32768 to 32767.
 *
 * The axis indices start at index 0.
 *
 * \param joystick an SDL_Joystick structure containing joystick information.
 * \param axis the axis to query; the axis indices start at index 0.
 * \param state upon return, the initial value is supplied here.
 * \returns true if this axis has any initial value, or false if not.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetJoystickAxisInitialState(joystick: SDL_Joystick; axis: Integer; state: PSint16): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetJoystickAxisInitialState';

(**
 * Get the ball axis change since the last poll.
 *
 * Trackballs can only return relative motion since the last call to
 * SDL_GetJoystickBall(), these motion deltas are placed into `dx` and `dy`.
 *
 * Most joysticks do not have trackballs.
 *
 * \param joystick the SDL_Joystick to query.
 * \param ball the ball index to query; ball indices start at index 0.
 * \param dx stores the difference in the x axis position since the last poll.
 * \param dy stores the difference in the y axis position since the last poll.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetNumJoystickBalls
 *)
function SDL_GetJoystickBall(joystick: SDL_Joystick; ball: Integer; dx: PInteger; dy: PInteger): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetJoystickBall';

(**
 * Get the current state of a POV hat on a joystick.
 *
 * The returned value will be one of the `SDL_HAT_*` values.
 *
 * \param joystick an SDL_Joystick structure containing joystick information.
 * \param hat the hat index to get the state from; indices start at index 0.
 * \returns the current hat position.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetNumJoystickHats
 *)
function SDL_GetJoystickHat(joystick: SDL_Joystick; hat: Integer): Uint8; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetJoystickHat';

const
  SDL_HAT_CENTERED = $00;
  SDL_HAT_UP = $01;
  SDL_HAT_RIGHT = $02;
  SDL_HAT_DOWN = $04;
  SDL_HAT_LEFT = $08;
  SDL_HAT_RIGHTUP = (SDL_HAT_RIGHT or SDL_HAT_UP);
  SDL_HAT_RIGHTDOWN = (SDL_HAT_RIGHT or SDL_HAT_DOWN);
  SDL_HAT_LEFTUP = (SDL_HAT_LEFT or SDL_HAT_UP);
  SDL_HAT_LEFTDOWN = (SDL_HAT_LEFT or SDL_HAT_DOWN);

(**
 * Get the current state of a button on a joystick.
 *
 * \param joystick an SDL_Joystick structure containing joystick information.
 * \param button the button index to get the state from; indices start at
 *               index 0.
 * \returns true if the button is pressed, false otherwise.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetNumJoystickButtons
 *)
function SDL_GetJoystickButton(joystick: SDL_Joystick; button: Integer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetJoystickButton';

(**
 * Start a rumble effect.
 *
 * Each call to this function cancels any previous rumble effect, and calling
 * it with 0 intensity stops any rumbling.
 *
 * This function requires you to process SDL events or call
 * SDL_UpdateJoysticks() to update rumble state.
 *
 * \param joystick the joystick to vibrate.
 * \param low_frequency_rumble the intensity of the low frequency (left)
 *                             rumble motor, from 0 to 0xFFFF.
 * \param high_frequency_rumble the intensity of the high frequency (right)
 *                              rumble motor, from 0 to 0xFFFF.
 * \param duration_ms the duration of the rumble effect, in milliseconds.
 * \returns true, or false if rumble isn't supported on this joystick.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_RumbleJoystick(joystick: SDL_Joystick; low_frequency_rumble: Uint16; high_frequency_rumble: Uint16; duration_ms: Uint32): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_RumbleJoystick';

(**
 * Start a rumble effect in the joystick's triggers.
 *
 * Each call to this function cancels any previous trigger rumble effect, and
 * calling it with 0 intensity stops any rumbling.
 *
 * Note that this is rumbling of the _triggers_ and not the game controller as
 * a whole. This is currently only supported on Xbox One controllers. If you
 * want the (more common) whole-controller rumble, use SDL_RumbleJoystick()
 * instead.
 *
 * This function requires you to process SDL events or call
 * SDL_UpdateJoysticks() to update rumble state.
 *
 * \param joystick the joystick to vibrate.
 * \param left_rumble the intensity of the left trigger rumble motor, from 0
 *                    to 0xFFFF.
 * \param right_rumble the intensity of the right trigger rumble motor, from 0
 *                     to 0xFFFF.
 * \param duration_ms the duration of the rumble effect, in milliseconds.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_RumbleJoystick
 *)
function SDL_RumbleJoystickTriggers(joystick: SDL_Joystick; left_rumble: Uint16; right_rumble: Uint16; duration_ms: Uint32): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_RumbleJoystickTriggers';

(**
 * Update a joystick's LED color.
 *
 * An example of a joystick LED is the light on the back of a PlayStation 4's
 * DualShock 4 controller.
 *
 * For joysticks with a single color LED, the maximum of the RGB values will
 * be used as the LED brightness.
 *
 * \param joystick the joystick to update.
 * \param red the intensity of the red LED.
 * \param green the intensity of the green LED.
 * \param blue the intensity of the blue LED.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_SetJoystickLED(joystick: SDL_Joystick; red: Uint8; green: Uint8; blue: Uint8): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetJoystickLED';

(**
 * Send a joystick specific effect packet.
 *
 * \param joystick the joystick to affect.
 * \param data the data to send to the joystick.
 * \param size the size of the data to send to the joystick.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_SendJoystickEffect(joystick: SDL_Joystick; const data: Pointer; size: Integer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SendJoystickEffect';

(**
 * Close a joystick previously opened with SDL_OpenJoystick().
 *
 * \param joystick the joystick device to close.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_OpenJoystick
 *)
procedure SDL_CloseJoystick(joystick: SDL_Joystick); cdecl;
  external LIB_SDL3 name _PU + 'SDL_CloseJoystick';

(**
 * Get the connection state of a joystick.
 *
 * \param joystick the joystick to query.
 * \returns the connection state on success or
 *          `SDL_JOYSTICK_CONNECTION_INVALID` on failure; call SDL_GetError()
 *          for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetJoystickConnectionState(joystick: SDL_Joystick): SDL_JoystickConnectionState; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetJoystickConnectionState';

(**
 * Get the battery state of a joystick.
 *
 * You should never take a battery status as absolute truth. Batteries
 * (especially failing batteries) are delicate hardware, and the values
 * reported here are best estimates based on what that hardware reports. It's
 * not uncommon for older batteries to lose stored power much faster than it
 * reports, or completely drain when reporting it has 20 percent left, etc.
 *
 * \param joystick the joystick to query.
 * \param percent a pointer filled in with the percentage of battery life
 *                left, between 0 and 100, or NULL to ignore. This will be
 *                filled in with -1 we can't determine a value or there is no
 *                battery.
 * \returns the current battery state or `SDL_POWERSTATE_ERROR` on failure;
 *          call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetJoystickPowerInfo(joystick: SDL_Joystick; percent: PInteger): SDL_PowerState; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetJoystickPowerInfo';
{$ENDREGION 'SDL_joystick.h'}

{$REGION 'SDL_gamepad.h'}
(**
 * # CategoryGamepad
 *
 * SDL provides a low-level joystick API, which just treats joysticks as an
 * arbitrary pile of buttons, axes, and hat switches. If you're planning to
 * write your own control configuration screen, this can give you a lot of
 * flexibility, but that's a lot of work, and most things that we consider
 * "joysticks" now are actually console-style gamepads. So SDL provides the
 * gamepad API on top of the lower-level joystick functionality.
 *
 * The difference betweena joystick and a gamepad is that a gamepad tells you
 * _where_ a button or axis is on the device. You don't speak to gamepads in
 * terms of arbitrary numbers like "button 3" or "axis 2" but in standard
 * locations: the d-pad, the shoulder buttons, triggers, A/B/X/Y (or
 * X/O/Square/Triangle, if you will).
 *
 * One turns a joystick into a gamepad by providing a magic configuration
 * string, which tells SDL the details of a specific device: when you see this
 * specific hardware, if button 2 gets pressed, this is actually D-Pad Up,
 * etc.
 *
 * SDL has many popular controllers configured out of the box, and users can
 * add their own controller details through an environment variable if it's
 * otherwise unknown to SDL.
 *
 * In order to use these functions, SDL_Init() must have been called with the
 * SDL_INIT_GAMEPAD flag. This causes SDL to scan the system for gamepads, and
 * load appropriate drivers.
 *
 * If you would like to receive gamepad updates while the application is in
 * the background, you should set the following hint before calling
 * SDL_Init(): SDL_HINT_JOYSTICK_ALLOW_BACKGROUND_EVENTS
 *
 * Gamepads support various optional features such as rumble, color LEDs,
 * touchpad, gyro, etc. The support for these features varies depending on the
 * controller and OS support available. You can check for LED and rumble
 * capabilities at runtime by calling SDL_GetGamepadProperties() and checking
 * the various capability properties. You can check for touchpad by calling
 * SDL_GetNumGamepadTouchpads() and check for gyro and accelerometer by
 * calling SDL_GamepadHasSensor().
 *
 * By default SDL will try to use the most capable driver available, but you
 * can tune which OS drivers to use with the various joystick hints in
 * SDL_hints.h.
 *
 * Your application should always support gamepad hotplugging. On some
 * platforms like Xbox, Steam Deck, etc., this is a requirement for
 * certification. On other platforms, like macOS and Windows when using
 * Windows.Gaming.Input, controllers may not be available at startup and will
 * come in at some point after you've started processing events.
 *)

type
  (**
   * The structure used to identify an SDL gamepad
   *
   * \since This struct is available since SDL 3.2.0.
   *)
  SDL_Gamepad = THandle;

(**
 * Standard gamepad types.
 *
 * This type does not necessarily map to first-party controllers from
 * Microsoft/Sony/Nintendo; in many cases, third-party controllers can report
 * as these, either because they were designed for a specific console, or they
 * simply most closely match that console's controllers (does it have A/B/X/Y
 * buttons or X/O/Square/Triangle? Does it have a touchpad? etc).
 *)
type
  SDL_GamepadType = Integer;

const
  SDL_GAMEPAD_TYPE_UNKNOWN = 0;
  SDL_GAMEPAD_TYPE_STANDARD = 1;
  SDL_GAMEPAD_TYPE_XBOX360 = 2;
  SDL_GAMEPAD_TYPE_XBOXONE = 3;
  SDL_GAMEPAD_TYPE_PS3 = 4;
  SDL_GAMEPAD_TYPE_PS4 = 5;
  SDL_GAMEPAD_TYPE_PS5 = 6;
  SDL_GAMEPAD_TYPE_NINTENDO_SWITCH_PRO = 7;
  SDL_GAMEPAD_TYPE_NINTENDO_SWITCH_JOYCON_LEFT = 8;
  SDL_GAMEPAD_TYPE_NINTENDO_SWITCH_JOYCON_RIGHT = 9;
  SDL_GAMEPAD_TYPE_NINTENDO_SWITCH_JOYCON_PAIR = 10;
  SDL_GAMEPAD_TYPE_COUNT = 11;

(**
 * The list of buttons available on a gamepad
 *
 * For controllers that use a diamond pattern for the face buttons, the
 * south/east/west/north buttons below correspond to the locations in the
 * diamond pattern. For Xbox controllers, this would be A/B/X/Y, for Nintendo
 * Switch controllers, this would be B/A/Y/X, for PlayStation controllers this
 * would be Cross/Circle/Square/Triangle.
 *
 * For controllers that don't use a diamond pattern for the face buttons, the
 * south/east/west/north buttons indicate the buttons labeled A, B, C, D, or
 * 1, 2, 3, 4, or for controllers that aren't labeled, they are the primary,
 * secondary, etc. buttons.
 *
 * The activate action is often the south button and the cancel action is
 * often the east button, but in some regions this is reversed, so your game
 * should allow remapping actions based on user preferences.
 *
 * You can query the labels for the face buttons using
 * SDL_GetGamepadButtonLabel()
 *
 * \since This enum is available since SDL 3.2.0.
 *)
type
  SDL_GamepadButton = Integer;

const
  SDL_GAMEPAD_BUTTON_INVALID = -1;
  (** Bottom face button (e.g. Xbox A button) *)
  SDL_GAMEPAD_BUTTON_SOUTH = 0;
  (** Right face button (e.g. Xbox B button) *)
  SDL_GAMEPAD_BUTTON_EAST = 1;
  (** Left face button (e.g. Xbox X button) *)
  SDL_GAMEPAD_BUTTON_WEST = 2;
  (** Top face button (e.g. Xbox Y button) *)
  SDL_GAMEPAD_BUTTON_NORTH = 3;
  SDL_GAMEPAD_BUTTON_BACK = 4;
  SDL_GAMEPAD_BUTTON_GUIDE = 5;
  SDL_GAMEPAD_BUTTON_START = 6;
  SDL_GAMEPAD_BUTTON_LEFT_STICK = 7;
  SDL_GAMEPAD_BUTTON_RIGHT_STICK = 8;
  SDL_GAMEPAD_BUTTON_LEFT_SHOULDER = 9;
  SDL_GAMEPAD_BUTTON_RIGHT_SHOULDER = 10;
  SDL_GAMEPAD_BUTTON_DPAD_UP = 11;
  SDL_GAMEPAD_BUTTON_DPAD_DOWN = 12;
  SDL_GAMEPAD_BUTTON_DPAD_LEFT = 13;
  SDL_GAMEPAD_BUTTON_DPAD_RIGHT = 14;
  (** Additional button (e.g. Xbox Series X share button, PS5 microphone button, Nintendo Switch Pro capture button, Amazon Luna microphone button, Google Stadia capture button) *)
  SDL_GAMEPAD_BUTTON_MISC1 = 15;
  (** Upper or primary paddle, under your right hand (e.g. Xbox Elite paddle P1) *)
  SDL_GAMEPAD_BUTTON_RIGHT_PADDLE1 = 16;
  (** Upper or primary paddle, under your left hand (e.g. Xbox Elite paddle P3) *)
  SDL_GAMEPAD_BUTTON_LEFT_PADDLE1 = 17;
  (** Lower or secondary paddle, under your right hand (e.g. Xbox Elite paddle P2) *)
  SDL_GAMEPAD_BUTTON_RIGHT_PADDLE2 = 18;
  (** Lower or secondary paddle, under your left hand (e.g. Xbox Elite paddle P4) *)
  SDL_GAMEPAD_BUTTON_LEFT_PADDLE2 = 19;
  (** PS4/PS5 touchpad button *)
  SDL_GAMEPAD_BUTTON_TOUCHPAD = 20;
  (** Additional button *)
  SDL_GAMEPAD_BUTTON_MISC2 = 21;
  (** Additional button *)
  SDL_GAMEPAD_BUTTON_MISC3 = 22;
  (** Additional button *)
  SDL_GAMEPAD_BUTTON_MISC4 = 23;
  (** Additional button *)
  SDL_GAMEPAD_BUTTON_MISC5 = 24;
  (** Additional button *)
  SDL_GAMEPAD_BUTTON_MISC6 = 25;
  SDL_GAMEPAD_BUTTON_COUNT = 26;

(**
 * The set of gamepad button labels
 *
 * This isn't a complete set, just the face buttons to make it easy to show
 * button prompts.
 *
 * For a complete set, you should look at the button and gamepad type and have
 * a set of symbols that work well with your art style.
 *
 * \since This enum is available since SDL 3.2.0.
 *)
type
  SDL_GamepadButtonLabel = Integer;

const
  SDL_GAMEPAD_BUTTON_LABEL_UNKNOWN = 0;
  SDL_GAMEPAD_BUTTON_LABEL_A = 1;
  SDL_GAMEPAD_BUTTON_LABEL_B = 2;
  SDL_GAMEPAD_BUTTON_LABEL_X = 3;
  SDL_GAMEPAD_BUTTON_LABEL_Y = 4;
  SDL_GAMEPAD_BUTTON_LABEL_CROSS = 5;
  SDL_GAMEPAD_BUTTON_LABEL_CIRCLE = 6;
  SDL_GAMEPAD_BUTTON_LABEL_SQUARE = 7;
  SDL_GAMEPAD_BUTTON_LABEL_TRIANGLE = 8;

(**
 * The list of axes available on a gamepad
 *
 * Thumbstick axis values range from SDL_JOYSTICK_AXIS_MIN to
 * SDL_JOYSTICK_AXIS_MAX, and are centered within ~8000 of zero, though
 * advanced UI will allow users to set or autodetect the dead zone, which
 * varies between gamepads.
 *
 * Trigger axis values range from 0 (released) to SDL_JOYSTICK_AXIS_MAX (fully
 * pressed) when reported by SDL_GetGamepadAxis(). Note that this is not the
 * same range that will be reported by the lower-level SDL_GetJoystickAxis().
 *
 * \since This enum is available since SDL 3.2.0.
 *)
type
  SDL_GamepadAxis = Integer;

const
  SDL_GAMEPAD_AXIS_INVALID = -1;
  SDL_GAMEPAD_AXIS_LEFTX = 0;
  SDL_GAMEPAD_AXIS_LEFTY = 1;
  SDL_GAMEPAD_AXIS_RIGHTX = 2;
  SDL_GAMEPAD_AXIS_RIGHTY = 3;
  SDL_GAMEPAD_AXIS_LEFT_TRIGGER = 4;
  SDL_GAMEPAD_AXIS_RIGHT_TRIGGER = 5;
  SDL_GAMEPAD_AXIS_COUNT = 6;

(**
 * Types of gamepad control bindings.
 *
 * A gamepad is a collection of bindings that map arbitrary joystick buttons,
 * axes and hat switches to specific positions on a generic console-style
 * gamepad. This enum is used as part of SDL_GamepadBinding to specify those
 * mappings.
 *
 * \since This enum is available since SDL 3.2.0.
 *)
type
  SDL_GamepadBindingType = Integer;

const
  SDL_GAMEPAD_BINDTYPE_NONE = 0;
  SDL_GAMEPAD_BINDTYPE_BUTTON = 1;
  SDL_GAMEPAD_BINDTYPE_AXIS = 2;
  SDL_GAMEPAD_BINDTYPE_HAT = 3;

type
  (**
   * A mapping between one joystick input to a gamepad control.
   *
   * A gamepad has a collection of several bindings, to say, for example, when
   * joystick button number 5 is pressed, that should be treated like the
   * gamepad's "start" button.
   *
   * SDL has these bindings built-in for many popular controllers, and can add
   * more with a simple text string. Those strings are parsed into a collection
   * of these structs to make it easier to operate on the data.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_GetGamepadBindings
   *)

  SDL_GamepadBinding = record
  public
    input_type: SDL_GamepadBindingType;
    input:  record
            case Integer of
              0: (button: Integer);
              1: (axis: record
                          axis: Integer;
                          axis_min: Integer;
                          axis_max: Integer;
                        end);
              2: (hat:  record
                          hat: Integer;
                          hat_mask: Integer
                        end);
            end;
    output_type: SDL_GamepadBindingType;
    output: record
            case Integer of
              0: (button: SDL_GamepadButton);
              1: (axis: record
                          axis: SDL_GamepadAxis;
                          axis_min: Integer;
                          axis_max: Integer;
                        end);
            end;
  end;
  PSDL_GamepadBinding = ^SDL_GamepadBinding;
  PPSDL_GamepadBinding = ^PSDL_GamepadBinding;

(**
 * Add support for gamepads that SDL is unaware of or change the binding of an
 * existing gamepad.
 *
 * The mapping string has the format "GUID,name,mapping", where GUID is the
 * string value from SDL_GUIDToString(), name is the human readable string for
 * the device and mappings are gamepad mappings to joystick ones. Under
 * Windows there is a reserved GUID of "xinput" that covers all XInput
 * devices. The mapping format for joystick is:
 *
 * - `bX`: a joystick button, index X
 * - `hX.Y`: hat X with value Y
 * - `aX`: axis X of the joystick
 *
 * Buttons can be used as a gamepad axes and vice versa.
 *
 * If a device with this GUID is already plugged in, SDL will generate an
 * SDL_EVENT_GAMEPAD_ADDED event.
 *
 * This string shows an example of a valid mapping for a gamepad:
 *
 * ```c
 * "341a3608000000000000504944564944,Afterglow PS3 Controller,a:b1,b:b2,y:b3,x:b0,start:b9,guide:b12,back:b8,dpup:h0.1,dpleft:h0.8,dpdown:h0.4,dpright:h0.2,leftshoulder:b4,rightshoulder:b5,leftstick:b10,rightstick:b11,leftx:a0,lefty:a1,rightx:a2,righty:a3,lefttrigger:b6,righttrigger:b7"
 * ```
 *
 * \param mapping the mapping string.
 * \returns 1 if a new mapping is added, 0 if an existing mapping is updated,
 *          -1 on failure; call SDL_GetError() for more information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_AddGamepadMappingsFromFile
 * \sa SDL_AddGamepadMappingsFromIO
 * \sa SDL_GetGamepadMapping
 * \sa SDL_GetGamepadMappingForGUID
 * \sa SDL_HINT_GAMECONTROLLERCONFIG
 * \sa SDL_HINT_GAMECONTROLLERCONFIG_FILE
 * \sa SDL_EVENT_GAMEPAD_ADDED
 *)
function SDL_AddGamepadMapping(const mapping: PUTF8Char): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_AddGamepadMapping';

(**
 * Load a set of gamepad mappings from an SDL_IOStream.
 *
 * You can call this function several times, if needed, to load different
 * database files.
 *
 * If a new mapping is loaded for an already known gamepad GUID, the later
 * version will overwrite the one currently loaded.
 *
 * Any new mappings for already plugged in controllers will generate
 * SDL_EVENT_GAMEPAD_ADDED events.
 *
 * Mappings not belonging to the current platform or with no platform field
 * specified will be ignored (i.e. mappings for Linux will be ignored in
 * Windows, etc).
 *
 * This function will load the text database entirely in memory before
 * processing it, so take this into consideration if you are in a memory
 * constrained environment.
 *
 * \param src the data stream for the mappings to be added.
 * \param closeio if true, calls SDL_CloseIO() on `src` before returning, even
 *                in the case of an error.
 * \returns the number of mappings added or -1 on failure; call SDL_GetError()
 *          for more information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_AddGamepadMapping
 * \sa SDL_AddGamepadMappingsFromFile
 * \sa SDL_GetGamepadMapping
 * \sa SDL_GetGamepadMappingForGUID
 * \sa SDL_HINT_GAMECONTROLLERCONFIG
 * \sa SDL_HINT_GAMECONTROLLERCONFIG_FILE
 * \sa SDL_EVENT_GAMEPAD_ADDED
 *)
function SDL_AddGamepadMappingsFromIO(src: SDL_IOStream; closeio: Boolean): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_AddGamepadMappingsFromIO';

(**
 * Load a set of gamepad mappings from a file.
 *
 * You can call this function several times, if needed, to load different
 * database files.
 *
 * If a new mapping is loaded for an already known gamepad GUID, the later
 * version will overwrite the one currently loaded.
 *
 * Any new mappings for already plugged in controllers will generate
 * SDL_EVENT_GAMEPAD_ADDED events.
 *
 * Mappings not belonging to the current platform or with no platform field
 * specified will be ignored (i.e. mappings for Linux will be ignored in
 * Windows, etc).
 *
 * \param file the mappings file to load.
 * \returns the number of mappings added or -1 on failure; call SDL_GetError()
 *          for more information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_AddGamepadMapping
 * \sa SDL_AddGamepadMappingsFromIO
 * \sa SDL_GetGamepadMapping
 * \sa SDL_GetGamepadMappingForGUID
 * \sa SDL_HINT_GAMECONTROLLERCONFIG
 * \sa SDL_HINT_GAMECONTROLLERCONFIG_FILE
 * \sa SDL_EVENT_GAMEPAD_ADDED
 *)
function SDL_AddGamepadMappingsFromFile(const &file: PUTF8Char): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_AddGamepadMappingsFromFile';

(**
 * Reinitialize the SDL mapping database to its initial state.
 *
 * This will generate gamepad events as needed if device mappings change.
 *
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_ReloadGamepadMappings(): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_ReloadGamepadMappings';

(**
 * Get the current gamepad mappings.
 *
 * \param count a pointer filled in with the number of mappings returned, can
 *              be NULL.
 * \returns an array of the mapping strings, NULL-terminated, or NULL on
 *          failure; call SDL_GetError() for more information. This is a
 *          single allocation that should be freed with SDL_free() when it is
 *          no longer needed.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetGamepadMappings(count: PInteger): PPUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetGamepadMappings';

(**
 * Get the gamepad mapping string for a given GUID.
 *
 * \param guid a structure containing the GUID for which a mapping is desired.
 * \returns a mapping string or NULL on failure; call SDL_GetError() for more
 *          information. This should be freed with SDL_free() when it is no
 *          longer needed.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetJoystickGUIDForID
 * \sa SDL_GetJoystickGUID
 *)
function SDL_GetGamepadMappingForGUID(guid: SDL_GUID): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetGamepadMappingForGUID';

(**
 * Get the current mapping of a gamepad.
 *
 * Details about mappings are discussed with SDL_AddGamepadMapping().
 *
 * \param gamepad the gamepad you want to get the current mapping for.
 * \returns a string that has the gamepad's mapping or NULL if no mapping is
 *          available; call SDL_GetError() for more information. This should
 *          be freed with SDL_free() when it is no longer needed.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_AddGamepadMapping
 * \sa SDL_GetGamepadMappingForID
 * \sa SDL_GetGamepadMappingForGUID
 * \sa SDL_SetGamepadMapping
 *)
function SDL_GetGamepadMapping(gamepad: SDL_Gamepad): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetGamepadMapping';

(**
 * Set the current mapping of a joystick or gamepad.
 *
 * Details about mappings are discussed with SDL_AddGamepadMapping().
 *
 * \param instance_id the joystick instance ID.
 * \param mapping the mapping to use for this device, or NULL to clear the
 *                mapping.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_AddGamepadMapping
 * \sa SDL_GetGamepadMapping
 *)
function SDL_SetGamepadMapping(instance_id: SDL_JoystickID; const mapping: PUTF8Char): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetGamepadMapping';

(**
 * Return whether a gamepad is currently connected.
 *
 * \returns true if a gamepad is connected, false otherwise.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetGamepads
 *)
function SDL_HasGamepad(): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_HasGamepad';

(**
 * Get a list of currently connected gamepads.
 *
 * \param count a pointer filled in with the number of gamepads returned, may
 *              be NULL.
 * \returns a 0 terminated array of joystick instance IDs or NULL on failure;
 *          call SDL_GetError() for more information. This should be freed
 *          with SDL_free() when it is no longer needed.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_HasGamepad
 * \sa SDL_OpenGamepad
 *)
function SDL_GetGamepads(count: PInteger): PSDL_JoystickID; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetGamepads';

(**
 * Check if the given joystick is supported by the gamepad interface.
 *
 * \param instance_id the joystick instance ID.
 * \returns true if the given joystick is supported by the gamepad interface,
 *          false if it isn't or it's an invalid index.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetJoysticks
 * \sa SDL_OpenGamepad
 *)
function SDL_IsGamepad(instance_id: SDL_JoystickID): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_IsGamepad';

(**
 * Get the implementation dependent name of a gamepad.
 *
 * This can be called before any gamepads are opened.
 *
 * \param instance_id the joystick instance ID.
 * \returns the name of the selected gamepad. If no name can be found, this
 *          function returns NULL; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetGamepadName
 * \sa SDL_GetGamepads
 *)
function SDL_GetGamepadNameForID(instance_id: SDL_JoystickID): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetGamepadNameForID';

(**
 * Get the implementation dependent path of a gamepad.
 *
 * This can be called before any gamepads are opened.
 *
 * \param instance_id the joystick instance ID.
 * \returns the path of the selected gamepad. If no path can be found, this
 *          function returns NULL; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetGamepadPath
 * \sa SDL_GetGamepads
 *)
function SDL_GetGamepadPathForID(instance_id: SDL_JoystickID): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetGamepadPathForID';

(**
 * Get the player index of a gamepad.
 *
 * This can be called before any gamepads are opened.
 *
 * \param instance_id the joystick instance ID.
 * \returns the player index of a gamepad, or -1 if it's not available.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetGamepadPlayerIndex
 * \sa SDL_GetGamepads
 *)
function SDL_GetGamepadPlayerIndexForID(instance_id: SDL_JoystickID): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetGamepadPlayerIndexForID';

(**
 * Get the implementation-dependent GUID of a gamepad.
 *
 * This can be called before any gamepads are opened.
 *
 * \param instance_id the joystick instance ID.
 * \returns the GUID of the selected gamepad. If called on an invalid index,
 *          this function returns a zero GUID.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GUIDToString
 * \sa SDL_GetGamepads
 *)
function SDL_GetGamepadGUIDForID(instance_id: SDL_JoystickID): SDL_GUID; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetGamepadGUIDForID';

(**
 * Get the USB vendor ID of a gamepad, if available.
 *
 * This can be called before any gamepads are opened. If the vendor ID isn't
 * available this function returns 0.
 *
 * \param instance_id the joystick instance ID.
 * \returns the USB vendor ID of the selected gamepad. If called on an invalid
 *          index, this function returns zero.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetGamepadVendor
 * \sa SDL_GetGamepads
 *)
function SDL_GetGamepadVendorForID(instance_id: SDL_JoystickID): Uint16; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetGamepadVendorForID';

(**
 * Get the USB product ID of a gamepad, if available.
 *
 * This can be called before any gamepads are opened. If the product ID isn't
 * available this function returns 0.
 *
 * \param instance_id the joystick instance ID.
 * \returns the USB product ID of the selected gamepad. If called on an
 *          invalid index, this function returns zero.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetGamepadProduct
 * \sa SDL_GetGamepads
 *)
function SDL_GetGamepadProductForID(instance_id: SDL_JoystickID): Uint16; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetGamepadProductForID';

(**
 * Get the product version of a gamepad, if available.
 *
 * This can be called before any gamepads are opened. If the product version
 * isn't available this function returns 0.
 *
 * \param instance_id the joystick instance ID.
 * \returns the product version of the selected gamepad. If called on an
 *          invalid index, this function returns zero.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetGamepadProductVersion
 * \sa SDL_GetGamepads
 *)
function SDL_GetGamepadProductVersionForID(instance_id: SDL_JoystickID): Uint16; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetGamepadProductVersionForID';

(**
 * Get the type of a gamepad.
 *
 * This can be called before any gamepads are opened.
 *
 * \param instance_id the joystick instance ID.
 * \returns the gamepad type.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetGamepadType
 * \sa SDL_GetGamepads
 * \sa SDL_GetRealGamepadTypeForID
 *)
function SDL_GetGamepadTypeForID(instance_id: SDL_JoystickID): SDL_GamepadType; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetGamepadTypeForID';

(**
 * Get the type of a gamepad, ignoring any mapping override.
 *
 * This can be called before any gamepads are opened.
 *
 * \param instance_id the joystick instance ID.
 * \returns the gamepad type.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetGamepadTypeForID
 * \sa SDL_GetGamepads
 * \sa SDL_GetRealGamepadType
 *)
function SDL_GetRealGamepadTypeForID(instance_id: SDL_JoystickID): SDL_GamepadType; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetRealGamepadTypeForID';

(**
 * Get the mapping of a gamepad.
 *
 * This can be called before any gamepads are opened.
 *
 * \param instance_id the joystick instance ID.
 * \returns the mapping string. Returns NULL if no mapping is available. This
 *          should be freed with SDL_free() when it is no longer needed.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetGamepads
 * \sa SDL_GetGamepadMapping
 *)
function SDL_GetGamepadMappingForID(instance_id: SDL_JoystickID): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetGamepadMappingForID';

(**
 * Open a gamepad for use.
 *
 * \param instance_id the joystick instance ID.
 * \returns a gamepad identifier or NULL if an error occurred; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CloseGamepad
 * \sa SDL_IsGamepad
 *)
function SDL_OpenGamepad(instance_id: SDL_JoystickID): SDL_Gamepad; cdecl;
  external LIB_SDL3 name _PU + 'SDL_OpenGamepad';

(**
 * Get the SDL_Gamepad associated with a joystick instance ID, if it has been
 * opened.
 *
 * \param instance_id the joystick instance ID of the gamepad.
 * \returns an SDL_Gamepad on success or NULL on failure or if it hasn't been
 *          opened yet; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetGamepadFromID(instance_id: SDL_JoystickID): SDL_Gamepad; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetGamepadFromID';

(**
 * Get the SDL_Gamepad associated with a player index.
 *
 * \param player_index the player index, which different from the instance ID.
 * \returns the SDL_Gamepad associated with a player index.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetGamepadPlayerIndex
 * \sa SDL_SetGamepadPlayerIndex
 *)
function SDL_GetGamepadFromPlayerIndex(player_index: Integer): SDL_Gamepad; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetGamepadFromPlayerIndex';

(**
 * Get the properties associated with an opened gamepad.
 *
 * These properties are shared with the underlying joystick object.
 *
 * The following read-only properties are provided by SDL:
 *
 * - `SDL_PROP_GAMEPAD_CAP_MONO_LED_BOOLEAN`: true if this gamepad has an LED
 *   that has adjustable brightness
 * - `SDL_PROP_GAMEPAD_CAP_RGB_LED_BOOLEAN`: true if this gamepad has an LED
 *   that has adjustable color
 * - `SDL_PROP_GAMEPAD_CAP_PLAYER_LED_BOOLEAN`: true if this gamepad has a
 *   player LED
 * - `SDL_PROP_GAMEPAD_CAP_RUMBLE_BOOLEAN`: true if this gamepad has
 *   left/right rumble
 * - `SDL_PROP_GAMEPAD_CAP_TRIGGER_RUMBLE_BOOLEAN`: true if this gamepad has
 *   simple trigger rumble
 *
 * \param gamepad a gamepad identifier previously returned by
 *                SDL_OpenGamepad().
 * \returns a valid property ID on success or 0 on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetGamepadProperties(gamepad: SDL_Gamepad): SDL_PropertiesID; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetGamepadProperties';

const
  SDL_PROP_GAMEPAD_CAP_MONO_LED_BOOLEAN = SDL_PROP_JOYSTICK_CAP_MONO_LED_BOOLEAN;
  SDL_PROP_GAMEPAD_CAP_RGB_LED_BOOLEAN = SDL_PROP_JOYSTICK_CAP_RGB_LED_BOOLEAN;
  SDL_PROP_GAMEPAD_CAP_PLAYER_LED_BOOLEAN = SDL_PROP_JOYSTICK_CAP_PLAYER_LED_BOOLEAN;
  SDL_PROP_GAMEPAD_CAP_RUMBLE_BOOLEAN = SDL_PROP_JOYSTICK_CAP_RUMBLE_BOOLEAN;
  SDL_PROP_GAMEPAD_CAP_TRIGGER_RUMBLE_BOOLEAN = SDL_PROP_JOYSTICK_CAP_TRIGGER_RUMBLE_BOOLEAN;

(**
 * Get the instance ID of an opened gamepad.
 *
 * \param gamepad a gamepad identifier previously returned by
 *                SDL_OpenGamepad().
 * \returns the instance ID of the specified gamepad on success or 0 on
 *          failure; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetGamepadID(gamepad: SDL_Gamepad): SDL_JoystickID; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetGamepadID';

(**
 * Get the implementation-dependent name for an opened gamepad.
 *
 * \param gamepad a gamepad identifier previously returned by
 *                SDL_OpenGamepad().
 * \returns the implementation dependent name for the gamepad, or NULL if
 *          there is no name or the identifier passed is invalid.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetGamepadNameForID
 *)
function SDL_GetGamepadName(gamepad: SDL_Gamepad): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetGamepadName';

(**
 * Get the implementation-dependent path for an opened gamepad.
 *
 * \param gamepad a gamepad identifier previously returned by
 *                SDL_OpenGamepad().
 * \returns the implementation dependent path for the gamepad, or NULL if
 *          there is no path or the identifier passed is invalid.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetGamepadPathForID
 *)
function SDL_GetGamepadPath(gamepad: SDL_Gamepad): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetGamepadPath';

(**
 * Get the type of an opened gamepad.
 *
 * \param gamepad the gamepad object to query.
 * \returns the gamepad type, or SDL_GAMEPAD_TYPE_UNKNOWN if it's not
 *          available.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetGamepadTypeForID
 *)
function SDL_GetGamepadType(gamepad: SDL_Gamepad): SDL_GamepadType; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetGamepadType';

(**
 * Get the type of an opened gamepad, ignoring any mapping override.
 *
 * \param gamepad the gamepad object to query.
 * \returns the gamepad type, or SDL_GAMEPAD_TYPE_UNKNOWN if it's not
 *          available.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetRealGamepadTypeForID
 *)
function SDL_GetRealGamepadType(gamepad: SDL_Gamepad): SDL_GamepadType; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetRealGamepadType';

(**
 * Get the player index of an opened gamepad.
 *
 * For XInput gamepads this returns the XInput user index.
 *
 * \param gamepad the gamepad object to query.
 * \returns the player index for gamepad, or -1 if it's not available.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetGamepadPlayerIndex
 *)
function SDL_GetGamepadPlayerIndex(gamepad: SDL_Gamepad): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetGamepadPlayerIndex';

(**
 * Set the player index of an opened gamepad.
 *
 * \param gamepad the gamepad object to adjust.
 * \param player_index player index to assign to this gamepad, or -1 to clear
 *                     the player index and turn off player LEDs.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetGamepadPlayerIndex
 *)
function SDL_SetGamepadPlayerIndex(gamepad: SDL_Gamepad; player_index: Integer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetGamepadPlayerIndex';

(**
 * Get the USB vendor ID of an opened gamepad, if available.
 *
 * If the vendor ID isn't available this function returns 0.
 *
 * \param gamepad the gamepad object to query.
 * \returns the USB vendor ID, or zero if unavailable.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetGamepadVendorForID
 *)
function SDL_GetGamepadVendor(gamepad: SDL_Gamepad): Uint16; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetGamepadVendor';

(**
 * Get the USB product ID of an opened gamepad, if available.
 *
 * If the product ID isn't available this function returns 0.
 *
 * \param gamepad the gamepad object to query.
 * \returns the USB product ID, or zero if unavailable.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetGamepadProductForID
 *)
function SDL_GetGamepadProduct(gamepad: SDL_Gamepad): Uint16; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetGamepadProduct';

(**
 * Get the product version of an opened gamepad, if available.
 *
 * If the product version isn't available this function returns 0.
 *
 * \param gamepad the gamepad object to query.
 * \returns the USB product version, or zero if unavailable.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetGamepadProductVersionForID
 *)
function SDL_GetGamepadProductVersion(gamepad: SDL_Gamepad): Uint16; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetGamepadProductVersion';

(**
 * Get the firmware version of an opened gamepad, if available.
 *
 * If the firmware version isn't available this function returns 0.
 *
 * \param gamepad the gamepad object to query.
 * \returns the gamepad firmware version, or zero if unavailable.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetGamepadFirmwareVersion(gamepad: SDL_Gamepad): Uint16; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetGamepadFirmwareVersion';

(**
 * Get the serial number of an opened gamepad, if available.
 *
 * Returns the serial number of the gamepad, or NULL if it is not available.
 *
 * \param gamepad the gamepad object to query.
 * \returns the serial number, or NULL if unavailable.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetGamepadSerial(gamepad: SDL_Gamepad): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetGamepadSerial';

(**
 * Get the Steam Input handle of an opened gamepad, if available.
 *
 * Returns an InputHandle_t for the gamepad that can be used with Steam Input
 * API: https://partner.steamgames.com/doc/api/ISteamInput
 *
 * \param gamepad the gamepad object to query.
 * \returns the gamepad handle, or 0 if unavailable.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetGamepadSteamHandle(gamepad: SDL_Gamepad): Uint64; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetGamepadSteamHandle';

(**
 * Get the connection state of a gamepad.
 *
 * \param gamepad the gamepad object to query.
 * \returns the connection state on success or
 *          `SDL_JOYSTICK_CONNECTION_INVALID` on failure; call SDL_GetError()
 *          for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetGamepadConnectionState(gamepad: SDL_Gamepad): SDL_JoystickConnectionState; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetGamepadConnectionState';

(**
 * Get the battery state of a gamepad.
 *
 * You should never take a battery status as absolute truth. Batteries
 * (especially failing batteries) are delicate hardware, and the values
 * reported here are best estimates based on what that hardware reports. It's
 * not uncommon for older batteries to lose stored power much faster than it
 * reports, or completely drain when reporting it has 20 percent left, etc.
 *
 * \param gamepad the gamepad object to query.
 * \param percent a pointer filled in with the percentage of battery life
 *                left, between 0 and 100, or NULL to ignore. This will be
 *                filled in with -1 we can't determine a value or there is no
 *                battery.
 * \returns the current battery state.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetGamepadPowerInfo(gamepad: SDL_Gamepad; percent: PInteger): SDL_PowerState; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetGamepadPowerInfo';

(**
 * Check if a gamepad has been opened and is currently connected.
 *
 * \param gamepad a gamepad identifier previously returned by
 *                SDL_OpenGamepad().
 * \returns true if the gamepad has been opened and is currently connected, or
 *          false if not.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GamepadConnected(gamepad: SDL_Gamepad): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GamepadConnected';

(**
 * Get the underlying joystick from a gamepad.
 *
 * This function will give you a SDL_Joystick object, which allows you to use
 * the SDL_Joystick functions with a SDL_Gamepad object. This would be useful
 * for getting a joystick's position at any given time, even if it hasn't
 * moved (moving it would produce an event, which would have the axis' value).
 *
 * The pointer returned is owned by the SDL_Gamepad. You should not call
 * SDL_CloseJoystick() on it, for example, since doing so will likely cause
 * SDL to crash.
 *
 * \param gamepad the gamepad object that you want to get a joystick from.
 * \returns an SDL_Joystick object, or NULL on failure; call SDL_GetError()
 *          for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetGamepadJoystick(gamepad: SDL_Gamepad): SDL_Joystick; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetGamepadJoystick';

(**
 * Set the state of gamepad event processing.
 *
 * If gamepad events are disabled, you must call SDL_UpdateGamepads() yourself
 * and check the state of the gamepad when you want gamepad information.
 *
 * \param enabled whether to process gamepad events or not.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GamepadEventsEnabled
 * \sa SDL_UpdateGamepads
 *)
procedure SDL_SetGamepadEventsEnabled(enabled: Boolean); cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetGamepadEventsEnabled';

(**
 * Query the state of gamepad event processing.
 *
 * If gamepad events are disabled, you must call SDL_UpdateGamepads() yourself
 * and check the state of the gamepad when you want gamepad information.
 *
 * \returns true if gamepad events are being processed, false otherwise.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetGamepadEventsEnabled
 *)
function SDL_GamepadEventsEnabled(): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GamepadEventsEnabled';

(**
 * Get the SDL joystick layer bindings for a gamepad.
 *
 * \param gamepad a gamepad.
 * \param count a pointer filled in with the number of bindings returned.
 * \returns a NULL terminated array of pointers to bindings or NULL on
 *          failure; call SDL_GetError() for more information. This is a
 *          single allocation that should be freed with SDL_free() when it is
 *          no longer needed.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetGamepadBindings(gamepad: SDL_Gamepad; count: PInteger): PPSDL_GamepadBinding; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetGamepadBindings';

(**
 * Manually pump gamepad updates if not using the loop.
 *
 * This function is called automatically by the event loop if events are
 * enabled. Under such circumstances, it will not be necessary to call this
 * function.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_UpdateGamepads(); cdecl;
  external LIB_SDL3 name _PU + 'SDL_UpdateGamepads';

(**
 * Convert a string into SDL_GamepadType enum.
 *
 * This function is called internally to translate SDL_Gamepad mapping strings
 * for the underlying joystick device into the consistent SDL_Gamepad mapping.
 * You do not normally need to call this function unless you are parsing
 * SDL_Gamepad mappings in your own code.
 *
 * \param str string representing a SDL_GamepadType type.
 * \returns the SDL_GamepadType enum corresponding to the input string, or
 *          `SDL_GAMEPAD_TYPE_UNKNOWN` if no match was found.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetGamepadStringForType
 *)
function SDL_GetGamepadTypeFromString(const str: PUTF8Char): SDL_GamepadType; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetGamepadTypeFromString';

(**
 * Convert from an SDL_GamepadType enum to a string.
 *
 * \param type an enum value for a given SDL_GamepadType.
 * \returns a string for the given type, or NULL if an invalid type is
 *          specified. The string returned is of the format used by
 *          SDL_Gamepad mapping strings.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetGamepadTypeFromString
 *)
function SDL_GetGamepadStringForType(&type: SDL_GamepadType): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetGamepadStringForType';

(**
 * Convert a string into SDL_GamepadAxis enum.
 *
 * This function is called internally to translate SDL_Gamepad mapping strings
 * for the underlying joystick device into the consistent SDL_Gamepad mapping.
 * You do not normally need to call this function unless you are parsing
 * SDL_Gamepad mappings in your own code.
 *
 * Note specially that "righttrigger" and "lefttrigger" map to
 * `SDL_GAMEPAD_AXIS_RIGHT_TRIGGER` and `SDL_GAMEPAD_AXIS_LEFT_TRIGGER`,
 * respectively.
 *
 * \param str string representing a SDL_Gamepad axis.
 * \returns the SDL_GamepadAxis enum corresponding to the input string, or
 *          `SDL_GAMEPAD_AXIS_INVALID` if no match was found.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetGamepadStringForAxis
 *)
function SDL_GetGamepadAxisFromString(const str: PUTF8Char): SDL_GamepadAxis; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetGamepadAxisFromString';

(**
 * Convert from an SDL_GamepadAxis enum to a string.
 *
 * \param axis an enum value for a given SDL_GamepadAxis.
 * \returns a string for the given axis, or NULL if an invalid axis is
 *          specified. The string returned is of the format used by
 *          SDL_Gamepad mapping strings.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetGamepadAxisFromString
 *)
function SDL_GetGamepadStringForAxis(axis: SDL_GamepadAxis): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetGamepadStringForAxis';

(**
 * Query whether a gamepad has a given axis.
 *
 * This merely reports whether the gamepad's mapping defined this axis, as
 * that is all the information SDL has about the physical device.
 *
 * \param gamepad a gamepad.
 * \param axis an axis enum value (an SDL_GamepadAxis value).
 * \returns true if the gamepad has this axis, false otherwise.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GamepadHasButton
 * \sa SDL_GetGamepadAxis
 *)
function SDL_GamepadHasAxis(gamepad: SDL_Gamepad; axis: SDL_GamepadAxis): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GamepadHasAxis';

(**
 * Get the current state of an axis control on a gamepad.
 *
 * The axis indices start at index 0.
 *
 * For thumbsticks, the state is a value ranging from -32768 (up/left) to
 * 32767 (down/right).
 *
 * Triggers range from 0 when released to 32767 when fully pressed, and never
 * return a negative value. Note that this differs from the value reported by
 * the lower-level SDL_GetJoystickAxis(), which normally uses the full range.
 *
 * \param gamepad a gamepad.
 * \param axis an axis index (one of the SDL_GamepadAxis values).
 * \returns axis state (including 0) on success or 0 (also) on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GamepadHasAxis
 * \sa SDL_GetGamepadButton
 *)
function SDL_GetGamepadAxis(gamepad: SDL_Gamepad; axis: SDL_GamepadAxis): Sint16; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetGamepadAxis';

(**
 * Convert a string into an SDL_GamepadButton enum.
 *
 * This function is called internally to translate SDL_Gamepad mapping strings
 * for the underlying joystick device into the consistent SDL_Gamepad mapping.
 * You do not normally need to call this function unless you are parsing
 * SDL_Gamepad mappings in your own code.
 *
 * \param str string representing a SDL_Gamepad axis.
 * \returns the SDL_GamepadButton enum corresponding to the input string, or
 *          `SDL_GAMEPAD_BUTTON_INVALID` if no match was found.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetGamepadStringForButton
 *)
function SDL_GetGamepadButtonFromString(const str: PUTF8Char): SDL_GamepadButton; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetGamepadButtonFromString';

(**
 * Convert from an SDL_GamepadButton enum to a string.
 *
 * \param button an enum value for a given SDL_GamepadButton.
 * \returns a string for the given button, or NULL if an invalid button is
 *          specified. The string returned is of the format used by
 *          SDL_Gamepad mapping strings.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetGamepadButtonFromString
 *)
function SDL_GetGamepadStringForButton(button: SDL_GamepadButton): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetGamepadStringForButton';

(**
 * Query whether a gamepad has a given button.
 *
 * This merely reports whether the gamepad's mapping defined this button, as
 * that is all the information SDL has about the physical device.
 *
 * \param gamepad a gamepad.
 * \param button a button enum value (an SDL_GamepadButton value).
 * \returns true if the gamepad has this button, false otherwise.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GamepadHasAxis
 *)
function SDL_GamepadHasButton(gamepad: SDL_Gamepad; button: SDL_GamepadButton): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GamepadHasButton';

(**
 * Get the current state of a button on a gamepad.
 *
 * \param gamepad a gamepad.
 * \param button a button index (one of the SDL_GamepadButton values).
 * \returns true if the button is pressed, false otherwise.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GamepadHasButton
 * \sa SDL_GetGamepadAxis
 *)
function SDL_GetGamepadButton(gamepad: SDL_Gamepad; button: SDL_GamepadButton): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetGamepadButton';

(**
 * Get the label of a button on a gamepad.
 *
 * \param type the type of gamepad to check.
 * \param button a button index (one of the SDL_GamepadButton values).
 * \returns the SDL_GamepadButtonLabel enum corresponding to the button label.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetGamepadButtonLabel
 *)
function SDL_GetGamepadButtonLabelForType(&type: SDL_GamepadType; button: SDL_GamepadButton): SDL_GamepadButtonLabel; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetGamepadButtonLabelForType';

(**
 * Get the label of a button on a gamepad.
 *
 * \param gamepad a gamepad.
 * \param button a button index (one of the SDL_GamepadButton values).
 * \returns the SDL_GamepadButtonLabel enum corresponding to the button label.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetGamepadButtonLabelForType
 *)
function SDL_GetGamepadButtonLabel(gamepad: SDL_Gamepad; button: SDL_GamepadButton): SDL_GamepadButtonLabel; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetGamepadButtonLabel';

(**
 * Get the number of touchpads on a gamepad.
 *
 * \param gamepad a gamepad.
 * \returns number of touchpads.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetNumGamepadTouchpadFingers
 *)
function SDL_GetNumGamepadTouchpads(gamepad: SDL_Gamepad): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetNumGamepadTouchpads';

(**
 * Get the number of supported simultaneous fingers on a touchpad on a game
 * gamepad.
 *
 * \param gamepad a gamepad.
 * \param touchpad a touchpad.
 * \returns number of supported simultaneous fingers.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetGamepadTouchpadFinger
 * \sa SDL_GetNumGamepadTouchpads
 *)
function SDL_GetNumGamepadTouchpadFingers(gamepad: SDL_Gamepad; touchpad: Integer): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetNumGamepadTouchpadFingers';

(**
 * Get the current state of a finger on a touchpad on a gamepad.
 *
 * \param gamepad a gamepad.
 * \param touchpad a touchpad.
 * \param finger a finger.
 * \param down a pointer filled with true if the finger is down, false
 *             otherwise, may be NULL.
 * \param x a pointer filled with the x position, normalized 0 to 1, with the
 *          origin in the upper left, may be NULL.
 * \param y a pointer filled with the y position, normalized 0 to 1, with the
 *          origin in the upper left, may be NULL.
 * \param pressure a pointer filled with pressure value, may be NULL.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetNumGamepadTouchpadFingers
 *)
function SDL_GetGamepadTouchpadFinger(gamepad: SDL_Gamepad; touchpad: Integer; finger: Integer; down: PBoolean; x: PSingle; y: PSingle; pressure: PSingle): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetGamepadTouchpadFinger';

(**
 * Return whether a gamepad has a particular sensor.
 *
 * \param gamepad the gamepad to query.
 * \param type the type of sensor to query.
 * \returns true if the sensor exists, false otherwise.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetGamepadSensorData
 * \sa SDL_GetGamepadSensorDataRate
 * \sa SDL_SetGamepadSensorEnabled
 *)
function SDL_GamepadHasSensor(gamepad: SDL_Gamepad; &type: SDL_SensorType): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GamepadHasSensor';

(**
 * Set whether data reporting for a gamepad sensor is enabled.
 *
 * \param gamepad the gamepad to update.
 * \param type the type of sensor to enable/disable.
 * \param enabled whether data reporting should be enabled.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GamepadHasSensor
 * \sa SDL_GamepadSensorEnabled
 *)
function SDL_SetGamepadSensorEnabled(gamepad: SDL_Gamepad; &type: SDL_SensorType; enabled: Boolean): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetGamepadSensorEnabled';

(**
 * Query whether sensor data reporting is enabled for a gamepad.
 *
 * \param gamepad the gamepad to query.
 * \param type the type of sensor to query.
 * \returns true if the sensor is enabled, false otherwise.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetGamepadSensorEnabled
 *)
function SDL_GamepadSensorEnabled(gamepad: SDL_Gamepad; &type: SDL_SensorType): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GamepadSensorEnabled';

(**
 * Get the data rate (number of events per second) of a gamepad sensor.
 *
 * \param gamepad the gamepad to query.
 * \param type the type of sensor to query.
 * \returns the data rate, or 0.0f if the data rate is not available.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetGamepadSensorDataRate(gamepad: SDL_Gamepad; &type: SDL_SensorType): Single; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetGamepadSensorDataRate';

(**
 * Get the current state of a gamepad sensor.
 *
 * The number of values and interpretation of the data is sensor dependent.
 * See SDL_sensor.h for the details for each type of sensor.
 *
 * \param gamepad the gamepad to query.
 * \param type the type of sensor to query.
 * \param data a pointer filled with the current sensor state.
 * \param num_values the number of values to write to data.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetGamepadSensorData(gamepad: SDL_Gamepad; &type: SDL_SensorType; data: PSingle; num_values: Integer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetGamepadSensorData';

(**
 * Start a rumble effect on a gamepad.
 *
 * Each call to this function cancels any previous rumble effect, and calling
 * it with 0 intensity stops any rumbling.
 *
 * This function requires you to process SDL events or call
 * SDL_UpdateJoysticks() to update rumble state.
 *
 * \param gamepad the gamepad to vibrate.
 * \param low_frequency_rumble the intensity of the low frequency (left)
 *                             rumble motor, from 0 to 0xFFFF.
 * \param high_frequency_rumble the intensity of the high frequency (right)
 *                              rumble motor, from 0 to 0xFFFF.
 * \param duration_ms the duration of the rumble effect, in milliseconds.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_RumbleGamepad(gamepad: SDL_Gamepad; low_frequency_rumble: Uint16; high_frequency_rumble: Uint16; duration_ms: Uint32): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_RumbleGamepad';

(**
 * Start a rumble effect in the gamepad's triggers.
 *
 * Each call to this function cancels any previous trigger rumble effect, and
 * calling it with 0 intensity stops any rumbling.
 *
 * Note that this is rumbling of the _triggers_ and not the gamepad as a
 * whole. This is currently only supported on Xbox One gamepads. If you want
 * the (more common) whole-gamepad rumble, use SDL_RumbleGamepad() instead.
 *
 * This function requires you to process SDL events or call
 * SDL_UpdateJoysticks() to update rumble state.
 *
 * \param gamepad the gamepad to vibrate.
 * \param left_rumble the intensity of the left trigger rumble motor, from 0
 *                    to 0xFFFF.
 * \param right_rumble the intensity of the right trigger rumble motor, from 0
 *                     to 0xFFFF.
 * \param duration_ms the duration of the rumble effect, in milliseconds.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_RumbleGamepad
 *)
function SDL_RumbleGamepadTriggers(gamepad: SDL_Gamepad; left_rumble: Uint16; right_rumble: Uint16; duration_ms: Uint32): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_RumbleGamepadTriggers';

(**
 * Update a gamepad's LED color.
 *
 * An example of a joystick LED is the light on the back of a PlayStation 4's
 * DualShock 4 controller.
 *
 * For gamepads with a single color LED, the maximum of the RGB values will be
 * used as the LED brightness.
 *
 * \param gamepad the gamepad to update.
 * \param red the intensity of the red LED.
 * \param green the intensity of the green LED.
 * \param blue the intensity of the blue LED.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_SetGamepadLED(gamepad: SDL_Gamepad; red: Uint8; green: Uint8; blue: Uint8): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetGamepadLED';

(**
 * Send a gamepad specific effect packet.
 *
 * \param gamepad the gamepad to affect.
 * \param data the data to send to the gamepad.
 * \param size the size of the data to send to the gamepad.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_SendGamepadEffect(gamepad: SDL_Gamepad; const data: Pointer; size: Integer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SendGamepadEffect';

(**
 * Close a gamepad previously opened with SDL_OpenGamepad().
 *
 * \param gamepad a gamepad identifier previously returned by
 *                SDL_OpenGamepad().
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_OpenGamepad
 *)
procedure SDL_CloseGamepad(gamepad: SDL_Gamepad); cdecl;
  external LIB_SDL3 name _PU + 'SDL_CloseGamepad';

(**
 * Return the sfSymbolsName for a given button on a gamepad on Apple
 * platforms.
 *
 * \param gamepad the gamepad to query.
 * \param button a button on the gamepad.
 * \returns the sfSymbolsName or NULL if the name can't be found.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetGamepadAppleSFSymbolsNameForAxis
 *)
function SDL_GetGamepadAppleSFSymbolsNameForButton(gamepad: SDL_Gamepad; button: SDL_GamepadButton): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetGamepadAppleSFSymbolsNameForButton';

(**
 * Return the sfSymbolsName for a given axis on a gamepad on Apple platforms.
 *
 * \param gamepad the gamepad to query.
 * \param axis an axis on the gamepad.
 * \returns the sfSymbolsName or NULL if the name can't be found.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetGamepadAppleSFSymbolsNameForButton
 *)
function SDL_GetGamepadAppleSFSymbolsNameForAxis(gamepad: SDL_Gamepad; axis: SDL_GamepadAxis): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetGamepadAppleSFSymbolsNameForAxis';
{$ENDREGION 'SDL_gamepad.h'}

{$REGION 'SDL_scancode.h'}
(**
 * # CategoryScancode
 *
 * Defines keyboard scancodes.
 *
 * Please refer to the Best Keyboard Practices document for details on what
 * this information means and how best to use it.
 *
 * https://wiki.libsdl.org/SDL3/BestKeyboardPractices
 *)

(**
 * The SDL keyboard scancode representation.
 *
 * An SDL scancode is the physical representation of a key on the keyboard,
 * independent of language and keyboard mapping.
 *
 * Values of this type are used to represent keyboard keys, among other places
 * in the `scancode` field of the SDL_KeyboardEvent structure.
 *
 * The values in this enumeration are based on the USB usage page standard:
 * https://usb.org/sites/default/files/hut1_5.pdf
 *
 * \since This enum is available since SDL 3.2.0.
 *)
type
  SDL_Scancode = Integer;

const
  SDL_SCANCODE_UNKNOWN = 0;
  SDL_SCANCODE_A = 4;
  SDL_SCANCODE_B = 5;
  SDL_SCANCODE_C = 6;
  SDL_SCANCODE_D = 7;
  SDL_SCANCODE_E = 8;
  SDL_SCANCODE_F = 9;
  SDL_SCANCODE_G = 10;
  SDL_SCANCODE_H = 11;
  SDL_SCANCODE_I = 12;
  SDL_SCANCODE_J = 13;
  SDL_SCANCODE_K = 14;
  SDL_SCANCODE_L = 15;
  SDL_SCANCODE_M = 16;
  SDL_SCANCODE_N = 17;
  SDL_SCANCODE_O = 18;
  SDL_SCANCODE_P = 19;
  SDL_SCANCODE_Q = 20;
  SDL_SCANCODE_R = 21;
  SDL_SCANCODE_S = 22;
  SDL_SCANCODE_T = 23;
  SDL_SCANCODE_U = 24;
  SDL_SCANCODE_V = 25;
  SDL_SCANCODE_W = 26;
  SDL_SCANCODE_X = 27;
  SDL_SCANCODE_Y = 28;
  SDL_SCANCODE_Z = 29;
  SDL_SCANCODE_1 = 30;
  SDL_SCANCODE_2 = 31;
  SDL_SCANCODE_3 = 32;
  SDL_SCANCODE_4 = 33;
  SDL_SCANCODE_5 = 34;
  SDL_SCANCODE_6 = 35;
  SDL_SCANCODE_7 = 36;
  SDL_SCANCODE_8 = 37;
  SDL_SCANCODE_9 = 38;
  SDL_SCANCODE_0 = 39;
  SDL_SCANCODE_RETURN = 40;
  SDL_SCANCODE_ESCAPE = 41;
  SDL_SCANCODE_BACKSPACE = 42;
  SDL_SCANCODE_TAB = 43;
  SDL_SCANCODE_SPACE = 44;
  SDL_SCANCODE_MINUS = 45;
  SDL_SCANCODE_EQUALS = 46;
  SDL_SCANCODE_LEFTBRACKET = 47;
  SDL_SCANCODE_RIGHTBRACKET = 48;
  (** Located at the lower left of the return
   *   key on ISO keyboards and at the right end
   *   of the QWERTY row on ANSI keyboards.
   *   Produces REVERSE SOLIDUS (backslash) and
   *   VERTICAL LINE in a US layout, REVERSE
   *   SOLIDUS and VERTICAL LINE in a UK Mac
   *   layout, NUMBER SIGN and TILDE in a UK
   *   Windows layout, DOLLAR SIGN and POUND SIGN
   *   in a Swiss German layout, NUMBER SIGN and
   *   APOSTROPHE in a German layout, GRAVE
   *   ACCENT and POUND SIGN in a French Mac
   *   layout, and ASTERISK and MICRO SIGN in a
   *   French Windows layout.
   *)
  SDL_SCANCODE_BACKSLASH = 49;
  (** ISO USB keyboards actually use this code
   *   instead of 49 for the same key, but all
   *   OSes I've seen treat the two codes
   *   identically. So, as an implementor, unless
   *   your keyboard generates both of those
   *   codes and your OS treats them differently,
   *   you should generate SDL_SCANCODE_BACKSLASH
   *   instead of this code. As a user, you
   *   should not rely on this code because SDL
   *   will never generate it with most (all?)
   *   keyboards.
   *)
  SDL_SCANCODE_NONUSHASH = 50;
  SDL_SCANCODE_SEMICOLON = 51;
  SDL_SCANCODE_APOSTROPHE = 52;
  (** Located in the top left corner (on both ANSI
   *   and ISO keyboards). Produces GRAVE ACCENT and
   *   TILDE in a US Windows layout and in US and UK
   *   Mac layouts on ANSI keyboards, GRAVE ACCENT
   *   and NOT SIGN in a UK Windows layout, SECTION
   *   SIGN and PLUS-MINUS SIGN in US and UK Mac
   *   layouts on ISO keyboards, SECTION SIGN and
   *   DEGREE SIGN in a Swiss German layout (Mac:
   *   only on ISO keyboards), CIRCUMFLEX ACCENT and
   *   DEGREE SIGN in a German layout (Mac: only on
   *   ISO keyboards), SUPERSCRIPT TWO and TILDE in a
   *   French Windows layout, COMMERCIAL AT and
   *   NUMBER SIGN in a French Mac layout on ISO
   *   keyboards, and LESS-THAN SIGN and GREATER-THAN
   *   SIGN in a Swiss German, German, or French Mac
   *   layout on ANSI keyboards.
   *)
  SDL_SCANCODE_GRAVE = 53;
  SDL_SCANCODE_COMMA = 54;
  SDL_SCANCODE_PERIOD = 55;
  SDL_SCANCODE_SLASH = 56;
  SDL_SCANCODE_CAPSLOCK = 57;
  SDL_SCANCODE_F1 = 58;
  SDL_SCANCODE_F2 = 59;
  SDL_SCANCODE_F3 = 60;
  SDL_SCANCODE_F4 = 61;
  SDL_SCANCODE_F5 = 62;
  SDL_SCANCODE_F6 = 63;
  SDL_SCANCODE_F7 = 64;
  SDL_SCANCODE_F8 = 65;
  SDL_SCANCODE_F9 = 66;
  SDL_SCANCODE_F10 = 67;
  SDL_SCANCODE_F11 = 68;
  SDL_SCANCODE_F12 = 69;
  SDL_SCANCODE_PRINTSCREEN = 70;
  SDL_SCANCODE_SCROLLLOCK = 71;
  SDL_SCANCODE_PAUSE = 72;
  (** insert on PC, help on some Mac keyboards (but
                                     does send code 73, not 117) *)
  SDL_SCANCODE_INSERT = 73;
  SDL_SCANCODE_HOME = 74;
  SDL_SCANCODE_PAGEUP = 75;
  SDL_SCANCODE_DELETE = 76;
  SDL_SCANCODE_END = 77;
  SDL_SCANCODE_PAGEDOWN = 78;
  SDL_SCANCODE_RIGHT = 79;
  SDL_SCANCODE_LEFT = 80;
  SDL_SCANCODE_DOWN = 81;
  SDL_SCANCODE_UP = 82;
  (** num lock on PC, clear on Mac keyboards
   *)
  SDL_SCANCODE_NUMLOCKCLEAR = 83;
  SDL_SCANCODE_KP_DIVIDE = 84;
  SDL_SCANCODE_KP_MULTIPLY = 85;
  SDL_SCANCODE_KP_MINUS = 86;
  SDL_SCANCODE_KP_PLUS = 87;
  SDL_SCANCODE_KP_ENTER = 88;
  SDL_SCANCODE_KP_1 = 89;
  SDL_SCANCODE_KP_2 = 90;
  SDL_SCANCODE_KP_3 = 91;
  SDL_SCANCODE_KP_4 = 92;
  SDL_SCANCODE_KP_5 = 93;
  SDL_SCANCODE_KP_6 = 94;
  SDL_SCANCODE_KP_7 = 95;
  SDL_SCANCODE_KP_8 = 96;
  SDL_SCANCODE_KP_9 = 97;
  SDL_SCANCODE_KP_0 = 98;
  SDL_SCANCODE_KP_PERIOD = 99;
  (** This is the additional key that ISO
   *   keyboards have over ANSI ones,
   *   located between left shift and Y.
   *   Produces GRAVE ACCENT and TILDE in a
   *   US or UK Mac layout, REVERSE SOLIDUS
   *   (backslash) and VERTICAL LINE in a
   *   US or UK Windows layout, and
   *   LESS-THAN SIGN and GREATER-THAN SIGN
   *   in a Swiss German, German, or French
   *   layout. *)
  SDL_SCANCODE_NONUSBACKSLASH = 100;
  (** windows contextual menu, compose *)
  SDL_SCANCODE_APPLICATION = 101;
  (** The USB document says this is a status flag,
   *   not a physical key - but some Mac keyboards
   *   do have a power key. *)
  SDL_SCANCODE_POWER = 102;
  SDL_SCANCODE_KP_EQUALS = 103;
  SDL_SCANCODE_F13 = 104;
  SDL_SCANCODE_F14 = 105;
  SDL_SCANCODE_F15 = 106;
  SDL_SCANCODE_F16 = 107;
  SDL_SCANCODE_F17 = 108;
  SDL_SCANCODE_F18 = 109;
  SDL_SCANCODE_F19 = 110;
  SDL_SCANCODE_F20 = 111;
  SDL_SCANCODE_F21 = 112;
  SDL_SCANCODE_F22 = 113;
  SDL_SCANCODE_F23 = 114;
  SDL_SCANCODE_F24 = 115;
  SDL_SCANCODE_EXECUTE = 116;
  (** AL Integrated Help Center *)
  SDL_SCANCODE_HELP = 117;
  (** Menu (show menu) *)
  SDL_SCANCODE_MENU = 118;
  SDL_SCANCODE_SELECT = 119;
  (** AC Stop *)
  SDL_SCANCODE_STOP = 120;
  (** AC Redo/Repeat *)
  SDL_SCANCODE_AGAIN = 121;
  (** AC Undo *)
  SDL_SCANCODE_UNDO = 122;
  (** AC Cut *)
  SDL_SCANCODE_CUT = 123;
  (** AC Copy *)
  SDL_SCANCODE_COPY = 124;
  (** AC Paste *)
  SDL_SCANCODE_PASTE = 125;
  (** AC Find *)
  SDL_SCANCODE_FIND = 126;
  SDL_SCANCODE_MUTE = 127;
  SDL_SCANCODE_VOLUMEUP = 128;
  SDL_SCANCODE_VOLUMEDOWN = 129;
  SDL_SCANCODE_KP_COMMA = 133;
  SDL_SCANCODE_KP_EQUALSAS400 = 134;
  (** used on Asian keyboards, see
                                              footnotes in USB doc *)
  SDL_SCANCODE_INTERNATIONAL1 = 135;
  SDL_SCANCODE_INTERNATIONAL2 = 136;
  (** Yen *)
  SDL_SCANCODE_INTERNATIONAL3 = 137;
  SDL_SCANCODE_INTERNATIONAL4 = 138;
  SDL_SCANCODE_INTERNATIONAL5 = 139;
  SDL_SCANCODE_INTERNATIONAL6 = 140;
  SDL_SCANCODE_INTERNATIONAL7 = 141;
  SDL_SCANCODE_INTERNATIONAL8 = 142;
  SDL_SCANCODE_INTERNATIONAL9 = 143;
  (** Hangul/English toggle *)
  SDL_SCANCODE_LANG1 = 144;
  (** Hanja conversion *)
  SDL_SCANCODE_LANG2 = 145;
  (** Katakana *)
  SDL_SCANCODE_LANG3 = 146;
  (** Hiragana *)
  SDL_SCANCODE_LANG4 = 147;
  (** Zenkaku/Hankaku *)
  SDL_SCANCODE_LANG5 = 148;
  (** reserved *)
  SDL_SCANCODE_LANG6 = 149;
  (** reserved *)
  SDL_SCANCODE_LANG7 = 150;
  (** reserved *)
  SDL_SCANCODE_LANG8 = 151;
  (** reserved *)
  SDL_SCANCODE_LANG9 = 152;
  (** Erase-Eaze *)
  SDL_SCANCODE_ALTERASE = 153;
  SDL_SCANCODE_SYSREQ = 154;
  (** AC Cancel *)
  SDL_SCANCODE_CANCEL = 155;
  SDL_SCANCODE_CLEAR = 156;
  SDL_SCANCODE_PRIOR = 157;
  SDL_SCANCODE_RETURN2 = 158;
  SDL_SCANCODE_SEPARATOR = 159;
  SDL_SCANCODE_OUT = 160;
  SDL_SCANCODE_OPER = 161;
  SDL_SCANCODE_CLEARAGAIN = 162;
  SDL_SCANCODE_CRSEL = 163;
  SDL_SCANCODE_EXSEL = 164;
  SDL_SCANCODE_KP_00 = 176;
  SDL_SCANCODE_KP_000 = 177;
  SDL_SCANCODE_THOUSANDSSEPARATOR = 178;
  SDL_SCANCODE_DECIMALSEPARATOR = 179;
  SDL_SCANCODE_CURRENCYUNIT = 180;
  SDL_SCANCODE_CURRENCYSUBUNIT = 181;
  SDL_SCANCODE_KP_LEFTPAREN = 182;
  SDL_SCANCODE_KP_RIGHTPAREN = 183;
  SDL_SCANCODE_KP_LEFTBRACE = 184;
  SDL_SCANCODE_KP_RIGHTBRACE = 185;
  SDL_SCANCODE_KP_TAB = 186;
  SDL_SCANCODE_KP_BACKSPACE = 187;
  SDL_SCANCODE_KP_A = 188;
  SDL_SCANCODE_KP_B = 189;
  SDL_SCANCODE_KP_C = 190;
  SDL_SCANCODE_KP_D = 191;
  SDL_SCANCODE_KP_E = 192;
  SDL_SCANCODE_KP_F = 193;
  SDL_SCANCODE_KP_XOR = 194;
  SDL_SCANCODE_KP_POWER = 195;
  SDL_SCANCODE_KP_PERCENT = 196;
  SDL_SCANCODE_KP_LESS = 197;
  SDL_SCANCODE_KP_GREATER = 198;
  SDL_SCANCODE_KP_AMPERSAND = 199;
  SDL_SCANCODE_KP_DBLAMPERSAND = 200;
  SDL_SCANCODE_KP_VERTICALBAR = 201;
  SDL_SCANCODE_KP_DBLVERTICALBAR = 202;
  SDL_SCANCODE_KP_COLON = 203;
  SDL_SCANCODE_KP_HASH = 204;
  SDL_SCANCODE_KP_SPACE = 205;
  SDL_SCANCODE_KP_AT = 206;
  SDL_SCANCODE_KP_EXCLAM = 207;
  SDL_SCANCODE_KP_MEMSTORE = 208;
  SDL_SCANCODE_KP_MEMRECALL = 209;
  SDL_SCANCODE_KP_MEMCLEAR = 210;
  SDL_SCANCODE_KP_MEMADD = 211;
  SDL_SCANCODE_KP_MEMSUBTRACT = 212;
  SDL_SCANCODE_KP_MEMMULTIPLY = 213;
  SDL_SCANCODE_KP_MEMDIVIDE = 214;
  SDL_SCANCODE_KP_PLUSMINUS = 215;
  SDL_SCANCODE_KP_CLEAR = 216;
  SDL_SCANCODE_KP_CLEARENTRY = 217;
  SDL_SCANCODE_KP_BINARY = 218;
  SDL_SCANCODE_KP_OCTAL = 219;
  SDL_SCANCODE_KP_DECIMAL = 220;
  SDL_SCANCODE_KP_HEXADECIMAL = 221;
  SDL_SCANCODE_LCTRL = 224;
  SDL_SCANCODE_LSHIFT = 225;
  (** alt, option *)
  SDL_SCANCODE_LALT = 226;
  (** windows, command (apple), meta *)
  SDL_SCANCODE_LGUI = 227;
  SDL_SCANCODE_RCTRL = 228;
  SDL_SCANCODE_RSHIFT = 229;
  (** alt gr, option *)
  SDL_SCANCODE_RALT = 230;
  (** windows, command (apple), meta *)
  SDL_SCANCODE_RGUI = 231;
  (** I'm not sure if this is really not covered
   *   by any of the above, but since there's a
   *   special SDL_KMOD_MODE for it I'm adding it here
   *)
  SDL_SCANCODE_MODE = 257;
  (** Sleep *)
  SDL_SCANCODE_SLEEP = 258;
  (** Wake *)
  SDL_SCANCODE_WAKE = 259;
  (** Channel Increment *)
  SDL_SCANCODE_CHANNEL_INCREMENT = 260;
  (** Channel Decrement *)
  SDL_SCANCODE_CHANNEL_DECREMENT = 261;
  (** Play *)
  SDL_SCANCODE_MEDIA_PLAY = 262;
  (** Pause *)
  SDL_SCANCODE_MEDIA_PAUSE = 263;
  (** Record *)
  SDL_SCANCODE_MEDIA_RECORD = 264;
  (** Fast Forward *)
  SDL_SCANCODE_MEDIA_FAST_FORWARD = 265;
  (** Rewind *)
  SDL_SCANCODE_MEDIA_REWIND = 266;
  (** Next Track *)
  SDL_SCANCODE_MEDIA_NEXT_TRACK = 267;
  (** Previous Track *)
  SDL_SCANCODE_MEDIA_PREVIOUS_TRACK = 268;
  (** Stop *)
  SDL_SCANCODE_MEDIA_STOP = 269;
  (** Eject *)
  SDL_SCANCODE_MEDIA_EJECT = 270;
  (** Play / Pause *)
  SDL_SCANCODE_MEDIA_PLAY_PAUSE = 271;
  SDL_SCANCODE_MEDIA_SELECT = 272;
  (** AC New *)
  SDL_SCANCODE_AC_NEW = 273;
  (** AC Open *)
  SDL_SCANCODE_AC_OPEN = 274;
  (** AC Close *)
  SDL_SCANCODE_AC_CLOSE = 275;
  (** AC Exit *)
  SDL_SCANCODE_AC_EXIT = 276;
  (** AC Save *)
  SDL_SCANCODE_AC_SAVE = 277;
  (** AC Print *)
  SDL_SCANCODE_AC_PRINT = 278;
  (** AC Properties *)
  SDL_SCANCODE_AC_PROPERTIES = 279;
  (** AC Search *)
  SDL_SCANCODE_AC_SEARCH = 280;
  (** AC Home *)
  SDL_SCANCODE_AC_HOME = 281;
  (** AC Back *)
  SDL_SCANCODE_AC_BACK = 282;
  (** AC Forward *)
  SDL_SCANCODE_AC_FORWARD = 283;
  (** AC Stop *)
  SDL_SCANCODE_AC_STOP = 284;
  (** AC Refresh *)
  SDL_SCANCODE_AC_REFRESH = 285;
  (** AC Bookmarks *)
  SDL_SCANCODE_AC_BOOKMARKS = 286;
  (** Usually situated below the display on phones and
                                        used as a multi-function feature key for selecting
                                        a software defined function shown on the bottom left
                                        of the display. *)
  SDL_SCANCODE_SOFTLEFT = 287;
  (** Usually situated below the display on phones and
                                         used as a multi-function feature key for selecting
                                         a software defined function shown on the bottom right
                                         of the display. *)
  SDL_SCANCODE_SOFTRIGHT = 288;
  (** Used for accepting phone calls. *)
  SDL_SCANCODE_CALL = 289;
  (** Used for rejecting phone calls. *)
  SDL_SCANCODE_ENDCALL = 290;
  (** 400-500 reserved for dynamic keycodes *)
  SDL_SCANCODE_RESERVED = 400;
  (** not a key, just marks the number of scancodes for array bounds *)
  SDL_SCANCODE_COUNT = 512;
{$ENDREGION 'SDL_scancode.h'}

{$REGION 'SDL_keycode.h'}
(**
 * # CategoryKeycode
 *
 * Defines constants which identify keyboard keys and modifiers.
 *
 * Please refer to the Best Keyboard Practices document for details on what
 * this information means and how best to use it.
 *
 * https://wiki.libsdl.org/SDL3/BestKeyboardPractices
 *)

type
  (**
   * The SDL virtual key representation.
   *
   * Values of this type are used to represent keyboard keys using the current
   * layout of the keyboard. These values include Unicode values representing
   * the unmodified character that would be generated by pressing the key, or an
   * `SDLK_*` constant for those keys that do not generate characters.
   *
   * A special exception is the number keys at the top of the keyboard which map
   * to SDLK_0...SDLK_9 on AZERTY layouts.
   *
   * Keys with the `SDLK_EXTENDED_MASK` bit set do not map to a scancode or
   * unicode code point.
   *
   * \since This datatype is available since SDL 3.2.0.
   *)
  SDL_Keycode = Uint32;

const
  SDLK_EXTENDED_MASK          = (1 shl 29);
  SDLK_SCANCODE_MASK          = (1 shl 30);
  SDLK_UNKNOWN                = $00000000; // 0
  SDLK_RETURN                 = $0000000d; // '\r'
  SDLK_ESCAPE                 = $0000001b; // '\x1B'
  SDLK_BACKSPACE              = $00000008; // '\b'
  SDLK_TAB                    = $00000009; // '\t'
  SDLK_SPACE                  = $00000020; // ' '
  SDLK_EXCLAIM                = $00000021; // '!'
  SDLK_DBLAPOSTROPHE          = $00000022; // '"'
  SDLK_HASH                   = $00000023; // '#'
  SDLK_DOLLAR                 = $00000024; // '$'
  SDLK_PERCENT                = $00000025; // '%'
  SDLK_AMPERSAND              = $00000026; // '&'
  SDLK_APOSTROPHE             = $00000027; // '\'
  SDLK_LEFTPAREN              = $00000028; // '('
  SDLK_RIGHTPAREN             = $00000029; // ')'
  SDLK_ASTERISK               = $0000002a; // '*'
  SDLK_PLUS                   = $0000002b; // '+'
  SDLK_COMMA                  = $0000002c; // ','
  SDLK_MINUS                  = $0000002d; // '-'
  SDLK_PERIOD                 = $0000002e; // '.'
  SDLK_SLASH                  = $0000002f; // '/'
  SDLK_0                      = $00000030; // '0'
  SDLK_1                      = $00000031; // '1'
  SDLK_2                      = $00000032; // '2'
  SDLK_3                      = $00000033; // '3'
  SDLK_4                      = $00000034; // '4'
  SDLK_5                      = $00000035; // '5'
  SDLK_6                      = $00000036; // '6'
  SDLK_7                      = $00000037; // '7'
  SDLK_8                      = $00000038; // '8'
  SDLK_9                      = $00000039; // '9'
  SDLK_COLON                  = $0000003a; // ':'
  SDLK_SEMICOLON              = $0000003b; // ';'
  SDLK_LESS                   = $0000003c; // '<'
  SDLK_EQUALS                 = $0000003d; // '='
  SDLK_GREATER                = $0000003e; // '>'
  SDLK_QUESTION               = $0000003f; // '?'
  SDLK_AT                     = $00000040; // '@'
  SDLK_LEFTBRACKET            = $0000005b; // '['
  SDLK_BACKSLASH              = $0000005c; // '\'
  SDLK_RIGHTBRACKET           = $0000005d; // ']'
  SDLK_CARET                  = $0000005e; // '^'
  SDLK_UNDERSCORE             = $0000005f; // '_'
  SDLK_GRAVE                  = $00000060; // '`'
  SDLK_A                      = $00000061; // 'a'
  SDLK_B                      = $00000062; // 'b'
  SDLK_C                      = $00000063; // 'c'
  SDLK_D                      = $00000064; // 'd'
  SDLK_E                      = $00000065; // 'e'
  SDLK_F                      = $00000066; // 'f'
  SDLK_G                      = $00000067; // 'g'
  SDLK_H                      = $00000068; // 'h'
  SDLK_I                      = $00000069; // 'i'
  SDLK_J                      = $0000006a; // 'j'
  SDLK_K                      = $0000006b; // 'k'
  SDLK_L                      = $0000006c; // 'l'
  SDLK_M                      = $0000006d; // 'm'
  SDLK_N                      = $0000006e; // 'n'
  SDLK_O                      = $0000006f; // 'o'
  SDLK_P                      = $00000070; // 'p'
  SDLK_Q                      = $00000071; // 'q'
  SDLK_R                      = $00000072; // 'r'
  SDLK_S                      = $00000073; // 's'
  SDLK_T                      = $00000074; // 't'
  SDLK_U                      = $00000075; // 'u'
  SDLK_V                      = $00000076; // 'v'
  SDLK_W                      = $00000077; // 'w'
  SDLK_X                      = $00000078; // 'x'
  SDLK_Y                      = $00000079; // 'y'
  SDLK_Z                      = $0000007a; // 'z'
  SDLK_LEFTBRACE              = $0000007b; // '{'
  SDLK_PIPE                   = $0000007c; // '|'
  SDLK_RIGHTBRACE             = $0000007d; // '}'
  SDLK_TILDE                  = $0000007e; // '~'
  SDLK_DELETE                 = $0000007f; // '\x7F'
  SDLK_PLUSMINUS              = $000000b1; // '\xB1'
  SDLK_CAPSLOCK               = $40000039; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_CAPSLOCK)
  SDLK_F1                     = $4000003a; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_F1)
  SDLK_F2                     = $4000003b; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_F2)
  SDLK_F3                     = $4000003c; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_F3)
  SDLK_F4                     = $4000003d; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_F4)
  SDLK_F5                     = $4000003e; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_F5)
  SDLK_F6                     = $4000003f; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_F6)
  SDLK_F7                     = $40000040; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_F7)
  SDLK_F8                     = $40000041; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_F8)
  SDLK_F9                     = $40000042; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_F9)
  SDLK_F10                    = $40000043; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_F10)
  SDLK_F11                    = $40000044; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_F11)
  SDLK_F12                    = $40000045; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_F12)
  SDLK_PRINTSCREEN            = $40000046; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_PRINTSCREEN)
  SDLK_SCROLLLOCK             = $40000047; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_SCROLLLOCK)
  SDLK_PAUSE                  = $40000048; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_PAUSE)
  SDLK_INSERT                 = $40000049; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_INSERT)
  SDLK_HOME                   = $4000004a; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_HOME)
  SDLK_PAGEUP                 = $4000004b; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_PAGEUP)
  SDLK_END                    = $4000004d; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_END)
  SDLK_PAGEDOWN               = $4000004e; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_PAGEDOWN)
  SDLK_RIGHT                  = $4000004f; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_RIGHT)
  SDLK_LEFT                   = $40000050; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_LEFT)
  SDLK_DOWN                   = $40000051; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_DOWN)
  SDLK_UP                     = $40000052; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_UP)
  SDLK_NUMLOCKCLEAR           = $40000053; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_NUMLOCKCLEAR)
  SDLK_KP_DIVIDE              = $40000054; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_KP_DIVIDE)
  SDLK_KP_MULTIPLY            = $40000055; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_KP_MULTIPLY)
  SDLK_KP_MINUS               = $40000056; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_KP_MINUS)
  SDLK_KP_PLUS                = $40000057; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_KP_PLUS)
  SDLK_KP_ENTER               = $40000058; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_KP_ENTER)
  SDLK_KP_1                   = $40000059; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_KP_1)
  SDLK_KP_2                   = $4000005a; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_KP_2)
  SDLK_KP_3                   = $4000005b; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_KP_3)
  SDLK_KP_4                   = $4000005c; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_KP_4)
  SDLK_KP_5                   = $4000005d; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_KP_5)
  SDLK_KP_6                   = $4000005e; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_KP_6)
  SDLK_KP_7                   = $4000005f; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_KP_7)
  SDLK_KP_8                   = $40000060; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_KP_8)
  SDLK_KP_9                   = $40000061; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_KP_9)
  SDLK_KP_0                   = $40000062; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_KP_0)
  SDLK_KP_PERIOD              = $40000063; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_KP_PERIOD)
  SDLK_APPLICATION            = $40000065; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_APPLICATION)
  SDLK_POWER                  = $40000066; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_POWER)
  SDLK_KP_EQUALS              = $40000067; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_KP_EQUALS)
  SDLK_F13                    = $40000068; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_F13)
  SDLK_F14                    = $40000069; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_F14)
  SDLK_F15                    = $4000006a; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_F15)
  SDLK_F16                    = $4000006b; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_F16)
  SDLK_F17                    = $4000006c; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_F17)
  SDLK_F18                    = $4000006d; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_F18)
  SDLK_F19                    = $4000006e; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_F19)
  SDLK_F20                    = $4000006f; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_F20)
  SDLK_F21                    = $40000070; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_F21)
  SDLK_F22                    = $40000071; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_F22)
  SDLK_F23                    = $40000072; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_F23)
  SDLK_F24                    = $40000073; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_F24)
  SDLK_EXECUTE                = $40000074; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_EXECUTE)
  SDLK_HELP                   = $40000075; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_HELP)
  SDLK_MENU                   = $40000076; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_MENU)
  SDLK_SELECT                 = $40000077; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_SELECT)
  SDLK_STOP                   = $40000078; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_STOP)
  SDLK_AGAIN                  = $40000079; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_AGAIN)
  SDLK_UNDO                   = $4000007a; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_UNDO)
  SDLK_CUT                    = $4000007b; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_CUT)
  SDLK_COPY                   = $4000007c; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_COPY)
  SDLK_PASTE                  = $4000007d; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_PASTE)
  SDLK_FIND                   = $4000007e; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_FIND)
  SDLK_MUTE                   = $4000007f; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_MUTE)
  SDLK_VOLUMEUP               = $40000080; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_VOLUMEUP)
  SDLK_VOLUMEDOWN             = $40000081; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_VOLUMEDOWN)
  SDLK_KP_COMMA               = $40000085; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_KP_COMMA)
  SDLK_KP_EQUALSAS400         = $40000086; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_KP_EQUALSAS400)
  SDLK_ALTERASE               = $40000099; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_ALTERASE)
  SDLK_SYSREQ                 = $4000009a; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_SYSREQ)
  SDLK_CANCEL                 = $4000009b; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_CANCEL)
  SDLK_CLEAR                  = $4000009c; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_CLEAR)
  SDLK_PRIOR                  = $4000009d; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_PRIOR)
  SDLK_RETURN2                = $4000009e; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_RETURN2)
  SDLK_SEPARATOR              = $4000009f; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_SEPARATOR)
  SDLK_OUT                    = $400000a0; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_OUT)
  SDLK_OPER                   = $400000a1; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_OPER)
  SDLK_CLEARAGAIN             = $400000a2; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_CLEARAGAIN)
  SDLK_CRSEL                  = $400000a3; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_CRSEL)
  SDLK_EXSEL                  = $400000a4; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_EXSEL)
  SDLK_KP_00                  = $400000b0; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_KP_00)
  SDLK_KP_000                 = $400000b1; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_KP_000)
  SDLK_THOUSANDSSEPARATOR     = $400000b2; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_THOUSANDSSEPARATOR)
  SDLK_DECIMALSEPARATOR       = $400000b3; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_DECIMALSEPARATOR)
  SDLK_CURRENCYUNIT           = $400000b4; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_CURRENCYUNIT)
  SDLK_CURRENCYSUBUNIT        = $400000b5; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_CURRENCYSUBUNIT)
  SDLK_KP_LEFTPAREN           = $400000b6; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_KP_LEFTPAREN)
  SDLK_KP_RIGHTPAREN          = $400000b7; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_KP_RIGHTPAREN)
  SDLK_KP_LEFTBRACE           = $400000b8; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_KP_LEFTBRACE)
  SDLK_KP_RIGHTBRACE          = $400000b9; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_KP_RIGHTBRACE)
  SDLK_KP_TAB                 = $400000ba; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_KP_TAB)
  SDLK_KP_BACKSPACE           = $400000bb; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_KP_BACKSPACE)
  SDLK_KP_A                   = $400000bc; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_KP_A)
  SDLK_KP_B                   = $400000bd; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_KP_B)
  SDLK_KP_C                   = $400000be; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_KP_C)
  SDLK_KP_D                   = $400000bf; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_KP_D)
  SDLK_KP_E                   = $400000c0; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_KP_E)
  SDLK_KP_F                   = $400000c1; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_KP_F)
  SDLK_KP_XOR                 = $400000c2; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_KP_XOR)
  SDLK_KP_POWER               = $400000c3; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_KP_POWER)
  SDLK_KP_PERCENT             = $400000c4; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_KP_PERCENT)
  SDLK_KP_LESS                = $400000c5; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_KP_LESS)
  SDLK_KP_GREATER             = $400000c6; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_KP_GREATER)
  SDLK_KP_AMPERSAND           = $400000c7; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_KP_AMPERSAND)
  SDLK_KP_DBLAMPERSAND        = $400000c8; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_KP_DBLAMPERSAND)
  SDLK_KP_VERTICALBAR         = $400000c9; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_KP_VERTICALBAR)
  SDLK_KP_DBLVERTICALBAR      = $400000ca; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_KP_DBLVERTICALBAR)
  SDLK_KP_COLON               = $400000cb; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_KP_COLON)
  SDLK_KP_HASH                = $400000cc; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_KP_HASH)
  SDLK_KP_SPACE               = $400000cd; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_KP_SPACE)
  SDLK_KP_AT                  = $400000ce; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_KP_AT)
  SDLK_KP_EXCLAM              = $400000cf; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_KP_EXCLAM)
  SDLK_KP_MEMSTORE            = $400000d0; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_KP_MEMSTORE)
  SDLK_KP_MEMRECALL           = $400000d1; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_KP_MEMRECALL)
  SDLK_KP_MEMCLEAR            = $400000d2; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_KP_MEMCLEAR)
  SDLK_KP_MEMADD              = $400000d3; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_KP_MEMADD)
  SDLK_KP_MEMSUBTRACT         = $400000d4; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_KP_MEMSUBTRACT)
  SDLK_KP_MEMMULTIPLY         = $400000d5; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_KP_MEMMULTIPLY)
  SDLK_KP_MEMDIVIDE           = $400000d6; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_KP_MEMDIVIDE)
  SDLK_KP_PLUSMINUS           = $400000d7; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_KP_PLUSMINUS)
  SDLK_KP_CLEAR               = $400000d8; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_KP_CLEAR)
  SDLK_KP_CLEARENTRY          = $400000d9; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_KP_CLEARENTRY)
  SDLK_KP_BINARY              = $400000da; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_KP_BINARY)
  SDLK_KP_OCTAL               = $400000db; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_KP_OCTAL)
  SDLK_KP_DECIMAL             = $400000dc; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_KP_DECIMAL)
  SDLK_KP_HEXADECIMAL         = $400000dd; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_KP_HEXADECIMAL)
  SDLK_LCTRL                  = $400000e0; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_LCTRL)
  SDLK_LSHIFT                 = $400000e1; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_LSHIFT)
  SDLK_LALT                   = $400000e2; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_LALT)
  SDLK_LGUI                   = $400000e3; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_LGUI)
  SDLK_RCTRL                  = $400000e4; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_RCTRL)
  SDLK_RSHIFT                 = $400000e5; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_RSHIFT)
  SDLK_RALT                   = $400000e6; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_RALT)
  SDLK_RGUI                   = $400000e7; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_RGUI)
  SDLK_MODE                   = $40000101; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_MODE)
  SDLK_SLEEP                  = $40000102; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_SLEEP)
  SDLK_WAKE                   = $40000103; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_WAKE)
  SDLK_CHANNEL_INCREMENT      = $40000104; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_CHANNEL_INCREMENT)
  SDLK_CHANNEL_DECREMENT      = $40000105; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_CHANNEL_DECREMENT)
  SDLK_MEDIA_PLAY             = $40000106; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_MEDIA_PLAY)
  SDLK_MEDIA_PAUSE            = $40000107; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_MEDIA_PAUSE)
  SDLK_MEDIA_RECORD           = $40000108; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_MEDIA_RECORD)
  SDLK_MEDIA_FAST_FORWARD     = $40000109; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_MEDIA_FAST_FORWARD)
  SDLK_MEDIA_REWIND           = $4000010a; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_MEDIA_REWIND)
  SDLK_MEDIA_NEXT_TRACK       = $4000010b; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_MEDIA_NEXT_TRACK)
  SDLK_MEDIA_PREVIOUS_TRACK   = $4000010c; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_MEDIA_PREVIOUS_TRACK)
  SDLK_MEDIA_STOP             = $4000010d; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_MEDIA_STOP)
  SDLK_MEDIA_EJECT            = $4000010e; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_MEDIA_EJECT)
  SDLK_MEDIA_PLAY_PAUSE       = $4000010f; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_MEDIA_PLAY_PAUSE)
  SDLK_MEDIA_SELECT           = $40000110; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_MEDIA_SELECT)
  SDLK_AC_NEW                 = $40000111; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_AC_NEW)
  SDLK_AC_OPEN                = $40000112; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_AC_OPEN)
  SDLK_AC_CLOSE               = $40000113; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_AC_CLOSE)
  SDLK_AC_EXIT                = $40000114; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_AC_EXIT)
  SDLK_AC_SAVE                = $40000115; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_AC_SAVE)
  SDLK_AC_PRINT               = $40000116; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_AC_PRINT)
  SDLK_AC_PROPERTIES          = $40000117; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_AC_PROPERTIES)
  SDLK_AC_SEARCH              = $40000118; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_AC_SEARCH)
  SDLK_AC_HOME                = $40000119; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_AC_HOME)
  SDLK_AC_BACK                = $4000011a; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_AC_BACK)
  SDLK_AC_FORWARD             = $4000011b; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_AC_FORWARD)
  SDLK_AC_STOP                = $4000011c; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_AC_STOP)
  SDLK_AC_REFRESH             = $4000011d; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_AC_REFRESH)
  SDLK_AC_BOOKMARKS           = $4000011e; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_AC_BOOKMARKS)
  SDLK_SOFTLEFT               = $4000011f; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_SOFTLEFT)
  SDLK_SOFTRIGHT              = $40000120; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_SOFTRIGHT)
  SDLK_CALL                   = $40000121; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_CALL)
  SDLK_ENDCALL                = $40000122; // SDL_SCANCODE_TO_KEYCODE(SDL_SCANCODE_ENDCALL)
  SDLK_LEFT_TAB               = $20000001; // Extended key Left Tab
  SDLK_LEVEL5_SHIFT           = $20000002; // Extended key Level 5 Shift
  SDLK_MULTI_KEY_COMPOSE      = $20000003; // Extended key Multi-key Compose
  SDLK_LMETA                  = $20000004; // Extended key Left Meta
  SDLK_RMETA                  = $20000005; // Extended key Right Meta
  SDLK_LHYPER                 = $20000006; // Extended key Left Hyper
  SDLK_RHYPER                 = $20000007; // Extended key Right Hyper

function SDL_ScancodeToKeycode(X: SDL_Scancode): SDL_Keycode; inline;

type
  (**
   * Valid key modifiers (possibly OR'd together).
   *
   * \since This datatype is available since SDL 3.2.0.
   *)
  SDL_Keymod = Uint16;
  PSDL_Keymod = ^SDL_Keymod;

const
  SDL_KMOD_NONE   = $0000; // no modifier is applicable.
  SDL_KMOD_LSHIFT = $0001; // the left Shift key is down.
  SDL_KMOD_RSHIFT = $0002; // the right Shift key is down.
  SDL_KMOD_LEVEL5 = $0004; // the Level 5 Shift key is down.
  SDL_KMOD_LCTRL  = $0040; // the left Ctrl (Control) key is down.
  SDL_KMOD_RCTRL  = $0080; // the right Ctrl (Control) key is down.
  SDL_KMOD_LALT   = $0100; // the left Alt key is down.
  SDL_KMOD_RALT   = $0200; // the right Alt key is down.
  SDL_KMOD_LGUI   = $0400; // the left GUI key (often the Windows key) is down.
  SDL_KMOD_RGUI   = $0800; // the right GUI key (often the Windows key) is down.
  SDL_KMOD_NUM    = $1000; // the Num Lock key (may be located on an extended keypad) is down.
  SDL_KMOD_CAPS   = $2000; // the Caps Lock key is down.
  SDL_KMOD_MODE   = $4000; // the !AltGr key is down.
  SDL_KMOD_SCROLL = $8000; // the Scroll Lock key is down.
  SDL_KMOD_CTRL = (SDL_KMOD_LCTRL or SDL_KMOD_RCTRL);    // Any Ctrl key is down.
  SDL_KMOD_SHIFT = (SDL_KMOD_LSHIFT or SDL_KMOD_RSHIFT); // Any Shift key is down.
  SDL_KMOD_ALT = (SDL_KMOD_LALT or SDL_KMOD_RALT);       // Any Alt key is down.
  SDL_KMOD_GUI = (SDL_KMOD_LGUI or SDL_KMOD_RGUI);       // Any GUI key is down.
{$ENDREGION 'SDL_keycode.h'}

{$REGION 'SDL_keyboard.h'}
(**
 * # CategoryKeyboard
 *
 * SDL keyboard management.
 *
 * Please refer to the Best Keyboard Practices document for details on how
 * best to accept keyboard input in various types of programs:
 *
 * https://wiki.libsdl.org/SDL3/BestKeyboardPractices
 *)

type
  (**
   * This is a unique ID for a keyboard for the time it is connected to the
   * system, and is never reused for the lifetime of the application.
   *
   * If the keyboard is disconnected and reconnected, it will get a new ID.
   *
   * The value 0 is an invalid ID.
   *
   * \since This datatype is available since SDL 3.2.0.
   *)
  SDL_KeyboardID = Uint32;
  PSDL_KeyboardID = ^SDL_KeyboardID;

(**
 * Return whether a keyboard is currently connected.
 *
 * \returns true if a keyboard is connected, false otherwise.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetKeyboards
 *)
function SDL_HasKeyboard(): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_HasKeyboard';

(**
 * Get a list of currently connected keyboards.
 *
 * Note that this will include any device or virtual driver that includes
 * keyboard functionality, including some mice, KVM switches, motherboard
 * power buttons, etc. You should wait for input from a device before you
 * consider it actively in use.
 *
 * \param count a pointer filled in with the number of keyboards returned, may
 *              be NULL.
 * \returns a 0 terminated array of keyboards instance IDs or NULL on failure;
 *          call SDL_GetError() for more information. This should be freed
 *          with SDL_free() when it is no longer needed.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetKeyboardNameForID
 * \sa SDL_HasKeyboard
 *)
function SDL_GetKeyboards(count: PInteger): PSDL_KeyboardID; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetKeyboards';

(**
 * Get the name of a keyboard.
 *
 * This function returns "" if the keyboard doesn't have a name.
 *
 * \param instance_id the keyboard instance ID.
 * \returns the name of the selected keyboard or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetKeyboards
 *)
function SDL_GetKeyboardNameForID(instance_id: SDL_KeyboardID): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetKeyboardNameForID';

(**
 * Query the window which currently has keyboard focus.
 *
 * \returns the window with keyboard focus.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetKeyboardFocus(): SDL_Window; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetKeyboardFocus';

(**
 * Get a snapshot of the current state of the keyboard.
 *
 * The pointer returned is a pointer to an internal SDL array. It will be
 * valid for the whole lifetime of the application and should not be freed by
 * the caller.
 *
 * A array element with a value of true means that the key is pressed and a
 * value of false means that it is not. Indexes into this array are obtained
 * by using SDL_Scancode values.
 *
 * Use SDL_PumpEvents() to update the state array.
 *
 * This function gives you the current state after all events have been
 * processed, so if a key or button has been pressed and released before you
 * process events, then the pressed state will never show up in the
 * SDL_GetKeyboardState() calls.
 *
 * Note: This function doesn't take into account whether shift has been
 * pressed or not.
 *
 * \param numkeys if non-NULL, receives the length of the returned array.
 * \returns a pointer to an array of key states.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_PumpEvents
 * \sa SDL_ResetKeyboard
 *)
function SDL_GetKeyboardState(numkeys: PInteger): PBoolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetKeyboardState';

(**
 * Clear the state of the keyboard.
 *
 * This function will generate key up events for all pressed keys.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetKeyboardState
 *)
procedure SDL_ResetKeyboard(); cdecl;
  external LIB_SDL3 name _PU + 'SDL_ResetKeyboard';

(**
 * Get the current key modifier state for the keyboard.
 *
 * \returns an OR'd combination of the modifier keys for the keyboard. See
 *          SDL_Keymod for details.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetKeyboardState
 * \sa SDL_SetModState
 *)
function SDL_GetModState(): SDL_Keymod; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetModState';

(**
 * Set the current key modifier state for the keyboard.
 *
 * The inverse of SDL_GetModState(), SDL_SetModState() allows you to impose
 * modifier key states on your application. Simply pass your desired modifier
 * states into `modstate`. This value may be a bitwise, OR'd combination of
 * SDL_Keymod values.
 *
 * This does not change the keyboard state, only the key modifier flags that
 * SDL reports.
 *
 * \param modstate the desired SDL_Keymod for the keyboard.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetModState
 *)
procedure SDL_SetModState(modstate: SDL_Keymod); cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetModState';

(**
 * Get the key code corresponding to the given scancode according to the
 * current keyboard layout.
 *
 * If you want to get the keycode as it would be delivered in key events,
 * including options specified in SDL_HINT_KEYCODE_OPTIONS, then you should
 * pass `key_event` as true. Otherwise this function simply translates the
 * scancode based on the given modifier state.
 *
 * \param scancode the desired SDL_Scancode to query.
 * \param modstate the modifier state to use when translating the scancode to
 *                 a keycode.
 * \param key_event true if the keycode will be used in key events.
 * \returns the SDL_Keycode that corresponds to the given SDL_Scancode.
 *
 * \threadsafety This function is not thread safe.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetKeyName
 * \sa SDL_GetScancodeFromKey
 *)
function SDL_GetKeyFromScancode(scancode: SDL_Scancode; modstate: SDL_Keymod; key_event: Boolean): SDL_Keycode; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetKeyFromScancode';

(**
 * Get the scancode corresponding to the given key code according to the
 * current keyboard layout.
 *
 * Note that there may be multiple scancode+modifier states that can generate
 * this keycode, this will just return the first one found.
 *
 * \param key the desired SDL_Keycode to query.
 * \param modstate a pointer to the modifier state that would be used when the
 *                 scancode generates this key, may be NULL.
 * \returns the SDL_Scancode that corresponds to the given SDL_Keycode.
 *
 * \threadsafety This function is not thread safe.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetKeyFromScancode
 * \sa SDL_GetScancodeName
 *)
function SDL_GetScancodeFromKey(key: SDL_Keycode; modstate: PSDL_Keymod): SDL_Scancode; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetScancodeFromKey';

(**
 * Set a human-readable name for a scancode.
 *
 * \param scancode the desired SDL_Scancode.
 * \param name the name to use for the scancode, encoded as UTF-8. The string
 *             is not copied, so the pointer given to this function must stay
 *             valid while SDL is being used.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function is not thread safe.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetScancodeName
 *)
function SDL_SetScancodeName(scancode: SDL_Scancode; const name: PUTF8Char): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetScancodeName';

(**
 * Get a human-readable name for a scancode.
 *
 * **Warning**: The returned name is by design not stable across platforms,
 * e.g. the name for `SDL_SCANCODE_LGUI` is "Left GUI" under Linux but "Left
 * Windows" under Microsoft Windows, and some scancodes like
 * `SDL_SCANCODE_NONUSBACKSLASH` don't have any name at all. There are even
 * scancodes that share names, e.g. `SDL_SCANCODE_RETURN` and
 * `SDL_SCANCODE_RETURN2` (both called "Return"). This function is therefore
 * unsuitable for creating a stable cross-platform two-way mapping between
 * strings and scancodes.
 *
 * \param scancode the desired SDL_Scancode to query.
 * \returns a pointer to the name for the scancode. If the scancode doesn't
 *          have a name this function returns an empty string ("").
 *
 * \threadsafety This function is not thread safe.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetScancodeFromKey
 * \sa SDL_GetScancodeFromName
 * \sa SDL_SetScancodeName
 *)
function SDL_GetScancodeName(scancode: SDL_Scancode): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetScancodeName';

(**
 * Get a scancode from a human-readable name.
 *
 * \param name the human-readable scancode name.
 * \returns the SDL_Scancode, or `SDL_SCANCODE_UNKNOWN` if the name wasn't
 *          recognized; call SDL_GetError() for more information.
 *
 * \threadsafety This function is not thread safe.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetKeyFromName
 * \sa SDL_GetScancodeFromKey
 * \sa SDL_GetScancodeName
 *)
function SDL_GetScancodeFromName(const name: PUTF8Char): SDL_Scancode; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetScancodeFromName';

(**
 * Get a human-readable name for a key.
 *
 * If the key doesn't have a name, this function returns an empty string ("").
 *
 * Letters will be presented in their uppercase form, if applicable.
 *
 * \param key the desired SDL_Keycode to query.
 * \returns a UTF-8 encoded string of the key name.
 *
 * \threadsafety This function is not thread safe.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetKeyFromName
 * \sa SDL_GetKeyFromScancode
 * \sa SDL_GetScancodeFromKey
 *)
function SDL_GetKeyName(key: SDL_Keycode): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetKeyName';

(**
 * Get a key code from a human-readable name.
 *
 * \param name the human-readable key name.
 * \returns key code, or `SDLK_UNKNOWN` if the name wasn't recognized; call
 *          SDL_GetError() for more information.
 *
 * \threadsafety This function is not thread safe.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetKeyFromScancode
 * \sa SDL_GetKeyName
 * \sa SDL_GetScancodeFromName
 *)
function SDL_GetKeyFromName(const name: PUTF8Char): SDL_Keycode; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetKeyFromName';

(**
 * Start accepting Unicode text input events in a window.
 *
 * This function will enable text input (SDL_EVENT_TEXT_INPUT and
 * SDL_EVENT_TEXT_EDITING events) in the specified window. Please use this
 * function paired with SDL_StopTextInput().
 *
 * Text input events are not received by default.
 *
 * On some platforms using this function shows the screen keyboard and/or
 * activates an IME, which can prevent some key press events from being passed
 * through.
 *
 * \param window the window to enable text input.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetTextInputArea
 * \sa SDL_StartTextInputWithProperties
 * \sa SDL_StopTextInput
 * \sa SDL_TextInputActive
 *)
function SDL_StartTextInput(window: SDL_Window): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_StartTextInput';

(**
 * Text input type.
 *
 * These are the valid values for SDL_PROP_TEXTINPUT_TYPE_NUMBER. Not every
 * value is valid on every platform, but where a value isn't supported, a
 * reasonable fallback will be used.
 *
 * \since This enum is available since SDL 3.2.0.
 *
 * \sa SDL_StartTextInputWithProperties
 *)
type
  SDL_TextInputType = Integer;

const
  (** The input is text *)
  SDL_TEXTINPUT_TYPE_TEXT = 0;
  (** The input is a person's name *)
  SDL_TEXTINPUT_TYPE_TEXT_NAME = 1;
  (** The input is an e-mail address *)
  SDL_TEXTINPUT_TYPE_TEXT_EMAIL = 2;
  (** The input is a username *)
  SDL_TEXTINPUT_TYPE_TEXT_USERNAME = 3;
  (** The input is a secure password that is hidden *)
  SDL_TEXTINPUT_TYPE_TEXT_PASSWORD_HIDDEN = 4;
  (** The input is a secure password that is visible *)
  SDL_TEXTINPUT_TYPE_TEXT_PASSWORD_VISIBLE = 5;
  (** The input is a number *)
  SDL_TEXTINPUT_TYPE_NUMBER = 6;
  (** The input is a secure PIN that is hidden *)
  SDL_TEXTINPUT_TYPE_NUMBER_PASSWORD_HIDDEN = 7;
  (** The input is a secure PIN that is visible *)
  SDL_TEXTINPUT_TYPE_NUMBER_PASSWORD_VISIBLE = 8;

(**
 * Auto capitalization type.
 *
 * These are the valid values for SDL_PROP_TEXTINPUT_CAPITALIZATION_NUMBER.
 * Not every value is valid on every platform, but where a value isn't
 * supported, a reasonable fallback will be used.
 *
 * \since This enum is available since SDL 3.2.0.
 *
 * \sa SDL_StartTextInputWithProperties
 *)
type
  SDL_Capitalization = Integer;

const
  (** No auto-capitalization will be done *)
  SDL_CAPITALIZE_NONE = 0;
  (** The first letter of sentences will be capitalized *)
  SDL_CAPITALIZE_SENTENCES = 1;
  (** The first letter of words will be capitalized *)
  SDL_CAPITALIZE_WORDS = 2;
  (** All letters will be capitalized *)
  SDL_CAPITALIZE_LETTERS = 3;

(**
 * Start accepting Unicode text input events in a window, with properties
 * describing the input.
 *
 * This function will enable text input (SDL_EVENT_TEXT_INPUT and
 * SDL_EVENT_TEXT_EDITING events) in the specified window. Please use this
 * function paired with SDL_StopTextInput().
 *
 * Text input events are not received by default.
 *
 * On some platforms using this function shows the screen keyboard and/or
 * activates an IME, which can prevent some key press events from being passed
 * through.
 *
 * These are the supported properties:
 *
 * - `SDL_PROP_TEXTINPUT_TYPE_NUMBER` - an SDL_TextInputType value that
 *   describes text being input, defaults to SDL_TEXTINPUT_TYPE_TEXT.
 * - `SDL_PROP_TEXTINPUT_CAPITALIZATION_NUMBER` - an SDL_Capitalization value
 *   that describes how text should be capitalized, defaults to
 *   SDL_CAPITALIZE_SENTENCES for normal text entry, SDL_CAPITALIZE_WORDS for
 *   SDL_TEXTINPUT_TYPE_TEXT_NAME, and SDL_CAPITALIZE_NONE for e-mail
 *   addresses, usernames, and passwords.
 * - `SDL_PROP_TEXTINPUT_AUTOCORRECT_BOOLEAN` - true to enable auto completion
 *   and auto correction, defaults to true.
 * - `SDL_PROP_TEXTINPUT_MULTILINE_BOOLEAN` - true if multiple lines of text
 *   are allowed. This defaults to true if SDL_HINT_RETURN_KEY_HIDES_IME is
 *   "0" or is not set, and defaults to false if SDL_HINT_RETURN_KEY_HIDES_IME
 *   is "1".
 *
 * On Android you can directly specify the input type:
 *
 * - `SDL_PROP_TEXTINPUT_ANDROID_INPUTTYPE_NUMBER` - the text input type to
 *   use, overriding other properties. This is documented at
 *   https://developer.android.com/reference/android/text/InputType
 *
 * \param window the window to enable text input.
 * \param props the properties to use.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetTextInputArea
 * \sa SDL_StartTextInput
 * \sa SDL_StopTextInput
 * \sa SDL_TextInputActive
 *)
function SDL_StartTextInputWithProperties(window: SDL_Window; props: SDL_PropertiesID): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_StartTextInputWithProperties';

const
  SDL_PROP_TEXTINPUT_TYPE_NUMBER = 'SDL.textinput.type';
  SDL_PROP_TEXTINPUT_CAPITALIZATION_NUMBER = 'SDL.textinput.capitalization';
  SDL_PROP_TEXTINPUT_AUTOCORRECT_BOOLEAN = 'SDL.textinput.autocorrect';
  SDL_PROP_TEXTINPUT_MULTILINE_BOOLEAN = 'SDL.textinput.multiline';
  SDL_PROP_TEXTINPUT_ANDROID_INPUTTYPE_NUMBER = 'SDL.textinput.android.inputtype';

(**
 * Check whether or not Unicode text input events are enabled for a window.
 *
 * \param window the window to check.
 * \returns true if text input events are enabled else false.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_StartTextInput
 *)
function SDL_TextInputActive(window: SDL_Window): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_TextInputActive';

(**
 * Stop receiving any text input events in a window.
 *
 * If SDL_StartTextInput() showed the screen keyboard, this function will hide
 * it.
 *
 * \param window the window to disable text input.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_StartTextInput
 *)
function SDL_StopTextInput(window: SDL_Window): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_StopTextInput';

(**
 * Dismiss the composition window/IME without disabling the subsystem.
 *
 * \param window the window to affect.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_StartTextInput
 * \sa SDL_StopTextInput
 *)
function SDL_ClearComposition(window: SDL_Window): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_ClearComposition';

(**
 * Set the area used to type Unicode text input.
 *
 * Native input methods may place a window with word suggestions near the
 * cursor, without covering the text being entered.
 *
 * \param window the window for which to set the text input area.
 * \param rect the SDL_Rect representing the text input area, in window
 *             coordinates, or NULL to clear it.
 * \param cursor the offset of the current cursor location relative to
 *               `rect->x`, in window coordinates.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetTextInputArea
 * \sa SDL_StartTextInput
 *)
function SDL_SetTextInputArea(window: SDL_Window; const rect: PSDL_Rect; cursor: Integer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetTextInputArea';

(**
 * Get the area used to type Unicode text input.
 *
 * This returns the values previously set by SDL_SetTextInputArea().
 *
 * \param window the window for which to query the text input area.
 * \param rect a pointer to an SDL_Rect filled in with the text input area,
 *             may be NULL.
 * \param cursor a pointer to the offset of the current cursor location
 *               relative to `rect->x`, may be NULL.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetTextInputArea
 *)
function SDL_GetTextInputArea(window: SDL_Window; rect: PSDL_Rect; cursor: PInteger): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetTextInputArea';

(**
 * Check whether the platform has screen keyboard support.
 *
 * \returns true if the platform has some screen keyboard support or false if
 *          not.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_StartTextInput
 * \sa SDL_ScreenKeyboardShown
 *)
function SDL_HasScreenKeyboardSupport(): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_HasScreenKeyboardSupport';

(**
 * Check whether the screen keyboard is shown for given window.
 *
 * \param window the window for which screen keyboard should be queried.
 * \returns true if screen keyboard is shown or false if not.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_HasScreenKeyboardSupport
 *)
function SDL_ScreenKeyboardShown(window: SDL_Window): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_ScreenKeyboardShown';
{$ENDREGION 'SDL_keyboard.h'}

{$REGION 'SDL_mouse.h'}
(**
 * # CategoryMouse
 *
 * Any GUI application has to deal with the mouse, and SDL provides functions
 * to manage mouse input and the displayed cursor.
 *
 * Most interactions with the mouse will come through the event subsystem.
 * Moving a mouse generates an SDL_EVENT_MOUSE_MOTION event, pushing a button
 * generates SDL_EVENT_MOUSE_BUTTON_DOWN, etc, but one can also query the
 * current state of the mouse at any time with SDL_GetMouseState().
 *
 * For certain games, it's useful to disassociate the mouse cursor from mouse
 * input. An FPS, for example, would not want the player's motion to stop as
 * the mouse hits the edge of the window. For these scenarios, use
 * SDL_SetWindowRelativeMouseMode(), which hides the cursor, grabs mouse input
 * to the window, and reads mouse input no matter how far it moves.
 *
 * Games that want the system to track the mouse but want to draw their own
 * cursor can use SDL_HideCursor() and SDL_ShowCursor(). It might be more
 * efficient to let the system manage the cursor, if possible, using
 * SDL_SetCursor() with a custom image made through SDL_CreateColorCursor(),
 * or perhaps just a specific system cursor from SDL_CreateSystemCursor().
 *
 * SDL can, on many platforms, differentiate between multiple connected mice,
 * allowing for interesting input scenarios and multiplayer games. They can be
 * enumerated with SDL_GetMice(), and SDL will send SDL_EVENT_MOUSE_ADDED and
 * SDL_EVENT_MOUSE_REMOVED events as they are connected and unplugged.
 *
 * Since many apps only care about basic mouse input, SDL offers a virtual
 * mouse device for touch and pen input, which often can make a desktop
 * application work on a touchscreen phone without any code changes. Apps that
 * care about touch/pen separately from mouse input should filter out events
 * with a `which` field of SDL_TOUCH_MOUSEID/SDL_PEN_MOUSEID.
 *)

type
  (**
   * This is a unique ID for a mouse for the time it is connected to the system,
   * and is never reused for the lifetime of the application.
   *
   * If the mouse is disconnected and reconnected, it will get a new ID.
   *
   * The value 0 is an invalid ID.
   *
   * \since This datatype is available since SDL 3.2.0.
   *)
  SDL_MouseID = Uint32;
  PSDL_MouseID = ^SDL_MouseID;

  (**
   * The structure used to identify an SDL cursor.
   *
   * This is opaque data.
   *
   * \since This struct is available since SDL 3.2.0.
   *)
  SDL_Cursor = THandle;

(**
 * Cursor types for SDL_CreateSystemCursor().
 *
 * \since This enum is available since SDL 3.2.0.
 *)
type
  SDL_SystemCursor = Integer;

const
  (** Default cursor. Usually an arrow. *)
  SDL_SYSTEM_CURSOR_DEFAULT = 0;
  (** Text selection. Usually an I-beam. *)
  SDL_SYSTEM_CURSOR_TEXT = 1;
  (** Wait. Usually an hourglass or watch or spinning ball. *)
  SDL_SYSTEM_CURSOR_WAIT = 2;
  (** Crosshair. *)
  SDL_SYSTEM_CURSOR_CROSSHAIR = 3;
  (** Program is busy but still interactive. Usually it's WAIT with an arrow. *)
  SDL_SYSTEM_CURSOR_PROGRESS = 4;
  (** Double arrow pointing northwest and southeast. *)
  SDL_SYSTEM_CURSOR_NWSE_RESIZE = 5;
  (** Double arrow pointing northeast and southwest. *)
  SDL_SYSTEM_CURSOR_NESW_RESIZE = 6;
  (** Double arrow pointing west and east. *)
  SDL_SYSTEM_CURSOR_EW_RESIZE = 7;
  (** Double arrow pointing north and south. *)
  SDL_SYSTEM_CURSOR_NS_RESIZE = 8;
  (** Four pointed arrow pointing north, south, east, and west. *)
  SDL_SYSTEM_CURSOR_MOVE = 9;
  (** Not permitted. Usually a slashed circle or crossbones. *)
  SDL_SYSTEM_CURSOR_NOT_ALLOWED = 10;
  (** Pointer that indicates a link. Usually a pointing hand. *)
  SDL_SYSTEM_CURSOR_POINTER = 11;
  (** Window resize top-left. This may be a single arrow or a double arrow like NWSE_RESIZE. *)
  SDL_SYSTEM_CURSOR_NW_RESIZE = 12;
  (** Window resize top. May be NS_RESIZE. *)
  SDL_SYSTEM_CURSOR_N_RESIZE = 13;
  (** Window resize top-right. May be NESW_RESIZE. *)
  SDL_SYSTEM_CURSOR_NE_RESIZE = 14;
  (** Window resize right. May be EW_RESIZE. *)
  SDL_SYSTEM_CURSOR_E_RESIZE = 15;
  (** Window resize bottom-right. May be NWSE_RESIZE. *)
  SDL_SYSTEM_CURSOR_SE_RESIZE = 16;
  (** Window resize bottom. May be NS_RESIZE. *)
  SDL_SYSTEM_CURSOR_S_RESIZE = 17;
  (** Window resize bottom-left. May be NESW_RESIZE. *)
  SDL_SYSTEM_CURSOR_SW_RESIZE = 18;
  (** Window resize left. May be EW_RESIZE. *)
  SDL_SYSTEM_CURSOR_W_RESIZE = 19;
  SDL_SYSTEM_CURSOR_COUNT = 20;

(**
 * Scroll direction types for the Scroll event
 *
 * \since This enum is available since SDL 3.2.0.
 *)
type
  SDL_MouseWheelDirection = Integer;

const
  (** The scroll direction is normal *)
  SDL_MOUSEWHEEL_NORMAL = 0;
  (** The scroll direction is flipped / natural *)
  SDL_MOUSEWHEEL_FLIPPED = 1;

type
  (**
   * A bitmask of pressed mouse buttons, as reported by SDL_GetMouseState, etc.
   *
   * - Button 1: Left mouse button
   * - Button 2: Middle mouse button
   * - Button 3: Right mouse button
   * - Button 4: Side mouse button 1
   * - Button 5: Side mouse button 2
   *
   * \since This datatype is available since SDL 3.2.0.
   *
   * \sa SDL_GetMouseState
   * \sa SDL_GetGlobalMouseState
   * \sa SDL_GetRelativeMouseState
   *)
  SDL_MouseButtonFlags = Uint32;

const
  SDL_BUTTON_LEFT   = 1;
  SDL_BUTTON_MIDDLE = 2;
  SDL_BUTTON_RIGHT  = 3;
  SDL_BUTTON_X1     = 4;
  SDL_BUTTON_X2     = 5;
  SDL_BUTTON_LMASK  = 1 shl (SDL_BUTTON_LEFT - 1);
  SDL_BUTTON_MMASK  = 1 shl (SDL_BUTTON_MIDDLE - 1);
  SDL_BUTTON_RMASK  = 1 shl (SDL_BUTTON_RIGHT - 1);
  SDL_BUTTON_X1MASK  = 1 shl (SDL_BUTTON_X1 - 1);
  SDL_BUTTON_X2MASK  = 1 shl (SDL_BUTTON_X2 - 1);

(**
 * Return whether a mouse is currently connected.
 *
 * \returns true if a mouse is connected, false otherwise.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetMice
 *)
function SDL_HasMouse(): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_HasMouse';

(**
 * Get a list of currently connected mice.
 *
 * Note that this will include any device or virtual driver that includes
 * mouse functionality, including some game controllers, KVM switches, etc.
 * You should wait for input from a device before you consider it actively in
 * use.
 *
 * \param count a pointer filled in with the number of mice returned, may be
 *              NULL.
 * \returns a 0 terminated array of mouse instance IDs or NULL on failure;
 *          call SDL_GetError() for more information. This should be freed
 *          with SDL_free() when it is no longer needed.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetMouseNameForID
 * \sa SDL_HasMouse
 *)
function SDL_GetMice(count: PInteger): PSDL_MouseID; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetMice';

(**
 * Get the name of a mouse.
 *
 * This function returns "" if the mouse doesn't have a name.
 *
 * \param instance_id the mouse instance ID.
 * \returns the name of the selected mouse, or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetMice
 *)
function SDL_GetMouseNameForID(instance_id: SDL_MouseID): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetMouseNameForID';

(**
 * Get the window which currently has mouse focus.
 *
 * \returns the window with mouse focus.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetMouseFocus(): SDL_Window; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetMouseFocus';

(**
 * Query SDL's cache for the synchronous mouse button state and the
 * window-relative SDL-cursor position.
 *
 * This function returns the cached synchronous state as SDL understands it
 * from the last pump of the event queue.
 *
 * To query the platform for immediate asynchronous state, use
 * SDL_GetGlobalMouseState.
 *
 * Passing non-NULL pointers to `x` or `y` will write the destination with
 * respective x or y coordinates relative to the focused window.
 *
 * In Relative Mode, the SDL-cursor's position usually contradicts the
 * platform-cursor's position as manually calculated from
 * SDL_GetGlobalMouseState() and SDL_GetWindowPosition.
 *
 * \param x a pointer to receive the SDL-cursor's x-position from the focused
 *          window's top left corner, can be NULL if unused.
 * \param y a pointer to receive the SDL-cursor's y-position from the focused
 *          window's top left corner, can be NULL if unused.
 * \returns a 32-bit bitmask of the button state that can be bitwise-compared
 *          against the SDL_BUTTON_MASK(X) macro.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetGlobalMouseState
 * \sa SDL_GetRelativeMouseState
 *)
function SDL_GetMouseState(x: PSingle; y: PSingle): SDL_MouseButtonFlags; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetMouseState';

(**
 * Query the platform for the asynchronous mouse button state and the
 * desktop-relative platform-cursor position.
 *
 * This function immediately queries the platform for the most recent
 * asynchronous state, more costly than retrieving SDL's cached state in
 * SDL_GetMouseState().
 *
 * Passing non-NULL pointers to `x` or `y` will write the destination with
 * respective x or y coordinates relative to the desktop.
 *
 * In Relative Mode, the platform-cursor's position usually contradicts the
 * SDL-cursor's position as manually calculated from SDL_GetMouseState() and
 * SDL_GetWindowPosition.
 *
 * This function can be useful if you need to track the mouse outside of a
 * specific window and SDL_CaptureMouse() doesn't fit your needs. For example,
 * it could be useful if you need to track the mouse while dragging a window,
 * where coordinates relative to a window might not be in sync at all times.
 *
 * \param x a pointer to receive the platform-cursor's x-position from the
 *          desktop's top left corner, can be NULL if unused.
 * \param y a pointer to receive the platform-cursor's y-position from the
 *          desktop's top left corner, can be NULL if unused.
 * \returns a 32-bit bitmask of the button state that can be bitwise-compared
 *          against the SDL_BUTTON_MASK(X) macro.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CaptureMouse
 * \sa SDL_GetMouseState
 * \sa SDL_GetGlobalMouseState
 *)
function SDL_GetGlobalMouseState(x: PSingle; y: PSingle): SDL_MouseButtonFlags; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetGlobalMouseState';

(**
 * Query SDL's cache for the synchronous mouse button state and accumulated
 * mouse delta since last call.
 *
 * This function returns the cached synchronous state as SDL understands it
 * from the last pump of the event queue.
 *
 * To query the platform for immediate asynchronous state, use
 * SDL_GetGlobalMouseState.
 *
 * Passing non-NULL pointers to `x` or `y` will write the destination with
 * respective x or y deltas accumulated since the last call to this function
 * (or since event initialization).
 *
 * This function is useful for reducing overhead by processing relative mouse
 * inputs in one go per-frame instead of individually per-event, at the
 * expense of losing the order between events within the frame (e.g. quickly
 * pressing and releasing a button within the same frame).
 *
 * \param x a pointer to receive the x mouse delta accumulated since last
 *          call, can be NULL if unused.
 * \param y a pointer to receive the y mouse delta accumulated since last
 *          call, can be NULL if unused.
 * \returns a 32-bit bitmask of the button state that can be bitwise-compared
 *          against the SDL_BUTTON_MASK(X) macro.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetMouseState
 * \sa SDL_GetGlobalMouseState
 *)
function SDL_GetRelativeMouseState(x: PSingle; y: PSingle): SDL_MouseButtonFlags; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetRelativeMouseState';

(**
 * Move the mouse cursor to the given position within the window.
 *
 * This function generates a mouse motion event if relative mode is not
 * enabled. If relative mode is enabled, you can force mouse events for the
 * warp by setting the SDL_HINT_MOUSE_RELATIVE_WARP_MOTION hint.
 *
 * Note that this function will appear to succeed, but not actually move the
 * mouse when used over Microsoft Remote Desktop.
 *
 * \param window the window to move the mouse into, or NULL for the current
 *               mouse focus.
 * \param x the x coordinate within the window.
 * \param y the y coordinate within the window.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_WarpMouseGlobal
 *)
procedure SDL_WarpMouseInWindow(window: SDL_Window; x: Single; y: Single); cdecl;
  external LIB_SDL3 name _PU + 'SDL_WarpMouseInWindow';

(**
 * Move the mouse to the given position in global screen space.
 *
 * This function generates a mouse motion event.
 *
 * A failure of this function usually means that it is unsupported by a
 * platform.
 *
 * Note that this function will appear to succeed, but not actually move the
 * mouse when used over Microsoft Remote Desktop.
 *
 * \param x the x coordinate.
 * \param y the y coordinate.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_WarpMouseInWindow
 *)
function SDL_WarpMouseGlobal(x: Single; y: Single): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_WarpMouseGlobal';

(**
 * Set relative mouse mode for a window.
 *
 * While the window has focus and relative mouse mode is enabled, the cursor
 * is hidden, the mouse position is constrained to the window, and SDL will
 * report continuous relative mouse motion even if the mouse is at the edge of
 * the window.
 *
 * If you'd like to keep the mouse position fixed while in relative mode you
 * can use SDL_SetWindowMouseRect(). If you'd like the cursor to be at a
 * specific location when relative mode ends, you should use
 * SDL_WarpMouseInWindow() before disabling relative mode.
 *
 * This function will flush any pending mouse motion for this window.
 *
 * \param window the window to change.
 * \param enabled true to enable relative mode, false to disable.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetWindowRelativeMouseMode
 *)
function SDL_SetWindowRelativeMouseMode(window: SDL_Window; enabled: Boolean): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetWindowRelativeMouseMode';

(**
 * Query whether relative mouse mode is enabled for a window.
 *
 * \param window the window to query.
 * \returns true if relative mode is enabled for a window or false otherwise.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetWindowRelativeMouseMode
 *)
function SDL_GetWindowRelativeMouseMode(window: SDL_Window): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetWindowRelativeMouseMode';

(**
 * Capture the mouse and to track input outside an SDL window.
 *
 * Capturing enables your app to obtain mouse events globally, instead of just
 * within your window. Not all video targets support this function. When
 * capturing is enabled, the current window will get all mouse events, but
 * unlike relative mode, no change is made to the cursor and it is not
 * restrained to your window.
 *
 * This function may also deny mouse input to other windows--both those in
 * your application and others on the system--so you should use this function
 * sparingly, and in small bursts. For example, you might want to track the
 * mouse while the user is dragging something, until the user releases a mouse
 * button. It is not recommended that you capture the mouse for long periods
 * of time, such as the entire time your app is running. For that, you should
 * probably use SDL_SetWindowRelativeMouseMode() or SDL_SetWindowMouseGrab(),
 * depending on your goals.
 *
 * While captured, mouse events still report coordinates relative to the
 * current (foreground) window, but those coordinates may be outside the
 * bounds of the window (including negative values). Capturing is only allowed
 * for the foreground window. If the window loses focus while capturing, the
 * capture will be disabled automatically.
 *
 * While capturing is enabled, the current window will have the
 * `SDL_WINDOW_MOUSE_CAPTURE` flag set.
 *
 * Please note that SDL will attempt to "auto capture" the mouse while the
 * user is pressing a button; this is to try and make mouse behavior more
 * consistent between platforms, and deal with the common case of a user
 * dragging the mouse outside of the window. This means that if you are
 * calling SDL_CaptureMouse() only to deal with this situation, you do not
 * have to (although it is safe to do so). If this causes problems for your
 * app, you can disable auto capture by setting the
 * `SDL_HINT_MOUSE_AUTO_CAPTURE` hint to zero.
 *
 * \param enabled true to enable capturing, false to disable.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetGlobalMouseState
 *)
function SDL_CaptureMouse(enabled: Boolean): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_CaptureMouse';

(**
 * Create a cursor using the specified bitmap data and mask (in MSB format).
 *
 * `mask` has to be in MSB (Most Significant Bit) format.
 *
 * The cursor width (`w`) must be a multiple of 8 bits.
 *
 * The cursor is created in black and white according to the following:
 *
 * - data=0, mask=1: white
 * - data=1, mask=1: black
 * - data=0, mask=0: transparent
 * - data=1, mask=0: inverted color if possible, black if not.
 *
 * Cursors created with this function must be freed with SDL_DestroyCursor().
 *
 * If you want to have a color cursor, or create your cursor from an
 * SDL_Surface, you should use SDL_CreateColorCursor(). Alternately, you can
 * hide the cursor and draw your own as part of your game's rendering, but it
 * will be bound to the framerate.
 *
 * Also, SDL_CreateSystemCursor() is available, which provides several
 * readily-available system cursors to pick from.
 *
 * \param data the color value for each pixel of the cursor.
 * \param mask the mask value for each pixel of the cursor.
 * \param w the width of the cursor.
 * \param h the height of the cursor.
 * \param hot_x the x-axis offset from the left of the cursor image to the
 *              mouse x position, in the range of 0 to `w` - 1.
 * \param hot_y the y-axis offset from the top of the cursor image to the
 *              mouse y position, in the range of 0 to `h` - 1.
 * \returns a new cursor with the specified parameters on success or NULL on
 *          failure; call SDL_GetError() for more information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CreateColorCursor
 * \sa SDL_CreateSystemCursor
 * \sa SDL_DestroyCursor
 * \sa SDL_SetCursor
 *)
function SDL_CreateCursor(const data: PUint8; const mask: PUint8; w: Integer; h: Integer; hot_x: Integer; hot_y: Integer): SDL_Cursor; cdecl;
  external LIB_SDL3 name _PU + 'SDL_CreateCursor';

(**
 * Create a color cursor.
 *
 * If this function is passed a surface with alternate representations, the
 * surface will be interpreted as the content to be used for 100% display
 * scale, and the alternate representations will be used for high DPI
 * situations. For example, if the original surface is 32x32, then on a 2x
 * macOS display or 200% display scale on Windows, a 64x64 version of the
 * image will be used, if available. If a matching version of the image isn't
 * available, the closest larger size image will be downscaled to the
 * appropriate size and be used instead, if available. Otherwise, the closest
 * smaller image will be upscaled and be used instead.
 *
 * \param surface an SDL_Surface structure representing the cursor image.
 * \param hot_x the x position of the cursor hot spot.
 * \param hot_y the y position of the cursor hot spot.
 * \returns the new cursor on success or NULL on failure; call SDL_GetError()
 *          for more information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CreateCursor
 * \sa SDL_CreateSystemCursor
 * \sa SDL_DestroyCursor
 * \sa SDL_SetCursor
 *)
function SDL_CreateColorCursor(surface: PSDL_Surface; hot_x: Integer; hot_y: Integer): SDL_Cursor; cdecl;
  external LIB_SDL3 name _PU + 'SDL_CreateColorCursor';

(**
 * Create a system cursor.
 *
 * \param id an SDL_SystemCursor enum value.
 * \returns a cursor on success or NULL on failure; call SDL_GetError() for
 *          more information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_DestroyCursor
 *)
function SDL_CreateSystemCursor(id: SDL_SystemCursor): SDL_Cursor; cdecl;
  external LIB_SDL3 name _PU + 'SDL_CreateSystemCursor';

(**
 * Set the active cursor.
 *
 * This function sets the currently active cursor to the specified one. If the
 * cursor is currently visible, the change will be immediately represented on
 * the display. SDL_SetCursor(NULL) can be used to force cursor redraw, if
 * this is desired for any reason.
 *
 * \param cursor a cursor to make active.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetCursor
 *)
function SDL_SetCursor(cursor: SDL_Cursor): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetCursor';

(**
 * Get the active cursor.
 *
 * This function returns a pointer to the current cursor which is owned by the
 * library. It is not necessary to free the cursor with SDL_DestroyCursor().
 *
 * \returns the active cursor or NULL if there is no mouse.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetCursor
 *)
function SDL_GetCursor(): SDL_Cursor; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetCursor';

(**
 * Get the default cursor.
 *
 * You do not have to call SDL_DestroyCursor() on the return value, but it is
 * safe to do so.
 *
 * \returns the default cursor on success or NULL on failuree; call
 *          SDL_GetError() for more information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetDefaultCursor(): SDL_Cursor; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetDefaultCursor';

(**
 * Free a previously-created cursor.
 *
 * Use this function to free cursor resources created with SDL_CreateCursor(),
 * SDL_CreateColorCursor() or SDL_CreateSystemCursor().
 *
 * \param cursor the cursor to free.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CreateColorCursor
 * \sa SDL_CreateCursor
 * \sa SDL_CreateSystemCursor
 *)
procedure SDL_DestroyCursor(cursor: SDL_Cursor); cdecl;
  external LIB_SDL3 name _PU + 'SDL_DestroyCursor';

(**
 * Show the cursor.
 *
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CursorVisible
 * \sa SDL_HideCursor
 *)
function SDL_ShowCursor(): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_ShowCursor';

(**
 * Hide the cursor.
 *
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CursorVisible
 * \sa SDL_ShowCursor
 *)
function SDL_HideCursor(): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_HideCursor';

(**
 * Return whether the cursor is currently being shown.
 *
 * \returns `true` if the cursor is being shown, or `false` if the cursor is
 *          hidden.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_HideCursor
 * \sa SDL_ShowCursor
 *)
function SDL_CursorVisible(): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_CursorVisible';
{$ENDREGION 'SDL_mouse.h'}

{$REGION 'SDL_pen.h'}
(**
 * # CategoryPen
 *
 * SDL pen event handling.
 *
 * SDL provides an API for pressure-sensitive pen (stylus and/or eraser)
 * handling, e.g., for input and drawing tablets or suitably equipped mobile /
 * tablet devices.
 *
 * To get started with pens, simply handle SDL_EVENT_PEN_* events. When a pen
 * starts providing input, SDL will assign it a unique SDL_PenID, which will
 * remain for the life of the process, as long as the pen stays connected.
 *
 * Pens may provide more than simple touch input; they might have other axes,
 * such as pressure, tilt, rotation, etc.
 *)

type
  (**
   * SDL pen instance IDs.
   *
   * Zero is used to signify an invalid/null device.
   *
   * These show up in pen events when SDL sees input from them. They remain
   * consistent as long as SDL can recognize a tool to be the same pen; but if a
   * pen physically leaves the area and returns, it might get a new ID.
   *
   * \since This datatype is available since SDL 3.2.0.
   *)
  SDL_PenID = Uint32;

const
  (**
   * The SDL_MouseID for mouse events simulated with pen input.
   *
   * \since This macro is available since SDL 3.2.0.
   *)
  SDL_PEN_MOUSEID = -2;

  (**
   * The SDL_TouchID for touch events simulated with pen input.
   *
   * \since This macro is available since SDL 3.2.0.
   *)
  SDL_PEN_TOUCHID = -2;

type
  (**
   * Pen input flags, as reported by various pen events' `pen_state` field.
   *
   * \since This datatype is available since SDL 3.2.0.
   *)
  SDL_PenInputFlags = Uint32;

const
  SDL_PEN_INPUT_DOWN       = (1 shl 0);  // pen is pressed down
  SDL_PEN_INPUT_BUTTON_1   = (1 shl 1);  // button 1 is pressed
  SDL_PEN_INPUT_BUTTON_2   = (1 shl 2);  // button 2 is pressed
  SDL_PEN_INPUT_BUTTON_3   = (1 shl 3);  // button 3 is pressed
  SDL_PEN_INPUT_BUTTON_4   = (1 shl 4);  // button 4 is pressed
  SDL_PEN_INPUT_BUTTON_5   = (1 shl 5);  // button 5 is pressed
  SDL_PEN_INPUT_ERASER_TIP = (1 shl 30); // eraser tip is use

(**
 * Pen axis indices.
 *
 * These are the valid values for the `axis` field in SDL_PenAxisEvent. All
 * axes are either normalised to 0..1 or report a (positive or negative) angle
 * in degrees, with 0.0 representing the centre. Not all pens/backends support
 * all axes: unsupported axes are always zero.
 *
 * To convert angles for tilt and rotation into vector representation, use
 * SDL_sinf on the XTILT, YTILT, or ROTATION component, for example:
 *
 * `SDL_sinf(xtilt * SDL_PI_F / 180.0)`.
 *
 * \since This enum is available since SDL 3.2.0.
 *)
type
  SDL_PenAxis = Integer;

const
  (** Pen pressure.  Unidirectional: 0 to 1.0 *)
  SDL_PEN_AXIS_PRESSURE = 0;
  (** Pen horizontal tilt angle.  Bidirectional: -90.0 to 90.0 (left-to-right). *)
  SDL_PEN_AXIS_XTILT = 1;
  (** Pen vertical tilt angle.  Bidirectional: -90.0 to 90.0 (top-to-down). *)
  SDL_PEN_AXIS_YTILT = 2;
  (** Pen distance to drawing surface.  Unidirectional: 0.0 to 1.0 *)
  SDL_PEN_AXIS_DISTANCE = 3;
  (** Pen barrel rotation.  Bidirectional: -180 to 179.9 (clockwise, 0 is facing up, -180.0 is facing down). *)
  SDL_PEN_AXIS_ROTATION = 4;
  (** Pen finger wheel or slider (e.g., Airbrush Pen).  Unidirectional: 0 to 1.0 *)
  SDL_PEN_AXIS_SLIDER = 5;
  (** Pressure from squeezing the pen ("barrel pressure"). *)
  SDL_PEN_AXIS_TANGENTIAL_PRESSURE = 6;
  (** Total known pen axis types in this version of SDL. This number may grow in future releases! *)
  SDL_PEN_AXIS_COUNT = 7;
{$ENDREGION 'SDL_pen.h'}

{$REGION 'SDL_touch.h'}
(**
 * # CategoryTouch
 *
 * SDL offers touch input, on platforms that support it. It can manage
 * multiple touch devices and track multiple fingers on those devices.
 *
 * Touches are mostly dealt with through the event system, in the
 * SDL_EVENT_FINGER_DOWN, SDL_EVENT_FINGER_MOTION, and SDL_EVENT_FINGER_UP
 * events, but there are also functions to query for hardware details, etc.
 *
 * The touch system, by default, will also send virtual mouse events; this can
 * be useful for making a some desktop apps work on a phone without
 * significant changes. For apps that care about mouse and touch input
 * separately, they should ignore mouse events that have a `which` field of
 * SDL_TOUCH_MOUSEID.
 *)

type
  (**
   * A unique ID for a touch device.
   *
   * This ID is valid for the time the device is connected to the system, and is
   * never reused for the lifetime of the application.
   *
   * The value 0 is an invalid ID.
   *
   * \since This datatype is available since SDL 3.2.0.
   *)
  SDL_TouchID = Uint64;
  PSDL_TouchID = ^SDL_TouchID;

type
  (**
   * A unique ID for a single finger on a touch device.
   *
   * This ID is valid for the time the finger (stylus, etc) is touching and will
   * be unique for all fingers currently in contact, so this ID tracks the
   * lifetime of a single continuous touch. This value may represent an index, a
   * pointer, or some other unique ID, depending on the platform.
   *
   * The value 0 is an invalid ID.
   *
   * \since This datatype is available since SDL 3.2.0.
   *)
  SDL_FingerID = Uint64;

(**
 * An enum that describes the type of a touch device.
 *
 * \since This enum is available since SDL 3.2.0.
 *)
type
  SDL_TouchDeviceType = Integer;

const
  SDL_TOUCH_DEVICE_INVALID = -1;
  (** touch screen with window-relative coordinates *)
  SDL_TOUCH_DEVICE_DIRECT = 0;
  (** trackpad with absolute device coordinates *)
  SDL_TOUCH_DEVICE_INDIRECT_ABSOLUTE = 1;
  (** trackpad with screen cursor-relative coordinates *)
  SDL_TOUCH_DEVICE_INDIRECT_RELATIVE = 2;

type
  (**
   * Data about a single finger in a multitouch event.
   *
   * Each touch event is a collection of fingers that are simultaneously in
   * contact with the touch device (so a "touch" can be a "multitouch," in
   * reality), and this struct reports details of the specific fingers.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_GetTouchFingers
   *)
  SDL_Finger = record
    (** the finger ID *)
    id: SDL_FingerID;
    (** the x-axis location of the touch event, normalized (0...1) *)
    x: Single;
    (** the y-axis location of the touch event, normalized (0...1) *)
    y: Single;
    (** the quantity of pressure applied, normalized (0...1) *)
    pressure: Single;
  end;
  PSDL_Finger = ^SDL_Finger;
  PPSDL_Finger = ^PSDL_Finger;

const
  (**
   * The SDL_MouseID for mouse events simulated with touch input.
   *
   * \since This macro is available since SDL 3.2.0.
   *)
  SDL_TOUCH_MOUSEID = -1;

  (**
   * The SDL_TouchID for touch events simulated with mouse input.
   *
   * \since This macro is available since SDL 3.2.0.
   *)
  SDL_MOUSE_TOUCHID = -1;

(**
 * Get a list of registered touch devices.
 *
 * On some platforms SDL first sees the touch device if it was actually used.
 * Therefore the returned list might be empty, although devices are available.
 * After using all devices at least once the number will be correct.
 *
 * \param count a pointer filled in with the number of devices returned, may
 *              be NULL.
 * \returns a 0 terminated array of touch device IDs or NULL on failure; call
 *          SDL_GetError() for more information. This should be freed with
 *          SDL_free() when it is no longer needed.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetTouchDevices(count: PInteger): PSDL_TouchID; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetTouchDevices';

(**
 * Get the touch device name as reported from the driver.
 *
 * \param touchID the touch device instance ID.
 * \returns touch device name, or NULL on failure; call SDL_GetError() for
 *          more information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetTouchDeviceName(touchID: SDL_TouchID): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetTouchDeviceName';

(**
 * Get the type of the given touch device.
 *
 * \param touchID the ID of a touch device.
 * \returns touch device type.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetTouchDeviceType(touchID: SDL_TouchID): SDL_TouchDeviceType; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetTouchDeviceType';

(**
 * Get a list of active fingers for a given touch device.
 *
 * \param touchID the ID of a touch device.
 * \param count a pointer filled in with the number of fingers returned, can
 *              be NULL.
 * \returns a NULL terminated array of SDL_Finger pointers or NULL on failure;
 *          call SDL_GetError() for more information. This is a single
 *          allocation that should be freed with SDL_free() when it is no
 *          longer needed.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetTouchFingers(touchID: SDL_TouchID; count: PInteger): PPSDL_Finger; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetTouchFingers';
{$ENDREGION 'SDL_touch.h'}

{$REGION 'SDL_events.h'}
(**
 * # CategoryEvents
 *
 * Event queue management.
 *
 * It's extremely common--often required--that an app deal with SDL's event
 * queue. Almost all useful information about interactions with the real world
 * flow through here: the user interacting with the computer and app, hardware
 * coming and going, the system changing in some way, etc.
 *
 * An app generally takes a moment, perhaps at the start of a new frame, to
 * examine any events that have occured since the last time and process or
 * ignore them. This is generally done by calling SDL_PollEvent() in a loop
 * until it returns false (or, if using the main callbacks, events are
 * provided one at a time in calls to SDL_AppEvent() before the next call to
 * SDL_AppIterate(); in this scenario, the app does not call SDL_PollEvent()
 * at all).
 *
 * There is other forms of control, too: SDL_PeepEvents() has more
 * functionality at the cost of more complexity, and SDL_WaitEvent() can block
 * the process until something interesting happens, which might be beneficial
 * for certain types of programs on low-power hardware. One may also call
 * SDL_AddEventWatch() to set a callback when new events arrive.
 *
 * The app is free to generate their own events, too: SDL_PushEvent allows the
 * app to put events onto the queue for later retrieval; SDL_RegisterEvents
 * can guarantee that these events have a type that isn't in use by other
 * parts of the system.
 *)

(**
 * The types of events that can be delivered.
 *
 * \since This enum is available since SDL 3.2.0.
 *)
type
  SDL_EventType = Integer;

const
  (** Unused (do not remove) *)
  SDL_EVENT_FIRST = 0;
  (** User-requested quit *)
  SDL_EVENT_QUIT = 256;
  (** The application is being terminated by the OS. This event must be handled in a callback set with SDL_AddEventWatch().
                                       Called on iOS in applicationWillTerminate()
                                       Called on Android in onDestroy()
   *)
  SDL_EVENT_TERMINATING = 257;
  (** The application is low on memory, free memory if possible. This event must be handled in a callback set with SDL_AddEventWatch().
                                       Called on iOS in applicationDidReceiveMemoryWarning()
                                       Called on Android in onTrimMemory()
   *)
  SDL_EVENT_LOW_MEMORY = 258;
  (** The application is about to enter the background. This event must be handled in a callback set with SDL_AddEventWatch().
                                       Called on iOS in applicationWillResignActive()
                                       Called on Android in onPause()
   *)
  SDL_EVENT_WILL_ENTER_BACKGROUND = 259;
  (** The application did enter the background and may not get CPU for some time. This event must be handled in a callback set with SDL_AddEventWatch().
                                       Called on iOS in applicationDidEnterBackground()
                                       Called on Android in onPause()
   *)
  SDL_EVENT_DID_ENTER_BACKGROUND = 260;
  (** The application is about to enter the foreground. This event must be handled in a callback set with SDL_AddEventWatch().
                                       Called on iOS in applicationWillEnterForeground()
                                       Called on Android in onResume()
   *)
  SDL_EVENT_WILL_ENTER_FOREGROUND = 261;
  (** The application is now interactive. This event must be handled in a callback set with SDL_AddEventWatch().
                                       Called on iOS in applicationDidBecomeActive()
                                       Called on Android in onResume()
   *)
  SDL_EVENT_DID_ENTER_FOREGROUND = 262;
  (** The user's locale preferences have changed. *)
  SDL_EVENT_LOCALE_CHANGED = 263;
  (** The system theme changed *)
  SDL_EVENT_SYSTEM_THEME_CHANGED = 264;
  (** Display orientation has changed to data1 *)
  SDL_EVENT_DISPLAY_ORIENTATION = 337;
  (** Display has been added to the system *)
  SDL_EVENT_DISPLAY_ADDED = 338;
  (** Display has been removed from the system *)
  SDL_EVENT_DISPLAY_REMOVED = 339;
  (** Display has changed position *)
  SDL_EVENT_DISPLAY_MOVED = 340;
  (** Display has changed desktop mode *)
  SDL_EVENT_DISPLAY_DESKTOP_MODE_CHANGED = 341;
  (** Display has changed current mode *)
  SDL_EVENT_DISPLAY_CURRENT_MODE_CHANGED = 342;
  (** Display has changed content scale *)
  SDL_EVENT_DISPLAY_CONTENT_SCALE_CHANGED = 343;
  SDL_EVENT_DISPLAY_FIRST = 337;
  SDL_EVENT_DISPLAY_LAST = 343;
  (** Window has been shown *)
  SDL_EVENT_WINDOW_SHOWN = 514;
  (** Window has been hidden *)
  SDL_EVENT_WINDOW_HIDDEN = 515;
  (** Window has been exposed and should be redrawn, and can be redrawn directly from event watchers for this event *)
  SDL_EVENT_WINDOW_EXPOSED = 516;
  (** Window has been moved to data1, data2 *)
  SDL_EVENT_WINDOW_MOVED = 517;
  (** Window has been resized to data1xdata2 *)
  SDL_EVENT_WINDOW_RESIZED = 518;
  (** The pixel size of the window has changed to data1xdata2 *)
  SDL_EVENT_WINDOW_PIXEL_SIZE_CHANGED = 519;
  (** The pixel size of a Metal view associated with the window has changed *)
  SDL_EVENT_WINDOW_METAL_VIEW_RESIZED = 520;
  (** Window has been minimized *)
  SDL_EVENT_WINDOW_MINIMIZED = 521;
  (** Window has been maximized *)
  SDL_EVENT_WINDOW_MAXIMIZED = 522;
  (** Window has been restored to normal size and position *)
  SDL_EVENT_WINDOW_RESTORED = 523;
  (** Window has gained mouse focus *)
  SDL_EVENT_WINDOW_MOUSE_ENTER = 524;
  (** Window has lost mouse focus *)
  SDL_EVENT_WINDOW_MOUSE_LEAVE = 525;
  (** Window has gained keyboard focus *)
  SDL_EVENT_WINDOW_FOCUS_GAINED = 526;
  (** Window has lost keyboard focus *)
  SDL_EVENT_WINDOW_FOCUS_LOST = 527;
  (** The window manager requests that the window be closed *)
  SDL_EVENT_WINDOW_CLOSE_REQUESTED = 528;
  (** Window had a hit test that wasn't SDL_HITTEST_NORMAL *)
  SDL_EVENT_WINDOW_HIT_TEST = 529;
  (** The ICC profile of the window's display has changed *)
  SDL_EVENT_WINDOW_ICCPROF_CHANGED = 530;
  (** Window has been moved to display data1 *)
  SDL_EVENT_WINDOW_DISPLAY_CHANGED = 531;
  (** Window display scale has been changed *)
  SDL_EVENT_WINDOW_DISPLAY_SCALE_CHANGED = 532;
  (** The window safe area has been changed *)
  SDL_EVENT_WINDOW_SAFE_AREA_CHANGED = 533;
  (** The window has been occluded *)
  SDL_EVENT_WINDOW_OCCLUDED = 534;
  (** The window has entered fullscreen mode *)
  SDL_EVENT_WINDOW_ENTER_FULLSCREEN = 535;
  (** The window has left fullscreen mode *)
  SDL_EVENT_WINDOW_LEAVE_FULLSCREEN = 536;
  (** The window with the associated ID is being or has been destroyed. If this message is being handled
                                               in an event watcher, the window handle is still valid and can still be used to retrieve any properties
                                               associated with the window. Otherwise, the handle has already been destroyed and all resources
                                               associated with it are invalid *)
  SDL_EVENT_WINDOW_DESTROYED = 537;
  (** Window HDR properties have changed *)
  SDL_EVENT_WINDOW_HDR_STATE_CHANGED = 538;
  SDL_EVENT_WINDOW_FIRST = 514;
  SDL_EVENT_WINDOW_LAST = 538;
  (** Key pressed *)
  SDL_EVENT_KEY_DOWN = 768;
  (** Key released *)
  SDL_EVENT_KEY_UP = 769;
  (** Keyboard text editing (composition) *)
  SDL_EVENT_TEXT_EDITING = 770;
  (** Keyboard text input *)
  SDL_EVENT_TEXT_INPUT = 771;
  (** Keymap changed due to a system event such as an
                                              input language or keyboard layout change. *)
  SDL_EVENT_KEYMAP_CHANGED = 772;
  (** A new keyboard has been inserted into the system *)
  SDL_EVENT_KEYBOARD_ADDED = 773;
  (** A keyboard has been removed *)
  SDL_EVENT_KEYBOARD_REMOVED = 774;
  (** Keyboard text editing candidates *)
  SDL_EVENT_TEXT_EDITING_CANDIDATES = 775;
  (** Mouse moved *)
  SDL_EVENT_MOUSE_MOTION = 1024;
  (** Mouse button pressed *)
  SDL_EVENT_MOUSE_BUTTON_DOWN = 1025;
  (** Mouse button released *)
  SDL_EVENT_MOUSE_BUTTON_UP = 1026;
  (** Mouse wheel motion *)
  SDL_EVENT_MOUSE_WHEEL = 1027;
  (** A new mouse has been inserted into the system *)
  SDL_EVENT_MOUSE_ADDED = 1028;
  (** A mouse has been removed *)
  SDL_EVENT_MOUSE_REMOVED = 1029;
  (** Joystick axis motion *)
  SDL_EVENT_JOYSTICK_AXIS_MOTION = 1536;
  (** Joystick trackball motion *)
  SDL_EVENT_JOYSTICK_BALL_MOTION = 1537;
  (** Joystick hat position change *)
  SDL_EVENT_JOYSTICK_HAT_MOTION = 1538;
  (** Joystick button pressed *)
  SDL_EVENT_JOYSTICK_BUTTON_DOWN = 1539;
  (** Joystick button released *)
  SDL_EVENT_JOYSTICK_BUTTON_UP = 1540;
  (** A new joystick has been inserted into the system *)
  SDL_EVENT_JOYSTICK_ADDED = 1541;
  (** An opened joystick has been removed *)
  SDL_EVENT_JOYSTICK_REMOVED = 1542;
  (** Joystick battery level change *)
  SDL_EVENT_JOYSTICK_BATTERY_UPDATED = 1543;
  (** Joystick update is complete *)
  SDL_EVENT_JOYSTICK_UPDATE_COMPLETE = 1544;
  (** Gamepad axis motion *)
  SDL_EVENT_GAMEPAD_AXIS_MOTION = 1616;
  (** Gamepad button pressed *)
  SDL_EVENT_GAMEPAD_BUTTON_DOWN = 1617;
  (** Gamepad button released *)
  SDL_EVENT_GAMEPAD_BUTTON_UP = 1618;
  (** A new gamepad has been inserted into the system *)
  SDL_EVENT_GAMEPAD_ADDED = 1619;
  (** A gamepad has been removed *)
  SDL_EVENT_GAMEPAD_REMOVED = 1620;
  (** The gamepad mapping was updated *)
  SDL_EVENT_GAMEPAD_REMAPPED = 1621;
  (** Gamepad touchpad was touched *)
  SDL_EVENT_GAMEPAD_TOUCHPAD_DOWN = 1622;
  (** Gamepad touchpad finger was moved *)
  SDL_EVENT_GAMEPAD_TOUCHPAD_MOTION = 1623;
  (** Gamepad touchpad finger was lifted *)
  SDL_EVENT_GAMEPAD_TOUCHPAD_UP = 1624;
  (** Gamepad sensor was updated *)
  SDL_EVENT_GAMEPAD_SENSOR_UPDATE = 1625;
  (** Gamepad update is complete *)
  SDL_EVENT_GAMEPAD_UPDATE_COMPLETE = 1626;
  (** Gamepad Steam handle has changed *)
  SDL_EVENT_GAMEPAD_STEAM_HANDLE_UPDATED = 1627;
  SDL_EVENT_FINGER_DOWN = 1792;
  SDL_EVENT_FINGER_UP = 1793;
  SDL_EVENT_FINGER_MOTION = 1794;
  SDL_EVENT_FINGER_CANCELED = 1795;
  (** The clipboard or primary selection changed *)
  SDL_EVENT_CLIPBOARD_UPDATE = 2304;
  (** The system requests a file open *)
  SDL_EVENT_DROP_FILE = 4096;
  (** text/plain drag-and-drop event *)
  SDL_EVENT_DROP_TEXT = 4097;
  (** A new set of drops is beginning (NULL filename) *)
  SDL_EVENT_DROP_BEGIN = 4098;
  (** Current set of drops is now complete (NULL filename) *)
  SDL_EVENT_DROP_COMPLETE = 4099;
  (** Position while moving over the window *)
  SDL_EVENT_DROP_POSITION = 4100;
  (** A new audio device is available *)
  SDL_EVENT_AUDIO_DEVICE_ADDED = 4352;
  (** An audio device has been removed. *)
  SDL_EVENT_AUDIO_DEVICE_REMOVED = 4353;
  (** An audio device's format has been changed by the system. *)
  SDL_EVENT_AUDIO_DEVICE_FORMAT_CHANGED = 4354;
  (** A sensor was updated *)
  SDL_EVENT_SENSOR_UPDATE = 4608;
  (** Pressure-sensitive pen has become available *)
  SDL_EVENT_PEN_PROXIMITY_IN = 4864;
  (** Pressure-sensitive pen has become unavailable *)
  SDL_EVENT_PEN_PROXIMITY_OUT = 4865;
  (** Pressure-sensitive pen touched drawing surface *)
  SDL_EVENT_PEN_DOWN = 4866;
  (** Pressure-sensitive pen stopped touching drawing surface *)
  SDL_EVENT_PEN_UP = 4867;
  (** Pressure-sensitive pen button pressed *)
  SDL_EVENT_PEN_BUTTON_DOWN = 4868;
  (** Pressure-sensitive pen button released *)
  SDL_EVENT_PEN_BUTTON_UP = 4869;
  (** Pressure-sensitive pen is moving on the tablet *)
  SDL_EVENT_PEN_MOTION = 4870;
  (** Pressure-sensitive pen angle/pressure/etc changed *)
  SDL_EVENT_PEN_AXIS = 4871;
  (** A new camera device is available *)
  SDL_EVENT_CAMERA_DEVICE_ADDED = 5120;
  (** A camera device has been removed. *)
  SDL_EVENT_CAMERA_DEVICE_REMOVED = 5121;
  (** A camera device has been approved for use by the user. *)
  SDL_EVENT_CAMERA_DEVICE_APPROVED = 5122;
  (** A camera device has been denied for use by the user. *)
  SDL_EVENT_CAMERA_DEVICE_DENIED = 5123;
  (** The render targets have been reset and their contents need to be updated *)
  SDL_EVENT_RENDER_TARGETS_RESET = 8192;
  (** The device has been reset and all textures need to be recreated *)
  SDL_EVENT_RENDER_DEVICE_RESET = 8193;
  (** The device has been lost and can't be recovered. *)
  SDL_EVENT_RENDER_DEVICE_LOST = 8194;
  SDL_EVENT_PRIVATE0 = 16384;
  SDL_EVENT_PRIVATE1 = 16385;
  SDL_EVENT_PRIVATE2 = 16386;
  SDL_EVENT_PRIVATE3 = 16387;
  (** Signals the end of an event poll cycle *)
  SDL_EVENT_POLL_SENTINEL = 32512;
  (** Events SDL_EVENT_USER through SDL_EVENT_LAST are for your use,
   *  and should be allocated with SDL_RegisterEvents()
   *)
  SDL_EVENT_USER = 32768;
  (**
   *  This last event is only for bounding internal arrays
   *)
  SDL_EVENT_LAST = 65535;
  (**
   *  This last event is only for bounding internal arrays
   *)
  SDL_EVENT_ENUM_PADDING = 2147483647;

type
  (**
   * Fields shared by every event
   *
   * \since This struct is available since SDL 3.2.0.
   *)
  SDL_CommonEvent = record
    (** Event type, shared with all events, Uint32 to cover user events which are not in the SDL_EventType enumeration *)
    &type: Uint32;
    reserved: Uint32;
    (** In nanoseconds, populated using SDL_GetTicksNS() *)
    timestamp: Uint64;
  end;

  (**
   * Display state change event data (event.display.* )
   *
   * \since This struct is available since SDL 3.2.0.
   *)
  SDL_DisplayEvent = record
    (** SDL_DISPLAYEVENT_* *)
    &type: SDL_EventType;
    reserved: Uint32;
    (** In nanoseconds, populated using SDL_GetTicksNS() *)
    timestamp: Uint64;
    (** The associated display *)
    displayID: SDL_DisplayID;
    (** event dependent data *)
    data1: Sint32;
    (** event dependent data *)
    data2: Sint32;
  end;

  (**
   * Window state change event data (event.window.* )
   *
   * \since This struct is available since SDL 3.2.0.
   *)
  SDL_WindowEvent = record
    (** SDL_EVENT_WINDOW_* *)
    &type: SDL_EventType;
    reserved: Uint32;
    (** In nanoseconds, populated using SDL_GetTicksNS() *)
    timestamp: Uint64;
    (** The associated window *)
    windowID: SDL_WindowID;
    (** event dependent data *)
    data1: Sint32;
    (** event dependent data *)
    data2: Sint32;
  end;

  (**
   * Keyboard device event structure (event.kdevice.* )
   *
   * \since This struct is available since SDL 3.2.0.
   *)
  SDL_KeyboardDeviceEvent = record
    (** SDL_EVENT_KEYBOARD_ADDED or SDL_EVENT_KEYBOARD_REMOVED *)
    &type: SDL_EventType;
    reserved: Uint32;
    (** In nanoseconds, populated using SDL_GetTicksNS() *)
    timestamp: Uint64;
    (** The keyboard instance id *)
    which: SDL_KeyboardID;
  end;

  (**
   * Keyboard button event structure (event.key.* )
   *
   * The `key` is the base SDL_Keycode generated by pressing the `scancode`
   * using the current keyboard layout, applying any options specified in
   * SDL_HINT_KEYCODE_OPTIONS. You can get the SDL_Keycode corresponding to the
   * event scancode and modifiers directly from the keyboard layout, bypassing
   * SDL_HINT_KEYCODE_OPTIONS, by calling SDL_GetKeyFromScancode().
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_GetKeyFromScancode
   * \sa SDL_HINT_KEYCODE_OPTIONS
   *)
  SDL_KeyboardEvent = record
    (** SDL_EVENT_KEY_DOWN or SDL_EVENT_KEY_UP *)
    &type: SDL_EventType;
    reserved: Uint32;
    (** In nanoseconds, populated using SDL_GetTicksNS() *)
    timestamp: Uint64;
    (** The window with keyboard focus, if any *)
    windowID: SDL_WindowID;
    (** The keyboard instance id, or 0 if unknown or virtual *)
    which: SDL_KeyboardID;
    (** SDL physical key code *)
    scancode: SDL_Scancode;
    (** SDL virtual key code *)
    key: SDL_Keycode;
    (** current key modifiers *)
    &mod: SDL_Keymod;
    (** The platform dependent scancode for this event *)
    raw: Uint16;
    (** true if the key is pressed *)
    down: Boolean;
    (** true if this is a key repeat *)
    &repeat: Boolean;
  end;

  (**
   * Keyboard text editing event structure (event.edit.* )
   *
   * The start cursor is the position, in UTF-8 characters, where new typing
   * will be inserted into the editing text. The length is the number of UTF-8
   * characters that will be replaced by new typing.
   *
   * \since This struct is available since SDL 3.2.0.
   *)
  SDL_TextEditingEvent = record
    (** SDL_EVENT_TEXT_EDITING *)
    &type: SDL_EventType;
    reserved: Uint32;
    (** In nanoseconds, populated using SDL_GetTicksNS() *)
    timestamp: Uint64;
    (** The window with keyboard focus, if any *)
    windowID: SDL_WindowID;
    (** The editing text *)
    text: PUTF8Char;
    (** The start cursor of selected editing text, or -1 if not set *)
    start: Sint32;
    (** The length of selected editing text, or -1 if not set *)
    length: Sint32;
  end;

  (**
   * Keyboard IME candidates event structure (event.edit_candidates.* )
   *
   * \since This struct is available since SDL 3.2.0.
   *)
  SDL_TextEditingCandidatesEvent = record
    (** SDL_EVENT_TEXT_EDITING_CANDIDATES *)
    &type: SDL_EventType;
    reserved: Uint32;
    (** In nanoseconds, populated using SDL_GetTicksNS() *)
    timestamp: Uint64;
    (** The window with keyboard focus, if any *)
    windowID: SDL_WindowID;
    (** The list of candidates, or NULL if there are no candidates available *)
    candidates: PPUTF8Char;
    (** The number of strings in `candidates` *)
    num_candidates: Sint32;
    (** The index of the selected candidate, or -1 if no candidate is selected *)
    selected_candidate: Sint32;
    (** true if the list is horizontal, false if it's vertical *)
    horizontal: Boolean;
    padding1: Uint8;
    padding2: Uint8;
    padding3: Uint8;
  end;

  (**
   * Keyboard text input event structure (event.text.* )
   *
   * This event will never be delivered unless text input is enabled by calling
   * SDL_StartTextInput(). Text input is disabled by default!
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_StartTextInput
   * \sa SDL_StopTextInput
   *)
  SDL_TextInputEvent = record
    (** SDL_EVENT_TEXT_INPUT *)
    &type: SDL_EventType;
    reserved: Uint32;
    (** In nanoseconds, populated using SDL_GetTicksNS() *)
    timestamp: Uint64;
    (** The window with keyboard focus, if any *)
    windowID: SDL_WindowID;
    (** The input text, UTF-8 encoded *)
    text: PUTF8Char;
  end;

  (**
   * Mouse device event structure (event.mdevice.* )
   *
   * \since This struct is available since SDL 3.2.0.
   *)
  SDL_MouseDeviceEvent = record
    (** SDL_EVENT_MOUSE_ADDED or SDL_EVENT_MOUSE_REMOVED *)
    &type: SDL_EventType;
    reserved: Uint32;
    (** In nanoseconds, populated using SDL_GetTicksNS() *)
    timestamp: Uint64;
    (** The mouse instance id *)
    which: SDL_MouseID;
  end;

  (**
   * Mouse motion event structure (event.motion.* )
   *
   * \since This struct is available since SDL 3.2.0.
   *)
  SDL_MouseMotionEvent = record
    (** SDL_EVENT_MOUSE_MOTION *)
    &type: SDL_EventType;
    reserved: Uint32;
    (** In nanoseconds, populated using SDL_GetTicksNS() *)
    timestamp: Uint64;
    (** The window with mouse focus, if any *)
    windowID: SDL_WindowID;
    (** The mouse instance id in relative mode, SDL_TOUCH_MOUSEID for touch events, or 0 *)
    which: SDL_MouseID;
    (** The current button state *)
    state: SDL_MouseButtonFlags;
    (** X coordinate, relative to window *)
    x: Single;
    (** Y coordinate, relative to window *)
    y: Single;
    (** The relative motion in the X direction *)
    xrel: Single;
    (** The relative motion in the Y direction *)
    yrel: Single;
  end;

  (**
   * Mouse button event structure (event.button.* )
   *
   * \since This struct is available since SDL 3.2.0.
   *)
  SDL_MouseButtonEvent = record
    (** SDL_EVENT_MOUSE_BUTTON_DOWN or SDL_EVENT_MOUSE_BUTTON_UP *)
    &type: SDL_EventType;
    reserved: Uint32;
    (** In nanoseconds, populated using SDL_GetTicksNS() *)
    timestamp: Uint64;
    (** The window with mouse focus, if any *)
    windowID: SDL_WindowID;
    (** The mouse instance id in relative mode, SDL_TOUCH_MOUSEID for touch events, or 0 *)
    which: SDL_MouseID;
    (** The mouse button index *)
    button: Uint8;
    (** true if the button is pressed *)
    down: Boolean;
    (** 1 for single-click, 2 for double-click, etc. *)
    clicks: Uint8;
    padding: Uint8;
    (** X coordinate, relative to window *)
    x: Single;
    (** Y coordinate, relative to window *)
    y: Single;
  end;

  (**
   * Mouse wheel event structure (event.wheel.* )
   *
   * \since This struct is available since SDL 3.2.0.
   *)
  SDL_MouseWheelEvent = record
    (** SDL_EVENT_MOUSE_WHEEL *)
    &type: SDL_EventType;
    reserved: Uint32;
    (** In nanoseconds, populated using SDL_GetTicksNS() *)
    timestamp: Uint64;
    (** The window with mouse focus, if any *)
    windowID: SDL_WindowID;
    (** The mouse instance id in relative mode or 0 *)
    which: SDL_MouseID;
    (** The amount scrolled horizontally, positive to the right and negative to the left *)
    x: Single;
    (** The amount scrolled vertically, positive away from the user and negative toward the user *)
    y: Single;
    (** Set to one of the SDL_MOUSEWHEEL_* defines. When FLIPPED the values in X and Y will be opposite. Multiply by -1 to change them back *)
    direction: SDL_MouseWheelDirection;
    (** X coordinate, relative to window *)
    mouse_x: Single;
    (** Y coordinate, relative to window *)
    mouse_y: Single;
  end;

  (**
   * Joystick axis motion event structure (event.jaxis.* )
   *
   * \since This struct is available since SDL 3.2.0.
   *)
  SDL_JoyAxisEvent = record
    (** SDL_EVENT_JOYSTICK_AXIS_MOTION *)
    &type: SDL_EventType;
    reserved: Uint32;
    (** In nanoseconds, populated using SDL_GetTicksNS() *)
    timestamp: Uint64;
    (** The joystick instance id *)
    which: SDL_JoystickID;
    (** The joystick axis index *)
    axis: Uint8;
    padding1: Uint8;
    padding2: Uint8;
    padding3: Uint8;
    (** The axis value (range: -32768 to 32767) *)
    value: Sint16;
    padding4: Uint16;
  end;

  (**
   * Joystick trackball motion event structure (event.jball.* )
   *
   * \since This struct is available since SDL 3.2.0.
   *)
  SDL_JoyBallEvent = record
    (** SDL_EVENT_JOYSTICK_BALL_MOTION *)
    &type: SDL_EventType;
    reserved: Uint32;
    (** In nanoseconds, populated using SDL_GetTicksNS() *)
    timestamp: Uint64;
    (** The joystick instance id *)
    which: SDL_JoystickID;
    (** The joystick trackball index *)
    ball: Uint8;
    padding1: Uint8;
    padding2: Uint8;
    padding3: Uint8;
    (** The relative motion in the X direction *)
    xrel: Sint16;
    (** The relative motion in the Y direction *)
    yrel: Sint16;
  end;

  (**
   * Joystick hat position change event structure (event.jhat.* )
   *
   * \since This struct is available since SDL 3.2.0.
   *)
  SDL_JoyHatEvent = record
    (** SDL_EVENT_JOYSTICK_HAT_MOTION *)
    &type: SDL_EventType;
    reserved: Uint32;
    (** In nanoseconds, populated using SDL_GetTicksNS() *)
    timestamp: Uint64;
    (** The joystick instance id *)
    which: SDL_JoystickID;
    (** The joystick hat index *)
    hat: Uint8;
    (** The hat position value.
     *   \sa SDL_HAT_LEFTUP SDL_HAT_UP SDL_HAT_RIGHTUP
     *   \sa SDL_HAT_LEFT SDL_HAT_CENTERED SDL_HAT_RIGHT
     *   \sa SDL_HAT_LEFTDOWN SDL_HAT_DOWN SDL_HAT_RIGHTDOWN
     *
     *   Note that zero means the POV is centered.
     *)
    value: Uint8;
    padding1: Uint8;
    padding2: Uint8;
  end;

  (**
   * Joystick button event structure (event.jbutton.* )
   *
   * \since This struct is available since SDL 3.2.0.
   *)
  SDL_JoyButtonEvent = record
    (** SDL_EVENT_JOYSTICK_BUTTON_DOWN or SDL_EVENT_JOYSTICK_BUTTON_UP *)
    &type: SDL_EventType;
    reserved: Uint32;
    (** In nanoseconds, populated using SDL_GetTicksNS() *)
    timestamp: Uint64;
    (** The joystick instance id *)
    which: SDL_JoystickID;
    (** The joystick button index *)
    button: Uint8;
    (** true if the button is pressed *)
    down: Boolean;
    padding1: Uint8;
    padding2: Uint8;
  end;

  (**
   * Joystick device event structure (event.jdevice.* )
   *
   * SDL will send JOYSTICK_ADDED events for devices that are already plugged in
   * during SDL_Init.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_GamepadDeviceEvent
   *)
  SDL_JoyDeviceEvent = record
    (** SDL_EVENT_JOYSTICK_ADDED or SDL_EVENT_JOYSTICK_REMOVED or SDL_EVENT_JOYSTICK_UPDATE_COMPLETE *)
    &type: SDL_EventType;
    reserved: Uint32;
    (** In nanoseconds, populated using SDL_GetTicksNS() *)
    timestamp: Uint64;
    (** The joystick instance id *)
    which: SDL_JoystickID;
  end;

  (**
   * Joystick battery level change event structure (event.jbattery.* )
   *
   * \since This struct is available since SDL 3.2.0.
   *)
  SDL_JoyBatteryEvent = record
    (** SDL_EVENT_JOYSTICK_BATTERY_UPDATED *)
    &type: SDL_EventType;
    reserved: Uint32;
    (** In nanoseconds, populated using SDL_GetTicksNS() *)
    timestamp: Uint64;
    (** The joystick instance id *)
    which: SDL_JoystickID;
    (** The joystick battery state *)
    state: SDL_PowerState;
    (** The joystick battery percent charge remaining *)
    percent: Integer;
  end;

  (**
   * Gamepad axis motion event structure (event.gaxis.* )
   *
   * \since This struct is available since SDL 3.2.0.
   *)
  SDL_GamepadAxisEvent = record
    (** SDL_EVENT_GAMEPAD_AXIS_MOTION *)
    &type: SDL_EventType;
    reserved: Uint32;
    (** In nanoseconds, populated using SDL_GetTicksNS() *)
    timestamp: Uint64;
    (** The joystick instance id *)
    which: SDL_JoystickID;
    (** The gamepad axis (SDL_GamepadAxis) *)
    axis: Uint8;
    padding1: Uint8;
    padding2: Uint8;
    padding3: Uint8;
    (** The axis value (range: -32768 to 32767) *)
    value: Sint16;
    padding4: Uint16;
  end;

  (**
   * Gamepad button event structure (event.gbutton.* )
   *
   * \since This struct is available since SDL 3.2.0.
   *)
  SDL_GamepadButtonEvent = record
    (** SDL_EVENT_GAMEPAD_BUTTON_DOWN or SDL_EVENT_GAMEPAD_BUTTON_UP *)
    &type: SDL_EventType;
    reserved: Uint32;
    (** In nanoseconds, populated using SDL_GetTicksNS() *)
    timestamp: Uint64;
    (** The joystick instance id *)
    which: SDL_JoystickID;
    (** The gamepad button (SDL_GamepadButton) *)
    button: Uint8;
    (** true if the button is pressed *)
    down: Boolean;
    padding1: Uint8;
    padding2: Uint8;
  end;

  (**
   * Gamepad device event structure (event.gdevice.* )
   *
   * Joysticks that are supported gamepads receive both an SDL_JoyDeviceEvent
   * and an SDL_GamepadDeviceEvent.
   *
   * SDL will send GAMEPAD_ADDED events for joysticks that are already plugged
   * in during SDL_Init() and are recognized as gamepads. It will also send
   * events for joysticks that get gamepad mappings at runtime.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_JoyDeviceEvent
   *)
  SDL_GamepadDeviceEvent = record
    (** SDL_EVENT_GAMEPAD_ADDED, SDL_EVENT_GAMEPAD_REMOVED, or SDL_EVENT_GAMEPAD_REMAPPED, SDL_EVENT_GAMEPAD_UPDATE_COMPLETE or SDL_EVENT_GAMEPAD_STEAM_HANDLE_UPDATED *)
    &type: SDL_EventType;
    reserved: Uint32;
    (** In nanoseconds, populated using SDL_GetTicksNS() *)
    timestamp: Uint64;
    (** The joystick instance id *)
    which: SDL_JoystickID;
  end;

  (**
   * Gamepad touchpad event structure (event.gtouchpad.* )
   *
   * \since This struct is available since SDL 3.2.0.
   *)
  SDL_GamepadTouchpadEvent = record
    (** SDL_EVENT_GAMEPAD_TOUCHPAD_DOWN or SDL_EVENT_GAMEPAD_TOUCHPAD_MOTION or SDL_EVENT_GAMEPAD_TOUCHPAD_UP *)
    &type: SDL_EventType;
    reserved: Uint32;
    (** In nanoseconds, populated using SDL_GetTicksNS() *)
    timestamp: Uint64;
    (** The joystick instance id *)
    which: SDL_JoystickID;
    (** The index of the touchpad *)
    touchpad: Sint32;
    (** The index of the finger on the touchpad *)
    finger: Sint32;
    (** Normalized in the range 0...1 with 0 being on the left *)
    x: Single;
    (** Normalized in the range 0...1 with 0 being at the top *)
    y: Single;
    (** Normalized in the range 0...1 *)
    pressure: Single;
  end;

  (**
   * Gamepad sensor event structure (event.gsensor.* )
   *
   * \since This struct is available since SDL 3.2.0.
   *)
  SDL_GamepadSensorEvent = record
    (** SDL_EVENT_GAMEPAD_SENSOR_UPDATE *)
    &type: SDL_EventType;
    reserved: Uint32;
    (** In nanoseconds, populated using SDL_GetTicksNS() *)
    timestamp: Uint64;
    (** The joystick instance id *)
    which: SDL_JoystickID;
    (** The type of the sensor, one of the values of SDL_SensorType *)
    sensor: Sint32;
    (** Up to 3 values from the sensor, as defined in SDL_sensor.h *)
    data: array [0..2] of Single;
    (** The timestamp of the sensor reading in nanoseconds, not necessarily synchronized with the system clock *)
    sensor_timestamp: Uint64;
  end;

  (**
   * Audio device event structure (event.adevice.* )
   *
   * \since This struct is available since SDL 3.2.0.
   *)
  SDL_AudioDeviceEvent = record
    (** SDL_EVENT_AUDIO_DEVICE_ADDED, or SDL_EVENT_AUDIO_DEVICE_REMOVED, or SDL_EVENT_AUDIO_DEVICE_FORMAT_CHANGED *)
    &type: SDL_EventType;
    reserved: Uint32;
    (** In nanoseconds, populated using SDL_GetTicksNS() *)
    timestamp: Uint64;
    (** SDL_AudioDeviceID for the device being added or removed or changing *)
    which: SDL_AudioDeviceID;
    (** false if a playback device, true if a recording device. *)
    recording: Boolean;
    padding1: Uint8;
    padding2: Uint8;
    padding3: Uint8;
  end;

  (**
   * Camera device event structure (event.cdevice.* )
   *
   * \since This struct is available since SDL 3.2.0.
   *)
  SDL_CameraDeviceEvent = record
    (** SDL_EVENT_CAMERA_DEVICE_ADDED, SDL_EVENT_CAMERA_DEVICE_REMOVED, SDL_EVENT_CAMERA_DEVICE_APPROVED, SDL_EVENT_CAMERA_DEVICE_DENIED *)
    &type: SDL_EventType;
    reserved: Uint32;
    (** In nanoseconds, populated using SDL_GetTicksNS() *)
    timestamp: Uint64;
    (** SDL_CameraID for the device being added or removed or changing *)
    which: SDL_CameraID;
  end;

  (**
   * Renderer event structure (event.render.* )
   *
   * \since This struct is available since SDL 3.2.0.
   *)
  SDL_RenderEvent = record
    (** SDL_EVENT_RENDER_TARGETS_RESET, SDL_EVENT_RENDER_DEVICE_RESET, SDL_EVENT_RENDER_DEVICE_LOST *)
    &type: SDL_EventType;
    reserved: Uint32;
    (** In nanoseconds, populated using SDL_GetTicksNS() *)
    timestamp: Uint64;
    (** The window containing the renderer in question. *)
    windowID: SDL_WindowID;
  end;

  (**
   * Touch finger event structure (event.tfinger.* )
   *
   * Coordinates in this event are normalized. `x` and `y` are normalized to a
   * range between 0.0f and 1.0f, relative to the window, so (0,0) is the top
   * left and (1,1) is the bottom right. Delta coordinates `dx` and `dy` are
   * normalized in the ranges of -1.0f (traversed all the way from the bottom or
   * right to all the way up or left) to 1.0f (traversed all the way from the
   * top or left to all the way down or right).
   *
   * Note that while the coordinates are _normalized_, they are not _clamped_,
   * which means in some circumstances you can get a value outside of this
   * range. For example, a renderer using logical presentation might give a
   * negative value when the touch is in the letterboxing. Some platforms might
   * report a touch outside of the window, which will also be outside of the
   * range.
   *
   * \since This struct is available since SDL 3.2.0.
   *)
  SDL_TouchFingerEvent = record
    (** SDL_EVENT_FINGER_DOWN, SDL_EVENT_FINGER_UP, SDL_EVENT_FINGER_MOTION, or SDL_EVENT_FINGER_CANCELED *)
    &type: SDL_EventType;
    reserved: Uint32;
    (** In nanoseconds, populated using SDL_GetTicksNS() *)
    timestamp: Uint64;
    (** The touch device id *)
    touchID: SDL_TouchID;
    fingerID: SDL_FingerID;
    (** Normalized in the range 0...1 *)
    x: Single;
    (** Normalized in the range 0...1 *)
    y: Single;
    (** Normalized in the range -1...1 *)
    dx: Single;
    (** Normalized in the range -1...1 *)
    dy: Single;
    (** Normalized in the range 0...1 *)
    pressure: Single;
    (** The window underneath the finger, if any *)
    windowID: SDL_WindowID;
  end;

  (**
   * Pressure-sensitive pen proximity event structure (event.pmotion.* )
   *
   * When a pen becomes visible to the system (it is close enough to a tablet,
   * etc), SDL will send an SDL_EVENT_PEN_PROXIMITY_IN event with the new pen's
   * ID. This ID is valid until the pen leaves proximity again (has been removed
   * from the tablet's area, the tablet has been unplugged, etc). If the same
   * pen reenters proximity again, it will be given a new ID.
   *
   * Note that "proximity" means "close enough for the tablet to know the tool
   * is there." The pen touching and lifting off from the tablet while not
   * leaving the area are handled by SDL_EVENT_PEN_DOWN and SDL_EVENT_PEN_UP.
   *
   * \since This struct is available since SDL 3.2.0.
   *)
  SDL_PenProximityEvent = record
    (** SDL_EVENT_PEN_PROXIMITY_IN or SDL_EVENT_PEN_PROXIMITY_OUT *)
    &type: SDL_EventType;
    reserved: Uint32;
    (** In nanoseconds, populated using SDL_GetTicksNS() *)
    timestamp: Uint64;
    (** The window with pen focus, if any *)
    windowID: SDL_WindowID;
    (** The pen instance id *)
    which: SDL_PenID;
  end;

  (**
   * Pressure-sensitive pen motion event structure (event.pmotion.* )
   *
   * Depending on the hardware, you may get motion events when the pen is not
   * touching a tablet, for tracking a pen even when it isn't drawing. You
   * should listen for SDL_EVENT_PEN_DOWN and SDL_EVENT_PEN_UP events, or check
   * `pen_state & SDL_PEN_INPUT_DOWN` to decide if a pen is "drawing" when
   * dealing with pen motion.
   *
   * \since This struct is available since SDL 3.2.0.
   *)
  SDL_PenMotionEvent = record
    (** SDL_EVENT_PEN_MOTION *)
    &type: SDL_EventType;
    reserved: Uint32;
    (** In nanoseconds, populated using SDL_GetTicksNS() *)
    timestamp: Uint64;
    (** The window with pen focus, if any *)
    windowID: SDL_WindowID;
    (** The pen instance id *)
    which: SDL_PenID;
    (** Complete pen input state at time of event *)
    pen_state: SDL_PenInputFlags;
    (** X coordinate, relative to window *)
    x: Single;
    (** Y coordinate, relative to window *)
    y: Single;
  end;

  (**
   * Pressure-sensitive pen touched event structure (event.ptouch.* )
   *
   * These events come when a pen touches a surface (a tablet, etc), or lifts
   * off from one.
   *
   * \since This struct is available since SDL 3.2.0.
   *)
  SDL_PenTouchEvent = record
    (** SDL_EVENT_PEN_DOWN or SDL_EVENT_PEN_UP *)
    &type: SDL_EventType;
    reserved: Uint32;
    (** In nanoseconds, populated using SDL_GetTicksNS() *)
    timestamp: Uint64;
    (** The window with pen focus, if any *)
    windowID: SDL_WindowID;
    (** The pen instance id *)
    which: SDL_PenID;
    (** Complete pen input state at time of event *)
    pen_state: SDL_PenInputFlags;
    (** X coordinate, relative to window *)
    x: Single;
    (** Y coordinate, relative to window *)
    y: Single;
    (** true if eraser end is used (not all pens support this). *)
    eraser: Boolean;
    (** true if the pen is touching or false if the pen is lifted off *)
    down: Boolean;
  end;

  (**
   * Pressure-sensitive pen button event structure (event.pbutton.* )
   *
   * This is for buttons on the pen itself that the user might click. The pen
   * itself pressing down to draw triggers a SDL_EVENT_PEN_DOWN event instead.
   *
   * \since This struct is available since SDL 3.2.0.
   *)
  SDL_PenButtonEvent = record
    (** SDL_EVENT_PEN_BUTTON_DOWN or SDL_EVENT_PEN_BUTTON_UP *)
    &type: SDL_EventType;
    reserved: Uint32;
    (** In nanoseconds, populated using SDL_GetTicksNS() *)
    timestamp: Uint64;
    (** The window with mouse focus, if any *)
    windowID: SDL_WindowID;
    (** The pen instance id *)
    which: SDL_PenID;
    (** Complete pen input state at time of event *)
    pen_state: SDL_PenInputFlags;
    (** X coordinate, relative to window *)
    x: Single;
    (** Y coordinate, relative to window *)
    y: Single;
    (** The pen button index (first button is 1). *)
    button: Uint8;
    (** true if the button is pressed *)
    down: Boolean;
  end;

  (**
   * Pressure-sensitive pen pressure / angle event structure (event.paxis.* )
   *
   * You might get some of these events even if the pen isn't touching the
   * tablet.
   *
   * \since This struct is available since SDL 3.2.0.
   *)
  SDL_PenAxisEvent = record
    (** SDL_EVENT_PEN_AXIS *)
    &type: SDL_EventType;
    reserved: Uint32;
    (** In nanoseconds, populated using SDL_GetTicksNS() *)
    timestamp: Uint64;
    (** The window with pen focus, if any *)
    windowID: SDL_WindowID;
    (** The pen instance id *)
    which: SDL_PenID;
    (** Complete pen input state at time of event *)
    pen_state: SDL_PenInputFlags;
    (** X coordinate, relative to window *)
    x: Single;
    (** Y coordinate, relative to window *)
    y: Single;
    (** Axis that has changed *)
    axis: SDL_PenAxis;
    (** New value of axis *)
    value: Single;
  end;

  (**
   * An event used to drop text or request a file open by the system
   * (event.drop.* )
   *
   * \since This struct is available since SDL 3.2.0.
   *)
  SDL_DropEvent = record
    (** SDL_EVENT_DROP_BEGIN or SDL_EVENT_DROP_FILE or SDL_EVENT_DROP_TEXT or SDL_EVENT_DROP_COMPLETE or SDL_EVENT_DROP_POSITION *)
    &type: SDL_EventType;
    reserved: Uint32;
    (** In nanoseconds, populated using SDL_GetTicksNS() *)
    timestamp: Uint64;
    (** The window that was dropped on, if any *)
    windowID: SDL_WindowID;
    (** X coordinate, relative to window (not on begin) *)
    x: Single;
    (** Y coordinate, relative to window (not on begin) *)
    y: Single;
    (** The source app that sent this drop event, or NULL if that isn't available *)
    source: PUTF8Char;
    (** The text for SDL_EVENT_DROP_TEXT and the file name for SDL_EVENT_DROP_FILE, NULL for other events *)
    data: PUTF8Char;
  end;

  (**
   * An event triggered when the clipboard contents have changed
   * (event.clipboard.* )
   *
   * \since This struct is available since SDL 3.2.0.
   *)
  SDL_ClipboardEvent = record
    (** SDL_EVENT_CLIPBOARD_UPDATE *)
    &type: SDL_EventType;
    reserved: Uint32;
    (** In nanoseconds, populated using SDL_GetTicksNS() *)
    timestamp: Uint64;
    (** are we owning the clipboard (internal update) *)
    owner: Boolean;
    (** number of mime types *)
    num_mime_types: Sint32;
    (** current mime types *)
    mime_types: PPUTF8Char;
  end;

  (**
   * Sensor event structure (event.sensor.* )
   *
   * \since This struct is available since SDL 3.2.0.
   *)
  SDL_SensorEvent = record
    (** SDL_EVENT_SENSOR_UPDATE *)
    &type: SDL_EventType;
    reserved: Uint32;
    (** In nanoseconds, populated using SDL_GetTicksNS() *)
    timestamp: Uint64;
    (** The instance ID of the sensor *)
    which: SDL_SensorID;
    (** Up to 6 values from the sensor - additional values can be queried using SDL_GetSensorData() *)
    data: array [0..5] of Single;
    (** The timestamp of the sensor reading in nanoseconds, not necessarily synchronized with the system clock *)
    sensor_timestamp: Uint64;
  end;

  (**
   * The "quit requested" event
   *
   * \since This struct is available since SDL 3.2.0.
   *)
  SDL_QuitEvent = record
    (** SDL_EVENT_QUIT *)
    &type: SDL_EventType;
    reserved: Uint32;
    (** In nanoseconds, populated using SDL_GetTicksNS() *)
    timestamp: Uint64;
  end;

  (**
   * A user-defined event type (event.user.* )
   *
   * This event is unique; it is never created by SDL, but only by the
   * application. The event can be pushed onto the event queue using
   * SDL_PushEvent(). The contents of the structure members are completely up to
   * the programmer; the only requirement is that '''type''' is a value obtained
   * from SDL_RegisterEvents().
   *
   * \since This struct is available since SDL 3.2.0.
   *)
  SDL_UserEvent = record
    (** SDL_EVENT_USER through SDL_EVENT_LAST-1, Uint32 because these are not in the SDL_EventType enumeration *)
    &type: Uint32;
    reserved: Uint32;
    (** In nanoseconds, populated using SDL_GetTicksNS() *)
    timestamp: Uint64;
    (** The associated window if any *)
    windowID: SDL_WindowID;
    (** User defined event code *)
    code: Sint32;
    (** User defined data pointer *)
    data1: Pointer;
    (** User defined data pointer *)
    data2: Pointer;
  end;

  (**
   * The structure for all events in SDL.
   *
   * The SDL_Event structure is the core of all event handling in SDL. SDL_Event
   * is a union of all event structures used in SDL.
   *
   * \since This struct is available since SDL 3.2.0.
   *)
  SDL_Event = record
    case Integer of
      0: ((** Event type, shared with all events, Uint32 to cover user events which are not in the SDL_EventType enumeration *)
    &type: Uint32);
      1: ((** Common event data *)
    common: SDL_CommonEvent);
      2: ((** Display event data *)
    display: SDL_DisplayEvent);
      3: ((** Window event data *)
    window: SDL_WindowEvent);
      4: ((** Keyboard device change event data *)
    kdevice: SDL_KeyboardDeviceEvent);
      5: ((** Keyboard event data *)
    key: SDL_KeyboardEvent);
      6: ((** Text editing event data *)
    edit: SDL_TextEditingEvent);
      7: ((** Text editing candidates event data *)
    edit_candidates: SDL_TextEditingCandidatesEvent);
      8: ((** Text input event data *)
    text: SDL_TextInputEvent);
      9: ((** Mouse device change event data *)
    mdevice: SDL_MouseDeviceEvent);
      10: ((** Mouse motion event data *)
    motion: SDL_MouseMotionEvent);
      11: ((** Mouse button event data *)
    button: SDL_MouseButtonEvent);
      12: ((** Mouse wheel event data *)
    wheel: SDL_MouseWheelEvent);
      13: ((** Joystick device change event data *)
    jdevice: SDL_JoyDeviceEvent);
      14: ((** Joystick axis event data *)
    jaxis: SDL_JoyAxisEvent);
      15: ((** Joystick ball event data *)
    jball: SDL_JoyBallEvent);
      16: ((** Joystick hat event data *)
    jhat: SDL_JoyHatEvent);
      17: ((** Joystick button event data *)
    jbutton: SDL_JoyButtonEvent);
      18: ((** Joystick battery event data *)
    jbattery: SDL_JoyBatteryEvent);
      19: ((** Gamepad device event data *)
    gdevice: SDL_GamepadDeviceEvent);
      20: ((** Gamepad axis event data *)
    gaxis: SDL_GamepadAxisEvent);
      21: ((** Gamepad button event data *)
    gbutton: SDL_GamepadButtonEvent);
      22: ((** Gamepad touchpad event data *)
    gtouchpad: SDL_GamepadTouchpadEvent);
      23: ((** Gamepad sensor event data *)
    gsensor: SDL_GamepadSensorEvent);
      24: ((** Audio device event data *)
    adevice: SDL_AudioDeviceEvent);
      25: ((** Camera device event data *)
    cdevice: SDL_CameraDeviceEvent);
      26: ((** Sensor event data *)
    sensor: SDL_SensorEvent);
      27: ((** Quit request event data *)
    quit: SDL_QuitEvent);
      28: ((** Custom event data *)
    user: SDL_UserEvent);
      29: ((** Touch finger event data *)
    tfinger: SDL_TouchFingerEvent);
      30: ((** Pen proximity event data *)
    pproximity: SDL_PenProximityEvent);
      31: ((** Pen tip touching event data *)
    ptouch: SDL_PenTouchEvent);
      32: ((** Pen motion event data *)
    pmotion: SDL_PenMotionEvent);
      33: ((** Pen button event data *)
    pbutton: SDL_PenButtonEvent);
      34: ((** Pen axis event data *)
    paxis: SDL_PenAxisEvent);
      35: ((** Render event data *)
    render: SDL_RenderEvent);
      36: ((** Drag and drop event data *)
    drop: SDL_DropEvent);
      37: ((** Clipboard event data *)
    clipboard: SDL_ClipboardEvent);
      38: (padding: array [0..127] of Uint8);
  end;
  PSDL_Event = ^SDL_Event;

(**
 * Pump the event loop, gathering events from the input devices.
 *
 * This function updates the event queue and internal input device state.
 *
 * SDL_PumpEvents() gathers all the pending input information from devices and
 * places it in the event queue. Without calls to SDL_PumpEvents() no events
 * would ever be placed on the queue. Often the need for calls to
 * SDL_PumpEvents() is hidden from the user since SDL_PollEvent() and
 * SDL_WaitEvent() implicitly call SDL_PumpEvents(). However, if you are not
 * polling or waiting for events (e.g. you are filtering them), then you must
 * call SDL_PumpEvents() to force an event queue update.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_PollEvent
 * \sa SDL_WaitEvent
 *)
procedure SDL_PumpEvents(); cdecl;
  external LIB_SDL3 name _PU + 'SDL_PumpEvents';

(**
 * The type of action to request from SDL_PeepEvents().
 *
 * \since This enum is available since SDL 3.2.0.
 *)
type
  SDL_EventAction = Integer;

const
  (** Add events to the back of the queue. *)
  SDL_ADDEVENT = 0;
  (** Check but don't remove events from the queue front. *)
  SDL_PEEKEVENT = 1;
  (** Retrieve/remove events from the front of the queue. *)
  SDL_GETEVENT = 2;

(**
 * Check the event queue for messages and optionally return them.
 *
 * `action` may be any of the following:
 *
 * - `SDL_ADDEVENT`: up to `numevents` events will be added to the back of the
 *   event queue.
 * - `SDL_PEEKEVENT`: `numevents` events at the front of the event queue,
 *   within the specified minimum and maximum type, will be returned to the
 *   caller and will _not_ be removed from the queue. If you pass NULL for
 *   `events`, then `numevents` is ignored and the total number of matching
 *   events will be returned.
 * - `SDL_GETEVENT`: up to `numevents` events at the front of the event queue,
 *   within the specified minimum and maximum type, will be returned to the
 *   caller and will be removed from the queue.
 *
 * You may have to call SDL_PumpEvents() before calling this function.
 * Otherwise, the events may not be ready to be filtered when you call
 * SDL_PeepEvents().
 *
 * \param events destination buffer for the retrieved events, may be NULL to
 *               leave the events in the queue and return the number of events
 *               that would have been stored.
 * \param numevents if action is SDL_ADDEVENT, the number of events to add
 *                  back to the event queue; if action is SDL_PEEKEVENT or
 *                  SDL_GETEVENT, the maximum number of events to retrieve.
 * \param action action to take; see [[#action|Remarks]] for details.
 * \param minType minimum value of the event type to be considered;
 *                SDL_EVENT_FIRST is a safe choice.
 * \param maxType maximum value of the event type to be considered;
 *                SDL_EVENT_LAST is a safe choice.
 * \returns the number of events actually stored or -1 on failure; call
 *          SDL_GetError() for more information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_PollEvent
 * \sa SDL_PumpEvents
 * \sa SDL_PushEvent
 *)
function SDL_PeepEvents(events: PSDL_Event; numevents: Integer; action: SDL_EventAction; minType: Uint32; maxType: Uint32): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_PeepEvents';

(**
 * Check for the existence of a certain event type in the event queue.
 *
 * If you need to check for a range of event types, use SDL_HasEvents()
 * instead.
 *
 * \param type the type of event to be queried; see SDL_EventType for details.
 * \returns true if events matching `type` are present, or false if events
 *          matching `type` are not present.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_HasEvents
 *)
function SDL_HasEvent(&type: Uint32): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_HasEvent';

(**
 * Check for the existence of certain event types in the event queue.
 *
 * If you need to check for a single event type, use SDL_HasEvent() instead.
 *
 * \param minType the low end of event type to be queried, inclusive; see
 *                SDL_EventType for details.
 * \param maxType the high end of event type to be queried, inclusive; see
 *                SDL_EventType for details.
 * \returns true if events with type >= `minType` and <= `maxType` are
 *          present, or false if not.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_HasEvents
 *)
function SDL_HasEvents(minType: Uint32; maxType: Uint32): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_HasEvents';

(**
 * Clear events of a specific type from the event queue.
 *
 * This will unconditionally remove any events from the queue that match
 * `type`. If you need to remove a range of event types, use SDL_FlushEvents()
 * instead.
 *
 * It's also normal to just ignore events you don't care about in your event
 * loop without calling this function.
 *
 * This function only affects currently queued events. If you want to make
 * sure that all pending OS events are flushed, you can call SDL_PumpEvents()
 * on the main thread immediately before the flush call.
 *
 * If you have user events with custom data that needs to be freed, you should
 * use SDL_PeepEvents() to remove and clean up those events before calling
 * this function.
 *
 * \param type the type of event to be cleared; see SDL_EventType for details.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_FlushEvents
 *)
procedure SDL_FlushEvent(&type: Uint32); cdecl;
  external LIB_SDL3 name _PU + 'SDL_FlushEvent';

(**
 * Clear events of a range of types from the event queue.
 *
 * This will unconditionally remove any events from the queue that are in the
 * range of `minType` to `maxType`, inclusive. If you need to remove a single
 * event type, use SDL_FlushEvent() instead.
 *
 * It's also normal to just ignore events you don't care about in your event
 * loop without calling this function.
 *
 * This function only affects currently queued events. If you want to make
 * sure that all pending OS events are flushed, you can call SDL_PumpEvents()
 * on the main thread immediately before the flush call.
 *
 * \param minType the low end of event type to be cleared, inclusive; see
 *                SDL_EventType for details.
 * \param maxType the high end of event type to be cleared, inclusive; see
 *                SDL_EventType for details.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_FlushEvent
 *)
procedure SDL_FlushEvents(minType: Uint32; maxType: Uint32); cdecl;
  external LIB_SDL3 name _PU + 'SDL_FlushEvents';

(**
 * Poll for currently pending events.
 *
 * If `event` is not NULL, the next event is removed from the queue and stored
 * in the SDL_Event structure pointed to by `event`. The 1 returned refers to
 * this event, immediately stored in the SDL Event structure -- not an event
 * to follow.
 *
 * If `event` is NULL, it simply returns 1 if there is an event in the queue,
 * but will not remove it from the queue.
 *
 * As this function may implicitly call SDL_PumpEvents(), you can only call
 * this function in the thread that set the video mode.
 *
 * SDL_PollEvent() is the favored way of receiving system events since it can
 * be done from the main loop and does not suspend the main loop while waiting
 * on an event to be posted.
 *
 * The common practice is to fully process the event queue once every frame,
 * usually as a first step before updating the game's state:
 *
 * ```c
 * while (game_is_still_running) {
 *     SDL_Event event;
 *     while (SDL_PollEvent(&event)) {  // poll until all events are handled!
 *         // decide what to do with this event.
 *     }
 *
 *     // update game state, draw the current frame
 * }
 * ```
 *
 * \param event the SDL_Event structure to be filled with the next event from
 *              the queue, or NULL.
 * \returns true if this got an event or false if there are none available.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_PushEvent
 * \sa SDL_WaitEvent
 * \sa SDL_WaitEventTimeout
 *)
function SDL_PollEvent(event: PSDL_Event): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_PollEvent';

(**
 * Wait indefinitely for the next available event.
 *
 * If `event` is not NULL, the next event is removed from the queue and stored
 * in the SDL_Event structure pointed to by `event`.
 *
 * As this function may implicitly call SDL_PumpEvents(), you can only call
 * this function in the thread that initialized the video subsystem.
 *
 * \param event the SDL_Event structure to be filled in with the next event
 *              from the queue, or NULL.
 * \returns true on success or false if there was an error while waiting for
 *          events; call SDL_GetError() for more information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_PollEvent
 * \sa SDL_PushEvent
 * \sa SDL_WaitEventTimeout
 *)
function SDL_WaitEvent(event: PSDL_Event): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_WaitEvent';

(**
 * Wait until the specified timeout (in milliseconds) for the next available
 * event.
 *
 * If `event` is not NULL, the next event is removed from the queue and stored
 * in the SDL_Event structure pointed to by `event`.
 *
 * As this function may implicitly call SDL_PumpEvents(), you can only call
 * this function in the thread that initialized the video subsystem.
 *
 * The timeout is not guaranteed, the actual wait time could be longer due to
 * system scheduling.
 *
 * \param event the SDL_Event structure to be filled in with the next event
 *              from the queue, or NULL.
 * \param timeoutMS the maximum number of milliseconds to wait for the next
 *                  available event.
 * \returns true if this got an event or false if the timeout elapsed without
 *          any events available.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_PollEvent
 * \sa SDL_PushEvent
 * \sa SDL_WaitEvent
 *)
function SDL_WaitEventTimeout(event: PSDL_Event; timeoutMS: Sint32): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_WaitEventTimeout';

(**
 * Add an event to the event queue.
 *
 * The event queue can actually be used as a two way communication channel.
 * Not only can events be read from the queue, but the user can also push
 * their own events onto it. `event` is a pointer to the event structure you
 * wish to push onto the queue. The event is copied into the queue, and the
 * caller may dispose of the memory pointed to after SDL_PushEvent() returns.
 *
 * Note: Pushing device input events onto the queue doesn't modify the state
 * of the device within SDL.
 *
 * Note: Events pushed onto the queue with SDL_PushEvent() get passed through
 * the event filter but events added with SDL_PeepEvents() do not.
 *
 * For pushing application-specific events, please use SDL_RegisterEvents() to
 * get an event type that does not conflict with other code that also wants
 * its own custom event types.
 *
 * \param event the SDL_Event to be added to the queue.
 * \returns true on success, false if the event was filtered or on failure;
 *          call SDL_GetError() for more information. A common reason for
 *          error is the event queue being full.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_PeepEvents
 * \sa SDL_PollEvent
 * \sa SDL_RegisterEvents
 *)
function SDL_PushEvent(event: PSDL_Event): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_PushEvent';

type
  (**
   * A function pointer used for callbacks that watch the event queue.
   *
   * \param userdata what was passed as `userdata` to SDL_SetEventFilter() or
   *                 SDL_AddEventWatch, etc.
   * \param event the event that triggered the callback.
   * \returns true to permit event to be added to the queue, and false to
   *          disallow it. When used with SDL_AddEventWatch, the return value is
   *          ignored.
   *
   * \threadsafety SDL may call this callback at any time from any thread; the
   *               application is responsible for locking resources the callback
   *               touches that need to be protected.
   *
   * \since This datatype is available since SDL 3.2.0.
   *
   * \sa SDL_SetEventFilter
   * \sa SDL_AddEventWatch
   *)
  SDL_EventFilter = function(userdata: Pointer; event: PSDL_Event): Boolean; cdecl;
  PSDL_EventFilter = ^SDL_EventFilter;

(**
 * Set up a filter to process all events before they are added to the internal
 * event queue.
 *
 * If you just want to see events without modifying them or preventing them
 * from being queued, you should use SDL_AddEventWatch() instead.
 *
 * If the filter function returns true when called, then the event will be
 * added to the internal queue. If it returns false, then the event will be
 * dropped from the queue, but the internal state will still be updated. This
 * allows selective filtering of dynamically arriving events.
 *
 * **WARNING**: Be very careful of what you do in the event filter function,
 * as it may run in a different thread!
 *
 * On platforms that support it, if the quit event is generated by an
 * interrupt signal (e.g. pressing Ctrl-C), it will be delivered to the
 * application at the next event poll.
 *
 * Note: Disabled events never make it to the event filter function; see
 * SDL_SetEventEnabled().
 *
 * Note: Events pushed onto the queue with SDL_PushEvent() get passed through
 * the event filter, but events pushed onto the queue with SDL_PeepEvents() do
 * not.
 *
 * \param filter an SDL_EventFilter function to call when an event happens.
 * \param userdata a pointer that is passed to `filter`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_AddEventWatch
 * \sa SDL_SetEventEnabled
 * \sa SDL_GetEventFilter
 * \sa SDL_PeepEvents
 * \sa SDL_PushEvent
 *)
procedure SDL_SetEventFilter(filter: SDL_EventFilter; userdata: Pointer); cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetEventFilter';

(**
 * Query the current event filter.
 *
 * This function can be used to "chain" filters, by saving the existing filter
 * before replacing it with a function that will call that saved filter.
 *
 * \param filter the current callback function will be stored here.
 * \param userdata the pointer that is passed to the current event filter will
 *                 be stored here.
 * \returns true on success or false if there is no event filter set.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetEventFilter
 *)
function SDL_GetEventFilter(filter: PSDL_EventFilter; userdata: PPointer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetEventFilter';

(**
 * Add a callback to be triggered when an event is added to the event queue.
 *
 * `filter` will be called when an event happens, and its return value is
 * ignored.
 *
 * **WARNING**: Be very careful of what you do in the event filter function,
 * as it may run in a different thread!
 *
 * If the quit event is generated by a signal (e.g. SIGINT), it will bypass
 * the internal queue and be delivered to the watch callback immediately, and
 * arrive at the next event poll.
 *
 * Note: the callback is called for events posted by the user through
 * SDL_PushEvent(), but not for disabled events, nor for events by a filter
 * callback set with SDL_SetEventFilter(), nor for events posted by the user
 * through SDL_PeepEvents().
 *
 * \param filter an SDL_EventFilter function to call when an event happens.
 * \param userdata a pointer that is passed to `filter`.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_RemoveEventWatch
 * \sa SDL_SetEventFilter
 *)
function SDL_AddEventWatch(filter: SDL_EventFilter; userdata: Pointer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_AddEventWatch';

(**
 * Remove an event watch callback added with SDL_AddEventWatch().
 *
 * This function takes the same input as SDL_AddEventWatch() to identify and
 * delete the corresponding callback.
 *
 * \param filter the function originally passed to SDL_AddEventWatch().
 * \param userdata the pointer originally passed to SDL_AddEventWatch().
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_AddEventWatch
 *)
procedure SDL_RemoveEventWatch(filter: SDL_EventFilter; userdata: Pointer); cdecl;
  external LIB_SDL3 name _PU + 'SDL_RemoveEventWatch';

(**
 * Run a specific filter function on the current event queue, removing any
 * events for which the filter returns false.
 *
 * See SDL_SetEventFilter() for more information. Unlike SDL_SetEventFilter(),
 * this function does not change the filter permanently, it only uses the
 * supplied filter until this function returns.
 *
 * \param filter the SDL_EventFilter function to call when an event happens.
 * \param userdata a pointer that is passed to `filter`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetEventFilter
 * \sa SDL_SetEventFilter
 *)
procedure SDL_FilterEvents(filter: SDL_EventFilter; userdata: Pointer); cdecl;
  external LIB_SDL3 name _PU + 'SDL_FilterEvents';

(**
 * Set the state of processing events by type.
 *
 * \param type the type of event; see SDL_EventType for details.
 * \param enabled whether to process the event or not.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_EventEnabled
 *)
procedure SDL_SetEventEnabled(&type: Uint32; enabled: Boolean); cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetEventEnabled';

(**
 * Query the state of processing events by type.
 *
 * \param type the type of event; see SDL_EventType for details.
 * \returns true if the event is being processed, false otherwise.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetEventEnabled
 *)
function SDL_EventEnabled(&type: Uint32): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_EventEnabled';

(**
 * Allocate a set of user-defined events, and return the beginning event
 * number for that set of events.
 *
 * \param numevents the number of events to be allocated.
 * \returns the beginning event number, or 0 if numevents is invalid or if
 *          there are not enough user-defined events left.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_PushEvent
 *)
function SDL_RegisterEvents(numevents: Integer): Uint32; cdecl;
  external LIB_SDL3 name _PU + 'SDL_RegisterEvents';

(**
 * Get window associated with an event.
 *
 * \param event an event containing a `windowID`.
 * \returns the associated window on success or NULL if there is none.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_PollEvent
 * \sa SDL_WaitEvent
 * \sa SDL_WaitEventTimeout
 *)
function SDL_GetWindowFromEvent(const event: PSDL_Event): SDL_Window; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetWindowFromEvent';
{$ENDREGION 'SDL_events.h'}

{$REGION 'SDL_gpu.h'}
(**
 * # CategoryGPU
 *
 * The GPU API offers a cross-platform way for apps to talk to modern graphics
 * hardware. It offers both 3D graphics and compute support, in the style of
 * Metal, Vulkan, and Direct3D 12.
 *
 * A basic workflow might be something like this:
 *
 * The app creates a GPU device with SDL_CreateGPUDevice(), and assigns it to
 * a window with SDL_ClaimWindowForGPUDevice()--although strictly speaking you
 * can render offscreen entirely, perhaps for image processing, and not use a
 * window at all.
 *
 * Next the app prepares static data (things that are created once and used
 * over and over). For example:
 *
 * - Shaders (programs that run on the GPU): use SDL_CreateGPUShader().
 * - Vertex buffers (arrays of geometry data) and other data rendering will
 *   need: use SDL_UploadToGPUBuffer().
 * - Textures (images): use SDL_UploadToGPUTexture().
 * - Samplers (how textures should be read from): use SDL_CreateGPUSampler().
 * - Render pipelines (precalculated rendering state): use
 *   SDL_CreateGPUGraphicsPipeline()
 *
 * To render, the app creates one or more command buffers, with
 * SDL_AcquireGPUCommandBuffer(). Command buffers collect rendering
 * instructions that will be submitted to the GPU in batch. Complex scenes can
 * use multiple command buffers, maybe configured across multiple threads in
 * parallel, as long as they are submitted in the correct order, but many apps
 * will just need one command buffer per frame.
 *
 * Rendering can happen to a texture (what other APIs call a "render target")
 * or it can happen to the swapchain texture (which is just a special texture
 * that represents a window's contents). The app can use
 * SDL_WaitAndAcquireGPUSwapchainTexture() to render to the window.
 *
 * Rendering actually happens in a Render Pass, which is encoded into a
 * command buffer. One can encode multiple render passes (or alternate between
 * render and compute passes) in a single command buffer, but many apps might
 * simply need a single render pass in a single command buffer. Render Passes
 * can render to up to four color textures and one depth texture
 * simultaneously. If the set of textures being rendered to needs to change,
 * the Render Pass must be ended and a new one must be begun.
 *
 * The app calls SDL_BeginGPURenderPass(). Then it sets states it needs for
 * each draw:
 *
 * - SDL_BindGPUGraphicsPipeline()
 * - SDL_SetGPUViewport()
 * - SDL_BindGPUVertexBuffers()
 * - SDL_BindGPUVertexSamplers()
 * - etc
 *
 * Then, make the actual draw commands with these states:
 *
 * - SDL_DrawGPUPrimitives()
 * - SDL_DrawGPUPrimitivesIndirect()
 * - SDL_DrawGPUIndexedPrimitivesIndirect()
 * - etc
 *
 * After all the drawing commands for a pass are complete, the app should call
 * SDL_EndGPURenderPass(). Once a render pass ends all render-related state is
 * reset.
 *
 * The app can begin new Render Passes and make new draws in the same command
 * buffer until the entire scene is rendered.
 *
 * Once all of the render commands for the scene are complete, the app calls
 * SDL_SubmitGPUCommandBuffer() to send it to the GPU for processing.
 *
 * If the app needs to read back data from texture or buffers, the API has an
 * efficient way of doing this, provided that the app is willing to tolerate
 * some latency. When the app uses SDL_DownloadFromGPUTexture() or
 * SDL_DownloadFromGPUBuffer(), submitting the command buffer with
 * SDL_SubmitGPUCommandBufferAndAcquireFence() will return a fence handle that
 * the app can poll or wait on in a thread. Once the fence indicates that the
 * command buffer is done processing, it is safe to read the downloaded data.
 * Make sure to call SDL_ReleaseGPUFence() when done with the fence.
 *
 * The API also has "compute" support. The app calls SDL_BeginGPUComputePass()
 * with compute-writeable textures and/or buffers, which can be written to in
 * a compute shader. Then it sets states it needs for the compute dispatches:
 *
 * - SDL_BindGPUComputePipeline()
 * - SDL_BindGPUComputeStorageBuffers()
 * - SDL_BindGPUComputeStorageTextures()
 *
 * Then, dispatch compute work:
 *
 * - SDL_DispatchGPUCompute()
 *
 * For advanced users, this opens up powerful GPU-driven workflows.
 *
 * Graphics and compute pipelines require the use of shaders, which as
 * mentioned above are small programs executed on the GPU. Each backend
 * (Vulkan, Metal, D3D12) requires a different shader format. When the app
 * creates the GPU device, the app lets the device know which shader formats
 * the app can provide. It will then select the appropriate backend depending
 * on the available shader formats and the backends available on the platform.
 * When creating shaders, the app must provide the correct shader format for
 * the selected backend. If you would like to learn more about why the API
 * works this way, there is a detailed
 * [blog post](https://moonside.games/posts/layers-all-the-way-down/)
 * explaining this situation.
 *
 * It is optimal for apps to pre-compile the shader formats they might use,
 * but for ease of use SDL provides a separate project,
 * [SDL_shadercross](https://github.com/libsdl-org/SDL_shadercross)
 * , for performing runtime shader cross-compilation.
 *
 * This is an extremely quick overview that leaves out several important
 * details. Already, though, one can see that GPU programming can be quite
 * complex! If you just need simple 2D graphics, the
 * [Render API](https://wiki.libsdl.org/SDL3/CategoryRender)
 * is much easier to use but still hardware-accelerated. That said, even for
 * 2D applications the performance benefits and expressiveness of the GPU API
 * are significant.
 *
 * The GPU API targets a feature set with a wide range of hardware support and
 * ease of portability. It is designed so that the app won't have to branch
 * itself by querying feature support. If you need cutting-edge features with
 * limited hardware support, this API is probably not for you.
 *
 * Examples demonstrating proper usage of this API can be found
 * [here](https://github.com/TheSpydog/SDL_gpu_examples)
 * .
 *
 * ## Performance considerations
 *
 * Here are some basic tips for maximizing your rendering performance.
 *
 * - Beginning a new render pass is relatively expensive. Use as few render
 *   passes as you can.
 * - Minimize the amount of state changes. For example, binding a pipeline is
 *   relatively cheap, but doing it hundreds of times when you don't need to
 *   will slow the performance significantly.
 * - Perform your data uploads as early as possible in the frame.
 * - Don't churn resources. Creating and releasing resources is expensive.
 *   It's better to create what you need up front and cache it.
 * - Don't use uniform buffers for large amounts of data (more than a matrix
 *   or so). Use a storage buffer instead.
 * - Use cycling correctly. There is a detailed explanation of cycling further
 *   below.
 * - Use culling techniques to minimize pixel writes. The less writing the GPU
 *   has to do the better. Culling can be a very advanced topic but even
 *   simple culling techniques can boost performance significantly.
 *
 * In general try to remember the golden rule of performance: doing things is
 * more expensive than not doing things. Don't Touch The Driver!
 *
 * ## FAQ
 *
 * **Question: When are you adding more advanced features, like ray tracing or
 * mesh shaders?**
 *
 * Answer: We don't have immediate plans to add more bleeding-edge features,
 * but we certainly might in the future, when these features prove worthwhile,
 * and reasonable to implement across several platforms and underlying APIs.
 * So while these things are not in the "never" category, they are definitely
 * not "near future" items either.
 *
 * **Question: Why is my shader not working?**
 *
 * Answer: A common oversight when using shaders is not properly laying out
 * the shader resources/registers correctly. The GPU API is very strict with
 * how it wants resources to be laid out and it's difficult for the API to
 * automatically validate shaders to see if they have a compatible layout. See
 * the documentation for SDL_CreateGPUShader() and
 * SDL_CreateGPUComputePipeline() for information on the expected layout.
 *
 * Another common issue is not setting the correct number of samplers,
 * textures, and buffers in SDL_GPUShaderCreateInfo. If possible use shader
 * reflection to extract the required information from the shader
 * automatically instead of manually filling in the struct's values.
 *
 * **Question: My application isn't performing very well. Is this the GPU
 * API's fault?**
 *
 * Answer: No. Long answer: The GPU API is a relatively thin layer over the
 * underlying graphics API. While it's possible that we have done something
 * inefficiently, it's very unlikely especially if you are relatively
 * inexperienced with GPU rendering. Please see the performance tips above and
 * make sure you are following them. Additionally, tools like RenderDoc can be
 * very helpful for diagnosing incorrect behavior and performance issues.
 *
 * ## System Requirements
 *
 * **Vulkan:** Supported on Windows, Linux, Nintendo Switch, and certain
 * Android devices. Requires Vulkan 1.0 with the following extensions and
 * device features:
 *
 * - `VK_KHR_swapchain`
 * - `VK_KHR_maintenance1`
 * - `independentBlend`
 * - `imageCubeArray`
 * - `depthClamp`
 * - `shaderClipDistance`
 * - `drawIndirectFirstInstance`
 *
 * **D3D12:** Supported on Windows 10 or newer, Xbox One (GDK), and Xbox
 * Series X|S (GDK). Requires a GPU that supports DirectX 12 Feature Level
 * 11_1.
 *
 * **Metal:** Supported on macOS 10.14+ and iOS/tvOS 13.0+. Hardware
 * requirements vary by operating system:
 *
 * - macOS requires an Apple Silicon or
 *   [Intel Mac2 family](https://developer.apple.com/documentation/metal/mtlfeatureset/mtlfeatureset_macos_gpufamily2_v1?language=objc)
 *   GPU
 * - iOS/tvOS requires an A9 GPU or newer
 * - iOS Simulator and tvOS Simulator are unsupported
 *
 * ## Uniform Data
 *
 * Uniforms are for passing data to shaders. The uniform data will be constant
 * across all executions of the shader.
 *
 * There are 4 available uniform slots per shader stage (where the stages are
 * vertex, fragment, and compute). Uniform data pushed to a slot on a stage
 * keeps its value throughout the command buffer until you call the relevant
 * Push function on that slot again.
 *
 * For example, you could write your vertex shaders to read a camera matrix
 * from uniform binding slot 0, push the camera matrix at the start of the
 * command buffer, and that data will be used for every subsequent draw call.
 *
 * It is valid to push uniform data during a render or compute pass.
 *
 * Uniforms are best for pushing small amounts of data. If you are pushing
 * more than a matrix or two per call you should consider using a storage
 * buffer instead.
 *
 * ## A Note On Cycling
 *
 * When using a command buffer, operations do not occur immediately - they
 * occur some time after the command buffer is submitted.
 *
 * When a resource is used in a pending or active command buffer, it is
 * considered to be "bound". When a resource is no longer used in any pending
 * or active command buffers, it is considered to be "unbound".
 *
 * If data resources are bound, it is unspecified when that data will be
 * unbound unless you acquire a fence when submitting the command buffer and
 * wait on it. However, this doesn't mean you need to track resource usage
 * manually.
 *
 * All of the functions and structs that involve writing to a resource have a
 * "cycle" bool. SDL_GPUTransferBuffer, SDL_GPUBuffer, and SDL_GPUTexture all
 * effectively function as ring buffers on internal resources. When cycle is
 * true, if the resource is bound, the cycle rotates to the next unbound
 * internal resource, or if none are available, a new one is created. This
 * means you don't have to worry about complex state tracking and
 * synchronization as long as cycling is correctly employed.
 *
 * For example: you can call SDL_MapGPUTransferBuffer(), write texture data,
 * SDL_UnmapGPUTransferBuffer(), and then SDL_UploadToGPUTexture(). The next
 * time you write texture data to the transfer buffer, if you set the cycle
 * param to true, you don't have to worry about overwriting any data that is
 * not yet uploaded.
 *
 * Another example: If you are using a texture in a render pass every frame,
 * this can cause a data dependency between frames. If you set cycle to true
 * in the SDL_GPUColorTargetInfo struct, you can prevent this data dependency.
 *
 * Cycling will never undefine already bound data. When cycling, all data in
 * the resource is considered to be undefined for subsequent commands until
 * that data is written again. You must take care not to read undefined data.
 *
 * Note that when cycling a texture, the entire texture will be cycled, even
 * if only part of the texture is used in the call, so you must consider the
 * entire texture to contain undefined data after cycling.
 *
 * You must also take care not to overwrite a section of data that has been
 * referenced in a command without cycling first. It is OK to overwrite
 * unreferenced data in a bound resource without cycling, but overwriting a
 * section of data that has already been referenced will produce unexpected
 * results.
 *)

type
  (**
   * An opaque handle representing the SDL_GPU context.
   *
   * \since This struct is available since SDL 3.2.0.
   *)
  SDL_GPUDevice = THandle;

  (**
   * An opaque handle representing a buffer.
   *
   * Used for vertices, indices, indirect draw commands, and general compute
   * data.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_CreateGPUBuffer
   * \sa SDL_UploadToGPUBuffer
   * \sa SDL_DownloadFromGPUBuffer
   * \sa SDL_CopyGPUBufferToBuffer
   * \sa SDL_BindGPUVertexBuffers
   * \sa SDL_BindGPUIndexBuffer
   * \sa SDL_BindGPUVertexStorageBuffers
   * \sa SDL_BindGPUFragmentStorageBuffers
   * \sa SDL_DrawGPUPrimitivesIndirect
   * \sa SDL_DrawGPUIndexedPrimitivesIndirect
   * \sa SDL_BindGPUComputeStorageBuffers
   * \sa SDL_DispatchGPUComputeIndirect
   * \sa SDL_ReleaseGPUBuffer
   *)
  SDL_GPUBuffer = THandle;
  PSDL_GPUBuffer = ^SDL_GPUBuffer;

  (**
   * An opaque handle representing a transfer buffer.
   *
   * Used for transferring data to and from the device.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_CreateGPUTransferBuffer
   * \sa SDL_MapGPUTransferBuffer
   * \sa SDL_UnmapGPUTransferBuffer
   * \sa SDL_UploadToGPUBuffer
   * \sa SDL_UploadToGPUTexture
   * \sa SDL_DownloadFromGPUBuffer
   * \sa SDL_DownloadFromGPUTexture
   * \sa SDL_ReleaseGPUTransferBuffer
   *)
  SDL_GPUTransferBuffer = THandle;

  (**
   * An opaque handle representing a texture.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_CreateGPUTexture
   * \sa SDL_UploadToGPUTexture
   * \sa SDL_DownloadFromGPUTexture
   * \sa SDL_CopyGPUTextureToTexture
   * \sa SDL_BindGPUVertexSamplers
   * \sa SDL_BindGPUVertexStorageTextures
   * \sa SDL_BindGPUFragmentSamplers
   * \sa SDL_BindGPUFragmentStorageTextures
   * \sa SDL_BindGPUComputeStorageTextures
   * \sa SDL_GenerateMipmapsForGPUTexture
   * \sa SDL_BlitGPUTexture
   * \sa SDL_ReleaseGPUTexture
   *)
  SDL_GPUTexture = THandle;
  PSDL_GPUTexture = ^SDL_GPUTexture;

  (**
   * An opaque handle representing a sampler.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_CreateGPUSampler
   * \sa SDL_BindGPUVertexSamplers
   * \sa SDL_BindGPUFragmentSamplers
   * \sa SDL_ReleaseGPUSampler
   *)
  SDL_GPUSampler = THandle;

  (**
   * An opaque handle representing a compiled shader object.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_CreateGPUShader
   * \sa SDL_CreateGPUGraphicsPipeline
   * \sa SDL_ReleaseGPUShader
   *)
  SDL_GPUShader = THandle;

  (**
   * An opaque handle representing a compute pipeline.
   *
   * Used during compute passes.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_CreateGPUComputePipeline
   * \sa SDL_BindGPUComputePipeline
   * \sa SDL_ReleaseGPUComputePipeline
   *)
  SDL_GPUComputePipeline = THandle;

  (**
   * An opaque handle representing a graphics pipeline.
   *
   * Used during render passes.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_CreateGPUGraphicsPipeline
   * \sa SDL_BindGPUGraphicsPipeline
   * \sa SDL_ReleaseGPUGraphicsPipeline
   *)
  SDL_GPUGraphicsPipeline = THandle;

  (**
   * An opaque handle representing a command buffer.
   *
   * Most state is managed via command buffers. When setting state using a
   * command buffer, that state is local to the command buffer.
   *
   * Commands only begin execution on the GPU once SDL_SubmitGPUCommandBuffer is
   * called. Once the command buffer is submitted, it is no longer valid to use
   * it.
   *
   * Command buffers are executed in submission order. If you submit command
   * buffer A and then command buffer B all commands in A will begin executing
   * before any command in B begins executing.
   *
   * In multi-threading scenarios, you should only access a command buffer on
   * the thread you acquired it from.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_AcquireGPUCommandBuffer
   * \sa SDL_SubmitGPUCommandBuffer
   * \sa SDL_SubmitGPUCommandBufferAndAcquireFence
   *)
  SDL_GPUCommandBuffer = THandle;

  (**
   * An opaque handle representing a render pass.
   *
   * This handle is transient and should not be held or referenced after
   * SDL_EndGPURenderPass is called.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_BeginGPURenderPass
   * \sa SDL_EndGPURenderPass
   *)
  SDL_GPURenderPass = THandle;

  (**
   * An opaque handle representing a compute pass.
   *
   * This handle is transient and should not be held or referenced after
   * SDL_EndGPUComputePass is called.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_BeginGPUComputePass
   * \sa SDL_EndGPUComputePass
   *)
  SDL_GPUComputePass = THandle;

  (**
   * An opaque handle representing a copy pass.
   *
   * This handle is transient and should not be held or referenced after
   * SDL_EndGPUCopyPass is called.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_BeginGPUCopyPass
   * \sa SDL_EndGPUCopyPass
   *)
  SDL_GPUCopyPass = THandle;

  (**
   * An opaque handle representing a fence.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_SubmitGPUCommandBufferAndAcquireFence
   * \sa SDL_QueryGPUFence
   * \sa SDL_WaitForGPUFences
   * \sa SDL_ReleaseGPUFence
   *)
  SDL_GPUFence = THandle;
  PSDL_GPUFence = ^SDL_GPUFence;

(**
 * Specifies the primitive topology of a graphics pipeline.
 *
 * If you are using POINTLIST you must include a point size output in the
 * vertex shader.
 *
 * - For HLSL compiling to SPIRV you must decorate a float output with
 *   [[vk::builtin("PointSize")]].
 * - For GLSL you must set the gl_PointSize builtin.
 * - For MSL you must include a float output with the [[point_size]]
 *   decorator.
 *
 * Note that sized point topology is totally unsupported on D3D12. Any size
 * other than 1 will be ignored. In general, you should avoid using point
 * topology for both compatibility and performance reasons. You WILL regret
 * using it.
 *
 * \since This enum is available since SDL 3.2.0.
 *
 * \sa SDL_CreateGPUGraphicsPipeline
 *)
type
  SDL_GPUPrimitiveType = Integer;

const
  (** A series of separate triangles. *)
  SDL_GPU_PRIMITIVETYPE_TRIANGLELIST = 0;
  (** A series of connected triangles. *)
  SDL_GPU_PRIMITIVETYPE_TRIANGLESTRIP = 1;
  (** A series of separate lines. *)
  SDL_GPU_PRIMITIVETYPE_LINELIST = 2;
  (** A series of connected lines. *)
  SDL_GPU_PRIMITIVETYPE_LINESTRIP = 3;
  (** A series of separate points. *)
  SDL_GPU_PRIMITIVETYPE_POINTLIST = 4;

(**
 * Specifies how the contents of a texture attached to a render pass are
 * treated at the beginning of the render pass.
 *
 * \since This enum is available since SDL 3.2.0.
 *
 * \sa SDL_BeginGPURenderPass
 *)
type
  SDL_GPULoadOp = Integer;

const
  (** The previous contents of the texture will be preserved. *)
  SDL_GPU_LOADOP_LOAD = 0;
  (** The contents of the texture will be cleared to a color. *)
  SDL_GPU_LOADOP_CLEAR = 1;
  (** The previous contents of the texture need not be preserved. The contents will be undefined. *)
  SDL_GPU_LOADOP_DONT_CARE = 2;

(**
 * Specifies how the contents of a texture attached to a render pass are
 * treated at the end of the render pass.
 *
 * \since This enum is available since SDL 3.2.0.
 *
 * \sa SDL_BeginGPURenderPass
 *)
type
  SDL_GPUStoreOp = Integer;

const
  (** The contents generated during the render pass will be written to memory. *)
  SDL_GPU_STOREOP_STORE = 0;
  (** The contents generated during the render pass are not needed and may be discarded. The contents will be undefined. *)
  SDL_GPU_STOREOP_DONT_CARE = 1;
  (** The multisample contents generated during the render pass will be resolved to a non-multisample texture. The contents in the multisample texture may then be discarded and will be undefined. *)
  SDL_GPU_STOREOP_RESOLVE = 2;
  (** The multisample contents generated during the render pass will be resolved to a non-multisample texture. The contents in the multisample texture will be written to memory. *)
  SDL_GPU_STOREOP_RESOLVE_AND_STORE = 3;

(**
 * Specifies the size of elements in an index buffer.
 *
 * \since This enum is available since SDL 3.2.0.
 *
 * \sa SDL_CreateGPUGraphicsPipeline
 *)
type
  SDL_GPUIndexElementSize = Integer;

const
  (** The index elements are 16-bit. *)
  SDL_GPU_INDEXELEMENTSIZE_16BIT = 0;
  (** The index elements are 32-bit. *)
  SDL_GPU_INDEXELEMENTSIZE_32BIT = 1;

(**
 * Specifies the pixel format of a texture.
 *
 * Texture format support varies depending on driver, hardware, and usage
 * flags. In general, you should use SDL_GPUTextureSupportsFormat to query if
 * a format is supported before using it. However, there are a few guaranteed
 * formats.
 *
 * FIXME: Check universal support for 32-bit component formats FIXME: Check
 * universal support for SIMULTANEOUS_READ_WRITE
 *
 * For SAMPLER usage, the following formats are universally supported:
 *
 * - R8G8B8A8_UNORM
 * - B8G8R8A8_UNORM
 * - R8_UNORM
 * - R8_SNORM
 * - R8G8_UNORM
 * - R8G8_SNORM
 * - R8G8B8A8_SNORM
 * - R16_FLOAT
 * - R16G16_FLOAT
 * - R16G16B16A16_FLOAT
 * - R32_FLOAT
 * - R32G32_FLOAT
 * - R32G32B32A32_FLOAT
 * - R11G11B10_UFLOAT
 * - R8G8B8A8_UNORM_SRGB
 * - B8G8R8A8_UNORM_SRGB
 * - D16_UNORM
 *
 * For COLOR_TARGET usage, the following formats are universally supported:
 *
 * - R8G8B8A8_UNORM
 * - B8G8R8A8_UNORM
 * - R8_UNORM
 * - R16_FLOAT
 * - R16G16_FLOAT
 * - R16G16B16A16_FLOAT
 * - R32_FLOAT
 * - R32G32_FLOAT
 * - R32G32B32A32_FLOAT
 * - R8_UINT
 * - R8G8_UINT
 * - R8G8B8A8_UINT
 * - R16_UINT
 * - R16G16_UINT
 * - R16G16B16A16_UINT
 * - R8_INT
 * - R8G8_INT
 * - R8G8B8A8_INT
 * - R16_INT
 * - R16G16_INT
 * - R16G16B16A16_INT
 * - R8G8B8A8_UNORM_SRGB
 * - B8G8R8A8_UNORM_SRGB
 *
 * For STORAGE usages, the following formats are universally supported:
 *
 * - R8G8B8A8_UNORM
 * - R8G8B8A8_SNORM
 * - R16G16B16A16_FLOAT
 * - R32_FLOAT
 * - R32G32_FLOAT
 * - R32G32B32A32_FLOAT
 * - R8G8B8A8_UINT
 * - R16G16B16A16_UINT
 * - R8G8B8A8_INT
 * - R16G16B16A16_INT
 *
 * For DEPTH_STENCIL_TARGET usage, the following formats are universally
 * supported:
 *
 * - D16_UNORM
 * - Either (but not necessarily both!) D24_UNORM or D32_FLOAT
 * - Either (but not necessarily both!) D24_UNORM_S8_UINT or D32_FLOAT_S8_UINT
 *
 * Unless D16_UNORM is sufficient for your purposes, always check which of
 * D24/D32 is supported before creating a depth-stencil texture!
 *
 * \since This enum is available since SDL 3.2.0.
 *
 * \sa SDL_CreateGPUTexture
 * \sa SDL_GPUTextureSupportsFormat
 *)
type
  SDL_GPUTextureFormat = Integer;
  PSDL_GPUTextureFormat = ^SDL_GPUTextureFormat;

const
  SDL_GPU_TEXTUREFORMAT_INVALID = 0;

  // Unsigned Normalized Float Color Formats
  SDL_GPU_TEXTUREFORMAT_A8_UNORM = 1;
  SDL_GPU_TEXTUREFORMAT_R8_UNORM = 2;
  SDL_GPU_TEXTUREFORMAT_R8G8_UNORM = 3;
  SDL_GPU_TEXTUREFORMAT_R8G8B8A8_UNORM = 4;
  SDL_GPU_TEXTUREFORMAT_R16_UNORM = 5;
  SDL_GPU_TEXTUREFORMAT_R16G16_UNORM = 6;
  SDL_GPU_TEXTUREFORMAT_R16G16B16A16_UNORM = 7;
  SDL_GPU_TEXTUREFORMAT_R10G10B10A2_UNORM = 8;
  SDL_GPU_TEXTUREFORMAT_B5G6R5_UNORM = 9;
  SDL_GPU_TEXTUREFORMAT_B5G5R5A1_UNORM = 10;
  SDL_GPU_TEXTUREFORMAT_B4G4R4A4_UNORM = 11;
  SDL_GPU_TEXTUREFORMAT_B8G8R8A8_UNORM = 12;

  // Compressed Unsigned Normalized Float Color Formats
  SDL_GPU_TEXTUREFORMAT_BC1_RGBA_UNORM = 13;
  SDL_GPU_TEXTUREFORMAT_BC2_RGBA_UNORM = 14;
  SDL_GPU_TEXTUREFORMAT_BC3_RGBA_UNORM = 15;
  SDL_GPU_TEXTUREFORMAT_BC4_R_UNORM = 16;
  SDL_GPU_TEXTUREFORMAT_BC5_RG_UNORM = 17;
  SDL_GPU_TEXTUREFORMAT_BC7_RGBA_UNORM = 18;

  // Compressed Signed Float Color Formats
  SDL_GPU_TEXTUREFORMAT_BC6H_RGB_FLOAT = 19;

  // Compressed Unsigned Float Color Formats
  SDL_GPU_TEXTUREFORMAT_BC6H_RGB_UFLOAT = 20;

  // Signed Normalized Float Color Formats
  SDL_GPU_TEXTUREFORMAT_R8_SNORM = 21;
  SDL_GPU_TEXTUREFORMAT_R8G8_SNORM = 22;
  SDL_GPU_TEXTUREFORMAT_R8G8B8A8_SNORM = 23;
  SDL_GPU_TEXTUREFORMAT_R16_SNORM = 24;
  SDL_GPU_TEXTUREFORMAT_R16G16_SNORM = 25;
  SDL_GPU_TEXTUREFORMAT_R16G16B16A16_SNORM = 26;

  // Signed Float Color Formats
  SDL_GPU_TEXTUREFORMAT_R16_FLOAT = 27;
  SDL_GPU_TEXTUREFORMAT_R16G16_FLOAT = 28;
  SDL_GPU_TEXTUREFORMAT_R16G16B16A16_FLOAT = 29;
  SDL_GPU_TEXTUREFORMAT_R32_FLOAT = 30;
  SDL_GPU_TEXTUREFORMAT_R32G32_FLOAT = 31;
  SDL_GPU_TEXTUREFORMAT_R32G32B32A32_FLOAT = 32;

  // Unsigned Float Color Formats
  SDL_GPU_TEXTUREFORMAT_R11G11B10_UFLOAT = 33;

  // Unsigned Integer Color Formats
  SDL_GPU_TEXTUREFORMAT_R8_UINT = 34;
  SDL_GPU_TEXTUREFORMAT_R8G8_UINT = 35;
  SDL_GPU_TEXTUREFORMAT_R8G8B8A8_UINT = 36;
  SDL_GPU_TEXTUREFORMAT_R16_UINT = 37;
  SDL_GPU_TEXTUREFORMAT_R16G16_UINT = 38;
  SDL_GPU_TEXTUREFORMAT_R16G16B16A16_UINT = 39;
  SDL_GPU_TEXTUREFORMAT_R32_UINT = 40;
  SDL_GPU_TEXTUREFORMAT_R32G32_UINT = 41;
  SDL_GPU_TEXTUREFORMAT_R32G32B32A32_UINT = 42;

  // Signed Integer Color Formats
  SDL_GPU_TEXTUREFORMAT_R8_INT = 43;
  SDL_GPU_TEXTUREFORMAT_R8G8_INT = 44;
  SDL_GPU_TEXTUREFORMAT_R8G8B8A8_INT = 45;
  SDL_GPU_TEXTUREFORMAT_R16_INT = 46;
  SDL_GPU_TEXTUREFORMAT_R16G16_INT = 47;
  SDL_GPU_TEXTUREFORMAT_R16G16B16A16_INT = 48;
  SDL_GPU_TEXTUREFORMAT_R32_INT = 49;
  SDL_GPU_TEXTUREFORMAT_R32G32_INT = 50;
  SDL_GPU_TEXTUREFORMAT_R32G32B32A32_INT = 51;

  // SRGB Unsigned Normalized Color Formats
  SDL_GPU_TEXTUREFORMAT_R8G8B8A8_UNORM_SRGB = 52;
  SDL_GPU_TEXTUREFORMAT_B8G8R8A8_UNORM_SRGB = 53;

  // Compressed SRGB Unsigned Normalized Color Formats
  SDL_GPU_TEXTUREFORMAT_BC1_RGBA_UNORM_SRGB = 54;
  SDL_GPU_TEXTUREFORMAT_BC2_RGBA_UNORM_SRGB = 55;
  SDL_GPU_TEXTUREFORMAT_BC3_RGBA_UNORM_SRGB = 56;
  SDL_GPU_TEXTUREFORMAT_BC7_RGBA_UNORM_SRGB = 57;

  // Depth Formats
  SDL_GPU_TEXTUREFORMAT_D16_UNORM = 58;
  SDL_GPU_TEXTUREFORMAT_D24_UNORM = 59;
  SDL_GPU_TEXTUREFORMAT_D32_FLOAT = 60;
  SDL_GPU_TEXTUREFORMAT_D24_UNORM_S8_UINT = 61;
  SDL_GPU_TEXTUREFORMAT_D32_FLOAT_S8_UINT = 62;

  // Compressed ASTC Normalized Float Color Formats
  SDL_GPU_TEXTUREFORMAT_ASTC_4x4_UNORM = 63;
  SDL_GPU_TEXTUREFORMAT_ASTC_5x4_UNORM = 64;
  SDL_GPU_TEXTUREFORMAT_ASTC_5x5_UNORM = 65;
  SDL_GPU_TEXTUREFORMAT_ASTC_6x5_UNORM = 66;
  SDL_GPU_TEXTUREFORMAT_ASTC_6x6_UNORM = 67;
  SDL_GPU_TEXTUREFORMAT_ASTC_8x5_UNORM = 68;
  SDL_GPU_TEXTUREFORMAT_ASTC_8x6_UNORM = 69;
  SDL_GPU_TEXTUREFORMAT_ASTC_8x8_UNORM = 70;
  SDL_GPU_TEXTUREFORMAT_ASTC_10x5_UNORM = 71;
  SDL_GPU_TEXTUREFORMAT_ASTC_10x6_UNORM = 72;
  SDL_GPU_TEXTUREFORMAT_ASTC_10x8_UNORM = 73;
  SDL_GPU_TEXTUREFORMAT_ASTC_10x10_UNORM = 74;
  SDL_GPU_TEXTUREFORMAT_ASTC_12x10_UNORM = 75;
  SDL_GPU_TEXTUREFORMAT_ASTC_12x12_UNORM = 76;

  // Compressed SRGB ASTC Normalized Float Color Formats
  SDL_GPU_TEXTUREFORMAT_ASTC_4x4_UNORM_SRGB = 77;
  SDL_GPU_TEXTUREFORMAT_ASTC_5x4_UNORM_SRGB = 78;
  SDL_GPU_TEXTUREFORMAT_ASTC_5x5_UNORM_SRGB = 79;
  SDL_GPU_TEXTUREFORMAT_ASTC_6x5_UNORM_SRGB = 80;
  SDL_GPU_TEXTUREFORMAT_ASTC_6x6_UNORM_SRGB = 81;
  SDL_GPU_TEXTUREFORMAT_ASTC_8x5_UNORM_SRGB = 82;
  SDL_GPU_TEXTUREFORMAT_ASTC_8x6_UNORM_SRGB = 83;
  SDL_GPU_TEXTUREFORMAT_ASTC_8x8_UNORM_SRGB = 84;
  SDL_GPU_TEXTUREFORMAT_ASTC_10x5_UNORM_SRGB = 85;
  SDL_GPU_TEXTUREFORMAT_ASTC_10x6_UNORM_SRGB = 86;
  SDL_GPU_TEXTUREFORMAT_ASTC_10x8_UNORM_SRGB = 87;
  SDL_GPU_TEXTUREFORMAT_ASTC_10x10_UNORM_SRGB = 88;
  SDL_GPU_TEXTUREFORMAT_ASTC_12x10_UNORM_SRGB = 89;
  SDL_GPU_TEXTUREFORMAT_ASTC_12x12_UNORM_SRGB = 90;

  // Compressed ASTC Signed Float Color Formats
  SDL_GPU_TEXTUREFORMAT_ASTC_4x4_FLOAT = 91;
  SDL_GPU_TEXTUREFORMAT_ASTC_5x4_FLOAT = 92;
  SDL_GPU_TEXTUREFORMAT_ASTC_5x5_FLOAT = 93;
  SDL_GPU_TEXTUREFORMAT_ASTC_6x5_FLOAT = 94;
  SDL_GPU_TEXTUREFORMAT_ASTC_6x6_FLOAT = 95;
  SDL_GPU_TEXTUREFORMAT_ASTC_8x5_FLOAT = 96;
  SDL_GPU_TEXTUREFORMAT_ASTC_8x6_FLOAT = 97;
  SDL_GPU_TEXTUREFORMAT_ASTC_8x8_FLOAT = 98;
  SDL_GPU_TEXTUREFORMAT_ASTC_10x5_FLOAT = 99;
  SDL_GPU_TEXTUREFORMAT_ASTC_10x6_FLOAT = 100;
  SDL_GPU_TEXTUREFORMAT_ASTC_10x8_FLOAT = 101;
  SDL_GPU_TEXTUREFORMAT_ASTC_10x10_FLOAT = 102;
  SDL_GPU_TEXTUREFORMAT_ASTC_12x10_FLOAT = 103;
  SDL_GPU_TEXTUREFORMAT_ASTC_12x12_FLOAT = 104;

type
  (**
   * Specifies how a texture is intended to be used by the client.
   *
   * A texture must have at least one usage flag. Note that some usage flag
   * combinations are invalid.
   *
   * With regards to compute storage usage, READ | WRITE means that you can have
   * shader A that only writes into the texture and shader B that only reads
   * from the texture and bind the same texture to either shader respectively.
   * SIMULTANEOUS means that you can do reads and writes within the same shader
   * or compute pass. It also implies that atomic ops can be used, since those
   * are read-modify-write operations. If you use SIMULTANEOUS, you are
   * responsible for avoiding data races, as there is no data synchronization
   * within a compute pass. Note that SIMULTANEOUS usage is only supported by a
   * limited number of texture formats.
   *
   * \since This datatype is available since SDL 3.2.0.
   *
   * \sa SDL_CreateGPUTexture
   *)
  SDL_GPUTextureUsageFlags = Uint32;

const
  // Texture supports sampling.
  SDL_GPU_TEXTUREUSAGE_SAMPLER = (1 shl 0);

  // Texture is a color render target.
  SDL_GPU_TEXTUREUSAGE_COLOR_TARGET = (1 shl 1);

  // Texture is a depth stencil target.
  SDL_GPU_TEXTUREUSAGE_DEPTH_STENCIL_TARGET = (1 shl 2);

  // Texture supports storage reads in graphics stages.
  SDL_GPU_TEXTUREUSAGE_GRAPHICS_STORAGE_READ = (1 shl 3);

  // Texture supports storage reads in the compute stage.
  SDL_GPU_TEXTUREUSAGE_COMPUTE_STORAGE_READ = (1 shl 4);

  // Texture supports storage writes in the compute stage.
  SDL_GPU_TEXTUREUSAGE_COMPUTE_STORAGE_WRITE = (1 shl 5);

  // Texture supports reads and writes in the same compute shader.
  // This is NOT equivalent to READ or WRITE.
  SDL_GPU_TEXTUREUSAGE_COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE = (1 shl 6);

(**
 * Specifies the type of a texture.
 *
 * \since This enum is available since SDL 3.2.0.
 *
 * \sa SDL_CreateGPUTexture
 *)
type
  SDL_GPUTextureType = Integer;

const
  (** The texture is a 2-dimensional image. *)
  SDL_GPU_TEXTURETYPE_2D = 0;
  (** The texture is a 2-dimensional array image. *)
  SDL_GPU_TEXTURETYPE_2D_ARRAY = 1;
  (** The texture is a 3-dimensional image. *)
  SDL_GPU_TEXTURETYPE_3D = 2;
  (** The texture is a cube image. *)
  SDL_GPU_TEXTURETYPE_CUBE = 3;
  (** The texture is a cube array image. *)
  SDL_GPU_TEXTURETYPE_CUBE_ARRAY = 4;

(**
 * Specifies the sample count of a texture.
 *
 * Used in multisampling. Note that this value only applies when the texture
 * is used as a render target.
 *
 * \since This enum is available since SDL 3.2.0.
 *
 * \sa SDL_CreateGPUTexture
 * \sa SDL_GPUTextureSupportsSampleCount
 *)
type
  SDL_GPUSampleCount = Integer;

const
  (** No multisampling. *)
  SDL_GPU_SAMPLECOUNT_1 = 0;
  (** MSAA 2x *)
  SDL_GPU_SAMPLECOUNT_2 = 1;
  (** MSAA 4x *)
  SDL_GPU_SAMPLECOUNT_4 = 2;
  (** MSAA 8x *)
  SDL_GPU_SAMPLECOUNT_8 = 3;

(**
 * Specifies the face of a cube map.
 *
 * Can be passed in as the layer field in texture-related structs.
 *
 * \since This enum is available since SDL 3.2.0.
 *)
type
  SDL_GPUCubeMapFace = Integer;

const
  SDL_GPU_CUBEMAPFACE_POSITIVEX = 0;
  SDL_GPU_CUBEMAPFACE_NEGATIVEX = 1;
  SDL_GPU_CUBEMAPFACE_POSITIVEY = 2;
  SDL_GPU_CUBEMAPFACE_NEGATIVEY = 3;
  SDL_GPU_CUBEMAPFACE_POSITIVEZ = 4;
  SDL_GPU_CUBEMAPFACE_NEGATIVEZ = 5;

type
  (**
   * Specifies how a buffer is intended to be used by the client.
   *
   * A buffer must have at least one usage flag. Note that some usage flag
   * combinations are invalid.
   *
   * Unlike textures, READ | WRITE can be used for simultaneous read-write
   * usage. The same data synchronization concerns as textures apply.
   *
   * \since This datatype is available since SDL 3.2.0.
   *
   * \sa SDL_CreateGPUBuffer
   *)
  SDL_GPUBufferUsageFlags = Uint32;

const
  // Buffer is a vertex buffer.
  SDL_GPU_BUFFERUSAGE_VERTEX = (1 shl 0);

  // Buffer is an index buffer.
  SDL_GPU_BUFFERUSAGE_INDEX = (1 shl 1);

  // Buffer is an indirect buffer.
  SDL_GPU_BUFFERUSAGE_INDIRECT = (1 shl 2);

  // Buffer supports storage reads in graphics stages.
  SDL_GPU_BUFFERUSAGE_GRAPHICS_STORAGE_READ = (1 shl 3);

  // Buffer supports storage reads in the compute stage.
  SDL_GPU_BUFFERUSAGE_COMPUTE_STORAGE_READ = (1 shl 4);

  // Buffer supports storage writes in the compute stage.
  SDL_GPU_BUFFERUSAGE_COMPUTE_STORAGE_WRITE = (1 shl 5);

(**
 * Specifies how a transfer buffer is intended to be used by the client.
 *
 * Note that mapping and copying FROM an upload transfer buffer or TO a
 * download transfer buffer is undefined behavior.
 *
 * \since This enum is available since SDL 3.2.0.
 *
 * \sa SDL_CreateGPUTransferBuffer
 *)
type
  SDL_GPUTransferBufferUsage = Integer;

const
  SDL_GPU_TRANSFERBUFFERUSAGE_UPLOAD = 0;
  SDL_GPU_TRANSFERBUFFERUSAGE_DOWNLOAD = 1;

(**
 * Specifies which stage a shader program corresponds to.
 *
 * \since This enum is available since SDL 3.2.0.
 *
 * \sa SDL_CreateGPUShader
 *)
type
  SDL_GPUShaderStage = Integer;

const
  SDL_GPU_SHADERSTAGE_VERTEX = 0;
  SDL_GPU_SHADERSTAGE_FRAGMENT = 1;

type
  (**
   * Specifies the format of shader code.
   *
   * Each format corresponds to a specific backend that accepts it.
   *
   * \since This datatype is available since SDL 3.2.0.
   *
   * \sa SDL_CreateGPUShader
   *)
  SDL_GPUShaderFormat = Uint32;

const
  SDL_GPU_SHADERFORMAT_INVALID = 0;

  // Shaders for NDA'd platforms.
  SDL_GPU_SHADERFORMAT_PRIVATE = (1 shl 0);

  // SPIR-V shaders for Vulkan.
  SDL_GPU_SHADERFORMAT_SPIRV = (1 shl 1);

  // DXBC SM5_1 shaders for D3D12.
  SDL_GPU_SHADERFORMAT_DXBC = (1 shl 2);

  // DXIL SM6_0 shaders for D3D12.
  SDL_GPU_SHADERFORMAT_DXIL = (1 shl 3);

  // MSL shaders for Metal.
  SDL_GPU_SHADERFORMAT_MSL = (1 shl 4);

  // Precompiled metallib shaders for Metal.
  SDL_GPU_SHADERFORMAT_METALLIB = (1 shl 5);

(**
 * Specifies the format of a vertex attribute.
 *
 * \since This enum is available since SDL 3.2.0.
 *
 * \sa SDL_CreateGPUGraphicsPipeline
 *)
type
  SDL_GPUVertexElementFormat = Integer;

const
  SDL_GPU_VERTEXELEMENTFORMAT_INVALID = 0;

  // 32-bit Signed Integers
  SDL_GPU_VERTEXELEMENTFORMAT_INT = 1;
  SDL_GPU_VERTEXELEMENTFORMAT_INT2 = 2;
  SDL_GPU_VERTEXELEMENTFORMAT_INT3 = 3;
  SDL_GPU_VERTEXELEMENTFORMAT_INT4 = 4;

  // 32-bit Unsigned Integers
  SDL_GPU_VERTEXELEMENTFORMAT_UINT = 5;
  SDL_GPU_VERTEXELEMENTFORMAT_UINT2 = 6;
  SDL_GPU_VERTEXELEMENTFORMAT_UINT3 = 7;
  SDL_GPU_VERTEXELEMENTFORMAT_UINT4 = 8;

  // 32-bit Floats
  SDL_GPU_VERTEXELEMENTFORMAT_FLOAT = 9;
  SDL_GPU_VERTEXELEMENTFORMAT_FLOAT2 = 10;
  SDL_GPU_VERTEXELEMENTFORMAT_FLOAT3 = 11;
  SDL_GPU_VERTEXELEMENTFORMAT_FLOAT4 = 12;

  // 8-bit Signed Integers
  SDL_GPU_VERTEXELEMENTFORMAT_BYTE2 = 13;
  SDL_GPU_VERTEXELEMENTFORMAT_BYTE4 = 14;

  // 8-bit Unsigned Integers
  SDL_GPU_VERTEXELEMENTFORMAT_UBYTE2 = 15;
  SDL_GPU_VERTEXELEMENTFORMAT_UBYTE4 = 16;

  // 8-bit Signed Normalized
  SDL_GPU_VERTEXELEMENTFORMAT_BYTE2_NORM = 17;
  SDL_GPU_VERTEXELEMENTFORMAT_BYTE4_NORM = 18;

  // 8-bit Unsigned Normalized
  SDL_GPU_VERTEXELEMENTFORMAT_UBYTE2_NORM = 19;
  SDL_GPU_VERTEXELEMENTFORMAT_UBYTE4_NORM = 20;

  // 16-bit Signed Integers
  SDL_GPU_VERTEXELEMENTFORMAT_SHORT2 = 21;
  SDL_GPU_VERTEXELEMENTFORMAT_SHORT4 = 22;

  // 16-bit Unsigned Integers
  SDL_GPU_VERTEXELEMENTFORMAT_USHORT2 = 23;
  SDL_GPU_VERTEXELEMENTFORMAT_USHORT4 = 24;

  // 16-bit Signed Normalized
  SDL_GPU_VERTEXELEMENTFORMAT_SHORT2_NORM = 25;
  SDL_GPU_VERTEXELEMENTFORMAT_SHORT4_NORM = 26;

  // 16-bit Unsigned Normalized
  SDL_GPU_VERTEXELEMENTFORMAT_USHORT2_NORM = 27;
  SDL_GPU_VERTEXELEMENTFORMAT_USHORT4_NORM = 28;

  // 16-bit Floats
  SDL_GPU_VERTEXELEMENTFORMAT_HALF2 = 29;
  SDL_GPU_VERTEXELEMENTFORMAT_HALF4 = 30;

(**
 * Specifies the rate at which vertex attributes are pulled from buffers.
 *
 * \since This enum is available since SDL 3.2.0.
 *
 * \sa SDL_CreateGPUGraphicsPipeline
 *)
type
  SDL_GPUVertexInputRate = Integer;

const
  (** Attribute addressing is a function of the vertex index. *)
  SDL_GPU_VERTEXINPUTRATE_VERTEX = 0;
  (** Attribute addressing is a function of the instance index. *)
  SDL_GPU_VERTEXINPUTRATE_INSTANCE = 1;

(**
 * Specifies the fill mode of the graphics pipeline.
 *
 * \since This enum is available since SDL 3.2.0.
 *
 * \sa SDL_CreateGPUGraphicsPipeline
 *)
type
  SDL_GPUFillMode = Integer;

const
  (** Polygons will be rendered via rasterization. *)
  SDL_GPU_FILLMODE_FILL = 0;
  (** Polygon edges will be drawn as line segments. *)
  SDL_GPU_FILLMODE_LINE = 1;

(**
 * Specifies the facing direction in which triangle faces will be culled.
 *
 * \since This enum is available since SDL 3.2.0.
 *
 * \sa SDL_CreateGPUGraphicsPipeline
 *)
type
  SDL_GPUCullMode = Integer;

const
  (** No triangles are culled. *)
  SDL_GPU_CULLMODE_NONE = 0;
  (** Front-facing triangles are culled. *)
  SDL_GPU_CULLMODE_FRONT = 1;
  (** Back-facing triangles are culled. *)
  SDL_GPU_CULLMODE_BACK = 2;

(**
 * Specifies the vertex winding that will cause a triangle to be determined to
 * be front-facing.
 *
 * \since This enum is available since SDL 3.2.0.
 *
 * \sa SDL_CreateGPUGraphicsPipeline
 *)
type
  SDL_GPUFrontFace = Integer;

const
  (** A triangle with counter-clockwise vertex winding will be considered front-facing. *)
  SDL_GPU_FRONTFACE_COUNTER_CLOCKWISE = 0;
  (** A triangle with clockwise vertex winding will be considered front-facing. *)
  SDL_GPU_FRONTFACE_CLOCKWISE = 1;

(**
 * Specifies a comparison operator for depth, stencil and sampler operations.
 *
 * \since This enum is available since SDL 3.2.0.
 *
 * \sa SDL_CreateGPUGraphicsPipeline
 *)
type
  SDL_GPUCompareOp = Integer;

const
  SDL_GPU_COMPAREOP_INVALID = 0;
  (** The comparison always evaluates false. *)
  SDL_GPU_COMPAREOP_NEVER = 1;
  (** The comparison evaluates reference < test. *)
  SDL_GPU_COMPAREOP_LESS = 2;
  (** The comparison evaluates reference == test. *)
  SDL_GPU_COMPAREOP_EQUAL = 3;
  (** The comparison evaluates reference <= test. *)
  SDL_GPU_COMPAREOP_LESS_OR_EQUAL = 4;
  (** The comparison evaluates reference > test. *)
  SDL_GPU_COMPAREOP_GREATER = 5;
  (** The comparison evaluates reference != test. *)
  SDL_GPU_COMPAREOP_NOT_EQUAL = 6;
  (** The comparison evalutes reference >= test. *)
  SDL_GPU_COMPAREOP_GREATER_OR_EQUAL = 7;
  (** The comparison always evaluates true. *)
  SDL_GPU_COMPAREOP_ALWAYS = 8;

(**
 * Specifies what happens to a stored stencil value if stencil tests fail or
 * pass.
 *
 * \since This enum is available since SDL 3.2.0.
 *
 * \sa SDL_CreateGPUGraphicsPipeline
 *)
type
  SDL_GPUStencilOp = Integer;

const
  SDL_GPU_STENCILOP_INVALID = 0;
  (** Keeps the current value. *)
  SDL_GPU_STENCILOP_KEEP = 1;
  (** Sets the value to 0. *)
  SDL_GPU_STENCILOP_ZERO = 2;
  (** Sets the value to reference. *)
  SDL_GPU_STENCILOP_REPLACE = 3;
  (** Increments the current value and clamps to the maximum value. *)
  SDL_GPU_STENCILOP_INCREMENT_AND_CLAMP = 4;
  (** Decrements the current value and clamps to 0. *)
  SDL_GPU_STENCILOP_DECREMENT_AND_CLAMP = 5;
  (** Bitwise-inverts the current value. *)
  SDL_GPU_STENCILOP_INVERT = 6;
  (** Increments the current value and wraps back to 0. *)
  SDL_GPU_STENCILOP_INCREMENT_AND_WRAP = 7;
  (** Decrements the current value and wraps to the maximum value. *)
  SDL_GPU_STENCILOP_DECREMENT_AND_WRAP = 8;

(**
 * Specifies the operator to be used when pixels in a render target are
 * blended with existing pixels in the texture.
 *
 * The source color is the value written by the fragment shader. The
 * destination color is the value currently existing in the texture.
 *
 * \since This enum is available since SDL 3.2.0.
 *
 * \sa SDL_CreateGPUGraphicsPipeline
 *)
type
  SDL_GPUBlendOp = Integer;

const
  SDL_GPU_BLENDOP_INVALID = 0;
  (** (source * source_factor) + (destination * destination_factor) *)
  SDL_GPU_BLENDOP_ADD = 1;
  (** (source * source_factor) - (destination * destination_factor) *)
  SDL_GPU_BLENDOP_SUBTRACT = 2;
  (** (destination * destination_factor) - (source * source_factor) *)
  SDL_GPU_BLENDOP_REVERSE_SUBTRACT = 3;
  (** min(source, destination) *)
  SDL_GPU_BLENDOP_MIN = 4;
  (** max(source, destination) *)
  SDL_GPU_BLENDOP_MAX = 5;

(**
 * Specifies a blending factor to be used when pixels in a render target are
 * blended with existing pixels in the texture.
 *
 * The source color is the value written by the fragment shader. The
 * destination color is the value currently existing in the texture.
 *
 * \since This enum is available since SDL 3.2.0.
 *
 * \sa SDL_CreateGPUGraphicsPipeline
 *)
type
  SDL_GPUBlendFactor = Integer;

const
  SDL_GPU_BLENDFACTOR_INVALID = 0;
  (** 0 *)
  SDL_GPU_BLENDFACTOR_ZERO = 1;
  (** 1 *)
  SDL_GPU_BLENDFACTOR_ONE = 2;
  (** source color *)
  SDL_GPU_BLENDFACTOR_SRC_COLOR = 3;
  (** 1 - source color *)
  SDL_GPU_BLENDFACTOR_ONE_MINUS_SRC_COLOR = 4;
  (** destination color *)
  SDL_GPU_BLENDFACTOR_DST_COLOR = 5;
  (** 1 - destination color *)
  SDL_GPU_BLENDFACTOR_ONE_MINUS_DST_COLOR = 6;
  (** source alpha *)
  SDL_GPU_BLENDFACTOR_SRC_ALPHA = 7;
  (** 1 - source alpha *)
  SDL_GPU_BLENDFACTOR_ONE_MINUS_SRC_ALPHA = 8;
  (** destination alpha *)
  SDL_GPU_BLENDFACTOR_DST_ALPHA = 9;
  (** 1 - destination alpha *)
  SDL_GPU_BLENDFACTOR_ONE_MINUS_DST_ALPHA = 10;
  (** blend constant *)
  SDL_GPU_BLENDFACTOR_CONSTANT_COLOR = 11;
  (** 1 - blend constant *)
  SDL_GPU_BLENDFACTOR_ONE_MINUS_CONSTANT_COLOR = 12;
  (** min(source alpha, 1 - destination alpha) *)
  SDL_GPU_BLENDFACTOR_SRC_ALPHA_SATURATE = 13;

type
  (**
   * Specifies which color components are written in a graphics pipeline.
   *
   * \since This datatype is available since SDL 3.2.0.
   *
   * \sa SDL_CreateGPUGraphicsPipeline
   *)
  SDL_GPUColorComponentFlags = Uint8;

const
  SDL_GPU_COLORCOMPONENT_R = (1 shl 0); // the red component
  SDL_GPU_COLORCOMPONENT_G = (1 shl 1); // the green component
  SDL_GPU_COLORCOMPONENT_B = (1 shl 2); // the blue component
  SDL_GPU_COLORCOMPONENT_A = (1 shl 3); // the alpha component

(**
 * Specifies a filter operation used by a sampler.
 *
 * \since This enum is available since SDL 3.2.0.
 *
 * \sa SDL_CreateGPUSampler
 *)
type
  SDL_GPUFilter = Integer;

const
  (** Point filtering. *)
  SDL_GPU_FILTER_NEAREST = 0;
  (** Linear filtering. *)
  SDL_GPU_FILTER_LINEAR = 1;

(**
 * Specifies a mipmap mode used by a sampler.
 *
 * \since This enum is available since SDL 3.2.0.
 *
 * \sa SDL_CreateGPUSampler
 *)
type
  SDL_GPUSamplerMipmapMode = Integer;

const
  (** Point filtering. *)
  SDL_GPU_SAMPLERMIPMAPMODE_NEAREST = 0;
  (** Linear filtering. *)
  SDL_GPU_SAMPLERMIPMAPMODE_LINEAR = 1;

(**
 * Specifies behavior of texture sampling when the coordinates exceed the 0-1
 * range.
 *
 * \since This enum is available since SDL 3.2.0.
 *
 * \sa SDL_CreateGPUSampler
 *)
type
  SDL_GPUSamplerAddressMode = Integer;

const
  (** Specifies that the coordinates will wrap around. *)
  SDL_GPU_SAMPLERADDRESSMODE_REPEAT = 0;
  (** Specifies that the coordinates will wrap around mirrored. *)
  SDL_GPU_SAMPLERADDRESSMODE_MIRRORED_REPEAT = 1;
  (** Specifies that the coordinates will clamp to the 0-1 range. *)
  SDL_GPU_SAMPLERADDRESSMODE_CLAMP_TO_EDGE = 2;

(**
 * Specifies the timing that will be used to present swapchain textures to the
 * OS.
 *
 * VSYNC mode will always be supported. IMMEDIATE and MAILBOX modes may not be
 * supported on certain systems.
 *
 * It is recommended to query SDL_WindowSupportsGPUPresentMode after claiming
 * the window if you wish to change the present mode to IMMEDIATE or MAILBOX.
 *
 * - VSYNC: Waits for vblank before presenting. No tearing is possible. If
 *   there is a pending image to present, the new image is enqueued for
 *   presentation. Disallows tearing at the cost of visual latency.
 * - IMMEDIATE: Immediately presents. Lowest latency option, but tearing may
 *   occur.
 * - MAILBOX: Waits for vblank before presenting. No tearing is possible. If
 *   there is a pending image to present, the pending image is replaced by the
 *   new image. Similar to VSYNC, but with reduced visual latency.
 *
 * \since This enum is available since SDL 3.2.0.
 *
 * \sa SDL_SetGPUSwapchainParameters
 * \sa SDL_WindowSupportsGPUPresentMode
 * \sa SDL_WaitAndAcquireGPUSwapchainTexture
 *)
type
  SDL_GPUPresentMode = Integer;

const
  SDL_GPU_PRESENTMODE_VSYNC = 0;
  SDL_GPU_PRESENTMODE_IMMEDIATE = 1;
  SDL_GPU_PRESENTMODE_MAILBOX = 2;

(**
 * Specifies the texture format and colorspace of the swapchain textures.
 *
 * SDR will always be supported. Other compositions may not be supported on
 * certain systems.
 *
 * It is recommended to query SDL_WindowSupportsGPUSwapchainComposition after
 * claiming the window if you wish to change the swapchain composition from
 * SDR.
 *
 * - SDR: B8G8R8A8 or R8G8B8A8 swapchain. Pixel values are in sRGB encoding.
 * - SDR_LINEAR: B8G8R8A8_SRGB or R8G8B8A8_SRGB swapchain. Pixel values are
 *   stored in memory in sRGB encoding but accessed in shaders in "linear
 *   sRGB" encoding which is sRGB but with a linear transfer function.
 * - HDR_EXTENDED_LINEAR: R16G16B16A16_FLOAT swapchain. Pixel values are in
 *   extended linear sRGB encoding and permits values outside of the [0, 1]
 *   range.
 * - HDR10_ST2084: A2R10G10B10 or A2B10G10R10 swapchain. Pixel values are in
 *   BT.2020 ST2084 (PQ) encoding.
 *
 * \since This enum is available since SDL 3.2.0.
 *
 * \sa SDL_SetGPUSwapchainParameters
 * \sa SDL_WindowSupportsGPUSwapchainComposition
 * \sa SDL_WaitAndAcquireGPUSwapchainTexture
 *)
type
  SDL_GPUSwapchainComposition = Integer;

const
  SDL_GPU_SWAPCHAINCOMPOSITION_SDR = 0;
  SDL_GPU_SWAPCHAINCOMPOSITION_SDR_LINEAR = 1;
  SDL_GPU_SWAPCHAINCOMPOSITION_HDR_EXTENDED_LINEAR = 2;
  SDL_GPU_SWAPCHAINCOMPOSITION_HDR10_ST2084 = 3;

type
  (**
   * A structure specifying a viewport.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_SetGPUViewport
   *)
  SDL_GPUViewport = record
    (** The left offset of the viewport. *)
    x: Single;
    (** The top offset of the viewport. *)
    y: Single;
    (** The width of the viewport. *)
    w: Single;
    (** The height of the viewport. *)
    h: Single;
    (** The minimum depth of the viewport. *)
    min_depth: Single;
    (** The maximum depth of the viewport. *)
    max_depth: Single;
  end;
  PSDL_GPUViewport = ^SDL_GPUViewport;

  (**
   * A structure specifying parameters related to transferring data to or from a
   * texture.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_UploadToGPUTexture
   * \sa SDL_DownloadFromGPUTexture
   *)
  SDL_GPUTextureTransferInfo = record
    (** The transfer buffer used in the transfer operation. *)
    transfer_buffer: SDL_GPUTransferBuffer;
    (** The starting byte of the image data in the transfer buffer. *)
    offset: Int32;
    (** The number of pixels from one row to the next. *)
    pixels_per_row: Int32;
    (** The number of rows from one layer/depth-slice to the next. *)
    rows_per_layer: Int32;
  end;
  PSDL_GPUTextureTransferInfo = ^SDL_GPUTextureTransferInfo;

  (**
   * A structure specifying a location in a transfer buffer.
   *
   * Used when transferring buffer data to or from a transfer buffer.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_UploadToGPUBuffer
   * \sa SDL_DownloadFromGPUBuffer
   *)
  SDL_GPUTransferBufferLocation = record
    (** The transfer buffer used in the transfer operation. *)
    transfer_buffer: SDL_GPUTransferBuffer;
    (** The starting byte of the buffer data in the transfer buffer. *)
    offset: Int32;
  end;
  PSDL_GPUTransferBufferLocation = ^SDL_GPUTransferBufferLocation;

  (**
   * A structure specifying a location in a texture.
   *
   * Used when copying data from one texture to another.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_CopyGPUTextureToTexture
   *)
  SDL_GPUTextureLocation = record
    (** The texture used in the copy operation. *)
    texture: SDL_GPUTexture;
    (** The mip level index of the location. *)
    mip_level: Int32;
    (** The layer index of the location. *)
    layer: Int32;
    (** The left offset of the location. *)
    x: Int32;
    (** The top offset of the location. *)
    y: Int32;
    (** The front offset of the location. *)
    z: Int32;
  end;
  PSDL_GPUTextureLocation = ^SDL_GPUTextureLocation;

  (**
   * A structure specifying a region of a texture.
   *
   * Used when transferring data to or from a texture.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_UploadToGPUTexture
   * \sa SDL_DownloadFromGPUTexture
   *)
  SDL_GPUTextureRegion = record
    (** The texture used in the copy operation. *)
    texture: SDL_GPUTexture;
    (** The mip level index to transfer. *)
    mip_level: Int32;
    (** The layer index to transfer. *)
    layer: Int32;
    (** The left offset of the region. *)
    x: Int32;
    (** The top offset of the region. *)
    y: Int32;
    (** The front offset of the region. *)
    z: Int32;
    (** The width of the region. *)
    w: Int32;
    (** The height of the region. *)
    h: Int32;
    (** The depth of the region. *)
    d: Int32;
  end;
  PSDL_GPUTextureRegion = ^SDL_GPUTextureRegion;

  (**
   * A structure specifying a region of a texture used in the blit operation.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_BlitGPUTexture
   *)
  SDL_GPUBlitRegion = record
    (** The texture. *)
    texture: SDL_GPUTexture;
    (** The mip level index of the region. *)
    mip_level: Int32;
    (** The layer index or depth plane of the region. This value is treated as a layer index on 2D array and cube textures, and as a depth plane on 3D textures. *)
    layer_or_depth_plane: Int32;
    (** The left offset of the region. *)
    x: Int32;
    (** The top offset of the region.  *)
    y: Int32;
    (** The width of the region. *)
    w: Int32;
    (** The height of the region. *)
    h: Int32;
  end;

  (**
   * A structure specifying a location in a buffer.
   *
   * Used when copying data between buffers.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_CopyGPUBufferToBuffer
   *)
  SDL_GPUBufferLocation = record
    (** The buffer. *)
    buffer: SDL_GPUBuffer;
    (** The starting byte within the buffer. *)
    offset: Int32;
  end;
  PSDL_GPUBufferLocation = ^SDL_GPUBufferLocation;

  (**
   * A structure specifying a region of a buffer.
   *
   * Used when transferring data to or from buffers.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_UploadToGPUBuffer
   * \sa SDL_DownloadFromGPUBuffer
   *)
  SDL_GPUBufferRegion = record
    (** The buffer. *)
    buffer: SDL_GPUBuffer;
    (** The starting byte within the buffer. *)
    offset: Int32;
    (** The size in bytes of the region. *)
    size: Int32;
  end;
  PSDL_GPUBufferRegion = ^SDL_GPUBufferRegion;

  (**
   * A structure specifying the parameters of an indirect draw command.
   *
   * Note that the `first_vertex` and `first_instance` parameters are NOT
   * compatible with built-in vertex/instance ID variables in shaders (for
   * example, SV_VertexID); GPU APIs and shader languages do not define these
   * built-in variables consistently, so if your shader depends on them, the
   * only way to keep behavior consistent and portable is to always pass 0 for
   * the correlating parameter in the draw calls.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_DrawGPUPrimitivesIndirect
   *)
  SDL_GPUIndirectDrawCommand = record
    (** The number of vertices to draw. *)
    num_vertices: Uint32;
    (** The number of instances to draw. *)
    num_instances: Uint32;
    (** The index of the first vertex to draw. *)
    first_vertex: Uint32;
    (** The ID of the first instance to draw. *)
    first_instance: Uint32;
  end;

  (**
   * A structure specifying the parameters of an indexed indirect draw command.
   *
   * Note that the `first_vertex` and `first_instance` parameters are NOT
   * compatible with built-in vertex/instance ID variables in shaders (for
   * example, SV_VertexID); GPU APIs and shader languages do not define these
   * built-in variables consistently, so if your shader depends on them, the
   * only way to keep behavior consistent and portable is to always pass 0 for
   * the correlating parameter in the draw calls.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_DrawGPUIndexedPrimitivesIndirect
   *)
  SDL_GPUIndexedIndirectDrawCommand = record
    (** The number of indices to draw per instance. *)
    num_indices: Uint32;
    (** The number of instances to draw. *)
    num_instances: Uint32;
    (** The base index within the index buffer. *)
    first_index: Uint32;
    (** The value added to the vertex index before indexing into the vertex buffer. *)
    vertex_offset: Sint32;
    (** The ID of the first instance to draw. *)
    first_instance: Uint32;
  end;

  (**
   * A structure specifying the parameters of an indexed dispatch command.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_DispatchGPUComputeIndirect
   *)
  SDL_GPUIndirectDispatchCommand = record
    (** The number of local workgroups to dispatch in the X dimension. *)
    groupcount_x: Uint32;
    (** The number of local workgroups to dispatch in the Y dimension. *)
    groupcount_y: Uint32;
    (** The number of local workgroups to dispatch in the Z dimension. *)
    groupcount_z: Uint32;
  end;

  (**
   * A structure specifying the parameters of a sampler.
   *
   * \since This function is available since SDL 3.2.0.
   *
   * \sa SDL_CreateGPUSampler
   *)
  SDL_GPUSamplerCreateInfo = record
    (** The minification filter to apply to lookups. *)
    min_filter: SDL_GPUFilter;
    (** The magnification filter to apply to lookups. *)
    mag_filter: SDL_GPUFilter;
    (** The mipmap filter to apply to lookups. *)
    mipmap_mode: SDL_GPUSamplerMipmapMode;
    (** The addressing mode for U coordinates outside [0, 1). *)
    address_mode_u: SDL_GPUSamplerAddressMode;
    (** The addressing mode for V coordinates outside [0, 1). *)
    address_mode_v: SDL_GPUSamplerAddressMode;
    (** The addressing mode for W coordinates outside [0, 1). *)
    address_mode_w: SDL_GPUSamplerAddressMode;
    (** The bias to be added to mipmap LOD calculation. *)
    mip_lod_bias: Single;
    (** The anisotropy value clamp used by the sampler. If enable_anisotropy is false, this is ignored. *)
    max_anisotropy: Single;
    (** The comparison operator to apply to fetched data before filtering. *)
    compare_op: SDL_GPUCompareOp;
    (** Clamps the minimum of the computed LOD value. *)
    min_lod: Single;
    (** Clamps the maximum of the computed LOD value. *)
    max_lod: Single;
    (** true to enable anisotropic filtering. *)
    enable_anisotropy: Boolean;
    (** true to enable comparison against a reference value during lookups. *)
    enable_compare: Boolean;
    padding1: Uint8;
    padding2: Uint8;
    (** A properties ID for extensions. Should be 0 if no extensions are needed. *)
    props: SDL_PropertiesID;
  end;
  PSDL_GPUSamplerCreateInfo = ^SDL_GPUSamplerCreateInfo;

  (**
   * A structure specifying the parameters of vertex buffers used in a graphics
   * pipeline.
   *
   * When you call SDL_BindGPUVertexBuffers, you specify the binding slots of
   * the vertex buffers. For example if you called SDL_BindGPUVertexBuffers with
   * a first_slot of 2 and num_bindings of 3, the binding slots 2, 3, 4 would be
   * used by the vertex buffers you pass in.
   *
   * Vertex attributes are linked to buffers via the buffer_slot field of
   * SDL_GPUVertexAttribute. For example, if an attribute has a buffer_slot of
   * 0, then that attribute belongs to the vertex buffer bound at slot 0.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_GPUVertexAttribute
   * \sa SDL_GPUVertexInputState
   *)
  SDL_GPUVertexBufferDescription = record
    (** The binding slot of the vertex buffer. *)
    slot: Int32;
    (** The byte pitch between consecutive elements of the vertex buffer. *)
    pitch: Int32;
    (** Whether attribute addressing is a function of the vertex index or instance index. *)
    input_rate: SDL_GPUVertexInputRate;
    (** The number of instances to draw using the same per-instance data before advancing in the instance buffer by one element. Ignored unless input_rate is SDL_GPU_VERTEXINPUTRATE_INSTANCE *)
    instance_step_rate: Int32;
  end;
  PSDL_GPUVertexBufferDescription = ^SDL_GPUVertexBufferDescription;

  (**
   * A structure specifying a vertex attribute.
   *
   * All vertex attribute locations provided to an SDL_GPUVertexInputState must
   * be unique.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_GPUVertexBufferDescription
   * \sa SDL_GPUVertexInputState
   *)
  SDL_GPUVertexAttribute = record
    (** The shader input location index. *)
    location: Int32;
    (** The binding slot of the associated vertex buffer. *)
    buffer_slot: Int32;
    (** The size and type of the attribute data. *)
    format: SDL_GPUVertexElementFormat;
    (** The byte offset of this attribute relative to the start of the vertex element. *)
    offset: Int32;
  end;
  PSDL_GPUVertexAttribute = ^SDL_GPUVertexAttribute;

  (**
   * A structure specifying the parameters of a graphics pipeline vertex input
   * state.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_GPUGraphicsPipelineCreateInfo
   * \sa SDL_GPUVertexBufferDescription
   * \sa SDL_GPUVertexAttribute
   *)
  SDL_GPUVertexInputState = record
    (** A pointer to an array of vertex buffer descriptions. *)
    vertex_buffer_descriptions: PSDL_GPUVertexBufferDescription;
    (** The number of vertex buffer descriptions in the above array. *)
    num_vertex_buffers: Uint32;
    (** A pointer to an array of vertex attribute descriptions. *)
    vertex_attributes: PSDL_GPUVertexAttribute;
    (** The number of vertex attribute descriptions in the above array. *)
    num_vertex_attributes: Uint32;
  end;

  (**
   * A structure specifying the stencil operation state of a graphics pipeline.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_GPUDepthStencilState
   *)
  SDL_GPUStencilOpState = record
    (** The action performed on samples that fail the stencil test. *)
    fail_op: SDL_GPUStencilOp;
    (** The action performed on samples that pass the depth and stencil tests. *)
    pass_op: SDL_GPUStencilOp;
    (** The action performed on samples that pass the stencil test and fail the depth test. *)
    depth_fail_op: SDL_GPUStencilOp;
    (** The comparison operator used in the stencil test. *)
    compare_op: SDL_GPUCompareOp;
  end;

  (**
   * A structure specifying the blend state of a color target.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_GPUColorTargetDescription
   *)
  SDL_GPUColorTargetBlendState = record
    (** The value to be multiplied by the source RGB value. *)
    src_color_blendfactor: SDL_GPUBlendFactor;
    (** The value to be multiplied by the destination RGB value. *)
    dst_color_blendfactor: SDL_GPUBlendFactor;
    (** The blend operation for the RGB components. *)
    color_blend_op: SDL_GPUBlendOp;
    (** The value to be multiplied by the source alpha. *)
    src_alpha_blendfactor: SDL_GPUBlendFactor;
    (** The value to be multiplied by the destination alpha. *)
    dst_alpha_blendfactor: SDL_GPUBlendFactor;
    (** The blend operation for the alpha component. *)
    alpha_blend_op: SDL_GPUBlendOp;
    (** A bitmask specifying which of the RGBA components are enabled for writing. Writes to all channels if enable_color_write_mask is false. *)
    color_write_mask: SDL_GPUColorComponentFlags;
    (** Whether blending is enabled for the color target. *)
    enable_blend: Boolean;
    (** Whether the color write mask is enabled. *)
    enable_color_write_mask: Boolean;
    padding1: Uint8;
    padding2: Uint8;
  end;

  (**
   * A structure specifying code and metadata for creating a shader object.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_CreateGPUShader
   *)
  SDL_GPUShaderCreateInfo = record
    (** The size in bytes of the code pointed to. *)
    code_size: NativeUInt;
    (** A pointer to shader code. *)
    code: PUint8;
    (** A pointer to a null-terminated UTF-8 string specifying the entry point function name for the shader. *)
    entrypoint: PUTF8Char;
    (** The format of the shader code. *)
    format: SDL_GPUShaderFormat;
    (** The stage the shader program corresponds to. *)
    stage: SDL_GPUShaderStage;
    (** The number of samplers defined in the shader. *)
    num_samplers: Int32;
    (** The number of storage textures defined in the shader. *)
    num_storage_textures: Int32;
    (** The number of storage buffers defined in the shader. *)
    num_storage_buffers: Int32;
    (** The number of uniform buffers defined in the shader. *)
    num_uniform_buffers: Int32;
    (** A properties ID for extensions. Should be 0 if no extensions are needed. *)
    props: SDL_PropertiesID;
  end;
  PSDL_GPUShaderCreateInfo = ^SDL_GPUShaderCreateInfo;

  (**
   * A structure specifying the parameters of a texture.
   *
   * Usage flags can be bitwise OR'd together for combinations of usages. Note
   * that certain usage combinations are invalid, for example SAMPLER and
   * GRAPHICS_STORAGE.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_CreateGPUTexture
   * \sa SDL_GPUTextureType
   * \sa SDL_GPUTextureFormat
   * \sa SDL_GPUTextureUsageFlags
   * \sa SDL_GPUSampleCount
   *)
  SDL_GPUTextureCreateInfo = record
    (** The base dimensionality of the texture. *)
    &type: SDL_GPUTextureType;
    (** The pixel format of the texture. *)
    format: SDL_GPUTextureFormat;
    (** How the texture is intended to be used by the client. *)
    usage: SDL_GPUTextureUsageFlags;
    (** The width of the texture. *)
    width: Int32;
    (** The height of the texture. *)
    height: Int32;
    (** The layer count or depth of the texture. This value is treated as a layer count on 2D array textures, and as a depth value on 3D textures. *)
    layer_count_or_depth: Int32;
    (** The number of mip levels in the texture. *)
    num_levels: Int32;
    (** The number of samples per texel. Only applies if the texture is used as a render target. *)
    sample_count: SDL_GPUSampleCount;
    (** A properties ID for extensions. Should be 0 if no extensions are needed. *)
    props: SDL_PropertiesID;
  end;
  PSDL_GPUTextureCreateInfo = ^SDL_GPUTextureCreateInfo;

  (**
   * A structure specifying the parameters of a buffer.
   *
   * Usage flags can be bitwise OR'd together for combinations of usages. Note
   * that certain combinations are invalid, for example VERTEX and INDEX.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_CreateGPUBuffer
   * \sa SDL_GPUBufferUsageFlags
   *)
  SDL_GPUBufferCreateInfo = record
    (** How the buffer is intended to be used by the client. *)
    usage: SDL_GPUBufferUsageFlags;
    (** The size in bytes of the buffer. *)
    size: Int32;
    (** A properties ID for extensions. Should be 0 if no extensions are needed. *)
    props: SDL_PropertiesID;
  end;
  PSDL_GPUBufferCreateInfo = ^SDL_GPUBufferCreateInfo;

  (**
   * A structure specifying the parameters of a transfer buffer.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_CreateGPUTransferBuffer
   *)
  SDL_GPUTransferBufferCreateInfo = record
    (** How the transfer buffer is intended to be used by the client. *)
    usage: SDL_GPUTransferBufferUsage;
    (** The size in bytes of the transfer buffer. *)
    size: Int32;
    (** A properties ID for extensions. Should be 0 if no extensions are needed. *)
    props: SDL_PropertiesID;
  end;
  PSDL_GPUTransferBufferCreateInfo = ^SDL_GPUTransferBufferCreateInfo;

  (**
   * A structure specifying the parameters of the graphics pipeline rasterizer
   * state.
   *
   * NOTE: Some backend APIs (D3D11/12) will enable depth clamping even if
   * enable_depth_clip is true. If you rely on this clamp+clip behavior,
   * consider enabling depth clip and then manually clamping depth in your
   * fragment shaders on Metal and Vulkan.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_GPUGraphicsPipelineCreateInfo
   *)
  SDL_GPURasterizerState = record
    (** Whether polygons will be filled in or drawn as lines. *)
    fill_mode: SDL_GPUFillMode;
    (** The facing direction in which triangles will be culled. *)
    cull_mode: SDL_GPUCullMode;
    (** The vertex winding that will cause a triangle to be determined as front-facing. *)
    front_face: SDL_GPUFrontFace;
    (** A scalar factor controlling the depth value added to each fragment. *)
    depth_bias_constant_factor: Single;
    (** The maximum depth bias of a fragment. *)
    depth_bias_clamp: Single;
    (** A scalar factor applied to a fragment's slope in depth calculations. *)
    depth_bias_slope_factor: Single;
    (** true to bias fragment depth values. *)
    enable_depth_bias: Boolean;
    (** true to enable depth clip, false to enable depth clamp. *)
    enable_depth_clip: Boolean;
    padding1: Uint8;
    padding2: Uint8;
  end;

  (**
   * A structure specifying the parameters of the graphics pipeline multisample
   * state.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_GPUGraphicsPipelineCreateInfo
   *)
  SDL_GPUMultisampleState = record
    (** The number of samples to be used in rasterization. *)
    sample_count: SDL_GPUSampleCount;
    (** Determines which samples get updated in the render targets. Treated as 0xFFFFFFFF if enable_mask is false. *)
    sample_mask: Int32;
    (** Enables sample masking. *)
    enable_mask: Boolean;
    padding1: Uint8;
    padding2: Uint8;
    padding3: Uint8;
  end;

  (**
   * A structure specifying the parameters of the graphics pipeline depth
   * stencil state.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_GPUGraphicsPipelineCreateInfo
   *)
  SDL_GPUDepthStencilState = record
    (** The comparison operator used for depth testing. *)
    compare_op: SDL_GPUCompareOp;
    (** The stencil op state for back-facing triangles. *)
    back_stencil_state: SDL_GPUStencilOpState;
    (** The stencil op state for front-facing triangles. *)
    front_stencil_state: SDL_GPUStencilOpState;
    (** Selects the bits of the stencil values participating in the stencil test. *)
    compare_mask: Uint8;
    (** Selects the bits of the stencil values updated by the stencil test. *)
    write_mask: Uint8;
    (** true enables the depth test. *)
    enable_depth_test: Boolean;
    (** true enables depth writes. Depth writes are always disabled when enable_depth_test is false. *)
    enable_depth_write: Boolean;
    (** true enables the stencil test. *)
    enable_stencil_test: Boolean;
    padding1: Uint8;
    padding2: Uint8;
    padding3: Uint8;
  end;

  (**
   * A structure specifying the parameters of color targets used in a graphics
   * pipeline.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_GPUGraphicsPipelineTargetInfo
   *)
  SDL_GPUColorTargetDescription = record
    (** The pixel format of the texture to be used as a color target. *)
    format: SDL_GPUTextureFormat;
    (** The blend state to be used for the color target. *)
    blend_state: SDL_GPUColorTargetBlendState;
  end;
  PSDL_GPUColorTargetDescription = ^SDL_GPUColorTargetDescription;

  (**
   * A structure specifying the descriptions of render targets used in a
   * graphics pipeline.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_GPUGraphicsPipelineCreateInfo
   *)
  SDL_GPUGraphicsPipelineTargetInfo = record
    (** A pointer to an array of color target descriptions. *)
    color_target_descriptions: PSDL_GPUColorTargetDescription;
    (** The number of color target descriptions in the above array. *)
    num_color_targets: Uint32;
    (** The pixel format of the depth-stencil target. Ignored if has_depth_stencil_target is false. *)
    depth_stencil_format: SDL_GPUTextureFormat;
    (** true specifies that the pipeline uses a depth-stencil target. *)
    has_depth_stencil_target: Boolean;
    padding1: Uint8;
    padding2: Uint8;
    padding3: Uint8;
  end;

  (**
   * A structure specifying the parameters of a graphics pipeline state.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_CreateGPUGraphicsPipeline
   * \sa SDL_GPUVertexInputState
   * \sa SDL_GPUPrimitiveType
   * \sa SDL_GPURasterizerState
   * \sa SDL_GPUMultisampleState
   * \sa SDL_GPUDepthStencilState
   * \sa SDL_GPUGraphicsPipelineTargetInfo
   *)
  SDL_GPUGraphicsPipelineCreateInfo = record
    (** The vertex shader used by the graphics pipeline. *)
    vertex_shader: SDL_GPUShader;
    (** The fragment shader used by the graphics pipeline. *)
    fragment_shader: SDL_GPUShader;
    (** The vertex layout of the graphics pipeline. *)
    vertex_input_state: SDL_GPUVertexInputState;
    (** The primitive topology of the graphics pipeline. *)
    primitive_type: SDL_GPUPrimitiveType;
    (** The rasterizer state of the graphics pipeline. *)
    rasterizer_state: SDL_GPURasterizerState;
    (** The multisample state of the graphics pipeline. *)
    multisample_state: SDL_GPUMultisampleState;
    (** The depth-stencil state of the graphics pipeline. *)
    depth_stencil_state: SDL_GPUDepthStencilState;
    (** Formats and blend modes for the render targets of the graphics pipeline. *)
    target_info: SDL_GPUGraphicsPipelineTargetInfo;
    (** A properties ID for extensions. Should be 0 if no extensions are needed. *)
    props: SDL_PropertiesID;
  end;
  PSDL_GPUGraphicsPipelineCreateInfo = ^SDL_GPUGraphicsPipelineCreateInfo;

  (**
   * A structure specifying the parameters of a compute pipeline state.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_CreateGPUComputePipeline
   *)
  SDL_GPUComputePipelineCreateInfo = record
    (** The size in bytes of the compute shader code pointed to. *)
    code_size: NativeInt;
    (** A pointer to compute shader code. *)
    code: PUint8;
    (** A pointer to a null-terminated UTF-8 string specifying the entry point function name for the shader. *)
    entrypoint: PUTF8Char;
    (** The format of the compute shader code. *)
    format: SDL_GPUShaderFormat;
    (** The number of samplers defined in the shader. *)
    num_samplers: Int32;
    (** The number of readonly storage textures defined in the shader. *)
    num_readonly_storage_textures: Int32;
    (** The number of readonly storage buffers defined in the shader. *)
    num_readonly_storage_buffers: Int32;
    (** The number of read-write storage textures defined in the shader. *)
    num_readwrite_storage_textures: Int32;
    (** The number of read-write storage buffers defined in the shader. *)
    num_readwrite_storage_buffers: Int32;
    (** The number of uniform buffers defined in the shader. *)
    num_uniform_buffers: Int32;
    (** The number of threads in the X dimension. This should match the value in the shader. *)
    threadcount_x: Int32;
    (** The number of threads in the Y dimension. This should match the value in the shader. *)
    threadcount_y: Int32;
    (** The number of threads in the Z dimension. This should match the value in the shader. *)
    threadcount_z: Int32;
    (** A properties ID for extensions. Should be 0 if no extensions are needed. *)
    props: SDL_PropertiesID;
  end;
  PSDL_GPUComputePipelineCreateInfo = ^SDL_GPUComputePipelineCreateInfo;

  (**
   * A structure specifying the parameters of a color target used by a render
   * pass.
   *
   * The load_op field determines what is done with the texture at the beginning
   * of the render pass.
   *
   * - LOAD: Loads the data currently in the texture. Not recommended for
   *   multisample textures as it requires significant memory bandwidth.
   * - CLEAR: Clears the texture to a single color.
   * - DONT_CARE: The driver will do whatever it wants with the texture memory.
   *   This is a good option if you know that every single pixel will be touched
   *   in the render pass.
   *
   * The store_op field determines what is done with the color results of the
   * render pass.
   *
   * - STORE: Stores the results of the render pass in the texture. Not
   *   recommended for multisample textures as it requires significant memory
   *   bandwidth.
   * - DONT_CARE: The driver will do whatever it wants with the texture memory.
   *   This is often a good option for depth/stencil textures.
   * - RESOLVE: Resolves a multisample texture into resolve_texture, which must
   *   have a sample count of 1. Then the driver may discard the multisample
   *   texture memory. This is the most performant method of resolving a
   *   multisample target.
   * - RESOLVE_AND_STORE: Resolves a multisample texture into the
   *   resolve_texture, which must have a sample count of 1. Then the driver
   *   stores the multisample texture's contents. Not recommended as it requires
   *   significant memory bandwidth.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_BeginGPURenderPass
   *)
  SDL_GPUColorTargetInfo = record
    (** The texture that will be used as a color target by a render pass. *)
    texture: SDL_GPUTexture;
    (** The mip level to use as a color target. *)
    mip_level: Int32;
    (** The layer index or depth plane to use as a color target. This value is treated as a layer index on 2D array and cube textures, and as a depth plane on 3D textures. *)
    layer_or_depth_plane: Int32;
    (** The color to clear the color target to at the start of the render pass. Ignored if SDL_GPU_LOADOP_CLEAR is not used. *)
    clear_color: SDL_FColor;
    (** What is done with the contents of the color target at the beginning of the render pass. *)
    load_op: SDL_GPULoadOp;
    (** What is done with the results of the render pass. *)
    store_op: SDL_GPUStoreOp;
    (** The texture that will receive the results of a multisample resolve operation. Ignored if a RESOLVE* store_op is not used. *)
    resolve_texture: SDL_GPUTexture;
    (** The mip level of the resolve texture to use for the resolve operation. Ignored if a RESOLVE* store_op is not used. *)
    resolve_mip_level: Int32;
    (** The layer index of the resolve texture to use for the resolve operation. Ignored if a RESOLVE* store_op is not used. *)
    resolve_layer: Int32;
    (** true cycles the texture if the texture is bound and load_op is not LOAD *)
    cycle: Boolean;
    (** true cycles the resolve texture if the resolve texture is bound. Ignored if a RESOLVE* store_op is not used. *)
    cycle_resolve_texture: Boolean;
    padding1: Uint8;
    padding2: Uint8;
  end;
  PSDL_GPUColorTargetInfo = ^SDL_GPUColorTargetInfo;

  (**
   * A structure specifying the parameters of a depth-stencil target used by a
   * render pass.
   *
   * The load_op field determines what is done with the depth contents of the
   * texture at the beginning of the render pass.
   *
   * - LOAD: Loads the depth values currently in the texture.
   * - CLEAR: Clears the texture to a single depth.
   * - DONT_CARE: The driver will do whatever it wants with the memory. This is
   *   a good option if you know that every single pixel will be touched in the
   *   render pass.
   *
   * The store_op field determines what is done with the depth results of the
   * render pass.
   *
   * - STORE: Stores the depth results in the texture.
   * - DONT_CARE: The driver will do whatever it wants with the depth results.
   *   This is often a good option for depth/stencil textures that don't need to
   *   be reused again.
   *
   * The stencil_load_op field determines what is done with the stencil contents
   * of the texture at the beginning of the render pass.
   *
   * - LOAD: Loads the stencil values currently in the texture.
   * - CLEAR: Clears the stencil values to a single value.
   * - DONT_CARE: The driver will do whatever it wants with the memory. This is
   *   a good option if you know that every single pixel will be touched in the
   *   render pass.
   *
   * The stencil_store_op field determines what is done with the stencil results
   * of the render pass.
   *
   * - STORE: Stores the stencil results in the texture.
   * - DONT_CARE: The driver will do whatever it wants with the stencil results.
   *   This is often a good option for depth/stencil textures that don't need to
   *   be reused again.
   *
   * Note that depth/stencil targets do not support multisample resolves.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_BeginGPURenderPass
   *)
  SDL_GPUDepthStencilTargetInfo = record
    (** The texture that will be used as the depth stencil target by the render pass. *)
    texture: SDL_GPUTexture;
    (** The value to clear the depth component to at the beginning of the render pass. Ignored if SDL_GPU_LOADOP_CLEAR is not used. *)
    clear_depth: Single;
    (** What is done with the depth contents at the beginning of the render pass. *)
    load_op: SDL_GPULoadOp;
    (** What is done with the depth results of the render pass. *)
    store_op: SDL_GPUStoreOp;
    (** What is done with the stencil contents at the beginning of the render pass. *)
    stencil_load_op: SDL_GPULoadOp;
    (** What is done with the stencil results of the render pass. *)
    stencil_store_op: SDL_GPUStoreOp;
    (** true cycles the texture if the texture is bound and any load ops are not LOAD *)
    cycle: Boolean;
    (** The value to clear the stencil component to at the beginning of the render pass. Ignored if SDL_GPU_LOADOP_CLEAR is not used. *)
    clear_stencil: Uint8;
    padding1: Uint8;
    padding2: Uint8;
  end;
  PSDL_GPUDepthStencilTargetInfo = ^SDL_GPUDepthStencilTargetInfo;

  (**
   * A structure containing parameters for a blit command.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_BlitGPUTexture
   *)
  SDL_GPUBlitInfo = record
    (** The source region for the blit. *)
    source: SDL_GPUBlitRegion;
    (** The destination region for the blit. *)
    destination: SDL_GPUBlitRegion;
    (** What is done with the contents of the destination before the blit. *)
    load_op: SDL_GPULoadOp;
    (** The color to clear the destination region to before the blit. Ignored if load_op is not SDL_GPU_LOADOP_CLEAR. *)
    clear_color: SDL_FColor;
    (** The flip mode for the source region. *)
    flip_mode: SDL_FlipMode;
    (** The filter mode used when blitting. *)
    filter: SDL_GPUFilter;
    (** true cycles the destination texture if it is already bound. *)
    cycle: Boolean;
    padding1: Uint8;
    padding2: Uint8;
    padding3: Uint8;
  end;
  PSDL_GPUBlitInfo = ^SDL_GPUBlitInfo;

  (**
   * A structure specifying parameters in a buffer binding call.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_BindGPUVertexBuffers
   * \sa SDL_BindGPUIndexBuffer
   *)
  SDL_GPUBufferBinding = record
    (** The buffer to bind. Must have been created with SDL_GPU_BUFFERUSAGE_VERTEX for SDL_BindGPUVertexBuffers, or SDL_GPU_BUFFERUSAGE_INDEX for SDL_BindGPUIndexBuffer. *)
    buffer: SDL_GPUBuffer;
    (** The starting byte of the data to bind in the buffer. *)
    offset: Int32;
  end;
  PSDL_GPUBufferBinding = ^SDL_GPUBufferBinding;

  (**
   * A structure specifying parameters in a sampler binding call.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_BindGPUVertexSamplers
   * \sa SDL_BindGPUFragmentSamplers
   *)
  SDL_GPUTextureSamplerBinding = record
    (** The texture to bind. Must have been created with SDL_GPU_TEXTUREUSAGE_SAMPLER. *)
    texture: SDL_GPUTexture;
    (** The sampler to bind. *)
    sampler: SDL_GPUSampler;
  end;
  PSDL_GPUTextureSamplerBinding = ^SDL_GPUTextureSamplerBinding;

  (**
   * A structure specifying parameters related to binding buffers in a compute
   * pass.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_BeginGPUComputePass
   *)
  SDL_GPUStorageBufferReadWriteBinding = record
    (** The buffer to bind. Must have been created with SDL_GPU_BUFFERUSAGE_COMPUTE_STORAGE_WRITE. *)
    buffer: SDL_GPUBuffer;
    (** true cycles the buffer if it is already bound. *)
    cycle: Boolean;
    padding1: Uint8;
    padding2: Uint8;
    padding3: Uint8;
  end;
  PSDL_GPUStorageBufferReadWriteBinding = ^SDL_GPUStorageBufferReadWriteBinding;

  (**
   * A structure specifying parameters related to binding textures in a compute
   * pass.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_BeginGPUComputePass
   *)
  SDL_GPUStorageTextureReadWriteBinding = record
    (** The texture to bind. Must have been created with SDL_GPU_TEXTUREUSAGE_COMPUTE_STORAGE_WRITE or SDL_GPU_TEXTUREUSAGE_COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE. *)
    texture: SDL_GPUTexture;
    (** The mip level index to bind. *)
    mip_level: Int32;
    (** The layer index to bind. *)
    layer: Int32;
    (** true cycles the texture if it is already bound. *)
    cycle: Boolean;
    padding1: Uint8;
    padding2: Uint8;
    padding3: Uint8;
  end;
  PSDL_GPUStorageTextureReadWriteBinding = ^SDL_GPUStorageTextureReadWriteBinding;

(**
 * Checks for GPU runtime support.
 *
 * \param format_flags a bitflag indicating which shader formats the app is
 *                     able to provide.
 * \param name the preferred GPU driver, or NULL to let SDL pick the optimal
 *             driver.
 * \returns true if supported, false otherwise.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CreateGPUDevice
 *)
function SDL_GPUSupportsShaderFormats(format_flags: SDL_GPUShaderFormat; const name: PUTF8Char): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GPUSupportsShaderFormats';

(**
 * Checks for GPU runtime support.
 *
 * \param props the properties to use.
 * \returns true if supported, false otherwise.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CreateGPUDeviceWithProperties
 *)
function SDL_GPUSupportsProperties(props: SDL_PropertiesID): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GPUSupportsProperties';

(**
 * Creates a GPU context.
 *
 * \param format_flags a bitflag indicating which shader formats the app is
 *                     able to provide.
 * \param debug_mode enable debug mode properties and validations.
 * \param name the preferred GPU driver, or NULL to let SDL pick the optimal
 *             driver.
 * \returns a GPU context on success or NULL on failure; call SDL_GetError()
 *          for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetGPUShaderFormats
 * \sa SDL_GetGPUDeviceDriver
 * \sa SDL_DestroyGPUDevice
 * \sa SDL_GPUSupportsShaderFormats
 *)
function SDL_CreateGPUDevice(format_flags: SDL_GPUShaderFormat; debug_mode: Boolean; const name: PUTF8Char): SDL_GPUDevice; cdecl;
  external LIB_SDL3 name _PU + 'SDL_CreateGPUDevice';

(**
 * Creates a GPU context.
 *
 * These are the supported properties:
 *
 * - `SDL_PROP_GPU_DEVICE_CREATE_DEBUGMODE_BOOLEAN`: enable debug mode
 *   properties and validations, defaults to true.
 * - `SDL_PROP_GPU_DEVICE_CREATE_PREFERLOWPOWER_BOOLEAN`: enable to prefer
 *   energy efficiency over maximum GPU performance, defaults to false.
 * - `SDL_PROP_GPU_DEVICE_CREATE_NAME_STRING`: the name of the GPU driver to
 *   use, if a specific one is desired.
 *
 * These are the current shader format properties:
 *
 * - `SDL_PROP_GPU_DEVICE_CREATE_SHADERS_PRIVATE_BOOLEAN`: The app is able to
 *   provide shaders for an NDA platform.
 * - `SDL_PROP_GPU_DEVICE_CREATE_SHADERS_SPIRV_BOOLEAN`: The app is able to
 *   provide SPIR-V shaders if applicable.
 * - `SDL_PROP_GPU_DEVICE_CREATE_SHADERS_DXBC_BOOLEAN`: The app is able to
 *   provide DXBC shaders if applicable
 * - `SDL_PROP_GPU_DEVICE_CREATE_SHADERS_DXIL_BOOLEAN`: The app is able to
 *   provide DXIL shaders if applicable.
 * - `SDL_PROP_GPU_DEVICE_CREATE_SHADERS_MSL_BOOLEAN`: The app is able to
 *   provide MSL shaders if applicable.
 * - `SDL_PROP_GPU_DEVICE_CREATE_SHADERS_METALLIB_BOOLEAN`: The app is able to
 *   provide Metal shader libraries if applicable.
 *
 * With the D3D12 renderer:
 *
 * - `SDL_PROP_GPU_DEVICE_CREATE_D3D12_SEMANTIC_NAME_STRING`: the prefix to
 *   use for all vertex semantics, default is "TEXCOORD".
 *
 * \param props the properties to use.
 * \returns a GPU context on success or NULL on failure; call SDL_GetError()
 *          for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetGPUShaderFormats
 * \sa SDL_GetGPUDeviceDriver
 * \sa SDL_DestroyGPUDevice
 * \sa SDL_GPUSupportsProperties
 *)
function SDL_CreateGPUDeviceWithProperties(props: SDL_PropertiesID): SDL_GPUDevice; cdecl;
  external LIB_SDL3 name _PU + 'SDL_CreateGPUDeviceWithProperties';

const
  SDL_PROP_GPU_DEVICE_CREATE_DEBUGMODE_BOOLEAN = 'SDL.gpu.device.create.debugmode';
  SDL_PROP_GPU_DEVICE_CREATE_PREFERLOWPOWER_BOOLEAN = 'SDL.gpu.device.create.preferlowpower';
  SDL_PROP_GPU_DEVICE_CREATE_NAME_STRING = 'SDL.gpu.device.create.name';
  SDL_PROP_GPU_DEVICE_CREATE_SHADERS_PRIVATE_BOOLEAN = 'SDL.gpu.device.create.shaders.private';
  SDL_PROP_GPU_DEVICE_CREATE_SHADERS_SPIRV_BOOLEAN = 'SDL.gpu.device.create.shaders.spirv';
  SDL_PROP_GPU_DEVICE_CREATE_SHADERS_DXBC_BOOLEAN = 'SDL.gpu.device.create.shaders.dxbc';
  SDL_PROP_GPU_DEVICE_CREATE_SHADERS_DXIL_BOOLEAN = 'SDL.gpu.device.create.shaders.dxil';
  SDL_PROP_GPU_DEVICE_CREATE_SHADERS_MSL_BOOLEAN = 'SDL.gpu.device.create.shaders.msl';
  SDL_PROP_GPU_DEVICE_CREATE_SHADERS_METALLIB_BOOLEAN = 'SDL.gpu.device.create.shaders.metallib';
  SDL_PROP_GPU_DEVICE_CREATE_D3D12_SEMANTIC_NAME_STRING = 'SDL.gpu.device.create.d3d12.semantic';

(**
 * Destroys a GPU context previously returned by SDL_CreateGPUDevice.
 *
 * \param device a GPU Context to destroy.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CreateGPUDevice
 *)
procedure SDL_DestroyGPUDevice(device: SDL_GPUDevice); cdecl;
  external LIB_SDL3 name _PU + 'SDL_DestroyGPUDevice';

(**
 * Get the number of GPU drivers compiled into SDL.
 *
 * \returns the number of built in GPU drivers.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetGPUDriver
 *)
function SDL_GetNumGPUDrivers(): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetNumGPUDrivers';

(**
 * Get the name of a built in GPU driver.
 *
 * The GPU drivers are presented in the order in which they are normally
 * checked during initialization.
 *
 * The names of drivers are all simple, low-ASCII identifiers, like "vulkan",
 * "metal" or "direct3d12". These never have Unicode characters, and are not
 * meant to be proper names.
 *
 * \param index the index of a GPU driver.
 * \returns the name of the GPU driver with the given **index**.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetNumGPUDrivers
 *)
function SDL_GetGPUDriver(index: Integer): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetGPUDriver';

(**
 * Returns the name of the backend used to create this GPU context.
 *
 * \param device a GPU context to query.
 * \returns the name of the device's driver, or NULL on error.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetGPUDeviceDriver(device: SDL_GPUDevice): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetGPUDeviceDriver';

(**
 * Returns the supported shader formats for this GPU context.
 *
 * \param device a GPU context to query.
 * \returns a bitflag indicating which shader formats the driver is able to
 *          consume.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetGPUShaderFormats(device: SDL_GPUDevice): SDL_GPUShaderFormat; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetGPUShaderFormats';

(**
 * Creates a pipeline object to be used in a compute workflow.
 *
 * Shader resource bindings must be authored to follow a particular order
 * depending on the shader format.
 *
 * For SPIR-V shaders, use the following resource sets:
 *
 * - 0: Sampled textures, followed by read-only storage textures, followed by
 *   read-only storage buffers
 * - 1: Read-write storage textures, followed by read-write storage buffers
 * - 2: Uniform buffers
 *
 * For DXBC and DXIL shaders, use the following register order:
 *
 * - (t[n], space0): Sampled textures, followed by read-only storage textures,
 *   followed by read-only storage buffers
 * - (u[n], space1): Read-write storage textures, followed by read-write
 *   storage buffers
 * - (b[n], space2): Uniform buffers
 *
 * For MSL/metallib, use the following order:
 *
 * - [[buffer]]: Uniform buffers, followed by read-only storage buffers,
 *   followed by read-write storage buffers
 * - [[texture]]: Sampled textures, followed by read-only storage textures,
 *   followed by read-write storage textures
 *
 * There are optional properties that can be provided through `props`. These
 * are the supported properties:
 *
 * - `SDL_PROP_GPU_COMPUTEPIPELINE_CREATE_NAME_STRING`: a name that can be
 *   displayed in debugging tools.
 *
 * \param device a GPU Context.
 * \param createinfo a struct describing the state of the compute pipeline to
 *                   create.
 * \returns a compute pipeline object on success, or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_BindGPUComputePipeline
 * \sa SDL_ReleaseGPUComputePipeline
 *)
function SDL_CreateGPUComputePipeline(device: SDL_GPUDevice; const createinfo: PSDL_GPUComputePipelineCreateInfo): SDL_GPUComputePipeline; cdecl;
  external LIB_SDL3 name _PU + 'SDL_CreateGPUComputePipeline';

const
  SDL_PROP_GPU_COMPUTEPIPELINE_CREATE_NAME_STRING = 'SDL.gpu.computepipeline.create.name';

(**
 * Creates a pipeline object to be used in a graphics workflow.
 *
 * There are optional properties that can be provided through `props`. These
 * are the supported properties:
 *
 * - `SDL_PROP_GPU_GRAPHICSPIPELINE_CREATE_NAME_STRING`: a name that can be
 *   displayed in debugging tools.
 *
 * \param device a GPU Context.
 * \param createinfo a struct describing the state of the graphics pipeline to
 *                   create.
 * \returns a graphics pipeline object on success, or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CreateGPUShader
 * \sa SDL_BindGPUGraphicsPipeline
 * \sa SDL_ReleaseGPUGraphicsPipeline
 *)
function SDL_CreateGPUGraphicsPipeline(device: SDL_GPUDevice; const createinfo: PSDL_GPUGraphicsPipelineCreateInfo): SDL_GPUGraphicsPipeline; cdecl;
  external LIB_SDL3 name _PU + 'SDL_CreateGPUGraphicsPipeline';

const
  SDL_PROP_GPU_GRAPHICSPIPELINE_CREATE_NAME_STRING = 'SDL.gpu.graphicspipeline.create.name';

(**
 * Creates a sampler object to be used when binding textures in a graphics
 * workflow.
 *
 * There are optional properties that can be provided through `props`. These
 * are the supported properties:
 *
 * - `SDL_PROP_GPU_SAMPLER_CREATE_NAME_STRING`: a name that can be displayed
 *   in debugging tools.
 *
 * \param device a GPU Context.
 * \param createinfo a struct describing the state of the sampler to create.
 * \returns a sampler object on success, or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_BindGPUVertexSamplers
 * \sa SDL_BindGPUFragmentSamplers
 * \sa SDL_ReleaseGPUSampler
 *)
function SDL_CreateGPUSampler(device: SDL_GPUDevice; const createinfo: PSDL_GPUSamplerCreateInfo): SDL_GPUSampler; cdecl;
  external LIB_SDL3 name _PU + 'SDL_CreateGPUSampler';

const
  SDL_PROP_GPU_SAMPLER_CREATE_NAME_STRING = 'SDL.gpu.sampler.create.name';

(**
 * Creates a shader to be used when creating a graphics pipeline.
 *
 * Shader resource bindings must be authored to follow a particular order
 * depending on the shader format.
 *
 * For SPIR-V shaders, use the following resource sets:
 *
 * For vertex shaders:
 *
 * - 0: Sampled textures, followed by storage textures, followed by storage
 *   buffers
 * - 1: Uniform buffers
 *
 * For fragment shaders:
 *
 * - 2: Sampled textures, followed by storage textures, followed by storage
 *   buffers
 * - 3: Uniform buffers
 *
 * For DXBC and DXIL shaders, use the following register order:
 *
 * For vertex shaders:
 *
 * - (t[n], space0): Sampled textures, followed by storage textures, followed
 *   by storage buffers
 * - (s[n], space0): Samplers with indices corresponding to the sampled
 *   textures
 * - (b[n], space1): Uniform buffers
 *
 * For pixel shaders:
 *
 * - (t[n], space2): Sampled textures, followed by storage textures, followed
 *   by storage buffers
 * - (s[n], space2): Samplers with indices corresponding to the sampled
 *   textures
 * - (b[n], space3): Uniform buffers
 *
 * For MSL/metallib, use the following order:
 *
 * - [[texture]]: Sampled textures, followed by storage textures
 * - [[sampler]]: Samplers with indices corresponding to the sampled textures
 * - [[buffer]]: Uniform buffers, followed by storage buffers. Vertex buffer 0
 *   is bound at [[buffer(14)]], vertex buffer 1 at [[buffer(15)]], and so on.
 *   Rather than manually authoring vertex buffer indices, use the
 *   [[stage_in]] attribute which will automatically use the vertex input
 *   information from the SDL_GPUGraphicsPipeline.
 *
 * Shader semantics other than system-value semantics do not matter in D3D12
 * and for ease of use the SDL implementation assumes that non system-value
 * semantics will all be TEXCOORD. If you are using HLSL as the shader source
 * language, your vertex semantics should start at TEXCOORD0 and increment
 * like so: TEXCOORD1, TEXCOORD2, etc. If you wish to change the semantic
 * prefix to something other than TEXCOORD you can use
 * SDL_PROP_GPU_DEVICE_CREATE_D3D12_SEMANTIC_NAME_STRING with
 * SDL_CreateGPUDeviceWithProperties().
 *
 * There are optional properties that can be provided through `props`. These
 * are the supported properties:
 *
 * - `SDL_PROP_GPU_SHADER_CREATE_NAME_STRING`: a name that can be displayed in
 *   debugging tools.
 *
 * \param device a GPU Context.
 * \param createinfo a struct describing the state of the shader to create.
 * \returns a shader object on success, or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CreateGPUGraphicsPipeline
 * \sa SDL_ReleaseGPUShader
 *)
function SDL_CreateGPUShader(device: SDL_GPUDevice; const createinfo: PSDL_GPUShaderCreateInfo): SDL_GPUShader; cdecl;
  external LIB_SDL3 name _PU + 'SDL_CreateGPUShader';

const
  SDL_PROP_GPU_SHADER_CREATE_NAME_STRING = 'SDL.gpu.shader.create.name';

(**
 * Creates a texture object to be used in graphics or compute workflows.
 *
 * The contents of this texture are undefined until data is written to the
 * texture.
 *
 * Note that certain combinations of usage flags are invalid. For example, a
 * texture cannot have both the SAMPLER and GRAPHICS_STORAGE_READ flags.
 *
 * If you request a sample count higher than the hardware supports, the
 * implementation will automatically fall back to the highest available sample
 * count.
 *
 * There are optional properties that can be provided through
 * SDL_GPUTextureCreateInfo's `props`. These are the supported properties:
 *
 * - `SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_R_FLOAT`: (Direct3D 12 only) if
 *   the texture usage is SDL_GPU_TEXTUREUSAGE_COLOR_TARGET, clear the texture
 *   to a color with this red intensity. Defaults to zero.
 * - `SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_G_FLOAT`: (Direct3D 12 only) if
 *   the texture usage is SDL_GPU_TEXTUREUSAGE_COLOR_TARGET, clear the texture
 *   to a color with this green intensity. Defaults to zero.
 * - `SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_B_FLOAT`: (Direct3D 12 only) if
 *   the texture usage is SDL_GPU_TEXTUREUSAGE_COLOR_TARGET, clear the texture
 *   to a color with this blue intensity. Defaults to zero.
 * - `SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_A_FLOAT`: (Direct3D 12 only) if
 *   the texture usage is SDL_GPU_TEXTUREUSAGE_COLOR_TARGET, clear the texture
 *   to a color with this alpha intensity. Defaults to zero.
 * - `SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_DEPTH_FLOAT`: (Direct3D 12 only)
 *   if the texture usage is SDL_GPU_TEXTUREUSAGE_DEPTH_STENCIL_TARGET, clear
 *   the texture to a depth of this value. Defaults to zero.
 * - `SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_STENCIL_UINT8`: (Direct3D 12
 *   only) if the texture usage is SDL_GPU_TEXTUREUSAGE_DEPTH_STENCIL_TARGET,
 *   clear the texture to a stencil of this value. Defaults to zero.
 * - `SDL_PROP_GPU_TEXTURE_CREATE_NAME_STRING`: a name that can be displayed
 *   in debugging tools.
 *
 * \param device a GPU Context.
 * \param createinfo a struct describing the state of the texture to create.
 * \returns a texture object on success, or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_UploadToGPUTexture
 * \sa SDL_DownloadFromGPUTexture
 * \sa SDL_BindGPUVertexSamplers
 * \sa SDL_BindGPUVertexStorageTextures
 * \sa SDL_BindGPUFragmentSamplers
 * \sa SDL_BindGPUFragmentStorageTextures
 * \sa SDL_BindGPUComputeStorageTextures
 * \sa SDL_BlitGPUTexture
 * \sa SDL_ReleaseGPUTexture
 * \sa SDL_GPUTextureSupportsFormat
 *)
function SDL_CreateGPUTexture(device: SDL_GPUDevice; const createinfo: PSDL_GPUTextureCreateInfo): SDL_GPUTexture; cdecl;
  external LIB_SDL3 name _PU + 'SDL_CreateGPUTexture';

const
  SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_R_FLOAT = 'SDL.gpu.texture.create.d3d12.clear.r';
  SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_G_FLOAT = 'SDL.gpu.texture.create.d3d12.clear.g';
  SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_B_FLOAT = 'SDL.gpu.texture.create.d3d12.clear.b';
  SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_A_FLOAT = 'SDL.gpu.texture.create.d3d12.clear.a';
  SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_DEPTH_FLOAT = 'SDL.gpu.texture.create.d3d12.clear.depth';
  SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_STENCIL_UINT8 = 'SDL.gpu.texture.create.d3d12.clear.stencil';
  SDL_PROP_GPU_TEXTURE_CREATE_NAME_STRING = 'SDL.gpu.texture.create.name';

(**
 * Creates a buffer object to be used in graphics or compute workflows.
 *
 * The contents of this buffer are undefined until data is written to the
 * buffer.
 *
 * Note that certain combinations of usage flags are invalid. For example, a
 * buffer cannot have both the VERTEX and INDEX flags.
 *
 * For better understanding of underlying concepts and memory management with
 * SDL GPU API, you may refer
 * [this blog post](https://moonside.games/posts/sdl-gpu-concepts-cycling/)
 * .
 *
 * There are optional properties that can be provided through `props`. These
 * are the supported properties:
 *
 * - `SDL_PROP_GPU_BUFFER_CREATE_NAME_STRING`: a name that can be displayed in
 *   debugging tools.
 *
 * \param device a GPU Context.
 * \param createinfo a struct describing the state of the buffer to create.
 * \returns a buffer object on success, or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_UploadToGPUBuffer
 * \sa SDL_DownloadFromGPUBuffer
 * \sa SDL_CopyGPUBufferToBuffer
 * \sa SDL_BindGPUVertexBuffers
 * \sa SDL_BindGPUIndexBuffer
 * \sa SDL_BindGPUVertexStorageBuffers
 * \sa SDL_BindGPUFragmentStorageBuffers
 * \sa SDL_DrawGPUPrimitivesIndirect
 * \sa SDL_DrawGPUIndexedPrimitivesIndirect
 * \sa SDL_BindGPUComputeStorageBuffers
 * \sa SDL_DispatchGPUComputeIndirect
 * \sa SDL_ReleaseGPUBuffer
 *)
function SDL_CreateGPUBuffer(device: SDL_GPUDevice; const createinfo: PSDL_GPUBufferCreateInfo): SDL_GPUBuffer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_CreateGPUBuffer';

const
  SDL_PROP_GPU_BUFFER_CREATE_NAME_STRING = 'SDL.gpu.buffer.create.name';

(**
 * Creates a transfer buffer to be used when uploading to or downloading from
 * graphics resources.
 *
 * Download buffers can be particularly expensive to create, so it is good
 * practice to reuse them if data will be downloaded regularly.
 *
 * There are optional properties that can be provided through `props`. These
 * are the supported properties:
 *
 * - `SDL_PROP_GPU_TRANSFERBUFFER_CREATE_NAME_STRING`: a name that can be
 *   displayed in debugging tools.
 *
 * \param device a GPU Context.
 * \param createinfo a struct describing the state of the transfer buffer to
 *                   create.
 * \returns a transfer buffer on success, or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_UploadToGPUBuffer
 * \sa SDL_DownloadFromGPUBuffer
 * \sa SDL_UploadToGPUTexture
 * \sa SDL_DownloadFromGPUTexture
 * \sa SDL_ReleaseGPUTransferBuffer
 *)
function SDL_CreateGPUTransferBuffer(device: SDL_GPUDevice; const createinfo: PSDL_GPUTransferBufferCreateInfo): SDL_GPUTransferBuffer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_CreateGPUTransferBuffer';

const
  SDL_PROP_GPU_TRANSFERBUFFER_CREATE_NAME_STRING = 'SDL.gpu.transferbuffer.create.name';

(**
 * Sets an arbitrary string constant to label a buffer.
 *
 * You should use SDL_PROP_GPU_BUFFER_CREATE_NAME_STRING with
 * SDL_CreateGPUBuffer instead of this function to avoid thread safety issues.
 *
 * \param device a GPU Context.
 * \param buffer a buffer to attach the name to.
 * \param text a UTF-8 string constant to mark as the name of the buffer.
 *
 * \threadsafety This function is not thread safe, you must make sure the
 *               buffer is not simultaneously used by any other thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CreateGPUBuffer
 *)
procedure SDL_SetGPUBufferName(device: SDL_GPUDevice; buffer: SDL_GPUBuffer; const text: PUTF8Char); cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetGPUBufferName';

(**
 * Sets an arbitrary string constant to label a texture.
 *
 * You should use SDL_PROP_GPU_TEXTURE_CREATE_NAME_STRING with
 * SDL_CreateGPUTexture instead of this function to avoid thread safety
 * issues.
 *
 * \param device a GPU Context.
 * \param texture a texture to attach the name to.
 * \param text a UTF-8 string constant to mark as the name of the texture.
 *
 * \threadsafety This function is not thread safe, you must make sure the
 *               texture is not simultaneously used by any other thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CreateGPUTexture
 *)
procedure SDL_SetGPUTextureName(device: SDL_GPUDevice; texture: SDL_GPUTexture; const text: PUTF8Char); cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetGPUTextureName';

(**
 * Inserts an arbitrary string label into the command buffer callstream.
 *
 * Useful for debugging.
 *
 * \param command_buffer a command buffer.
 * \param text a UTF-8 string constant to insert as the label.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_InsertGPUDebugLabel(command_buffer: SDL_GPUCommandBuffer; const text: PUTF8Char); cdecl;
  external LIB_SDL3 name _PU + 'SDL_InsertGPUDebugLabel';

(**
 * Begins a debug group with an arbitary name.
 *
 * Used for denoting groups of calls when viewing the command buffer
 * callstream in a graphics debugging tool.
 *
 * Each call to SDL_PushGPUDebugGroup must have a corresponding call to
 * SDL_PopGPUDebugGroup.
 *
 * On some backends (e.g. Metal), pushing a debug group during a
 * render/blit/compute pass will create a group that is scoped to the native
 * pass rather than the command buffer. For best results, if you push a debug
 * group during a pass, always pop it in the same pass.
 *
 * \param command_buffer a command buffer.
 * \param name a UTF-8 string constant that names the group.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_PopGPUDebugGroup
 *)
procedure SDL_PushGPUDebugGroup(command_buffer: SDL_GPUCommandBuffer; const name: PUTF8Char); cdecl;
  external LIB_SDL3 name _PU + 'SDL_PushGPUDebugGroup';

(**
 * Ends the most-recently pushed debug group.
 *
 * \param command_buffer a command buffer.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_PushGPUDebugGroup
 *)
procedure SDL_PopGPUDebugGroup(command_buffer: SDL_GPUCommandBuffer); cdecl;
  external LIB_SDL3 name _PU + 'SDL_PopGPUDebugGroup';

(**
 * Frees the given texture as soon as it is safe to do so.
 *
 * You must not reference the texture after calling this function.
 *
 * \param device a GPU context.
 * \param texture a texture to be destroyed.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_ReleaseGPUTexture(device: SDL_GPUDevice; texture: SDL_GPUTexture); cdecl;
  external LIB_SDL3 name _PU + 'SDL_ReleaseGPUTexture';

(**
 * Frees the given sampler as soon as it is safe to do so.
 *
 * You must not reference the sampler after calling this function.
 *
 * \param device a GPU context.
 * \param sampler a sampler to be destroyed.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_ReleaseGPUSampler(device: SDL_GPUDevice; sampler: SDL_GPUSampler); cdecl;
  external LIB_SDL3 name _PU + 'SDL_ReleaseGPUSampler';

(**
 * Frees the given buffer as soon as it is safe to do so.
 *
 * You must not reference the buffer after calling this function.
 *
 * \param device a GPU context.
 * \param buffer a buffer to be destroyed.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_ReleaseGPUBuffer(device: SDL_GPUDevice; buffer: SDL_GPUBuffer); cdecl;
  external LIB_SDL3 name _PU + 'SDL_ReleaseGPUBuffer';

(**
 * Frees the given transfer buffer as soon as it is safe to do so.
 *
 * You must not reference the transfer buffer after calling this function.
 *
 * \param device a GPU context.
 * \param transfer_buffer a transfer buffer to be destroyed.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_ReleaseGPUTransferBuffer(device: SDL_GPUDevice; transfer_buffer: SDL_GPUTransferBuffer); cdecl;
  external LIB_SDL3 name _PU + 'SDL_ReleaseGPUTransferBuffer';

(**
 * Frees the given compute pipeline as soon as it is safe to do so.
 *
 * You must not reference the compute pipeline after calling this function.
 *
 * \param device a GPU context.
 * \param compute_pipeline a compute pipeline to be destroyed.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_ReleaseGPUComputePipeline(device: SDL_GPUDevice; compute_pipeline: SDL_GPUComputePipeline); cdecl;
  external LIB_SDL3 name _PU + 'SDL_ReleaseGPUComputePipeline';

(**
 * Frees the given shader as soon as it is safe to do so.
 *
 * You must not reference the shader after calling this function.
 *
 * \param device a GPU context.
 * \param shader a shader to be destroyed.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_ReleaseGPUShader(device: SDL_GPUDevice; shader: SDL_GPUShader); cdecl;
  external LIB_SDL3 name _PU + 'SDL_ReleaseGPUShader';

(**
 * Frees the given graphics pipeline as soon as it is safe to do so.
 *
 * You must not reference the graphics pipeline after calling this function.
 *
 * \param device a GPU context.
 * \param graphics_pipeline a graphics pipeline to be destroyed.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_ReleaseGPUGraphicsPipeline(device: SDL_GPUDevice; graphics_pipeline: SDL_GPUGraphicsPipeline); cdecl;
  external LIB_SDL3 name _PU + 'SDL_ReleaseGPUGraphicsPipeline';

(**
 * Acquire a command buffer.
 *
 * This command buffer is managed by the implementation and should not be
 * freed by the user. The command buffer may only be used on the thread it was
 * acquired on. The command buffer should be submitted on the thread it was
 * acquired on.
 *
 * It is valid to acquire multiple command buffers on the same thread at once.
 * In fact a common design pattern is to acquire two command buffers per frame
 * where one is dedicated to render and compute passes and the other is
 * dedicated to copy passes and other preparatory work such as generating
 * mipmaps. Interleaving commands between the two command buffers reduces the
 * total amount of passes overall which improves rendering performance.
 *
 * \param device a GPU context.
 * \returns a command buffer, or NULL on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SubmitGPUCommandBuffer
 * \sa SDL_SubmitGPUCommandBufferAndAcquireFence
 *)
function SDL_AcquireGPUCommandBuffer(device: SDL_GPUDevice): SDL_GPUCommandBuffer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_AcquireGPUCommandBuffer';

(**
 * Pushes data to a vertex uniform slot on the command buffer.
 *
 * Subsequent draw calls will use this uniform data.
 *
 * \param command_buffer a command buffer.
 * \param slot_index the vertex uniform slot to push data to.
 * \param data client data to write.
 * \param length the length of the data to write.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_PushGPUVertexUniformData(command_buffer: SDL_GPUCommandBuffer; slot_index: Uint32; const data: Pointer; length: Uint32); cdecl;
  external LIB_SDL3 name _PU + 'SDL_PushGPUVertexUniformData';

(**
 * Pushes data to a fragment uniform slot on the command buffer.
 *
 * Subsequent draw calls will use this uniform data.
 *
 * \param command_buffer a command buffer.
 * \param slot_index the fragment uniform slot to push data to.
 * \param data client data to write.
 * \param length the length of the data to write.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_PushGPUFragmentUniformData(command_buffer: SDL_GPUCommandBuffer; slot_index: Uint32; const data: Pointer; length: Uint32); cdecl;
  external LIB_SDL3 name _PU + 'SDL_PushGPUFragmentUniformData';

(**
 * Pushes data to a uniform slot on the command buffer.
 *
 * Subsequent draw calls will use this uniform data.
 *
 * \param command_buffer a command buffer.
 * \param slot_index the uniform slot to push data to.
 * \param data client data to write.
 * \param length the length of the data to write.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_PushGPUComputeUniformData(command_buffer: SDL_GPUCommandBuffer; slot_index: Uint32; const data: Pointer; length: Uint32); cdecl;
  external LIB_SDL3 name _PU + 'SDL_PushGPUComputeUniformData';

(**
 * Begins a render pass on a command buffer.
 *
 * A render pass consists of a set of texture subresources (or depth slices in
 * the 3D texture case) which will be rendered to during the render pass,
 * along with corresponding clear values and load/store operations. All
 * operations related to graphics pipelines must take place inside of a render
 * pass. A default viewport and scissor state are automatically set when this
 * is called. You cannot begin another render pass, or begin a compute pass or
 * copy pass until you have ended the render pass.
 *
 * \param command_buffer a command buffer.
 * \param color_target_infos an array of texture subresources with
 *                           corresponding clear values and load/store ops.
 * \param num_color_targets the number of color targets in the
 *                          color_target_infos array.
 * \param depth_stencil_target_info a texture subresource with corresponding
 *                                  clear value and load/store ops, may be
 *                                  NULL.
 * \returns a render pass handle.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_EndGPURenderPass
 *)
function SDL_BeginGPURenderPass(command_buffer: SDL_GPUCommandBuffer; const color_target_infos: PSDL_GPUColorTargetInfo; num_color_targets: Uint32; const depth_stencil_target_info: PSDL_GPUDepthStencilTargetInfo): SDL_GPURenderPass; cdecl;
  external LIB_SDL3 name _PU + 'SDL_BeginGPURenderPass';

(**
 * Binds a graphics pipeline on a render pass to be used in rendering.
 *
 * A graphics pipeline must be bound before making any draw calls.
 *
 * \param render_pass a render pass handle.
 * \param graphics_pipeline the graphics pipeline to bind.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_BindGPUGraphicsPipeline(render_pass: SDL_GPURenderPass; graphics_pipeline: SDL_GPUGraphicsPipeline); cdecl;
  external LIB_SDL3 name _PU + 'SDL_BindGPUGraphicsPipeline';

(**
 * Sets the current viewport state on a command buffer.
 *
 * \param render_pass a render pass handle.
 * \param viewport the viewport to set.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_SetGPUViewport(render_pass: SDL_GPURenderPass; const viewport: PSDL_GPUViewport); cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetGPUViewport';

(**
 * Sets the current scissor state on a command buffer.
 *
 * \param render_pass a render pass handle.
 * \param scissor the scissor area to set.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_SetGPUScissor(render_pass: SDL_GPURenderPass; const scissor: PSDL_Rect); cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetGPUScissor';

(**
 * Sets the current blend constants on a command buffer.
 *
 * \param render_pass a render pass handle.
 * \param blend_constants the blend constant color.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GPU_BLENDFACTOR_CONSTANT_COLOR
 * \sa SDL_GPU_BLENDFACTOR_ONE_MINUS_CONSTANT_COLOR
 *)
procedure SDL_SetGPUBlendConstants(render_pass: SDL_GPURenderPass; blend_constants: SDL_FColor); cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetGPUBlendConstants';

(**
 * Sets the current stencil reference value on a command buffer.
 *
 * \param render_pass a render pass handle.
 * \param reference the stencil reference value to set.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_SetGPUStencilReference(render_pass: SDL_GPURenderPass; reference: Uint8); cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetGPUStencilReference';

(**
 * Binds vertex buffers on a command buffer for use with subsequent draw
 * calls.
 *
 * \param render_pass a render pass handle.
 * \param first_slot the vertex buffer slot to begin binding from.
 * \param bindings an array of SDL_GPUBufferBinding structs containing vertex
 *                 buffers and offset values.
 * \param num_bindings the number of bindings in the bindings array.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_BindGPUVertexBuffers(render_pass: SDL_GPURenderPass; first_slot: Uint32; const bindings: PSDL_GPUBufferBinding; num_bindings: Uint32); cdecl;
  external LIB_SDL3 name _PU + 'SDL_BindGPUVertexBuffers';

(**
 * Binds an index buffer on a command buffer for use with subsequent draw
 * calls.
 *
 * \param render_pass a render pass handle.
 * \param binding a pointer to a struct containing an index buffer and offset.
 * \param index_element_size whether the index values in the buffer are 16- or
 *                           32-bit.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_BindGPUIndexBuffer(render_pass: SDL_GPURenderPass; const binding: PSDL_GPUBufferBinding; index_element_size: SDL_GPUIndexElementSize); cdecl;
  external LIB_SDL3 name _PU + 'SDL_BindGPUIndexBuffer';

(**
 * Binds texture-sampler pairs for use on the vertex shader.
 *
 * The textures must have been created with SDL_GPU_TEXTUREUSAGE_SAMPLER.
 *
 * \param render_pass a render pass handle.
 * \param first_slot the vertex sampler slot to begin binding from.
 * \param texture_sampler_bindings an array of texture-sampler binding
 *                                 structs.
 * \param num_bindings the number of texture-sampler pairs to bind from the
 *                     array.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_BindGPUVertexSamplers(render_pass: SDL_GPURenderPass; first_slot: Uint32; const texture_sampler_bindings: PSDL_GPUTextureSamplerBinding; num_bindings: Uint32); cdecl;
  external LIB_SDL3 name _PU + 'SDL_BindGPUVertexSamplers';

(**
 * Binds storage textures for use on the vertex shader.
 *
 * These textures must have been created with
 * SDL_GPU_TEXTUREUSAGE_GRAPHICS_STORAGE_READ.
 *
 * \param render_pass a render pass handle.
 * \param first_slot the vertex storage texture slot to begin binding from.
 * \param storage_textures an array of storage textures.
 * \param num_bindings the number of storage texture to bind from the array.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_BindGPUVertexStorageTextures(render_pass: SDL_GPURenderPass; first_slot: Uint32; const storage_textures: PSDL_GPUTexture; num_bindings: Uint32); cdecl;
  external LIB_SDL3 name _PU + 'SDL_BindGPUVertexStorageTextures';

(**
 * Binds storage buffers for use on the vertex shader.
 *
 * These buffers must have been created with
 * SDL_GPU_BUFFERUSAGE_GRAPHICS_STORAGE_READ.
 *
 * \param render_pass a render pass handle.
 * \param first_slot the vertex storage buffer slot to begin binding from.
 * \param storage_buffers an array of buffers.
 * \param num_bindings the number of buffers to bind from the array.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_BindGPUVertexStorageBuffers(render_pass: SDL_GPURenderPass; first_slot: Uint32; const storage_buffers: PSDL_GPUBuffer; num_bindings: Uint32); cdecl;
  external LIB_SDL3 name _PU + 'SDL_BindGPUVertexStorageBuffers';

(**
 * Binds texture-sampler pairs for use on the fragment shader.
 *
 * The textures must have been created with SDL_GPU_TEXTUREUSAGE_SAMPLER.
 *
 * \param render_pass a render pass handle.
 * \param first_slot the fragment sampler slot to begin binding from.
 * \param texture_sampler_bindings an array of texture-sampler binding
 *                                 structs.
 * \param num_bindings the number of texture-sampler pairs to bind from the
 *                     array.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_BindGPUFragmentSamplers(render_pass: SDL_GPURenderPass; first_slot: Uint32; const texture_sampler_bindings: PSDL_GPUTextureSamplerBinding; num_bindings: Uint32); cdecl;
  external LIB_SDL3 name _PU + 'SDL_BindGPUFragmentSamplers';

(**
 * Binds storage textures for use on the fragment shader.
 *
 * These textures must have been created with
 * SDL_GPU_TEXTUREUSAGE_GRAPHICS_STORAGE_READ.
 *
 * \param render_pass a render pass handle.
 * \param first_slot the fragment storage texture slot to begin binding from.
 * \param storage_textures an array of storage textures.
 * \param num_bindings the number of storage textures to bind from the array.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_BindGPUFragmentStorageTextures(render_pass: SDL_GPURenderPass; first_slot: Uint32; const storage_textures: PSDL_GPUTexture; num_bindings: Uint32); cdecl;
  external LIB_SDL3 name _PU + 'SDL_BindGPUFragmentStorageTextures';

(**
 * Binds storage buffers for use on the fragment shader.
 *
 * These buffers must have been created with
 * SDL_GPU_BUFFERUSAGE_GRAPHICS_STORAGE_READ.
 *
 * \param render_pass a render pass handle.
 * \param first_slot the fragment storage buffer slot to begin binding from.
 * \param storage_buffers an array of storage buffers.
 * \param num_bindings the number of storage buffers to bind from the array.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_BindGPUFragmentStorageBuffers(render_pass: SDL_GPURenderPass; first_slot: Uint32; const storage_buffers: PSDL_GPUBuffer; num_bindings: Uint32); cdecl;
  external LIB_SDL3 name _PU + 'SDL_BindGPUFragmentStorageBuffers';

(**
 * Draws data using bound graphics state with an index buffer and instancing
 * enabled.
 *
 * You must not call this function before binding a graphics pipeline.
 *
 * Note that the `first_vertex` and `first_instance` parameters are NOT
 * compatible with built-in vertex/instance ID variables in shaders (for
 * example, SV_VertexID); GPU APIs and shader languages do not define these
 * built-in variables consistently, so if your shader depends on them, the
 * only way to keep behavior consistent and portable is to always pass 0 for
 * the correlating parameter in the draw calls.
 *
 * \param render_pass a render pass handle.
 * \param num_indices the number of indices to draw per instance.
 * \param num_instances the number of instances to draw.
 * \param first_index the starting index within the index buffer.
 * \param vertex_offset value added to vertex index before indexing into the
 *                      vertex buffer.
 * \param first_instance the ID of the first instance to draw.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_DrawGPUIndexedPrimitives(render_pass: SDL_GPURenderPass; num_indices: Uint32; num_instances: Uint32; first_index: Uint32; vertex_offset: Sint32; first_instance: Uint32); cdecl;
  external LIB_SDL3 name _PU + 'SDL_DrawGPUIndexedPrimitives';

(**
 * Draws data using bound graphics state.
 *
 * You must not call this function before binding a graphics pipeline.
 *
 * Note that the `first_vertex` and `first_instance` parameters are NOT
 * compatible with built-in vertex/instance ID variables in shaders (for
 * example, SV_VertexID); GPU APIs and shader languages do not define these
 * built-in variables consistently, so if your shader depends on them, the
 * only way to keep behavior consistent and portable is to always pass 0 for
 * the correlating parameter in the draw calls.
 *
 * \param render_pass a render pass handle.
 * \param num_vertices the number of vertices to draw.
 * \param num_instances the number of instances that will be drawn.
 * \param first_vertex the index of the first vertex to draw.
 * \param first_instance the ID of the first instance to draw.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_DrawGPUPrimitives(render_pass: SDL_GPURenderPass; num_vertices: Uint32; num_instances: Uint32; first_vertex: Uint32; first_instance: Uint32); cdecl;
  external LIB_SDL3 name _PU + 'SDL_DrawGPUPrimitives';

(**
 * Draws data using bound graphics state and with draw parameters set from a
 * buffer.
 *
 * The buffer must consist of tightly-packed draw parameter sets that each
 * match the layout of SDL_GPUIndirectDrawCommand. You must not call this
 * function before binding a graphics pipeline.
 *
 * \param render_pass a render pass handle.
 * \param buffer a buffer containing draw parameters.
 * \param offset the offset to start reading from the draw buffer.
 * \param draw_count the number of draw parameter sets that should be read
 *                   from the draw buffer.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_DrawGPUPrimitivesIndirect(render_pass: SDL_GPURenderPass; buffer: SDL_GPUBuffer; offset: Uint32; draw_count: Uint32); cdecl;
  external LIB_SDL3 name _PU + 'SDL_DrawGPUPrimitivesIndirect';

(**
 * Draws data using bound graphics state with an index buffer enabled and with
 * draw parameters set from a buffer.
 *
 * The buffer must consist of tightly-packed draw parameter sets that each
 * match the layout of SDL_GPUIndexedIndirectDrawCommand. You must not call
 * this function before binding a graphics pipeline.
 *
 * \param render_pass a render pass handle.
 * \param buffer a buffer containing draw parameters.
 * \param offset the offset to start reading from the draw buffer.
 * \param draw_count the number of draw parameter sets that should be read
 *                   from the draw buffer.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_DrawGPUIndexedPrimitivesIndirect(render_pass: SDL_GPURenderPass; buffer: SDL_GPUBuffer; offset: Uint32; draw_count: Uint32); cdecl;
  external LIB_SDL3 name _PU + 'SDL_DrawGPUIndexedPrimitivesIndirect';

(**
 * Ends the given render pass.
 *
 * All bound graphics state on the render pass command buffer is unset. The
 * render pass handle is now invalid.
 *
 * \param render_pass a render pass handle.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_EndGPURenderPass(render_pass: SDL_GPURenderPass); cdecl;
  external LIB_SDL3 name _PU + 'SDL_EndGPURenderPass';

(**
 * Begins a compute pass on a command buffer.
 *
 * A compute pass is defined by a set of texture subresources and buffers that
 * may be written to by compute pipelines. These textures and buffers must
 * have been created with the COMPUTE_STORAGE_WRITE bit or the
 * COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE bit. If you do not create a texture
 * with COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE, you must not read from the
 * texture in the compute pass. All operations related to compute pipelines
 * must take place inside of a compute pass. You must not begin another
 * compute pass, or a render pass or copy pass before ending the compute pass.
 *
 * A VERY IMPORTANT NOTE - Reads and writes in compute passes are NOT
 * implicitly synchronized. This means you may cause data races by both
 * reading and writing a resource region in a compute pass, or by writing
 * multiple times to a resource region. If your compute work depends on
 * reading the completed output from a previous dispatch, you MUST end the
 * current compute pass and begin a new one before you can safely access the
 * data. Otherwise you will receive unexpected results. Reading and writing a
 * texture in the same compute pass is only supported by specific texture
 * formats. Make sure you check the format support!
 *
 * \param command_buffer a command buffer.
 * \param storage_texture_bindings an array of writeable storage texture
 *                                 binding structs.
 * \param num_storage_texture_bindings the number of storage textures to bind
 *                                     from the array.
 * \param storage_buffer_bindings an array of writeable storage buffer binding
 *                                structs.
 * \param num_storage_buffer_bindings the number of storage buffers to bind
 *                                    from the array.
 * \returns a compute pass handle.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_EndGPUComputePass
 *)
function SDL_BeginGPUComputePass(command_buffer: SDL_GPUCommandBuffer; const storage_texture_bindings: PSDL_GPUStorageTextureReadWriteBinding; num_storage_texture_bindings: Uint32; const storage_buffer_bindings: PSDL_GPUStorageBufferReadWriteBinding; num_storage_buffer_bindings: Uint32): SDL_GPUComputePass; cdecl;
  external LIB_SDL3 name _PU + 'SDL_BeginGPUComputePass';

(**
 * Binds a compute pipeline on a command buffer for use in compute dispatch.
 *
 * \param compute_pass a compute pass handle.
 * \param compute_pipeline a compute pipeline to bind.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_BindGPUComputePipeline(compute_pass: SDL_GPUComputePass; compute_pipeline: SDL_GPUComputePipeline); cdecl;
  external LIB_SDL3 name _PU + 'SDL_BindGPUComputePipeline';

(**
 * Binds texture-sampler pairs for use on the compute shader.
 *
 * The textures must have been created with SDL_GPU_TEXTUREUSAGE_SAMPLER.
 *
 * \param compute_pass a compute pass handle.
 * \param first_slot the compute sampler slot to begin binding from.
 * \param texture_sampler_bindings an array of texture-sampler binding
 *                                 structs.
 * \param num_bindings the number of texture-sampler bindings to bind from the
 *                     array.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_BindGPUComputeSamplers(compute_pass: SDL_GPUComputePass; first_slot: Uint32; const texture_sampler_bindings: PSDL_GPUTextureSamplerBinding; num_bindings: Uint32); cdecl;
  external LIB_SDL3 name _PU + 'SDL_BindGPUComputeSamplers';

(**
 * Binds storage textures as readonly for use on the compute pipeline.
 *
 * These textures must have been created with
 * SDL_GPU_TEXTUREUSAGE_COMPUTE_STORAGE_READ.
 *
 * \param compute_pass a compute pass handle.
 * \param first_slot the compute storage texture slot to begin binding from.
 * \param storage_textures an array of storage textures.
 * \param num_bindings the number of storage textures to bind from the array.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_BindGPUComputeStorageTextures(compute_pass: SDL_GPUComputePass; first_slot: Uint32; const storage_textures: PSDL_GPUTexture; num_bindings: Uint32); cdecl;
  external LIB_SDL3 name _PU + 'SDL_BindGPUComputeStorageTextures';

(**
 * Binds storage buffers as readonly for use on the compute pipeline.
 *
 * These buffers must have been created with
 * SDL_GPU_BUFFERUSAGE_COMPUTE_STORAGE_READ.
 *
 * \param compute_pass a compute pass handle.
 * \param first_slot the compute storage buffer slot to begin binding from.
 * \param storage_buffers an array of storage buffer binding structs.
 * \param num_bindings the number of storage buffers to bind from the array.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_BindGPUComputeStorageBuffers(compute_pass: SDL_GPUComputePass; first_slot: Uint32; const storage_buffers: PSDL_GPUBuffer; num_bindings: Uint32); cdecl;
  external LIB_SDL3 name _PU + 'SDL_BindGPUComputeStorageBuffers';

(**
 * Dispatches compute work.
 *
 * You must not call this function before binding a compute pipeline.
 *
 * A VERY IMPORTANT NOTE If you dispatch multiple times in a compute pass, and
 * the dispatches write to the same resource region as each other, there is no
 * guarantee of which order the writes will occur. If the write order matters,
 * you MUST end the compute pass and begin another one.
 *
 * \param compute_pass a compute pass handle.
 * \param groupcount_x number of local workgroups to dispatch in the X
 *                     dimension.
 * \param groupcount_y number of local workgroups to dispatch in the Y
 *                     dimension.
 * \param groupcount_z number of local workgroups to dispatch in the Z
 *                     dimension.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_DispatchGPUCompute(compute_pass: SDL_GPUComputePass; groupcount_x: Uint32; groupcount_y: Uint32; groupcount_z: Uint32); cdecl;
  external LIB_SDL3 name _PU + 'SDL_DispatchGPUCompute';

(**
 * Dispatches compute work with parameters set from a buffer.
 *
 * The buffer layout should match the layout of
 * SDL_GPUIndirectDispatchCommand. You must not call this function before
 * binding a compute pipeline.
 *
 * A VERY IMPORTANT NOTE If you dispatch multiple times in a compute pass, and
 * the dispatches write to the same resource region as each other, there is no
 * guarantee of which order the writes will occur. If the write order matters,
 * you MUST end the compute pass and begin another one.
 *
 * \param compute_pass a compute pass handle.
 * \param buffer a buffer containing dispatch parameters.
 * \param offset the offset to start reading from the dispatch buffer.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_DispatchGPUComputeIndirect(compute_pass: SDL_GPUComputePass; buffer: SDL_GPUBuffer; offset: Uint32); cdecl;
  external LIB_SDL3 name _PU + 'SDL_DispatchGPUComputeIndirect';

(**
 * Ends the current compute pass.
 *
 * All bound compute state on the command buffer is unset. The compute pass
 * handle is now invalid.
 *
 * \param compute_pass a compute pass handle.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_EndGPUComputePass(compute_pass: SDL_GPUComputePass); cdecl;
  external LIB_SDL3 name _PU + 'SDL_EndGPUComputePass';

(**
 * Maps a transfer buffer into application address space.
 *
 * You must unmap the transfer buffer before encoding upload commands.
 *
 * \param device a GPU context.
 * \param transfer_buffer a transfer buffer.
 * \param cycle if true, cycles the transfer buffer if it is already bound.
 * \returns the address of the mapped transfer buffer memory, or NULL on
 *          failure; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_MapGPUTransferBuffer(device: SDL_GPUDevice; transfer_buffer: SDL_GPUTransferBuffer; cycle: Boolean): Pointer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_MapGPUTransferBuffer';

(**
 * Unmaps a previously mapped transfer buffer.
 *
 * \param device a GPU context.
 * \param transfer_buffer a previously mapped transfer buffer.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_UnmapGPUTransferBuffer(device: SDL_GPUDevice; transfer_buffer: SDL_GPUTransferBuffer); cdecl;
  external LIB_SDL3 name _PU + 'SDL_UnmapGPUTransferBuffer';

(**
 * Begins a copy pass on a command buffer.
 *
 * All operations related to copying to or from buffers or textures take place
 * inside a copy pass. You must not begin another copy pass, or a render pass
 * or compute pass before ending the copy pass.
 *
 * \param command_buffer a command buffer.
 * \returns a copy pass handle.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_BeginGPUCopyPass(command_buffer: SDL_GPUCommandBuffer): SDL_GPUCopyPass; cdecl;
  external LIB_SDL3 name _PU + 'SDL_BeginGPUCopyPass';

(**
 * Uploads data from a transfer buffer to a texture.
 *
 * The upload occurs on the GPU timeline. You may assume that the upload has
 * finished in subsequent commands.
 *
 * You must align the data in the transfer buffer to a multiple of the texel
 * size of the texture format.
 *
 * \param copy_pass a copy pass handle.
 * \param source the source transfer buffer with image layout information.
 * \param destination the destination texture region.
 * \param cycle if true, cycles the texture if the texture is bound, otherwise
 *              overwrites the data.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_UploadToGPUTexture(copy_pass: SDL_GPUCopyPass; const source: PSDL_GPUTextureTransferInfo; const destination: PSDL_GPUTextureRegion; cycle: Boolean); cdecl;
  external LIB_SDL3 name _PU + 'SDL_UploadToGPUTexture';

(**
 * Uploads data from a transfer buffer to a buffer.
 *
 * The upload occurs on the GPU timeline. You may assume that the upload has
 * finished in subsequent commands.
 *
 * \param copy_pass a copy pass handle.
 * \param source the source transfer buffer with offset.
 * \param destination the destination buffer with offset and size.
 * \param cycle if true, cycles the buffer if it is already bound, otherwise
 *              overwrites the data.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_UploadToGPUBuffer(copy_pass: SDL_GPUCopyPass; const source: PSDL_GPUTransferBufferLocation; const destination: PSDL_GPUBufferRegion; cycle: Boolean); cdecl;
  external LIB_SDL3 name _PU + 'SDL_UploadToGPUBuffer';

(**
 * Performs a texture-to-texture copy.
 *
 * This copy occurs on the GPU timeline. You may assume the copy has finished
 * in subsequent commands.
 *
 * \param copy_pass a copy pass handle.
 * \param source a source texture region.
 * \param destination a destination texture region.
 * \param w the width of the region to copy.
 * \param h the height of the region to copy.
 * \param d the depth of the region to copy.
 * \param cycle if true, cycles the destination texture if the destination
 *              texture is bound, otherwise overwrites the data.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_CopyGPUTextureToTexture(copy_pass: SDL_GPUCopyPass; const source: PSDL_GPUTextureLocation; const destination: PSDL_GPUTextureLocation; w: Uint32; h: Uint32; d: Uint32; cycle: Boolean); cdecl;
  external LIB_SDL3 name _PU + 'SDL_CopyGPUTextureToTexture';

(**
 * Performs a buffer-to-buffer copy.
 *
 * This copy occurs on the GPU timeline. You may assume the copy has finished
 * in subsequent commands.
 *
 * \param copy_pass a copy pass handle.
 * \param source the buffer and offset to copy from.
 * \param destination the buffer and offset to copy to.
 * \param size the length of the buffer to copy.
 * \param cycle if true, cycles the destination buffer if it is already bound,
 *              otherwise overwrites the data.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_CopyGPUBufferToBuffer(copy_pass: SDL_GPUCopyPass; const source: PSDL_GPUBufferLocation; const destination: PSDL_GPUBufferLocation; size: Uint32; cycle: Boolean); cdecl;
  external LIB_SDL3 name _PU + 'SDL_CopyGPUBufferToBuffer';

(**
 * Copies data from a texture to a transfer buffer on the GPU timeline.
 *
 * This data is not guaranteed to be copied until the command buffer fence is
 * signaled.
 *
 * \param copy_pass a copy pass handle.
 * \param source the source texture region.
 * \param destination the destination transfer buffer with image layout
 *                    information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_DownloadFromGPUTexture(copy_pass: SDL_GPUCopyPass; const source: PSDL_GPUTextureRegion; const destination: PSDL_GPUTextureTransferInfo); cdecl;
  external LIB_SDL3 name _PU + 'SDL_DownloadFromGPUTexture';

(**
 * Copies data from a buffer to a transfer buffer on the GPU timeline.
 *
 * This data is not guaranteed to be copied until the command buffer fence is
 * signaled.
 *
 * \param copy_pass a copy pass handle.
 * \param source the source buffer with offset and size.
 * \param destination the destination transfer buffer with offset.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_DownloadFromGPUBuffer(copy_pass: SDL_GPUCopyPass; const source: PSDL_GPUBufferRegion; const destination: PSDL_GPUTransferBufferLocation); cdecl;
  external LIB_SDL3 name _PU + 'SDL_DownloadFromGPUBuffer';

(**
 * Ends the current copy pass.
 *
 * \param copy_pass a copy pass handle.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_EndGPUCopyPass(copy_pass: SDL_GPUCopyPass); cdecl;
  external LIB_SDL3 name _PU + 'SDL_EndGPUCopyPass';

(**
 * Generates mipmaps for the given texture.
 *
 * This function must not be called inside of any pass.
 *
 * \param command_buffer a command_buffer.
 * \param texture a texture with more than 1 mip level.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_GenerateMipmapsForGPUTexture(command_buffer: SDL_GPUCommandBuffer; texture: SDL_GPUTexture); cdecl;
  external LIB_SDL3 name _PU + 'SDL_GenerateMipmapsForGPUTexture';

(**
 * Blits from a source texture region to a destination texture region.
 *
 * This function must not be called inside of any pass.
 *
 * \param command_buffer a command buffer.
 * \param info the blit info struct containing the blit parameters.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_BlitGPUTexture(command_buffer: SDL_GPUCommandBuffer; const info: PSDL_GPUBlitInfo); cdecl;
  external LIB_SDL3 name _PU + 'SDL_BlitGPUTexture';

(**
 * Determines whether a swapchain composition is supported by the window.
 *
 * The window must be claimed before calling this function.
 *
 * \param device a GPU context.
 * \param window an SDL_Window.
 * \param swapchain_composition the swapchain composition to check.
 * \returns true if supported, false if unsupported.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_ClaimWindowForGPUDevice
 *)
function SDL_WindowSupportsGPUSwapchainComposition(device: SDL_GPUDevice; window: SDL_Window; swapchain_composition: SDL_GPUSwapchainComposition): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_WindowSupportsGPUSwapchainComposition';

(**
 * Determines whether a presentation mode is supported by the window.
 *
 * The window must be claimed before calling this function.
 *
 * \param device a GPU context.
 * \param window an SDL_Window.
 * \param present_mode the presentation mode to check.
 * \returns true if supported, false if unsupported.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_ClaimWindowForGPUDevice
 *)
function SDL_WindowSupportsGPUPresentMode(device: SDL_GPUDevice; window: SDL_Window; present_mode: SDL_GPUPresentMode): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_WindowSupportsGPUPresentMode';

(**
 * Claims a window, creating a swapchain structure for it.
 *
 * This must be called before SDL_AcquireGPUSwapchainTexture is called using
 * the window. You should only call this function from the thread that created
 * the window.
 *
 * The swapchain will be created with SDL_GPU_SWAPCHAINCOMPOSITION_SDR and
 * SDL_GPU_PRESENTMODE_VSYNC. If you want to have different swapchain
 * parameters, you must call SDL_SetGPUSwapchainParameters after claiming the
 * window.
 *
 * \param device a GPU context.
 * \param window an SDL_Window.
 * \returns true on success, or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called from the thread that
 *               created the window.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_WaitAndAcquireGPUSwapchainTexture
 * \sa SDL_ReleaseWindowFromGPUDevice
 * \sa SDL_WindowSupportsGPUPresentMode
 * \sa SDL_WindowSupportsGPUSwapchainComposition
 *)
function SDL_ClaimWindowForGPUDevice(device: SDL_GPUDevice; window: SDL_Window): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_ClaimWindowForGPUDevice';

(**
 * Unclaims a window, destroying its swapchain structure.
 *
 * \param device a GPU context.
 * \param window an SDL_Window that has been claimed.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_ClaimWindowForGPUDevice
 *)
procedure SDL_ReleaseWindowFromGPUDevice(device: SDL_GPUDevice; window: SDL_Window); cdecl;
  external LIB_SDL3 name _PU + 'SDL_ReleaseWindowFromGPUDevice';

(**
 * Changes the swapchain parameters for the given claimed window.
 *
 * This function will fail if the requested present mode or swapchain
 * composition are unsupported by the device. Check if the parameters are
 * supported via SDL_WindowSupportsGPUPresentMode /
 * SDL_WindowSupportsGPUSwapchainComposition prior to calling this function.
 *
 * SDL_GPU_PRESENTMODE_VSYNC and SDL_GPU_SWAPCHAINCOMPOSITION_SDR are always
 * supported.
 *
 * \param device a GPU context.
 * \param window an SDL_Window that has been claimed.
 * \param swapchain_composition the desired composition of the swapchain.
 * \param present_mode the desired present mode for the swapchain.
 * \returns true if successful, false on error; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_WindowSupportsGPUPresentMode
 * \sa SDL_WindowSupportsGPUSwapchainComposition
 *)
function SDL_SetGPUSwapchainParameters(device: SDL_GPUDevice; window: SDL_Window; swapchain_composition: SDL_GPUSwapchainComposition; present_mode: SDL_GPUPresentMode): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetGPUSwapchainParameters';

(**
 * Configures the maximum allowed number of frames in flight.
 *
 * The default value when the device is created is 2. This means that after
 * you have submitted 2 frames for presentation, if the GPU has not finished
 * working on the first frame, SDL_AcquireGPUSwapchainTexture() will fill the
 * swapchain texture pointer with NULL, and
 * SDL_WaitAndAcquireGPUSwapchainTexture() will block.
 *
 * Higher values increase throughput at the expense of visual latency. Lower
 * values decrease visual latency at the expense of throughput.
 *
 * Note that calling this function will stall and flush the command queue to
 * prevent synchronization issues.
 *
 * The minimum value of allowed frames in flight is 1, and the maximum is 3.
 *
 * \param device a GPU context.
 * \param allowed_frames_in_flight the maximum number of frames that can be
 *                                 pending on the GPU.
 * \returns true if successful, false on error; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_SetGPUAllowedFramesInFlight(device: SDL_GPUDevice; allowed_frames_in_flight: Uint32): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetGPUAllowedFramesInFlight';

(**
 * Obtains the texture format of the swapchain for the given window.
 *
 * Note that this format can change if the swapchain parameters change.
 *
 * \param device a GPU context.
 * \param window an SDL_Window that has been claimed.
 * \returns the texture format of the swapchain.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetGPUSwapchainTextureFormat(device: SDL_GPUDevice; window: SDL_Window): SDL_GPUTextureFormat; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetGPUSwapchainTextureFormat';

(**
 * Acquire a texture to use in presentation.
 *
 * When a swapchain texture is acquired on a command buffer, it will
 * automatically be submitted for presentation when the command buffer is
 * submitted. The swapchain texture should only be referenced by the command
 * buffer used to acquire it.
 *
 * This function will fill the swapchain texture handle with NULL if too many
 * frames are in flight. This is not an error.
 *
 * If you use this function, it is possible to create a situation where many
 * command buffers are allocated while the rendering context waits for the GPU
 * to catch up, which will cause memory usage to grow. You should use
 * SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing
 * with timing.
 *
 * The swapchain texture is managed by the implementation and must not be
 * freed by the user. You MUST NOT call this function from any thread other
 * than the one that created the window.
 *
 * \param command_buffer a command buffer.
 * \param window a window that has been claimed.
 * \param swapchain_texture a pointer filled in with a swapchain texture
 *                          handle.
 * \param swapchain_texture_width a pointer filled in with the swapchain
 *                                texture width, may be NULL.
 * \param swapchain_texture_height a pointer filled in with the swapchain
 *                                 texture height, may be NULL.
 * \returns true on success, false on error; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called from the thread that
 *               created the window.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_ClaimWindowForGPUDevice
 * \sa SDL_SubmitGPUCommandBuffer
 * \sa SDL_SubmitGPUCommandBufferAndAcquireFence
 * \sa SDL_CancelGPUCommandBuffer
 * \sa SDL_GetWindowSizeInPixels
 * \sa SDL_WaitForGPUSwapchain
 * \sa SDL_WaitAndAcquireGPUSwapchainTexture
 * \sa SDL_SetGPUAllowedFramesInFlight
 *)
function SDL_AcquireGPUSwapchainTexture(command_buffer: SDL_GPUCommandBuffer; window: SDL_Window; swapchain_texture: PSDL_GPUTexture; swapchain_texture_width: PUint32; swapchain_texture_height: PUint32): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_AcquireGPUSwapchainTexture';

(**
 * Blocks the thread until a swapchain texture is available to be acquired.
 *
 * \param device a GPU context.
 * \param window a window that has been claimed.
 * \returns true on success, false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called from the thread that
 *               created the window.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_AcquireGPUSwapchainTexture
 * \sa SDL_WaitAndAcquireGPUSwapchainTexture
 * \sa SDL_SetGPUAllowedFramesInFlight
 *)
function SDL_WaitForGPUSwapchain(device: SDL_GPUDevice; window: SDL_Window): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_WaitForGPUSwapchain';

(**
 * Blocks the thread until a swapchain texture is available to be acquired,
 * and then acquires it.
 *
 * When a swapchain texture is acquired on a command buffer, it will
 * automatically be submitted for presentation when the command buffer is
 * submitted. The swapchain texture should only be referenced by the command
 * buffer used to acquire it. It is an error to call
 * SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.
 *
 * This function can fill the swapchain texture handle with NULL in certain
 * cases, for example if the window is minimized. This is not an error. You
 * should always make sure to check whether the pointer is NULL before
 * actually using it.
 *
 * The swapchain texture is managed by the implementation and must not be
 * freed by the user. You MUST NOT call this function from any thread other
 * than the one that created the window.
 *
 * \param command_buffer a command buffer.
 * \param window a window that has been claimed.
 * \param swapchain_texture a pointer filled in with a swapchain texture
 *                          handle.
 * \param swapchain_texture_width a pointer filled in with the swapchain
 *                                texture width, may be NULL.
 * \param swapchain_texture_height a pointer filled in with the swapchain
 *                                 texture height, may be NULL.
 * \returns true on success, false on error; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called from the thread that
 *               created the window.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SubmitGPUCommandBuffer
 * \sa SDL_SubmitGPUCommandBufferAndAcquireFence
 *)
function SDL_WaitAndAcquireGPUSwapchainTexture(command_buffer: SDL_GPUCommandBuffer; window: SDL_Window; swapchain_texture: PSDL_GPUTexture; swapchain_texture_width: PUint32; swapchain_texture_height: PUint32): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_WaitAndAcquireGPUSwapchainTexture';

(**
 * Submits a command buffer so its commands can be processed on the GPU.
 *
 * It is invalid to use the command buffer after this is called.
 *
 * This must be called from the thread the command buffer was acquired on.
 *
 * All commands in the submission are guaranteed to begin executing before any
 * command in a subsequent submission begins executing.
 *
 * \param command_buffer a command buffer.
 * \returns true on success, false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_AcquireGPUCommandBuffer
 * \sa SDL_WaitAndAcquireGPUSwapchainTexture
 * \sa SDL_AcquireGPUSwapchainTexture
 * \sa SDL_SubmitGPUCommandBufferAndAcquireFence
 *)
function SDL_SubmitGPUCommandBuffer(command_buffer: SDL_GPUCommandBuffer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SubmitGPUCommandBuffer';

(**
 * Submits a command buffer so its commands can be processed on the GPU, and
 * acquires a fence associated with the command buffer.
 *
 * You must release this fence when it is no longer needed or it will cause a
 * leak. It is invalid to use the command buffer after this is called.
 *
 * This must be called from the thread the command buffer was acquired on.
 *
 * All commands in the submission are guaranteed to begin executing before any
 * command in a subsequent submission begins executing.
 *
 * \param command_buffer a command buffer.
 * \returns a fence associated with the command buffer, or NULL on failure;
 *          call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_AcquireGPUCommandBuffer
 * \sa SDL_WaitAndAcquireGPUSwapchainTexture
 * \sa SDL_AcquireGPUSwapchainTexture
 * \sa SDL_SubmitGPUCommandBuffer
 * \sa SDL_ReleaseGPUFence
 *)
function SDL_SubmitGPUCommandBufferAndAcquireFence(command_buffer: SDL_GPUCommandBuffer): SDL_GPUFence; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SubmitGPUCommandBufferAndAcquireFence';

(**
 * Cancels a command buffer.
 *
 * None of the enqueued commands are executed.
 *
 * It is an error to call this function after a swapchain texture has been
 * acquired.
 *
 * This must be called from the thread the command buffer was acquired on.
 *
 * You must not reference the command buffer after calling this function.
 *
 * \param command_buffer a command buffer.
 * \returns true on success, false on error; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_WaitAndAcquireGPUSwapchainTexture
 * \sa SDL_AcquireGPUCommandBuffer
 * \sa SDL_AcquireGPUSwapchainTexture
 *)
function SDL_CancelGPUCommandBuffer(command_buffer: SDL_GPUCommandBuffer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_CancelGPUCommandBuffer';

(**
 * Blocks the thread until the GPU is completely idle.
 *
 * \param device a GPU context.
 * \returns true on success, false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_WaitForGPUFences
 *)
function SDL_WaitForGPUIdle(device: SDL_GPUDevice): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_WaitForGPUIdle';

(**
 * Blocks the thread until the given fences are signaled.
 *
 * \param device a GPU context.
 * \param wait_all if 0, wait for any fence to be signaled, if 1, wait for all
 *                 fences to be signaled.
 * \param fences an array of fences to wait on.
 * \param num_fences the number of fences in the fences array.
 * \returns true on success, false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SubmitGPUCommandBufferAndAcquireFence
 * \sa SDL_WaitForGPUIdle
 *)
function SDL_WaitForGPUFences(device: SDL_GPUDevice; wait_all: Boolean; const fences: PSDL_GPUFence; num_fences: Uint32): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_WaitForGPUFences';

(**
 * Checks the status of a fence.
 *
 * \param device a GPU context.
 * \param fence a fence.
 * \returns true if the fence is signaled, false if it is not.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SubmitGPUCommandBufferAndAcquireFence
 *)
function SDL_QueryGPUFence(device: SDL_GPUDevice; fence: SDL_GPUFence): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_QueryGPUFence';

(**
 * Releases a fence obtained from SDL_SubmitGPUCommandBufferAndAcquireFence.
 *
 * \param device a GPU context.
 * \param fence a fence.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SubmitGPUCommandBufferAndAcquireFence
 *)
procedure SDL_ReleaseGPUFence(device: SDL_GPUDevice; fence: SDL_GPUFence); cdecl;
  external LIB_SDL3 name _PU + 'SDL_ReleaseGPUFence';

(**
 * Obtains the texel block size for a texture format.
 *
 * \param format the texture format you want to know the texel size of.
 * \returns the texel block size of the texture format.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_UploadToGPUTexture
 *)
function SDL_GPUTextureFormatTexelBlockSize(format: SDL_GPUTextureFormat): Uint32; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GPUTextureFormatTexelBlockSize';

(**
 * Determines whether a texture format is supported for a given type and
 * usage.
 *
 * \param device a GPU context.
 * \param format the texture format to check.
 * \param type the type of texture (2D, 3D, Cube).
 * \param usage a bitmask of all usage scenarios to check.
 * \returns whether the texture format is supported for this type and usage.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GPUTextureSupportsFormat(device: SDL_GPUDevice; format: SDL_GPUTextureFormat; &type: SDL_GPUTextureType; usage: SDL_GPUTextureUsageFlags): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GPUTextureSupportsFormat';

(**
 * Determines if a sample count for a texture format is supported.
 *
 * \param device a GPU context.
 * \param format the texture format to check.
 * \param sample_count the sample count to check.
 * \returns a hardware-specific version of min(preferred, possible).
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GPUTextureSupportsSampleCount(device: SDL_GPUDevice; format: SDL_GPUTextureFormat; sample_count: SDL_GPUSampleCount): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GPUTextureSupportsSampleCount';

(**
 * Calculate the size in bytes of a texture format with dimensions.
 *
 * \param format a texture format.
 * \param width width in pixels.
 * \param height height in pixels.
 * \param depth_or_layer_count depth for 3D textures or layer count otherwise.
 * \returns the size of a texture with this format and dimensions.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_CalculateGPUTextureFormatSize(format: SDL_GPUTextureFormat; width: Uint32; height: Uint32; depth_or_layer_count: Uint32): Uint32; cdecl;
  external LIB_SDL3 name _PU + 'SDL_CalculateGPUTextureFormatSize';
{$ENDREGION 'SDL_gpu.h'}

{$REGION 'SDL_haptic.h'}
(**
 * # CategoryHaptic
 *
 * The SDL haptic subsystem manages haptic (force feedback) devices.
 *
 * The basic usage is as follows:
 *
 * - Initialize the subsystem (SDL_INIT_HAPTIC).
 * - Open a haptic device.
 * - SDL_OpenHaptic() to open from index.
 * - SDL_OpenHapticFromJoystick() to open from an existing joystick.
 * - Create an effect (SDL_HapticEffect).
 * - Upload the effect with SDL_CreateHapticEffect().
 * - Run the effect with SDL_RunHapticEffect().
 * - (optional) Free the effect with SDL_DestroyHapticEffect().
 * - Close the haptic device with SDL_CloseHaptic().
 *
 * Simple rumble example:
 *
 * ```c
 *    SDL_Haptic *haptic = NULL;
 *
 *    // Open the device
 *    SDL_HapticID *haptics = SDL_GetHaptics(NULL);
 *    if (haptics) {
 *        haptic = SDL_OpenHaptic(haptics[0]);
 *        SDL_free(haptics);
 *    }
 *    if (haptic == NULL)
 *       return;
 *
 *    // Initialize simple rumble
 *    if (!SDL_InitHapticRumble(haptic))
 *       return;
 *
 *    // Play effect at 50% strength for 2 seconds
 *    if (!SDL_PlayHapticRumble(haptic, 0.5, 2000))
 *       return;
 *    SDL_Delay(2000);
 *
 *    // Clean up
 *    SDL_CloseHaptic(haptic);
 * ```
 *
 * Complete example:
 *
 * ```c
 * bool test_haptic(SDL_Joystick *joystick)
 * {
 *    SDL_Haptic *haptic;
 *    SDL_HapticEffect effect;
 *    int effect_id;
 *
 *    // Open the device
 *    haptic = SDL_OpenHapticFromJoystick(joystick);
 *    if (haptic == NULL) return false; // Most likely joystick isn't haptic
 *
 *    // See if it can do sine waves
 *    if ((SDL_GetHapticFeatures(haptic) & SDL_HAPTIC_SINE)==0) {
 *       SDL_CloseHaptic(haptic); // No sine effect
 *       return false;
 *    }
 *
 *    // Create the effect
 *    SDL_memset(&effect, 0, sizeof(SDL_HapticEffect)); // 0 is safe default
 *    effect.type = SDL_HAPTIC_SINE;
 *    effect.periodic.direction.type = SDL_HAPTIC_POLAR; // Polar coordinates
 *    effect.periodic.direction.dir[0] = 18000; // Force comes from south
 *    effect.periodic.period = 1000; // 1000 ms
 *    effect.periodic.magnitude = 20000; // 20000/32767 strength
 *    effect.periodic.length = 5000; // 5 seconds long
 *    effect.periodic.attack_length = 1000; // Takes 1 second to get max strength
 *    effect.periodic.fade_length = 1000; // Takes 1 second to fade away
 *
 *    // Upload the effect
 *    effect_id = SDL_CreateHapticEffect(haptic, &effect);
 *
 *    // Test the effect
 *    SDL_RunHapticEffect(haptic, effect_id, 1);
 *    SDL_Delay(5000); // Wait for the effect to finish
 *
 *    // We destroy the effect, although closing the device also does this
 *    SDL_DestroyHapticEffect(haptic, effect_id);
 *
 *    // Close the device
 *    SDL_CloseHaptic(haptic);
 *
 *    return true; // Success
 * }
 * ```
 *
 * Note that the SDL haptic subsystem is not thread-safe.
 *)

type
  (**
   * The haptic structure used to identify an SDL haptic.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_OpenHaptic
   * \sa SDL_OpenHapticFromJoystick
   * \sa SDL_CloseHaptic
   *)
  SDL_Haptic = THandle;

const
  (**
   * Constant effect supported.
   *
   * Constant haptic effect.
   *
   * \since This macro is available since SDL 3.2.0.
   *
   * \sa SDL_HapticCondition
   *)
  SDL_HAPTIC_CONSTANT = (1 shl 0);

  (**
   * Sine wave effect supported.
   *
   * Periodic haptic effect that simulates sine waves.
   *
   * \since This macro is available since SDL 3.2.0.
   *
   * \sa SDL_HapticPeriodic
   *)
  SDL_HAPTIC_SINE = (1 shl 1);

  (**
   * Square wave effect supported.
   *
   * Periodic haptic effect that simulates square waves.
   *
   * \since This macro is available since SDL 3.2.0.
   *
   * \sa SDL_HapticPeriodic
   *)
  SDL_HAPTIC_SQUARE = (1 shl 2);

  (**
   * Triangle wave effect supported.
   *
   * Periodic haptic effect that simulates triangular waves.
   *
   * \since This macro is available since SDL 3.2.0.
   *
   * \sa SDL_HapticPeriodic
   *)
  SDL_HAPTIC_TRIANGLE = (1 shl 3);

  (**
   * Sawtoothup wave effect supported.
   *
   * Periodic haptic effect that simulates saw tooth up waves.
   *
   * \since This macro is available since SDL 3.2.0.
   *
   * \sa SDL_HapticPeriodic
   *)
  SDL_HAPTIC_SAWTOOTHUP = (1 shl 4);

  (**
   * Sawtoothdown wave effect supported.
   *
   * Periodic haptic effect that simulates saw tooth down waves.
   *
   * \since This macro is available since SDL 3.2.0.
   *
   * \sa SDL_HapticPeriodic
   *)
  SDL_HAPTIC_SAWTOOTHDOWN = (1 shl 5);

  (**
   * Ramp effect supported.
   *
   * Ramp haptic effect.
   *
   * \since This macro is available since SDL 3.2.0.
   *
   * \sa SDL_HapticRamp
   *)
  SDL_HAPTIC_RAMP = (1 shl 6);

  (**
   * Spring effect supported - uses axes position.
   *
   * Condition haptic effect that simulates a spring. Effect is based on the
   * axes position.
   *
   * \since This macro is available since SDL 3.2.0.
   *
   * \sa SDL_HapticCondition
   *)
  SDL_HAPTIC_SPRING = (1 shl 7);

  (**
   * Damper effect supported - uses axes velocity.
   *
   * Condition haptic effect that simulates dampening. Effect is based on the
   * axes velocity.
   *
   * \since This macro is available since SDL 3.2.0.
   *
   * \sa SDL_HapticCondition
   *)
  SDL_HAPTIC_DAMPER = (1 shl 8);

  (**
   * Inertia effect supported - uses axes acceleration.
   *
   * Condition haptic effect that simulates inertia. Effect is based on the axes
   * acceleration.
   *
   * \since This macro is available since SDL 3.2.0.
   *
   * \sa SDL_HapticCondition
   *)
  SDL_HAPTIC_INERTIA = (1 shl 9);

  (**
   * Friction effect supported - uses axes movement.
   *
   * Condition haptic effect that simulates friction. Effect is based on the
   * axes movement.
   *
   * \since This macro is available since SDL 3.2.0.
   *
   * \sa SDL_HapticCondition
   *)
  SDL_HAPTIC_FRICTION = (1 shl 10);

  (**
   * Left/Right effect supported.
   *
   * Haptic effect for direct control over high/low frequency motors.
   *
   * \since This macro is available since SDL 3.2.0.
   *
   * \sa SDL_HapticLeftRight
   *)
  SDL_HAPTIC_LEFTRIGHT = (1 shl 11);

  (**
   * Reserved for future use.
   *
   * \since This macro is available since SDL 3.2.0.
   *)
  SDL_HAPTIC_RESERVED1 = (1 shl 12);

  (**
   * Reserved for future use.
   *
   * \since This macro is available since SDL 3.2.0.
   *)
  SDL_HAPTIC_RESERVED2 = (1 shl 13);

  (**
   * Reserved for future use.
   *
   * \since This macro is available since SDL 3.2.0.
   *)
  SDL_HAPTIC_RESERVED3 = (1 shl 14);

  (**
   * Custom effect is supported.
   *
   * User defined custom haptic effect.
   *
   * \since This macro is available since SDL 3.2.0.
   *)
  SDL_HAPTIC_CUSTOM = (1 shl 15);

  (**
   * Device can set global gain.
   *
   * Device supports setting the global gain.
   *
   * \since This macro is available since SDL 3.2.0.
   *
   * \sa SDL_SetHapticGain
   *)
  SDL_HAPTIC_GAIN = (1 shl 16);

  (**
   * Device can set autocenter.
   *
   * Device supports setting autocenter.
   *
   * \since This macro is available since SDL 3.2.0.
   *
   * \sa SDL_SetHapticAutocenter
   *)
  SDL_HAPTIC_AUTOCENTER = (1 shl 17);

  (**
   * Device can be queried for effect status.
   *
   * Device supports querying effect status.
   *
   * \since This macro is available since SDL 3.2.0.
   *
   * \sa SDL_GetHapticEffectStatus
   *)
  SDL_HAPTIC_STATUS = (1 shl 18);

  (**
   * Device can be paused.
   *
   * Devices supports being paused.
   *
   * \since This macro is available since SDL 3.2.0.
   *
   * \sa SDL_PauseHaptic
   * \sa SDL_ResumeHaptic
   *)
  SDL_HAPTIC_PAUSE = (1 shl 19);

  (**
   * Uses polar coordinates for the direction.
   *
   * \since This macro is available since SDL 3.2.0.
   *
   * \sa SDL_HapticDirection
   *)
  SDL_HAPTIC_POLAR = 0;

  (**
   * Uses cartesian coordinates for the direction.
   *
   * \since This macro is available since SDL 3.2.0.
   *
   * \sa SDL_HapticDirection
   *)
  SDL_HAPTIC_CARTESIAN = 1;

  (**
   * Uses spherical coordinates for the direction.
   *
   * \since This macro is available since SDL 3.2.0.
   *
   * \sa SDL_HapticDirection
   *)
  SDL_HAPTIC_SPHERICAL = 2;

  (**
   * Use this value to play an effect on the steering wheel axis.
   *
   * This provides better compatibility across platforms and devices as SDL will
   * guess the correct axis.
   *
   * \since This macro is available since SDL 3.2.0.
   *
   * \sa SDL_HapticDirection
   *)
  SDL_HAPTIC_STEERING_AXIS = 3;

  (**
   * Used to play a device an infinite number of times.
   *
   * \since This macro is available since SDL 3.2.0.
   *
   * \sa SDL_RunHapticEffect
   *)
  SDL_HAPTIC_INFINITY = 4294967295;

type
  (**
   * Structure that represents a haptic direction.
   *
   * This is the direction where the force comes from, instead of the direction
   * in which the force is exerted.
   *
   * Directions can be specified by:
   *
   * - SDL_HAPTIC_POLAR : Specified by polar coordinates.
   * - SDL_HAPTIC_CARTESIAN : Specified by cartesian coordinates.
   * - SDL_HAPTIC_SPHERICAL : Specified by spherical coordinates.
   *
   * Cardinal directions of the haptic device are relative to the positioning of
   * the device. North is considered to be away from the user.
   *
   * The following diagram represents the cardinal directions:
   *
   * ```
   *                .--.
   *                |__| .-------.
   *                |=.| |.-----.|
   *                |--| ||     ||
   *                |  | |'-----'|
   *                |__|~')_____('
   *                  [ COMPUTER ]
   *
   *
   *                    North (0,-1)
   *                        ^
   *                        |
   *                        |
   *  (-1,0)  West <----[ HAPTIC ]----> East (1,0)
   *                        |
   *                        |
   *                        v
   *                     South (0,1)
   *
   *
   *                     [ USER ]
   *                       \|||/
   *                       (o o)
   *                 ---ooO-(_)-Ooo---
   * ```
   *
   * If type is SDL_HAPTIC_POLAR, direction is encoded by hundredths of a degree
   * starting north and turning clockwise. SDL_HAPTIC_POLAR only uses the first
   * `dir` parameter. The cardinal directions would be:
   *
   * - North: 0 (0 degrees)
   * - East: 9000 (90 degrees)
   * - South: 18000 (180 degrees)
   * - West: 27000 (270 degrees)
   *
   * If type is SDL_HAPTIC_CARTESIAN, direction is encoded by three positions (X
   * axis, Y axis and Z axis (with 3 axes)). SDL_HAPTIC_CARTESIAN uses the first
   * three `dir` parameters. The cardinal directions would be:
   *
   * - North: 0,-1, 0
   * - East: 1, 0, 0
   * - South: 0, 1, 0
   * - West: -1, 0, 0
   *
   * The Z axis represents the height of the effect if supported, otherwise it's
   * unused. In cartesian encoding (1, 2) would be the same as (2, 4), you can
   * use any multiple you want, only the direction matters.
   *
   * If type is SDL_HAPTIC_SPHERICAL, direction is encoded by two rotations. The
   * first two `dir` parameters are used. The `dir` parameters are as follows
   * (all values are in hundredths of degrees):
   *
   * - Degrees from (1, 0) rotated towards (0, 1).
   * - Degrees towards (0, 0, 1) (device needs at least 3 axes).
   *
   * Example of force coming from the south with all encodings (force coming
   * from the south means the user will have to pull the stick to counteract):
   *
   * ```c
   *  SDL_HapticDirection direction;
   *
   *  // Cartesian directions
   *  direction.type = SDL_HAPTIC_CARTESIAN; // Using cartesian direction encoding.
   *  direction.dir[0] = 0; // X position
   *  direction.dir[1] = 1; // Y position
   *  // Assuming the device has 2 axes, we don't need to specify third parameter.
   *
   *  // Polar directions
   *  direction.type = SDL_HAPTIC_POLAR; // We'll be using polar direction encoding.
   *  direction.dir[0] = 18000; // Polar only uses first parameter
   *
   *  // Spherical coordinates
   *  direction.type = SDL_HAPTIC_SPHERICAL; // Spherical encoding
   *  direction.dir[0] = 9000; // Since we only have two axes we don't need more parameters.
   * ```
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_HAPTIC_POLAR
   * \sa SDL_HAPTIC_CARTESIAN
   * \sa SDL_HAPTIC_SPHERICAL
   * \sa SDL_HAPTIC_STEERING_AXIS
   * \sa SDL_HapticEffect
   * \sa SDL_GetNumHapticAxes
   *)
  SDL_HapticDirection = record
    (** The type of encoding. *)
    &type: Uint8;
    (** The encoded direction. *)
    dir: array [0..2] of Sint32;
  end;

  (**
   * A structure containing a template for a Constant effect.
   *
   * This struct is exclusively for the SDL_HAPTIC_CONSTANT effect.
   *
   * A constant effect applies a constant force in the specified direction to
   * the joystick.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_HAPTIC_CONSTANT
   * \sa SDL_HapticEffect
   *)
  SDL_HapticConstant = record
    (** SDL_HAPTIC_CONSTANT *)
    &type: Uint16;
    (** Direction of the effect. *)
    direction: SDL_HapticDirection;
    (** Duration of the effect. *)
    length: Uint32;
    (** Delay before starting the effect. *)
    delay: Uint16;
    (** Button that triggers the effect. *)
    button: Uint16;
    (** How soon it can be triggered again after button. *)
    interval: Uint16;
    (** Strength of the constant effect. *)
    level: Sint16;
    (** Duration of the attack. *)
    attack_length: Uint16;
    (** Level at the start of the attack. *)
    attack_level: Uint16;
    (** Duration of the fade. *)
    fade_length: Uint16;
    (** Level at the end of the fade. *)
    fade_level: Uint16;
  end;

  (**
   * A structure containing a template for a Periodic effect.
   *
   * The struct handles the following effects:
   *
   * - SDL_HAPTIC_SINE
   * - SDL_HAPTIC_SQUARE
   * - SDL_HAPTIC_TRIANGLE
   * - SDL_HAPTIC_SAWTOOTHUP
   * - SDL_HAPTIC_SAWTOOTHDOWN
   *
   * A periodic effect consists in a wave-shaped effect that repeats itself over
   * time. The type determines the shape of the wave and the parameters
   * determine the dimensions of the wave.
   *
   * Phase is given by hundredth of a degree meaning that giving the phase a
   * value of 9000 will displace it 25% of its period. Here are sample values:
   *
   * - 0: No phase displacement.
   * - 9000: Displaced 25% of its period.
   * - 18000: Displaced 50% of its period.
   * - 27000: Displaced 75% of its period.
   * - 36000: Displaced 100% of its period, same as 0, but 0 is preferred.
   *
   * Examples:
   *
   * ```
   *   SDL_HAPTIC_SINE
   *     __      __      __      __
   *    /  \    /  \    /  \    /
   *   /    \__/    \__/    \__/
   *
   *   SDL_HAPTIC_SQUARE
   *    __    __    __    __    __
   *   |  |  |  |  |  |  |  |  |  |
   *   |  |__|  |__|  |__|  |__|  |
   *
   *   SDL_HAPTIC_TRIANGLE
   *     /\    /\    /\    /\    /\
   *    /  \  /  \  /  \  /  \  /
   *   /    \/    \/    \/    \/
   *
   *   SDL_HAPTIC_SAWTOOTHUP
   *     /|  /|  /|  /|  /|  /|  /|
   *    / | / | / | / | / | / | / |
   *   /  |/  |/  |/  |/  |/  |/  |
   *
   *   SDL_HAPTIC_SAWTOOTHDOWN
   *   \  |\  |\  |\  |\  |\  |\  |
   *    \ | \ | \ | \ | \ | \ | \ |
   *     \|  \|  \|  \|  \|  \|  \|
   * ```
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_HAPTIC_SINE
   * \sa SDL_HAPTIC_SQUARE
   * \sa SDL_HAPTIC_TRIANGLE
   * \sa SDL_HAPTIC_SAWTOOTHUP
   * \sa SDL_HAPTIC_SAWTOOTHDOWN
   * \sa SDL_HapticEffect
   *)
  SDL_HapticPeriodic = record
    (** SDL_HAPTIC_SINE, SDL_HAPTIC_SQUARE
                                 SDL_HAPTIC_TRIANGLE, SDL_HAPTIC_SAWTOOTHUP or
                                 SDL_HAPTIC_SAWTOOTHDOWN *)
    &type: Uint16;
    (** Direction of the effect. *)
    direction: SDL_HapticDirection;
    (** Duration of the effect. *)
    length: Uint32;
    (** Delay before starting the effect. *)
    delay: Uint16;
    (** Button that triggers the effect. *)
    button: Uint16;
    (** How soon it can be triggered again after button. *)
    interval: Uint16;
    (** Period of the wave. *)
    period: Uint16;
    (** Peak value; if negative, equivalent to 180 degrees extra phase shift. *)
    magnitude: Sint16;
    (** Mean value of the wave. *)
    offset: Sint16;
    (** Positive phase shift given by hundredth of a degree. *)
    phase: Uint16;
    (** Duration of the attack. *)
    attack_length: Uint16;
    (** Level at the start of the attack. *)
    attack_level: Uint16;
    (** Duration of the fade. *)
    fade_length: Uint16;
    (** Level at the end of the fade. *)
    fade_level: Uint16;
  end;

  (**
   * A structure containing a template for a Condition effect.
   *
   * The struct handles the following effects:
   *
   * - SDL_HAPTIC_SPRING: Effect based on axes position.
   * - SDL_HAPTIC_DAMPER: Effect based on axes velocity.
   * - SDL_HAPTIC_INERTIA: Effect based on axes acceleration.
   * - SDL_HAPTIC_FRICTION: Effect based on axes movement.
   *
   * Direction is handled by condition internals instead of a direction member.
   * The condition effect specific members have three parameters. The first
   * refers to the X axis, the second refers to the Y axis and the third refers
   * to the Z axis. The right terms refer to the positive side of the axis and
   * the left terms refer to the negative side of the axis. Please refer to the
   * SDL_HapticDirection diagram for which side is positive and which is
   * negative.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_HapticDirection
   * \sa SDL_HAPTIC_SPRING
   * \sa SDL_HAPTIC_DAMPER
   * \sa SDL_HAPTIC_INERTIA
   * \sa SDL_HAPTIC_FRICTION
   * \sa SDL_HapticEffect
   *)
  SDL_HapticCondition = record
    (** SDL_HAPTIC_SPRING, SDL_HAPTIC_DAMPER,
                                     SDL_HAPTIC_INERTIA or SDL_HAPTIC_FRICTION *)
    &type: Uint16;
    (** Direction of the effect. *)
    direction: SDL_HapticDirection;
    (** Duration of the effect. *)
    length: Uint32;
    (** Delay before starting the effect. *)
    delay: Uint16;
    (** Button that triggers the effect. *)
    button: Uint16;
    (** How soon it can be triggered again after button. *)
    interval: Uint16;
    (** Level when joystick is to the positive side; max 0xFFFF. *)
    right_sat: array [0..2] of Uint16;
    (** Level when joystick is to the negative side; max 0xFFFF. *)
    left_sat: array [0..2] of Uint16;
    (** How fast to increase the force towards the positive side. *)
    right_coeff: array [0..2] of Sint16;
    (** How fast to increase the force towards the negative side. *)
    left_coeff: array [0..2] of Sint16;
    (** Size of the dead zone; max 0xFFFF: whole axis-range when 0-centered. *)
    deadband: array [0..2] of Uint16;
    (** Position of the dead zone. *)
    center: array [0..2] of Sint16;
  end;

  (**
   * A structure containing a template for a Ramp effect.
   *
   * This struct is exclusively for the SDL_HAPTIC_RAMP effect.
   *
   * The ramp effect starts at start strength and ends at end strength. It
   * augments in linear fashion. If you use attack and fade with a ramp the
   * effects get added to the ramp effect making the effect become quadratic
   * instead of linear.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_HAPTIC_RAMP
   * \sa SDL_HapticEffect
   *)
  SDL_HapticRamp = record
    (** SDL_HAPTIC_RAMP *)
    &type: Uint16;
    (** Direction of the effect. *)
    direction: SDL_HapticDirection;
    (** Duration of the effect. *)
    length: Uint32;
    (** Delay before starting the effect. *)
    delay: Uint16;
    (** Button that triggers the effect. *)
    button: Uint16;
    (** How soon it can be triggered again after button. *)
    interval: Uint16;
    (** Beginning strength level. *)
    start: Sint16;
    (** Ending strength level. *)
    &end: Sint16;
    (** Duration of the attack. *)
    attack_length: Uint16;
    (** Level at the start of the attack. *)
    attack_level: Uint16;
    (** Duration of the fade. *)
    fade_length: Uint16;
    (** Level at the end of the fade. *)
    fade_level: Uint16;
  end;

  (**
   * A structure containing a template for a Left/Right effect.
   *
   * This struct is exclusively for the SDL_HAPTIC_LEFTRIGHT effect.
   *
   * The Left/Right effect is used to explicitly control the large and small
   * motors, commonly found in modern game controllers. The small (right) motor
   * is high frequency, and the large (left) motor is low frequency.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_HAPTIC_LEFTRIGHT
   * \sa SDL_HapticEffect
   *)
  SDL_HapticLeftRight = record
    (** SDL_HAPTIC_LEFTRIGHT *)
    &type: Uint16;
    (** Duration of the effect in milliseconds. *)
    length: Uint32;
    (** Control of the large controller motor. *)
    large_magnitude: Uint16;
    (** Control of the small controller motor. *)
    small_magnitude: Uint16;
  end;

  (**
   * A structure containing a template for the SDL_HAPTIC_CUSTOM effect.
   *
   * This struct is exclusively for the SDL_HAPTIC_CUSTOM effect.
   *
   * A custom force feedback effect is much like a periodic effect, where the
   * application can define its exact shape. You will have to allocate the data
   * yourself. Data should consist of channels * samples Uint16 samples.
   *
   * If channels is one, the effect is rotated using the defined direction.
   * Otherwise it uses the samples in data for the different axes.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_HAPTIC_CUSTOM
   * \sa SDL_HapticEffect
   *)
  SDL_HapticCustom = record
    (** SDL_HAPTIC_CUSTOM *)
    &type: Uint16;
    (** Direction of the effect. *)
    direction: SDL_HapticDirection;
    (** Duration of the effect. *)
    length: Uint32;
    (** Delay before starting the effect. *)
    delay: Uint16;
    (** Button that triggers the effect. *)
    button: Uint16;
    (** How soon it can be triggered again after button. *)
    interval: Uint16;
    (** Axes to use, minimum of one. *)
    channels: Uint8;
    (** Sample periods. *)
    period: Uint16;
    (** Amount of samples. *)
    samples: Uint16;
    (** Should contain channels*samples items. *)
    data: System.PWord;
    (** Duration of the attack. *)
    attack_length: Uint16;
    (** Level at the start of the attack. *)
    attack_level: Uint16;
    (** Duration of the fade. *)
    fade_length: Uint16;
    (** Level at the end of the fade. *)
    fade_level: Uint16;
  end;

  (**
   * The generic template for any haptic effect.
   *
   * All values max at 32767 (0x7FFF). Signed values also can be negative. Time
   * values unless specified otherwise are in milliseconds.
   *
   * You can also pass SDL_HAPTIC_INFINITY to length instead of a 0-32767 value.
   * Neither delay, interval, attack_length nor fade_length support
   * SDL_HAPTIC_INFINITY. Fade will also not be used since effect never ends.
   *
   * Additionally, the SDL_HAPTIC_RAMP effect does not support a duration of
   * SDL_HAPTIC_INFINITY.
   *
   * Button triggers may not be supported on all devices, it is advised to not
   * use them if possible. Buttons start at index 1 instead of index 0 like the
   * joystick.
   *
   * If both attack_length and fade_level are 0, the envelope is not used,
   * otherwise both values are used.
   *
   * Common parts:
   *
   * ```c
   *  // Replay - All effects have this
   *  Uint32 length;        // Duration of effect (ms).
   *  Uint16 delay;         // Delay before starting effect.
   *
   *  // Trigger - All effects have this
   *  Uint16 button;        // Button that triggers effect.
   *  Uint16 interval;      // How soon before effect can be triggered again.
   *
   *  // Envelope - All effects except condition effects have this
   *  Uint16 attack_length; // Duration of the attack (ms).
   *  Uint16 attack_level;  // Level at the start of the attack.
   *  Uint16 fade_length;   // Duration of the fade out (ms).
   *  Uint16 fade_level;    // Level at the end of the fade.
   * ```
   *
   * Here we have an example of a constant effect evolution in time:
   *
   * ```
   *  Strength
   *  ^
   *  |
   *  |    effect level -->  _________________
   *  |                     /                 \
   *  |                    /                   \
   *  |                   /                     \
   *  |                  /                       \
   *  | attack_level --> |                        \
   *  |                  |                        |  <---  fade_level
   *  |
   *  +--------------------------------------------------> Time
   *                     [--]                 [---]
   *                     attack_length        fade_length
   *
   *  [------------------][-----------------------]
   *  delay               length
   * ```
   *
   * Note either the attack_level or the fade_level may be above the actual
   * effect level.
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_HapticConstant
   * \sa SDL_HapticPeriodic
   * \sa SDL_HapticCondition
   * \sa SDL_HapticRamp
   * \sa SDL_HapticLeftRight
   * \sa SDL_HapticCustom
   *)
  SDL_HapticEffect = record
    case Integer of
      0: ((** Effect type. *)
    &type: Uint16);
      1: ((** Constant effect. *)
    constant: SDL_HapticConstant);
      2: ((** Periodic effect. *)
    periodic: SDL_HapticPeriodic);
      3: ((** Condition effect. *)
    condition: SDL_HapticCondition);
      4: ((** Ramp effect. *)
    ramp: SDL_HapticRamp);
      5: ((** Left/Right effect. *)
    leftright: SDL_HapticLeftRight);
      6: ((** Custom effect. *)
    custom: SDL_HapticCustom);
  end;
  PSDL_HapticEffect = ^SDL_HapticEffect;

  (**
   * This is a unique ID for a haptic device for the time it is connected to the
   * system, and is never reused for the lifetime of the application.
   *
   * If the haptic device is disconnected and reconnected, it will get a new ID.
   *
   * The value 0 is an invalid ID.
   *
   * \since This datatype is available since SDL 3.2.0.
   *)
  SDL_HapticID = Uint32;
  PSDL_HapticID = ^SDL_HapticID;

(**
 * Get a list of currently connected haptic devices.
 *
 * \param count a pointer filled in with the number of haptic devices
 *              returned, may be NULL.
 * \returns a 0 terminated array of haptic device instance IDs or NULL on
 *          failure; call SDL_GetError() for more information. This should be
 *          freed with SDL_free() when it is no longer needed.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_OpenHaptic
 *)
function SDL_GetHaptics(count: PInteger): PSDL_HapticID; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetHaptics';

(**
 * Get the implementation dependent name of a haptic device.
 *
 * This can be called before any haptic devices are opened.
 *
 * \param instance_id the haptic device instance ID.
 * \returns the name of the selected haptic device. If no name can be found,
 *          this function returns NULL; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetHapticName
 * \sa SDL_OpenHaptic
 *)
function SDL_GetHapticNameForID(instance_id: SDL_HapticID): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetHapticNameForID';

(**
 * Open a haptic device for use.
 *
 * The index passed as an argument refers to the N'th haptic device on this
 * system.
 *
 * When opening a haptic device, its gain will be set to maximum and
 * autocenter will be disabled. To modify these values use SDL_SetHapticGain()
 * and SDL_SetHapticAutocenter().
 *
 * \param instance_id the haptic device instance ID.
 * \returns the device identifier or NULL on failure; call SDL_GetError() for
 *          more information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CloseHaptic
 * \sa SDL_GetHaptics
 * \sa SDL_OpenHapticFromJoystick
 * \sa SDL_OpenHapticFromMouse
 * \sa SDL_SetHapticAutocenter
 * \sa SDL_SetHapticGain
 *)
function SDL_OpenHaptic(instance_id: SDL_HapticID): SDL_Haptic; cdecl;
  external LIB_SDL3 name _PU + 'SDL_OpenHaptic';

(**
 * Get the SDL_Haptic associated with an instance ID, if it has been opened.
 *
 * \param instance_id the instance ID to get the SDL_Haptic for.
 * \returns an SDL_Haptic on success or NULL on failure or if it hasn't been
 *          opened yet; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetHapticFromID(instance_id: SDL_HapticID): SDL_Haptic; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetHapticFromID';

(**
 * Get the instance ID of an opened haptic device.
 *
 * \param haptic the SDL_Haptic device to query.
 * \returns the instance ID of the specified haptic device on success or 0 on
 *          failure; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetHapticID(haptic: SDL_Haptic): SDL_HapticID; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetHapticID';

(**
 * Get the implementation dependent name of a haptic device.
 *
 * \param haptic the SDL_Haptic obtained from SDL_OpenJoystick().
 * \returns the name of the selected haptic device. If no name can be found,
 *          this function returns NULL; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetHapticNameForID
 *)
function SDL_GetHapticName(haptic: SDL_Haptic): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetHapticName';

(**
 * Query whether or not the current mouse has haptic capabilities.
 *
 * \returns true if the mouse is haptic or false if it isn't.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_OpenHapticFromMouse
 *)
function SDL_IsMouseHaptic(): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_IsMouseHaptic';

(**
 * Try to open a haptic device from the current mouse.
 *
 * \returns the haptic device identifier or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CloseHaptic
 * \sa SDL_IsMouseHaptic
 *)
function SDL_OpenHapticFromMouse(): SDL_Haptic; cdecl;
  external LIB_SDL3 name _PU + 'SDL_OpenHapticFromMouse';

(**
 * Query if a joystick has haptic features.
 *
 * \param joystick the SDL_Joystick to test for haptic capabilities.
 * \returns true if the joystick is haptic or false if it isn't.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_OpenHapticFromJoystick
 *)
function SDL_IsJoystickHaptic(joystick: SDL_Joystick): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_IsJoystickHaptic';

(**
 * Open a haptic device for use from a joystick device.
 *
 * You must still close the haptic device separately. It will not be closed
 * with the joystick.
 *
 * When opened from a joystick you should first close the haptic device before
 * closing the joystick device. If not, on some implementations the haptic
 * device will also get unallocated and you'll be unable to use force feedback
 * on that device.
 *
 * \param joystick the SDL_Joystick to create a haptic device from.
 * \returns a valid haptic device identifier on success or NULL on failure;
 *          call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CloseHaptic
 * \sa SDL_IsJoystickHaptic
 *)
function SDL_OpenHapticFromJoystick(joystick: SDL_Joystick): SDL_Haptic; cdecl;
  external LIB_SDL3 name _PU + 'SDL_OpenHapticFromJoystick';

(**
 * Close a haptic device previously opened with SDL_OpenHaptic().
 *
 * \param haptic the SDL_Haptic device to close.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_OpenHaptic
 *)
procedure SDL_CloseHaptic(haptic: SDL_Haptic); cdecl;
  external LIB_SDL3 name _PU + 'SDL_CloseHaptic';

(**
 * Get the number of effects a haptic device can store.
 *
 * On some platforms this isn't fully supported, and therefore is an
 * approximation. Always check to see if your created effect was actually
 * created and do not rely solely on SDL_GetMaxHapticEffects().
 *
 * \param haptic the SDL_Haptic device to query.
 * \returns the number of effects the haptic device can store or a negative
 *          error code on failure; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetMaxHapticEffectsPlaying
 * \sa SDL_GetHapticFeatures
 *)
function SDL_GetMaxHapticEffects(haptic: SDL_Haptic): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetMaxHapticEffects';

(**
 * Get the number of effects a haptic device can play at the same time.
 *
 * This is not supported on all platforms, but will always return a value.
 *
 * \param haptic the SDL_Haptic device to query maximum playing effects.
 * \returns the number of effects the haptic device can play at the same time
 *          or -1 on failure; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetMaxHapticEffects
 * \sa SDL_GetHapticFeatures
 *)
function SDL_GetMaxHapticEffectsPlaying(haptic: SDL_Haptic): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetMaxHapticEffectsPlaying';

(**
 * Get the haptic device's supported features in bitwise manner.
 *
 * \param haptic the SDL_Haptic device to query.
 * \returns a list of supported haptic features in bitwise manner (OR'd), or 0
 *          on failure; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_HapticEffectSupported
 * \sa SDL_GetMaxHapticEffects
 *)
function SDL_GetHapticFeatures(haptic: SDL_Haptic): Uint32; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetHapticFeatures';

(**
 * Get the number of haptic axes the device has.
 *
 * The number of haptic axes might be useful if working with the
 * SDL_HapticDirection effect.
 *
 * \param haptic the SDL_Haptic device to query.
 * \returns the number of axes on success or -1 on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetNumHapticAxes(haptic: SDL_Haptic): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetNumHapticAxes';

(**
 * Check to see if an effect is supported by a haptic device.
 *
 * \param haptic the SDL_Haptic device to query.
 * \param effect the desired effect to query.
 * \returns true if the effect is supported or false if it isn't.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CreateHapticEffect
 * \sa SDL_GetHapticFeatures
 *)
function SDL_HapticEffectSupported(haptic: SDL_Haptic; const effect: PSDL_HapticEffect): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_HapticEffectSupported';

(**
 * Create a new haptic effect on a specified device.
 *
 * \param haptic an SDL_Haptic device to create the effect on.
 * \param effect an SDL_HapticEffect structure containing the properties of
 *               the effect to create.
 * \returns the ID of the effect on success or -1 on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_DestroyHapticEffect
 * \sa SDL_RunHapticEffect
 * \sa SDL_UpdateHapticEffect
 *)
function SDL_CreateHapticEffect(haptic: SDL_Haptic; const effect: PSDL_HapticEffect): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_CreateHapticEffect';

(**
 * Update the properties of an effect.
 *
 * Can be used dynamically, although behavior when dynamically changing
 * direction may be strange. Specifically the effect may re-upload itself and
 * start playing from the start. You also cannot change the type either when
 * running SDL_UpdateHapticEffect().
 *
 * \param haptic the SDL_Haptic device that has the effect.
 * \param effect the identifier of the effect to update.
 * \param data an SDL_HapticEffect structure containing the new effect
 *             properties to use.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CreateHapticEffect
 * \sa SDL_RunHapticEffect
 *)
function SDL_UpdateHapticEffect(haptic: SDL_Haptic; effect: Integer; const data: PSDL_HapticEffect): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_UpdateHapticEffect';

(**
 * Run the haptic effect on its associated haptic device.
 *
 * To repeat the effect over and over indefinitely, set `iterations` to
 * `SDL_HAPTIC_INFINITY`. (Repeats the envelope - attack and fade.) To make
 * one instance of the effect last indefinitely (so the effect does not fade),
 * set the effect's `length` in its structure/union to `SDL_HAPTIC_INFINITY`
 * instead.
 *
 * \param haptic the SDL_Haptic device to run the effect on.
 * \param effect the ID of the haptic effect to run.
 * \param iterations the number of iterations to run the effect; use
 *                   `SDL_HAPTIC_INFINITY` to repeat forever.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetHapticEffectStatus
 * \sa SDL_StopHapticEffect
 * \sa SDL_StopHapticEffects
 *)
function SDL_RunHapticEffect(haptic: SDL_Haptic; effect: Integer; iterations: Uint32): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_RunHapticEffect';

(**
 * Stop the haptic effect on its associated haptic device.
 *
 * \param haptic the SDL_Haptic device to stop the effect on.
 * \param effect the ID of the haptic effect to stop.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_RunHapticEffect
 * \sa SDL_StopHapticEffects
 *)
function SDL_StopHapticEffect(haptic: SDL_Haptic; effect: Integer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_StopHapticEffect';

(**
 * Destroy a haptic effect on the device.
 *
 * This will stop the effect if it's running. Effects are automatically
 * destroyed when the device is closed.
 *
 * \param haptic the SDL_Haptic device to destroy the effect on.
 * \param effect the ID of the haptic effect to destroy.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CreateHapticEffect
 *)
procedure SDL_DestroyHapticEffect(haptic: SDL_Haptic; effect: Integer); cdecl;
  external LIB_SDL3 name _PU + 'SDL_DestroyHapticEffect';

(**
 * Get the status of the current effect on the specified haptic device.
 *
 * Device must support the SDL_HAPTIC_STATUS feature.
 *
 * \param haptic the SDL_Haptic device to query for the effect status on.
 * \param effect the ID of the haptic effect to query its status.
 * \returns true if it is playing, false if it isn't playing or haptic status
 *          isn't supported.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetHapticFeatures
 *)
function SDL_GetHapticEffectStatus(haptic: SDL_Haptic; effect: Integer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetHapticEffectStatus';

(**
 * Set the global gain of the specified haptic device.
 *
 * Device must support the SDL_HAPTIC_GAIN feature.
 *
 * The user may specify the maximum gain by setting the environment variable
 * `SDL_HAPTIC_GAIN_MAX` which should be between 0 and 100. All calls to
 * SDL_SetHapticGain() will scale linearly using `SDL_HAPTIC_GAIN_MAX` as the
 * maximum.
 *
 * \param haptic the SDL_Haptic device to set the gain on.
 * \param gain value to set the gain to, should be between 0 and 100 (0 -
 *             100).
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetHapticFeatures
 *)
function SDL_SetHapticGain(haptic: SDL_Haptic; gain: Integer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetHapticGain';

(**
 * Set the global autocenter of the device.
 *
 * Autocenter should be between 0 and 100. Setting it to 0 will disable
 * autocentering.
 *
 * Device must support the SDL_HAPTIC_AUTOCENTER feature.
 *
 * \param haptic the SDL_Haptic device to set autocentering on.
 * \param autocenter value to set autocenter to (0-100).
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetHapticFeatures
 *)
function SDL_SetHapticAutocenter(haptic: SDL_Haptic; autocenter: Integer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetHapticAutocenter';

(**
 * Pause a haptic device.
 *
 * Device must support the `SDL_HAPTIC_PAUSE` feature. Call SDL_ResumeHaptic()
 * to resume playback.
 *
 * Do not modify the effects nor add new ones while the device is paused. That
 * can cause all sorts of weird errors.
 *
 * \param haptic the SDL_Haptic device to pause.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_ResumeHaptic
 *)
function SDL_PauseHaptic(haptic: SDL_Haptic): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_PauseHaptic';

(**
 * Resume a haptic device.
 *
 * Call to unpause after SDL_PauseHaptic().
 *
 * \param haptic the SDL_Haptic device to unpause.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_PauseHaptic
 *)
function SDL_ResumeHaptic(haptic: SDL_Haptic): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_ResumeHaptic';

(**
 * Stop all the currently playing effects on a haptic device.
 *
 * \param haptic the SDL_Haptic device to stop.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_RunHapticEffect
 * \sa SDL_StopHapticEffects
 *)
function SDL_StopHapticEffects(haptic: SDL_Haptic): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_StopHapticEffects';

(**
 * Check whether rumble is supported on a haptic device.
 *
 * \param haptic haptic device to check for rumble support.
 * \returns true if the effect is supported or false if it isn't.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_InitHapticRumble
 *)
function SDL_HapticRumbleSupported(haptic: SDL_Haptic): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_HapticRumbleSupported';

(**
 * Initialize a haptic device for simple rumble playback.
 *
 * \param haptic the haptic device to initialize for simple rumble playback.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_PlayHapticRumble
 * \sa SDL_StopHapticRumble
 * \sa SDL_HapticRumbleSupported
 *)
function SDL_InitHapticRumble(haptic: SDL_Haptic): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_InitHapticRumble';

(**
 * Run a simple rumble effect on a haptic device.
 *
 * \param haptic the haptic device to play the rumble effect on.
 * \param strength strength of the rumble to play as a 0-1 float value.
 * \param length length of the rumble to play in milliseconds.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_InitHapticRumble
 * \sa SDL_StopHapticRumble
 *)
function SDL_PlayHapticRumble(haptic: SDL_Haptic; strength: Single; length: Uint32): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_PlayHapticRumble';

(**
 * Stop the simple rumble on a haptic device.
 *
 * \param haptic the haptic device to stop the rumble effect on.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_PlayHapticRumble
 *)
function SDL_StopHapticRumble(haptic: SDL_Haptic): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_StopHapticRumble';
{$ENDREGION 'SDL_haptic.h'}

{$REGION 'SDL_hints.h'}
(**
 * # CategoryHints
 *
 * This file contains functions to set and get configuration hints, as well as
 * listing each of them alphabetically.
 *
 * The convention for naming hints is SDL_HINT_X, where "SDL_X" is the
 * environment variable that can be used to override the default.
 *
 * In general these hints are just that - they may or may not be supported or
 * applicable on any given platform, but they provide a way for an application
 * or user to give the library a hint as to how they would like the library to
 * work.
 *)
const
  (**
   * Specify the behavior of Alt+Tab while the keyboard is grabbed.
   *
   * By default, SDL emulates Alt+Tab functionality while the keyboard is
   * grabbed and your window is full-screen. This prevents the user from getting
   * stuck in your application if you've enabled keyboard grab.
   *
   * The variable can be set to the following values:
   *
   * - "0": SDL will not handle Alt+Tab. Your application is responsible for
   *   handling Alt+Tab while the keyboard is grabbed.
   * - "1": SDL will minimize your window when Alt+Tab is pressed (default)
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_ALLOW_ALT_TAB_WHILE_GRABBED = 'SDL_ALLOW_ALT_TAB_WHILE_GRABBED';

  (**
   * A variable to control whether the SDL activity is allowed to be re-created.
   *
   * If this hint is true, the activity can be recreated on demand by the OS,
   * and Java static data and C++ static data remain with their current values.
   * If this hint is false, then SDL will call exit() when you return from your
   * main function and the application will be terminated and then started fresh
   * each time.
   *
   * The variable can be set to the following values:
   *
   * - "0": The application starts fresh at each launch. (default)
   * - "1": The application activity can be recreated by the OS.
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_ANDROID_ALLOW_RECREATE_ACTIVITY = 'SDL_ANDROID_ALLOW_RECREATE_ACTIVITY';

  (**
   * A variable to control whether the event loop will block itself when the app
   * is paused.
   *
   * The variable can be set to the following values:
   *
   * - "0": Non blocking.
   * - "1": Blocking. (default)
   *
   * This hint should be set before SDL is initialized.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_ANDROID_BLOCK_ON_PAUSE = 'SDL_ANDROID_BLOCK_ON_PAUSE';

  (**
   * A variable to control whether low latency audio should be enabled.
   *
   * Some devices have poor quality output when this is enabled, but this is
   * usually an improvement in audio latency.
   *
   * The variable can be set to the following values:
   *
   * - "0": Low latency audio is not enabled.
   * - "1": Low latency audio is enabled. (default)
   *
   * This hint should be set before SDL audio is initialized.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_ANDROID_LOW_LATENCY_AUDIO = 'SDL_ANDROID_LOW_LATENCY_AUDIO';

  (**
   * A variable to control whether we trap the Android back button to handle it
   * manually.
   *
   * This is necessary for the right mouse button to work on some Android
   * devices, or to be able to trap the back button for use in your code
   * reliably. If this hint is true, the back button will show up as an
   * SDL_EVENT_KEY_DOWN / SDL_EVENT_KEY_UP pair with a keycode of
   * SDL_SCANCODE_AC_BACK.
   *
   * The variable can be set to the following values:
   *
   * - "0": Back button will be handled as usual for system. (default)
   * - "1": Back button will be trapped, allowing you to handle the key press
   *   manually. (This will also let right mouse click work on systems where the
   *   right mouse button functions as back.)
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_ANDROID_TRAP_BACK_BUTTON = 'SDL_ANDROID_TRAP_BACK_BUTTON';

  (**
   * A variable setting the app ID string.
   *
   * This string is used by desktop compositors to identify and group windows
   * together, as well as match applications with associated desktop settings
   * and icons.
   *
   * This will override SDL_PROP_APP_METADATA_IDENTIFIER_STRING, if set by the
   * application.
   *
   * This hint should be set before SDL is initialized.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_APP_ID = 'SDL_APP_ID';

  (**
   * A variable setting the application name.
   *
   * This hint lets you specify the application name sent to the OS when
   * required. For example, this will often appear in volume control applets for
   * audio streams, and in lists of applications which are inhibiting the
   * screensaver. You should use a string that describes your program ("My Game
   * 2: The Revenge")
   *
   * This will override SDL_PROP_APP_METADATA_NAME_STRING, if set by the
   * application.
   *
   * This hint should be set before SDL is initialized.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_APP_NAME = 'SDL_APP_NAME';

  (**
   * A variable controlling whether controllers used with the Apple TV generate
   * UI events.
   *
   * When UI events are generated by controller input, the app will be
   * backgrounded when the Apple TV remote's menu button is pressed, and when
   * the pause or B buttons on gamepads are pressed.
   *
   * More information about properly making use of controllers for the Apple TV
   * can be found here:
   * https://developer.apple.com/tvos/human-interface-guidelines/remote-and-controllers/
   *
   * The variable can be set to the following values:
   *
   * - "0": Controller input does not generate UI events. (default)
   * - "1": Controller input generates UI events.
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_APPLE_TV_CONTROLLER_UI_EVENTS = 'SDL_APPLE_TV_CONTROLLER_UI_EVENTS';

  (**
   * A variable controlling whether the Apple TV remote's joystick axes will
   * automatically match the rotation of the remote.
   *
   * The variable can be set to the following values:
   *
   * - "0": Remote orientation does not affect joystick axes. (default)
   * - "1": Joystick axes are based on the orientation of the remote.
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_APPLE_TV_REMOTE_ALLOW_ROTATION = 'SDL_APPLE_TV_REMOTE_ALLOW_ROTATION';

  (**
   * Specify the default ALSA audio device name.
   *
   * This variable is a specific audio device to open when the "default" audio
   * device is used.
   *
   * This hint will be ignored when opening the default playback device if
   * SDL_HINT_AUDIO_ALSA_DEFAULT_PLAYBACK_DEVICE is set, or when opening the
   * default recording device if SDL_HINT_AUDIO_ALSA_DEFAULT_RECORDING_DEVICE is
   * set.
   *
   * This hint should be set before an audio device is opened.
   *
   * \since This hint is available since SDL 3.2.0.
   *
   * \sa SDL_HINT_AUDIO_ALSA_DEFAULT_PLAYBACK_DEVICE
   * \sa SDL_HINT_AUDIO_ALSA_DEFAULT_RECORDING_DEVICE
   *)
  SDL_HINT_AUDIO_ALSA_DEFAULT_DEVICE = 'SDL_AUDIO_ALSA_DEFAULT_DEVICE';

  (**
   * Specify the default ALSA audio playback device name.
   *
   * This variable is a specific audio device to open for playback, when the
   * "default" audio device is used.
   *
   * If this hint isn't set, SDL will check SDL_HINT_AUDIO_ALSA_DEFAULT_DEVICE
   * before choosing a reasonable default.
   *
   * This hint should be set before an audio device is opened.
   *
   * \since This hint is available since SDL 3.2.0.
   *
   * \sa SDL_HINT_AUDIO_ALSA_DEFAULT_RECORDING_DEVICE
   * \sa SDL_HINT_AUDIO_ALSA_DEFAULT_DEVICE
   *)
  SDL_HINT_AUDIO_ALSA_DEFAULT_PLAYBACK_DEVICE = 'SDL_AUDIO_ALSA_DEFAULT_PLAYBACK_DEVICE';

  (**
   * Specify the default ALSA audio recording device name.
   *
   * This variable is a specific audio device to open for recording, when the
   * "default" audio device is used.
   *
   * If this hint isn't set, SDL will check SDL_HINT_AUDIO_ALSA_DEFAULT_DEVICE
   * before choosing a reasonable default.
   *
   * This hint should be set before an audio device is opened.
   *
   * \since This hint is available since SDL 3.2.0.
   *
   * \sa SDL_HINT_AUDIO_ALSA_DEFAULT_PLAYBACK_DEVICE
   * \sa SDL_HINT_AUDIO_ALSA_DEFAULT_DEVICE
   *)
  SDL_HINT_AUDIO_ALSA_DEFAULT_RECORDING_DEVICE = 'SDL_AUDIO_ALSA_DEFAULT_RECORDING_DEVICE';

  (**
   * A variable controlling the audio category on iOS and macOS.
   *
   * The variable can be set to the following values:
   *
   * - "ambient": Use the AVAudioSessionCategoryAmbient audio category, will be
   *   muted by the phone mute switch (default)
   * - "playback": Use the AVAudioSessionCategoryPlayback category.
   *
   * For more information, see Apple's documentation:
   * https://developer.apple.com/library/content/documentation/Audio/Conceptual/AudioSessionProgrammingGuide/AudioSessionCategoriesandModes/AudioSessionCategoriesandModes.html
   *
   * This hint should be set before an audio device is opened.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_AUDIO_CATEGORY = 'SDL_AUDIO_CATEGORY';


  (**
   * A variable controlling the default audio channel count.
   *
   * If the application doesn't specify the audio channel count when opening the
   * device, this hint can be used to specify a default channel count that will
   * be used. This defaults to "1" for recording and "2" for playback devices.
   *
   * This hint should be set before an audio device is opened.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_AUDIO_CHANNELS = 'SDL_AUDIO_CHANNELS';

  (**
   * Specify an application icon name for an audio device.
   *
   * Some audio backends (such as Pulseaudio and Pipewire) allow you to set an
   * XDG icon name for your application. Among other things, this icon might
   * show up in a system control panel that lets the user adjust the volume on
   * specific audio streams instead of using one giant master volume slider.
   * Note that this is unrelated to the icon used by the windowing system, which
   * may be set with SDL_SetWindowIcon (or via desktop file on Wayland).
   *
   * Setting this to "" or leaving it unset will have SDL use a reasonable
   * default, "applications-games", which is likely to be installed. See
   * https://specifications.freedesktop.org/icon-theme-spec/icon-theme-spec-latest.html
   * and
   * https://specifications.freedesktop.org/icon-naming-spec/icon-naming-spec-latest.html
   * for the relevant XDG icon specs.
   *
   * This hint should be set before an audio device is opened.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_AUDIO_DEVICE_APP_ICON_NAME = 'SDL_AUDIO_DEVICE_APP_ICON_NAME';

  (**
   * A variable controlling device buffer size.
   *
   * This hint is an integer > 0, that represents the size of the device's
   * buffer in sample frames (stereo audio data in 16-bit format is 4 bytes per
   * sample frame, for example).
   *
   * SDL3 generally decides this value on behalf of the app, but if for some
   * reason the app needs to dictate this (because they want either lower
   * latency or higher throughput AND ARE WILLING TO DEAL WITH what that might
   * require of the app), they can specify it.
   *
   * SDL will try to accommodate this value, but there is no promise you'll get
   * the buffer size requested. Many platforms won't honor this request at all,
   * or might adjust it.
   *
   * This hint should be set before an audio device is opened.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_AUDIO_DEVICE_SAMPLE_FRAMES = 'SDL_AUDIO_DEVICE_SAMPLE_FRAMES';

  (**
   * Specify an audio stream name for an audio device.
   *
   * Some audio backends (such as PulseAudio) allow you to describe your audio
   * stream. Among other things, this description might show up in a system
   * control panel that lets the user adjust the volume on specific audio
   * streams instead of using one giant master volume slider.
   *
   * This hints lets you transmit that information to the OS. The contents of
   * this hint are used while opening an audio device. You should use a string
   * that describes your what your program is playing ("audio stream" is
   * probably sufficient in many cases, but this could be useful for something
   * like "team chat" if you have a headset playing VoIP audio separately).
   *
   * Setting this to "" or leaving it unset will have SDL use a reasonable
   * default: "audio stream" or something similar.
   *
   * Note that while this talks about audio streams, this is an OS-level
   * concept, so it applies to a physical audio device in this case, and not an
   * SDL_AudioStream, nor an SDL logical audio device.
   *
   * This hint should be set before an audio device is opened.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_AUDIO_DEVICE_STREAM_NAME = 'SDL_AUDIO_DEVICE_STREAM_NAME';

  (**
   * Specify an application role for an audio device.
   *
   * Some audio backends (such as Pipewire) allow you to describe the role of
   * your audio stream. Among other things, this description might show up in a
   * system control panel or software for displaying and manipulating media
   * playback/recording graphs.
   *
   * This hints lets you transmit that information to the OS. The contents of
   * this hint are used while opening an audio device. You should use a string
   * that describes your what your program is playing (Game, Music, Movie,
   * etc...).
   *
   * Setting this to "" or leaving it unset will have SDL use a reasonable
   * default: "Game" or something similar.
   *
   * Note that while this talks about audio streams, this is an OS-level
   * concept, so it applies to a physical audio device in this case, and not an
   * SDL_AudioStream, nor an SDL logical audio device.
   *
   * This hint should be set before an audio device is opened.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_AUDIO_DEVICE_STREAM_ROLE = 'SDL_AUDIO_DEVICE_STREAM_ROLE';

  (**
   * Specify the input file when recording audio using the disk audio driver.
   *
   * This defaults to "sdlaudio-in.raw"
   *
   * This hint should be set before an audio device is opened.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_AUDIO_DISK_INPUT_FILE = 'SDL_AUDIO_DISK_INPUT_FILE';

  (**
   * Specify the output file when playing audio using the disk audio driver.
   *
   * This defaults to "sdlaudio.raw"
   *
   * This hint should be set before an audio device is opened.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_AUDIO_DISK_OUTPUT_FILE = 'SDL_AUDIO_DISK_OUTPUT_FILE';

  (**
   * A variable controlling the audio rate when using the disk audio driver.
   *
   * The disk audio driver normally simulates real-time for the audio rate that
   * was specified, but you can use this variable to adjust this rate higher or
   * lower down to 0. The default value is "1.0".
   *
   * This hint should be set before an audio device is opened.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_AUDIO_DISK_TIMESCALE = 'SDL_AUDIO_DISK_TIMESCALE';

  (**
   * A variable that specifies an audio backend to use.
   *
   * By default, SDL will try all available audio backends in a reasonable order
   * until it finds one that can work, but this hint allows the app or user to
   * force a specific driver, such as "pipewire" if, say, you are on PulseAudio
   * but want to try talking to the lower level instead.
   *
   * This hint should be set before SDL is initialized.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_AUDIO_DRIVER = 'SDL_AUDIO_DRIVER';

  (**
   * A variable controlling the audio rate when using the dummy audio driver.
   *
   * The dummy audio driver normally simulates real-time for the audio rate that
   * was specified, but you can use this variable to adjust this rate higher or
   * lower down to 0. The default value is "1.0".
   *
   * This hint should be set before an audio device is opened.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_AUDIO_DUMMY_TIMESCALE = 'SDL_AUDIO_DUMMY_TIMESCALE';

  (**
   * A variable controlling the default audio format.
   *
   * If the application doesn't specify the audio format when opening the
   * device, this hint can be used to specify a default format that will be
   * used.
   *
   * The variable can be set to the following values:
   *
   * - "U8": Unsigned 8-bit audio
   * - "S8": Signed 8-bit audio
   * - "S16LE": Signed 16-bit little-endian audio
   * - "S16BE": Signed 16-bit big-endian audio
   * - "S16": Signed 16-bit native-endian audio (default)
   * - "S32LE": Signed 32-bit little-endian audio
   * - "S32BE": Signed 32-bit big-endian audio
   * - "S32": Signed 32-bit native-endian audio
   * - "F32LE": Floating point little-endian audio
   * - "F32BE": Floating point big-endian audio
   * - "F32": Floating point native-endian audio
   *
   * This hint should be set before an audio device is opened.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_AUDIO_FORMAT = 'SDL_AUDIO_FORMAT';

  (**
   * A variable controlling the default audio frequency.
   *
   * If the application doesn't specify the audio frequency when opening the
   * device, this hint can be used to specify a default frequency that will be
   * used. This defaults to "44100".
   *
   * This hint should be set before an audio device is opened.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_AUDIO_FREQUENCY = 'SDL_AUDIO_FREQUENCY';

  (**
   * A variable that causes SDL to not ignore audio "monitors".
   *
   * This is currently only used by the PulseAudio driver.
   *
   * By default, SDL ignores audio devices that aren't associated with physical
   * hardware. Changing this hint to "1" will expose anything SDL sees that
   * appears to be an audio source or sink. This will add "devices" to the list
   * that the user probably doesn't want or need, but it can be useful in
   * scenarios where you want to hook up SDL to some sort of virtual device,
   * etc.
   *
   * The variable can be set to the following values:
   *
   * - "0": Audio monitor devices will be ignored. (default)
   * - "1": Audio monitor devices will show up in the device list.
   *
   * This hint should be set before SDL is initialized.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_AUDIO_INCLUDE_MONITORS = 'SDL_AUDIO_INCLUDE_MONITORS';

  (**
   * A variable controlling whether SDL updates joystick state when getting
   * input events.
   *
   * The variable can be set to the following values:
   *
   * - "0": You'll call SDL_UpdateJoysticks() manually.
   * - "1": SDL will automatically call SDL_UpdateJoysticks(). (default)
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_AUTO_UPDATE_JOYSTICKS = 'SDL_AUTO_UPDATE_JOYSTICKS';

  (**
   * A variable controlling whether SDL updates sensor state when getting input
   * events.
   *
   * The variable can be set to the following values:
   *
   * - "0": You'll call SDL_UpdateSensors() manually.
   * - "1": SDL will automatically call SDL_UpdateSensors(). (default)
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_AUTO_UPDATE_SENSORS = 'SDL_AUTO_UPDATE_SENSORS';

  (**
   * Prevent SDL from using version 4 of the bitmap header when saving BMPs.
   *
   * The bitmap header version 4 is required for proper alpha channel support
   * and SDL will use it when required. Should this not be desired, this hint
   * can force the use of the 40 byte header version which is supported
   * everywhere.
   *
   * The variable can be set to the following values:
   *
   * - "0": Surfaces with a colorkey or an alpha channel are saved to a 32-bit
   *   BMP file with an alpha mask. SDL will use the bitmap header version 4 and
   *   set the alpha mask accordingly. (default)
   * - "1": Surfaces with a colorkey or an alpha channel are saved to a 32-bit
   *   BMP file without an alpha mask. The alpha channel data will be in the
   *   file, but applications are going to ignore it.
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_BMP_SAVE_LEGACY_FORMAT = 'SDL_BMP_SAVE_LEGACY_FORMAT';

  (**
   * A variable that decides what camera backend to use.
   *
   * By default, SDL will try all available camera backends in a reasonable
   * order until it finds one that can work, but this hint allows the app or
   * user to force a specific target, such as "directshow" if, say, you are on
   * Windows Media Foundations but want to try DirectShow instead.
   *
   * The default value is unset, in which case SDL will try to figure out the
   * best camera backend on your behalf. This hint needs to be set before
   * SDL_Init() is called to be useful.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_CAMERA_DRIVER = 'SDL_CAMERA_DRIVER';

  (**
   * A variable that limits what CPU features are available.
   *
   * By default, SDL marks all features the current CPU supports as available.
   * This hint allows to limit these to a subset.
   *
   * When the hint is unset, or empty, SDL will enable all detected CPU
   * features.
   *
   * The variable can be set to a comma separated list containing the following
   * items:
   *
   * - "all"
   * - "altivec"
   * - "sse"
   * - "sse2"
   * - "sse3"
   * - "sse41"
   * - "sse42"
   * - "avx"
   * - "avx2"
   * - "avx512f"
   * - "arm-simd"
   * - "neon"
   * - "lsx"
   * - "lasx"
   *
   * The items can be prefixed by '+'/'-' to add/remove features.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_CPU_FEATURE_MASK = 'SDL_CPU_FEATURE_MASK';

  (**
   * A variable controlling whether DirectInput should be used for controllers.
   *
   * The variable can be set to the following values:
   *
   * - "0": Disable DirectInput detection.
   * - "1": Enable DirectInput detection. (default)
   *
   * This hint should be set before SDL is initialized.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_JOYSTICK_DIRECTINPUT = 'SDL_JOYSTICK_DIRECTINPUT';

  (**
   * A variable that specifies a dialog backend to use.
   *
   * By default, SDL will try all available dialog backends in a reasonable
   * order until it finds one that can work, but this hint allows the app or
   * user to force a specific target.
   *
   * If the specified target does not exist or is not available, the
   * dialog-related function calls will fail.
   *
   * This hint currently only applies to platforms using the generic "Unix"
   * dialog implementation, but may be extended to more platforms in the future.
   * Note that some Unix and Unix-like platforms have their own implementation,
   * such as macOS and Haiku.
   *
   * The variable can be set to the following values:
   *
   * - NULL: Select automatically (default, all platforms)
   * - "portal": Use XDG Portals through DBus (Unix only)
   * - "zenity": Use the Zenity program (Unix only)
   *
   * More options may be added in the future.
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_FILE_DIALOG_DRIVER = 'SDL_FILE_DIALOG_DRIVER';

  (**
   * Override for SDL_GetDisplayUsableBounds().
   *
   * If set, this hint will override the expected results for
   * SDL_GetDisplayUsableBounds() for display index 0. Generally you don't want
   * to do this, but this allows an embedded system to request that some of the
   * screen be reserved for other uses when paired with a well-behaved
   * application.
   *
   * The contents of this hint must be 4 comma-separated integers, the first is
   * the bounds x, then y, width and height, in that order.
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_DISPLAY_USABLE_BOUNDS = 'SDL_DISPLAY_USABLE_BOUNDS';

  (**
   * Disable giving back control to the browser automatically when running with
   * asyncify.
   *
   * With -s ASYNCIFY, SDL calls emscripten_sleep during operations such as
   * refreshing the screen or polling events.
   *
   * This hint only applies to the emscripten platform.
   *
   * The variable can be set to the following values:
   *
   * - "0": Disable emscripten_sleep calls (if you give back browser control
   *   manually or use asyncify for other purposes).
   * - "1": Enable emscripten_sleep calls. (default)
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_EMSCRIPTEN_ASYNCIFY = 'SDL_EMSCRIPTEN_ASYNCIFY';

  (**
   * Specify the CSS selector used for the "default" window/canvas.
   *
   * This hint only applies to the emscripten platform.
   *
   * The default value is "#canvas"
   *
   * This hint should be set before creating a window.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_EMSCRIPTEN_CANVAS_SELECTOR = 'SDL_EMSCRIPTEN_CANVAS_SELECTOR';

  (**
   * Override the binding element for keyboard inputs for Emscripten builds.
   *
   * This hint only applies to the emscripten platform.
   *
   * The variable can be one of:
   *
   * - "#window": the javascript window object (default)
   * - "#document": the javascript document object
   * - "#screen": the javascript window.screen object
   * - "#canvas": the WebGL canvas element
   * - "#none": Don't bind anything at all
   * - any other string without a leading # sign applies to the element on the
   *   page with that ID.
   *
   * This hint should be set before creating a window.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_EMSCRIPTEN_KEYBOARD_ELEMENT = 'SDL_EMSCRIPTEN_KEYBOARD_ELEMENT';

  (**
   * A variable that controls whether the on-screen keyboard should be shown
   * when text input is active.
   *
   * The variable can be set to the following values:
   *
   * - "auto": The on-screen keyboard will be shown if there is no physical
   *   keyboard attached. (default)
   * - "0": Do not show the on-screen keyboard.
   * - "1": Show the on-screen keyboard, if available.
   *
   * This hint must be set before SDL_StartTextInput() is called
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_ENABLE_SCREEN_KEYBOARD = 'SDL_ENABLE_SCREEN_KEYBOARD';

  (**
   * A variable containing a list of evdev devices to use if udev is not
   * available.
   *
   * The list of devices is in the form:
   *
   * deviceclass:path[,deviceclass:path[,...]]
   *
   * where device class is an integer representing the SDL_UDEV_deviceclass and
   * path is the full path to the event device.
   *
   * This hint should be set before SDL is initialized.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_EVDEV_DEVICES = 'SDL_EVDEV_DEVICES';

  (**
   * A variable controlling verbosity of the logging of SDL events pushed onto
   * the internal queue.
   *
   * The variable can be set to the following values, from least to most
   * verbose:
   *
   * - "0": Don't log any events. (default)
   * - "1": Log most events (other than the really spammy ones).
   * - "2": Include mouse and finger motion events.
   *
   * This is generally meant to be used to debug SDL itself, but can be useful
   * for application developers that need better visibility into what is going
   * on in the event queue. Logged events are sent through SDL_Log(), which
   * means by default they appear on stdout on most platforms or maybe
   * OutputDebugString() on Windows, and can be funneled by the app with
   * SDL_SetLogOutputFunction(), etc.
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_EVENT_LOGGING = 'SDL_EVENT_LOGGING';

  (**
   * A variable controlling whether raising the window should be done more
   * forcefully.
   *
   * The variable can be set to the following values:
   *
   * - "0": Honor the OS policy for raising windows. (default)
   * - "1": Force the window to be raised, overriding any OS policy.
   *
   * At present, this is only an issue under MS Windows, which makes it nearly
   * impossible to programmatically move a window to the foreground, for
   * "security" reasons. See http://stackoverflow.com/a/34414846 for a
   * discussion.
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_FORCE_RAISEWINDOW = 'SDL_FORCE_RAISEWINDOW';

  (**
   * A variable controlling how 3D acceleration is used to accelerate the SDL
   * screen surface.
   *
   * SDL can try to accelerate the SDL screen surface by using streaming
   * textures with a 3D rendering engine. This variable controls whether and how
   * this is done.
   *
   * The variable can be set to the following values:
   *
   * - "0": Disable 3D acceleration
   * - "1": Enable 3D acceleration, using the default renderer. (default)
   * - "X": Enable 3D acceleration, using X where X is one of the valid
   *   rendering drivers. (e.g. "direct3d", "opengl", etc.)
   *
   * This hint should be set before calling SDL_GetWindowSurface()
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_FRAMEBUFFER_ACCELERATION = 'SDL_FRAMEBUFFER_ACCELERATION';

  (**
   * A variable that lets you manually hint extra gamecontroller db entries.
   *
   * The variable should be newline delimited rows of gamecontroller config
   * data, see SDL_gamepad.h
   *
   * You can update mappings after SDL is initialized with
   * SDL_GetGamepadMappingForGUID() and SDL_AddGamepadMapping()
   *
   * This hint should be set before SDL is initialized.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_GAMECONTROLLERCONFIG = 'SDL_GAMECONTROLLERCONFIG';

  (**
   * A variable that lets you provide a file with extra gamecontroller db
   * entries.
   *
   * The file should contain lines of gamecontroller config data, see
   * SDL_gamepad.h
   *
   * You can update mappings after SDL is initialized with
   * SDL_GetGamepadMappingForGUID() and SDL_AddGamepadMapping()
   *
   * This hint should be set before SDL is initialized.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_GAMECONTROLLERCONFIG_FILE = 'SDL_GAMECONTROLLERCONFIG_FILE';

  (**
   * A variable that overrides the automatic controller type detection.
   *
   * The variable should be comma separated entries, in the form: VID/PID=type
   *
   * The VID and PID should be hexadecimal with exactly 4 digits, e.g. 0x00fd
   *
   * This hint affects what low level protocol is used with the HIDAPI driver.
   *
   * The variable can be set to the following values:
   *
   * - "Xbox360"
   * - "XboxOne"
   * - "PS3"
   * - "PS4"
   * - "PS5"
   * - "SwitchPro"
   *
   * This hint should be set before SDL is initialized.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_GAMECONTROLLERTYPE = 'SDL_GAMECONTROLLERTYPE';

  (**
   * A variable containing a list of devices to skip when scanning for game
   * controllers.
   *
   * The format of the string is a comma separated list of USB VID/PID pairs in
   * hexadecimal form, e.g.
   *
   * 0xAAAA/0xBBBB,0xCCCC/0xDDDD
   *
   * The variable can also take the form of "@file", in which case the named
   * file will be loaded and interpreted as the value of the variable.
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_GAMECONTROLLER_IGNORE_DEVICES = 'SDL_GAMECONTROLLER_IGNORE_DEVICES';

  (**
   * If set, all devices will be skipped when scanning for game controllers
   * except for the ones listed in this variable.
   *
   * The format of the string is a comma separated list of USB VID/PID pairs in
   * hexadecimal form, e.g.
   *
   * 0xAAAA/0xBBBB,0xCCCC/0xDDDD
   *
   * The variable can also take the form of "@file", in which case the named
   * file will be loaded and interpreted as the value of the variable.
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_GAMECONTROLLER_IGNORE_DEVICES_EXCEPT = 'SDL_GAMECONTROLLER_IGNORE_DEVICES_EXCEPT';

  (**
   * A variable that controls whether the device's built-in accelerometer and
   * gyro should be used as sensors for gamepads.
   *
   * The variable can be set to the following values:
   *
   * - "0": Sensor fusion is disabled
   * - "1": Sensor fusion is enabled for all controllers that lack sensors
   *
   * Or the variable can be a comma separated list of USB VID/PID pairs in
   * hexadecimal form, e.g.
   *
   * 0xAAAA/0xBBBB,0xCCCC/0xDDDD
   *
   * The variable can also take the form of "@file", in which case the named
   * file will be loaded and interpreted as the value of the variable.
   *
   * This hint should be set before a gamepad is opened.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_GAMECONTROLLER_SENSOR_FUSION = 'SDL_GAMECONTROLLER_SENSOR_FUSION';

  (**
   * This variable sets the default text of the TextInput window on GDK
   * platforms.
   *
   * This hint is available only if SDL_GDK_TEXTINPUT defined.
   *
   * This hint should be set before calling SDL_StartTextInput()
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_GDK_TEXTINPUT_DEFAULT_TEXT = 'SDL_GDK_TEXTINPUT_DEFAULT_TEXT';

  (**
   * This variable sets the description of the TextInput window on GDK
   * platforms.
   *
   * This hint is available only if SDL_GDK_TEXTINPUT defined.
   *
   * This hint should be set before calling SDL_StartTextInput()
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_GDK_TEXTINPUT_DESCRIPTION = 'SDL_GDK_TEXTINPUT_DESCRIPTION';

  (**
   * This variable sets the maximum input length of the TextInput window on GDK
   * platforms.
   *
   * The value must be a stringified integer, for example "10" to allow for up
   * to 10 characters of text input.
   *
   * This hint is available only if SDL_GDK_TEXTINPUT defined.
   *
   * This hint should be set before calling SDL_StartTextInput()
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_GDK_TEXTINPUT_MAX_LENGTH = 'SDL_GDK_TEXTINPUT_MAX_LENGTH';

  (**
   * This variable sets the input scope of the TextInput window on GDK
   * platforms.
   *
   * Set this hint to change the XGameUiTextEntryInputScope value that will be
   * passed to the window creation function. The value must be a stringified
   * integer, for example "0" for XGameUiTextEntryInputScope::Default.
   *
   * This hint is available only if SDL_GDK_TEXTINPUT defined.
   *
   * This hint should be set before calling SDL_StartTextInput()
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_GDK_TEXTINPUT_SCOPE = 'SDL_GDK_TEXTINPUT_SCOPE';

  (**
   * This variable sets the title of the TextInput window on GDK platforms.
   *
   * This hint is available only if SDL_GDK_TEXTINPUT defined.
   *
   * This hint should be set before calling SDL_StartTextInput()
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_GDK_TEXTINPUT_TITLE = 'SDL_GDK_TEXTINPUT_TITLE';

  (**
   * A variable to control whether HIDAPI uses libusb for device access.
   *
   * By default libusb will only be used for a few devices that require direct
   * USB access, and this can be controlled with
   * SDL_HINT_HIDAPI_LIBUSB_WHITELIST.
   *
   * The variable can be set to the following values:
   *
   * - "0": HIDAPI will not use libusb for device access.
   * - "1": HIDAPI will use libusb for device access if available. (default)
   *
   * This hint should be set before SDL is initialized.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_HIDAPI_LIBUSB = 'SDL_HIDAPI_LIBUSB';

  (**
   * A variable to control whether HIDAPI uses libusb only for whitelisted
   * devices.
   *
   * By default libusb will only be used for a few devices that require direct
   * USB access.
   *
   * The variable can be set to the following values:
   *
   * - "0": HIDAPI will use libusb for all device access.
   * - "1": HIDAPI will use libusb only for whitelisted devices. (default)
   *
   * This hint should be set before SDL is initialized.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_HIDAPI_LIBUSB_WHITELIST = 'SDL_HIDAPI_LIBUSB_WHITELIST';

  (**
   * A variable to control whether HIDAPI uses udev for device detection.
   *
   * The variable can be set to the following values:
   *
   * - "0": HIDAPI will poll for device changes.
   * - "1": HIDAPI will use udev for device detection. (default)
   *
   * This hint should be set before SDL is initialized.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_HIDAPI_UDEV = 'SDL_HIDAPI_UDEV';

  (**
   * A variable that specifies a GPU backend to use.
   *
   * By default, SDL will try all available GPU backends in a reasonable order
   * until it finds one that can work, but this hint allows the app or user to
   * force a specific target, such as "direct3d11" if, say, your hardware
   * supports D3D12 but want to try using D3D11 instead.
   *
   * This hint should be set before any GPU functions are called.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_GPU_DRIVER = 'SDL_GPU_DRIVER';

  (**
   * A variable to control whether SDL_hid_enumerate() enumerates all HID
   * devices or only controllers.
   *
   * The variable can be set to the following values:
   *
   * - "0": SDL_hid_enumerate() will enumerate all HID devices.
   * - "1": SDL_hid_enumerate() will only enumerate controllers. (default)
   *
   * By default SDL will only enumerate controllers, to reduce risk of hanging
   * or crashing on devices with bad drivers and avoiding macOS keyboard capture
   * permission prompts.
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_HIDAPI_ENUMERATE_ONLY_CONTROLLERS = 'SDL_HIDAPI_ENUMERATE_ONLY_CONTROLLERS';

  (**
   * A variable containing a list of devices to ignore in SDL_hid_enumerate().
   *
   * The format of the string is a comma separated list of USB VID/PID pairs in
   * hexadecimal form, e.g.
   *
   * `0xAAAA/0xBBBB,0xCCCC/0xDDDD`
   *
   * For example, to ignore the Shanwan DS3 controller and any Valve controller,
   * you might use the string "0x2563/0x0523,0x28de/0x0000"
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_HIDAPI_IGNORE_DEVICES = 'SDL_HIDAPI_IGNORE_DEVICES';

  (**
   * A variable describing what IME UI elements the application can display.
   *
   * By default IME UI is handled using native components by the OS where
   * possible, however this can interfere with or not be visible when exclusive
   * fullscreen mode is used.
   *
   * The variable can be set to a comma separated list containing the following
   * items:
   *
   * - "none" or "0": The application can't render any IME elements, and native
   *   UI should be used. (default)
   * - "composition": The application handles SDL_EVENT_TEXT_EDITING events and
   *   can render the composition text.
   * - "candidates": The application handles SDL_EVENT_TEXT_EDITING_CANDIDATES
   *   and can render the candidate list.
   *
   * This hint should be set before SDL is initialized.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_IME_IMPLEMENTED_UI = 'SDL_IME_IMPLEMENTED_UI';

  (**
   * A variable controlling whether the home indicator bar on iPhone X should be
   * hidden.
   *
   * The variable can be set to the following values:
   *
   * - "0": The indicator bar is not hidden. (default for windowed applications)
   * - "1": The indicator bar is hidden and is shown when the screen is touched
   *   (useful for movie playback applications).
   * - "2": The indicator bar is dim and the first swipe makes it visible and
   *   the second swipe performs the "home" action. (default for fullscreen
   *   applications)
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_IOS_HIDE_HOME_INDICATOR = 'SDL_IOS_HIDE_HOME_INDICATOR';

  (**
   * A variable that lets you enable joystick (and gamecontroller) events even
   * when your app is in the background.
   *
   * The variable can be set to the following values:
   *
   * - "0": Disable joystick & gamecontroller input events when the application
   *   is in the background. (default)
   * - "1": Enable joystick & gamecontroller input events when the application
   *   is in the background.
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_JOYSTICK_ALLOW_BACKGROUND_EVENTS = 'SDL_JOYSTICK_ALLOW_BACKGROUND_EVENTS';

  (**
   * A variable containing a list of arcade stick style controllers.
   *
   * The format of the string is a comma separated list of USB VID/PID pairs in
   * hexadecimal form, e.g.
   *
   * `0xAAAA/0xBBBB,0xCCCC/0xDDDD`
   *
   * The variable can also take the form of "@file", in which case the named
   * file will be loaded and interpreted as the value of the variable.
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_JOYSTICK_ARCADESTICK_DEVICES = 'SDL_JOYSTICK_ARCADESTICK_DEVICES';

  (**
   * A variable containing a list of devices that are not arcade stick style
   * controllers.
   *
   * This will override SDL_HINT_JOYSTICK_ARCADESTICK_DEVICES and the built in
   * device list.
   *
   * The format of the string is a comma separated list of USB VID/PID pairs in
   * hexadecimal form, e.g.
   *
   * `0xAAAA/0xBBBB,0xCCCC/0xDDDD`
   *
   * The variable can also take the form of "@file", in which case the named
   * file will be loaded and interpreted as the value of the variable.
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_JOYSTICK_ARCADESTICK_DEVICES_EXCLUDED = 'SDL_JOYSTICK_ARCADESTICK_DEVICES_EXCLUDED';

  (**
   * A variable containing a list of devices that should not be considered
   * joysticks.
   *
   * The format of the string is a comma separated list of USB VID/PID pairs in
   * hexadecimal form, e.g.
   *
   * `0xAAAA/0xBBBB,0xCCCC/0xDDDD`
   *
   * The variable can also take the form of "@file", in which case the named
   * file will be loaded and interpreted as the value of the variable.
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_JOYSTICK_BLACKLIST_DEVICES = 'SDL_JOYSTICK_BLACKLIST_DEVICES';

  (**
   * A variable containing a list of devices that should be considered
   * joysticks.
   *
   * This will override SDL_HINT_JOYSTICK_BLACKLIST_DEVICES and the built in
   * device list.
   *
   * The format of the string is a comma separated list of USB VID/PID pairs in
   * hexadecimal form, e.g.
   *
   * `0xAAAA/0xBBBB,0xCCCC/0xDDDD`
   *
   * The variable can also take the form of "@file", in which case the named
   * file will be loaded and interpreted as the value of the variable.
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_JOYSTICK_BLACKLIST_DEVICES_EXCLUDED = 'SDL_JOYSTICK_BLACKLIST_DEVICES_EXCLUDED';

  (**
   * A variable containing a comma separated list of devices to open as
   * joysticks.
   *
   * This variable is currently only used by the Linux joystick driver.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_JOYSTICK_DEVICE = 'SDL_JOYSTICK_DEVICE';

  (**
   * A variable controlling whether enhanced reports should be used for
   * controllers when using the HIDAPI driver.
   *
   * Enhanced reports allow rumble and effects on Bluetooth PlayStation
   * controllers and gyro on Nintendo Switch controllers, but break Windows
   * DirectInput for other applications that don't use SDL.
   *
   * Once enhanced reports are enabled, they can't be disabled on PlayStation
   * controllers without power cycling the controller.
   *
   * The variable can be set to the following values:
   *
   * - "0": enhanced reports are not enabled.
   * - "1": enhanced reports are enabled. (default)
   * - "auto": enhanced features are advertised to the application, but SDL
   *   doesn't change the controller report mode unless the application uses
   *   them.
   *
   * This hint can be enabled anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_JOYSTICK_ENHANCED_REPORTS = 'SDL_JOYSTICK_ENHANCED_REPORTS';

  (**
   * A variable containing a list of flightstick style controllers.
   *
   * The format of the string is a comma separated list of USB VID/PID pairs in
   * hexadecimal form, e.g.
   *
   * `0xAAAA/0xBBBB,0xCCCC/0xDDDD`
   *
   * The variable can also take the form of @file, in which case the named file
   * will be loaded and interpreted as the value of the variable.
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_JOYSTICK_FLIGHTSTICK_DEVICES = 'SDL_JOYSTICK_FLIGHTSTICK_DEVICES';

  (**
   * A variable containing a list of devices that are not flightstick style
   * controllers.
   *
   * This will override SDL_HINT_JOYSTICK_FLIGHTSTICK_DEVICES and the built in
   * device list.
   *
   * The format of the string is a comma separated list of USB VID/PID pairs in
   * hexadecimal form, e.g.
   *
   * `0xAAAA/0xBBBB,0xCCCC/0xDDDD`
   *
   * The variable can also take the form of "@file", in which case the named
   * file will be loaded and interpreted as the value of the variable.
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_JOYSTICK_FLIGHTSTICK_DEVICES_EXCLUDED = 'SDL_JOYSTICK_FLIGHTSTICK_DEVICES_EXCLUDED';

  (**
   * A variable controlling whether GameInput should be used for controller
   * handling on Windows.
   *
   * The variable can be set to the following values:
   *
   * - "0": GameInput is not used.
   * - "1": GameInput is used.
   *
   * The default is "1" on GDK platforms, and "0" otherwise.
   *
   * This hint should be set before SDL is initialized.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_JOYSTICK_GAMEINPUT = 'SDL_JOYSTICK_GAMEINPUT';

  (**
   * A variable containing a list of devices known to have a GameCube form
   * factor.
   *
   * The format of the string is a comma separated list of USB VID/PID pairs in
   * hexadecimal form, e.g.
   *
   * `0xAAAA/0xBBBB,0xCCCC/0xDDDD`
   *
   * The variable can also take the form of "@file", in which case the named
   * file will be loaded and interpreted as the value of the variable.
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_JOYSTICK_GAMECUBE_DEVICES = 'SDL_JOYSTICK_GAMECUBE_DEVICES';

  (**
   * A variable containing a list of devices known not to have a GameCube form
   * factor.
   *
   * This will override SDL_HINT_JOYSTICK_GAMECUBE_DEVICES and the built in
   * device list.
   *
   * The format of the string is a comma separated list of USB VID/PID pairs in
   * hexadecimal form, e.g.
   *
   * `0xAAAA/0xBBBB,0xCCCC/0xDDDD`
   *
   * The variable can also take the form of "@file", in which case the named
   * file will be loaded and interpreted as the value of the variable.
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_JOYSTICK_GAMECUBE_DEVICES_EXCLUDED = 'SDL_JOYSTICK_GAMECUBE_DEVICES_EXCLUDED';

  (**
   * A variable controlling whether the HIDAPI joystick drivers should be used.
   *
   * The variable can be set to the following values:
   *
   * - "0": HIDAPI drivers are not used.
   * - "1": HIDAPI drivers are used. (default)
   *
   * This variable is the default for all drivers, but can be overridden by the
   * hints for specific drivers below.
   *
   * This hint should be set before initializing joysticks and gamepads.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_JOYSTICK_HIDAPI = 'SDL_JOYSTICK_HIDAPI';

  (**
   * A variable controlling whether Nintendo Switch Joy-Con controllers will be
   * combined into a single Pro-like controller when using the HIDAPI driver.
   *
   * The variable can be set to the following values:
   *
   * - "0": Left and right Joy-Con controllers will not be combined and each
   *   will be a mini-gamepad.
   * - "1": Left and right Joy-Con controllers will be combined into a single
   *   controller. (default)
   *
   * This hint should be set before initializing joysticks and gamepads.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_JOYSTICK_HIDAPI_COMBINE_JOY_CONS = 'SDL_JOYSTICK_HIDAPI_COMBINE_JOY_CONS';

  (**
   * A variable controlling whether the HIDAPI driver for Nintendo GameCube
   * controllers should be used.
   *
   * The variable can be set to the following values:
   *
   * - "0": HIDAPI driver is not used.
   * - "1": HIDAPI driver is used.
   *
   * The default is the value of SDL_HINT_JOYSTICK_HIDAPI
   *
   * This hint should be set before initializing joysticks and gamepads.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_JOYSTICK_HIDAPI_GAMECUBE = 'SDL_JOYSTICK_HIDAPI_GAMECUBE';

  (**
   * A variable controlling whether rumble is used to implement the GameCube
   * controller's 3 rumble modes, Stop(0), Rumble(1), and StopHard(2).
   *
   * This is useful for applications that need full compatibility for things
   * like ADSR envelopes. - Stop is implemented by setting low_frequency_rumble
   * to 0 and high_frequency_rumble >0 - Rumble is both at any arbitrary value -
   * StopHard is implemented by setting both low_frequency_rumble and
   * high_frequency_rumble to 0
   *
   * The variable can be set to the following values:
   *
   * - "0": Normal rumble behavior is behavior is used. (default)
   * - "1": Proper GameCube controller rumble behavior is used.
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_JOYSTICK_HIDAPI_GAMECUBE_RUMBLE_BRAKE = 'SDL_JOYSTICK_HIDAPI_GAMECUBE_RUMBLE_BRAKE';

  (**
   * A variable controlling whether the HIDAPI driver for Nintendo Switch
   * Joy-Cons should be used.
   *
   * The variable can be set to the following values:
   *
   * - "0": HIDAPI driver is not used.
   * - "1": HIDAPI driver is used.
   *
   * The default is the value of SDL_HINT_JOYSTICK_HIDAPI.
   *
   * This hint should be set before initializing joysticks and gamepads.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_JOYSTICK_HIDAPI_JOY_CONS = 'SDL_JOYSTICK_HIDAPI_JOY_CONS';

  (**
   * A variable controlling whether the Home button LED should be turned on when
   * a Nintendo Switch Joy-Con controller is opened.
   *
   * The variable can be set to the following values:
   *
   * - "0": home button LED is turned off
   * - "1": home button LED is turned on
   *
   * By default the Home button LED state is not changed. This hint can also be
   * set to a floating point value between 0.0 and 1.0 which controls the
   * brightness of the Home button LED.
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_JOYSTICK_HIDAPI_JOYCON_HOME_LED = 'SDL_JOYSTICK_HIDAPI_JOYCON_HOME_LED';

  (**
   * A variable controlling whether the HIDAPI driver for Amazon Luna
   * controllers connected via Bluetooth should be used.
   *
   * The variable can be set to the following values:
   *
   * - "0": HIDAPI driver is not used.
   * - "1": HIDAPI driver is used.
   *
   * The default is the value of SDL_HINT_JOYSTICK_HIDAPI.
   *
   * This hint should be set before initializing joysticks and gamepads.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_JOYSTICK_HIDAPI_LUNA = 'SDL_JOYSTICK_HIDAPI_LUNA';

  (**
   * A variable controlling whether the HIDAPI driver for Nintendo Online
   * classic controllers should be used.
   *
   * The variable can be set to the following values:
   *
   * - "0": HIDAPI driver is not used.
   * - "1": HIDAPI driver is used.
   *
   * The default is the value of SDL_HINT_JOYSTICK_HIDAPI.
   *
   * This hint should be set before initializing joysticks and gamepads.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_JOYSTICK_HIDAPI_NINTENDO_CLASSIC = 'SDL_JOYSTICK_HIDAPI_NINTENDO_CLASSIC';

  (**
   * A variable controlling whether the HIDAPI driver for PS3 controllers should
   * be used.
   *
   * The variable can be set to the following values:
   *
   * - "0": HIDAPI driver is not used.
   * - "1": HIDAPI driver is used.
   *
   * The default is the value of SDL_HINT_JOYSTICK_HIDAPI on macOS, and "0" on
   * other platforms.
   *
   * For official Sony driver (sixaxis.sys) use
   * SDL_HINT_JOYSTICK_HIDAPI_PS3_SIXAXIS_DRIVER. See
   * https://github.com/ViGEm/DsHidMini for an alternative driver on Windows.
   *
   * This hint should be set before initializing joysticks and gamepads.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_JOYSTICK_HIDAPI_PS3 = 'SDL_JOYSTICK_HIDAPI_PS3';

  (**
   * A variable controlling whether the Sony driver (sixaxis.sys) for PS3
   * controllers (Sixaxis/DualShock 3) should be used.
   *
   * The variable can be set to the following values:
   *
   * - "0": Sony driver (sixaxis.sys) is not used.
   * - "1": Sony driver (sixaxis.sys) is used.
   *
   * The default value is 0.
   *
   * This hint should be set before initializing joysticks and gamepads.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_JOYSTICK_HIDAPI_PS3_SIXAXIS_DRIVER = 'SDL_JOYSTICK_HIDAPI_PS3_SIXAXIS_DRIVER';

  (**
   * A variable controlling whether the HIDAPI driver for PS4 controllers should
   * be used.
   *
   * The variable can be set to the following values:
   *
   * - "0": HIDAPI driver is not used.
   * - "1": HIDAPI driver is used.
   *
   * The default is the value of SDL_HINT_JOYSTICK_HIDAPI.
   *
   * This hint should be set before initializing joysticks and gamepads.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_JOYSTICK_HIDAPI_PS4 = 'SDL_JOYSTICK_HIDAPI_PS4';

  (**
   * A variable controlling the update rate of the PS4 controller over Bluetooth
   * when using the HIDAPI driver.
   *
   * This defaults to 4 ms, to match the behavior over USB, and to be more
   * friendly to other Bluetooth devices and older Bluetooth hardware on the
   * computer. It can be set to "1" (1000Hz), "2" (500Hz) and "4" (250Hz)
   *
   * This hint can be set anytime, but only takes effect when extended input
   * reports are enabled.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_JOYSTICK_HIDAPI_PS4_REPORT_INTERVAL = 'SDL_JOYSTICK_HIDAPI_PS4_REPORT_INTERVAL';

  (**
   * A variable controlling whether the HIDAPI driver for PS5 controllers should
   * be used.
   *
   * The variable can be set to the following values:
   *
   * - "0": HIDAPI driver is not used.
   * - "1": HIDAPI driver is used.
   *
   * The default is the value of SDL_HINT_JOYSTICK_HIDAPI.
   *
   * This hint should be set before initializing joysticks and gamepads.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_JOYSTICK_HIDAPI_PS5 = 'SDL_JOYSTICK_HIDAPI_PS5';

  (**
   * A variable controlling whether the player LEDs should be lit to indicate
   * which player is associated with a PS5 controller.
   *
   * The variable can be set to the following values:
   *
   * - "0": player LEDs are not enabled.
   * - "1": player LEDs are enabled. (default)
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_JOYSTICK_HIDAPI_PS5_PLAYER_LED = 'SDL_JOYSTICK_HIDAPI_PS5_PLAYER_LED';

  (**
   * A variable controlling whether the HIDAPI driver for NVIDIA SHIELD
   * controllers should be used.
   *
   * The variable can be set to the following values:
   *
   * - "0": HIDAPI driver is not used.
   * - "1": HIDAPI driver is used.
   *
   * The default is the value of SDL_HINT_JOYSTICK_HIDAPI.
   *
   * This hint should be set before initializing joysticks and gamepads.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_JOYSTICK_HIDAPI_SHIELD = 'SDL_JOYSTICK_HIDAPI_SHIELD';

  (**
   * A variable controlling whether the HIDAPI driver for Google Stadia
   * controllers should be used.
   *
   * The variable can be set to the following values:
   *
   * - "0": HIDAPI driver is not used.
   * - "1": HIDAPI driver is used.
   *
   * The default is the value of SDL_HINT_JOYSTICK_HIDAPI.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_JOYSTICK_HIDAPI_STADIA = 'SDL_JOYSTICK_HIDAPI_STADIA';

  (**
   * A variable controlling whether the HIDAPI driver for Bluetooth Steam
   * Controllers should be used.
   *
   * The variable can be set to the following values:
   *
   * - "0": HIDAPI driver is not used. (default)
   * - "1": HIDAPI driver is used for Steam Controllers, which requires
   *   Bluetooth access and may prompt the user for permission on iOS and
   *   Android.
   *
   * This hint should be set before initializing joysticks and gamepads.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_JOYSTICK_HIDAPI_STEAM = 'SDL_JOYSTICK_HIDAPI_STEAM';

  (**
   * A variable controlling whether the Steam button LED should be turned on
   * when a Steam controller is opened.
   *
   * The variable can be set to the following values:
   *
   * - "0": Steam button LED is turned off.
   * - "1": Steam button LED is turned on.
   *
   * By default the Steam button LED state is not changed. This hint can also be
   * set to a floating point value between 0.0 and 1.0 which controls the
   * brightness of the Steam button LED.
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_JOYSTICK_HIDAPI_STEAM_HOME_LED = 'SDL_JOYSTICK_HIDAPI_STEAM_HOME_LED';

  (**
   * A variable controlling whether the HIDAPI driver for the Steam Deck builtin
   * controller should be used.
   *
   * The variable can be set to the following values:
   *
   * - "0": HIDAPI driver is not used.
   * - "1": HIDAPI driver is used.
   *
   * The default is the value of SDL_HINT_JOYSTICK_HIDAPI.
   *
   * This hint should be set before initializing joysticks and gamepads.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_JOYSTICK_HIDAPI_STEAMDECK = 'SDL_JOYSTICK_HIDAPI_STEAMDECK';

  (**
   * A variable controlling whether the HIDAPI driver for HORI licensed Steam
   * controllers should be used.
   *
   * This variable can be set to the following values: "0" - HIDAPI driver is
   * not used "1" - HIDAPI driver is used
   *
   * The default is the value of SDL_HINT_JOYSTICK_HIDAPI
   *)
  SDL_HINT_JOYSTICK_HIDAPI_STEAM_HORI = 'SDL_JOYSTICK_HIDAPI_STEAM_HORI';

  (**
   * A variable controlling whether the HIDAPI driver for Nintendo Switch
   * controllers should be used.
   *
   * The variable can be set to the following values:
   *
   * - "0": HIDAPI driver is not used.
   * - "1": HIDAPI driver is used.
   *
   * The default is the value of SDL_HINT_JOYSTICK_HIDAPI.
   *
   * This hint should be set before initializing joysticks and gamepads.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_JOYSTICK_HIDAPI_SWITCH = 'SDL_JOYSTICK_HIDAPI_SWITCH';

  (**
   * A variable controlling whether the Home button LED should be turned on when
   * a Nintendo Switch Pro controller is opened.
   *
   * The variable can be set to the following values:
   *
   * - "0": Home button LED is turned off.
   * - "1": Home button LED is turned on.
   *
   * By default the Home button LED state is not changed. This hint can also be
   * set to a floating point value between 0.0 and 1.0 which controls the
   * brightness of the Home button LED.
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_JOYSTICK_HIDAPI_SWITCH_HOME_LED = 'SDL_JOYSTICK_HIDAPI_SWITCH_HOME_LED';

  (**
   * A variable controlling whether the player LEDs should be lit to indicate
   * which player is associated with a Nintendo Switch controller.
   *
   * The variable can be set to the following values:
   *
   * - "0": Player LEDs are not enabled.
   * - "1": Player LEDs are enabled. (default)
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_JOYSTICK_HIDAPI_SWITCH_PLAYER_LED = 'SDL_JOYSTICK_HIDAPI_SWITCH_PLAYER_LED';

  (**
   * A variable controlling whether Nintendo Switch Joy-Con controllers will be
   * in vertical mode when using the HIDAPI driver.
   *
   * The variable can be set to the following values:
   *
   * - "0": Left and right Joy-Con controllers will not be in vertical mode.
   *   (default)
   * - "1": Left and right Joy-Con controllers will be in vertical mode.
   *
   * This hint should be set before opening a Joy-Con controller.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_JOYSTICK_HIDAPI_VERTICAL_JOY_CONS = 'SDL_JOYSTICK_HIDAPI_VERTICAL_JOY_CONS';

  (**
   * A variable controlling whether the HIDAPI driver for Nintendo Wii and Wii U
   * controllers should be used.
   *
   * The variable can be set to the following values:
   *
   * - "0": HIDAPI driver is not used.
   * - "1": HIDAPI driver is used.
   *
   * This driver doesn't work with the dolphinbar, so the default is false for
   * now.
   *
   * This hint should be set before initializing joysticks and gamepads.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_JOYSTICK_HIDAPI_WII = 'SDL_JOYSTICK_HIDAPI_WII';

  (**
   * A variable controlling whether the player LEDs should be lit to indicate
   * which player is associated with a Wii controller.
   *
   * The variable can be set to the following values:
   *
   * - "0": Player LEDs are not enabled.
   * - "1": Player LEDs are enabled. (default)
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_JOYSTICK_HIDAPI_WII_PLAYER_LED = 'SDL_JOYSTICK_HIDAPI_WII_PLAYER_LED';

  (**
   * A variable controlling whether the HIDAPI driver for XBox controllers
   * should be used.
   *
   * The variable can be set to the following values:
   *
   * - "0": HIDAPI driver is not used.
   * - "1": HIDAPI driver is used.
   *
   * The default is "0" on Windows, otherwise the value of
   * SDL_HINT_JOYSTICK_HIDAPI
   *
   * This hint should be set before initializing joysticks and gamepads.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_JOYSTICK_HIDAPI_XBOX = 'SDL_JOYSTICK_HIDAPI_XBOX';

  (**
   * A variable controlling whether the HIDAPI driver for XBox 360 controllers
   * should be used.
   *
   * The variable can be set to the following values:
   *
   * - "0": HIDAPI driver is not used.
   * - "1": HIDAPI driver is used.
   *
   * The default is the value of SDL_HINT_JOYSTICK_HIDAPI_XBOX
   *
   * This hint should be set before initializing joysticks and gamepads.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_JOYSTICK_HIDAPI_XBOX_360 = 'SDL_JOYSTICK_HIDAPI_XBOX_360';

  (**
   * A variable controlling whether the player LEDs should be lit to indicate
   * which player is associated with an Xbox 360 controller.
   *
   * The variable can be set to the following values:
   *
   * - "0": Player LEDs are not enabled.
   * - "1": Player LEDs are enabled. (default)
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_JOYSTICK_HIDAPI_XBOX_360_PLAYER_LED = 'SDL_JOYSTICK_HIDAPI_XBOX_360_PLAYER_LED';

  (**
   * A variable controlling whether the HIDAPI driver for XBox 360 wireless
   * controllers should be used.
   *
   * The variable can be set to the following values:
   *
   * - "0": HIDAPI driver is not used.
   * - "1": HIDAPI driver is used.
   *
   * The default is the value of SDL_HINT_JOYSTICK_HIDAPI_XBOX_360
   *
   * This hint should be set before initializing joysticks and gamepads.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_JOYSTICK_HIDAPI_XBOX_360_WIRELESS = 'SDL_JOYSTICK_HIDAPI_XBOX_360_WIRELESS';

  (**
   * A variable controlling whether the HIDAPI driver for XBox One controllers
   * should be used.
   *
   * The variable can be set to the following values:
   *
   * - "0": HIDAPI driver is not used.
   * - "1": HIDAPI driver is used.
   *
   * The default is the value of SDL_HINT_JOYSTICK_HIDAPI_XBOX.
   *
   * This hint should be set before initializing joysticks and gamepads.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_JOYSTICK_HIDAPI_XBOX_ONE = 'SDL_JOYSTICK_HIDAPI_XBOX_ONE';

  (**
   * A variable controlling whether the Home button LED should be turned on when
   * an Xbox One controller is opened.
   *
   * The variable can be set to the following values:
   *
   * - "0": Home button LED is turned off.
   * - "1": Home button LED is turned on.
   *
   * By default the Home button LED state is not changed. This hint can also be
   * set to a floating point value between 0.0 and 1.0 which controls the
   * brightness of the Home button LED. The default brightness is 0.4.
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_JOYSTICK_HIDAPI_XBOX_ONE_HOME_LED = 'SDL_JOYSTICK_HIDAPI_XBOX_ONE_HOME_LED';

  (**
   * A variable controlling whether IOKit should be used for controller
   * handling.
   *
   * The variable can be set to the following values:
   *
   * - "0": IOKit is not used.
   * - "1": IOKit is used. (default)
   *
   * This hint should be set before SDL is initialized.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_JOYSTICK_IOKIT = 'SDL_JOYSTICK_IOKIT';

  (**
   * A variable controlling whether to use the classic /dev/input/js* joystick
   * interface or the newer /dev/input/event* joystick interface on Linux.
   *
   * The variable can be set to the following values:
   *
   * - "0": Use /dev/input/event* (default)
   * - "1": Use /dev/input/js*
   *
   * This hint should be set before SDL is initialized.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_JOYSTICK_LINUX_CLASSIC = 'SDL_JOYSTICK_LINUX_CLASSIC';

  (**
   * A variable controlling whether joysticks on Linux adhere to their
   * HID-defined deadzones or return unfiltered values.
   *
   * The variable can be set to the following values:
   *
   * - "0": Return unfiltered joystick axis values. (default)
   * - "1": Return axis values with deadzones taken into account.
   *
   * This hint should be set before a controller is opened.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_JOYSTICK_LINUX_DEADZONES = 'SDL_JOYSTICK_LINUX_DEADZONES';

  (**
   * A variable controlling whether joysticks on Linux will always treat 'hat'
   * axis inputs (ABS_HAT0X - ABS_HAT3Y) as 8-way digital hats without checking
   * whether they may be analog.
   *
   * The variable can be set to the following values:
   *
   * - "0": Only map hat axis inputs to digital hat outputs if the input axes
   *   appear to actually be digital. (default)
   * - "1": Always handle the input axes numbered ABS_HAT0X to ABS_HAT3Y as
   *   digital hats.
   *
   * This hint should be set before a controller is opened.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_JOYSTICK_LINUX_DIGITAL_HATS = 'SDL_JOYSTICK_LINUX_DIGITAL_HATS';

  (**
   * A variable controlling whether digital hats on Linux will apply deadzones
   * to their underlying input axes or use unfiltered values.
   *
   * The variable can be set to the following values:
   *
   * - "0": Return digital hat values based on unfiltered input axis values.
   * - "1": Return digital hat values with deadzones on the input axes taken
   *   into account. (default)
   *
   * This hint should be set before a controller is opened.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_JOYSTICK_LINUX_HAT_DEADZONES = 'SDL_JOYSTICK_LINUX_HAT_DEADZONES';

  (**
   * A variable controlling whether GCController should be used for controller
   * handling.
   *
   * The variable can be set to the following values:
   *
   * - "0": GCController is not used.
   * - "1": GCController is used. (default)
   *
   * This hint should be set before SDL is initialized.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_JOYSTICK_MFI = 'SDL_JOYSTICK_MFI';

  (**
   * A variable controlling whether the RAWINPUT joystick drivers should be used
   * for better handling XInput-capable devices.
   *
   * The variable can be set to the following values:
   *
   * - "0": RAWINPUT drivers are not used.
   * - "1": RAWINPUT drivers are used. (default)
   *
   * This hint should be set before SDL is initialized.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_JOYSTICK_RAWINPUT = 'SDL_JOYSTICK_RAWINPUT';

  (**
   * A variable controlling whether the RAWINPUT driver should pull correlated
   * data from XInput.
   *
   * The variable can be set to the following values:
   *
   * - "0": RAWINPUT driver will only use data from raw input APIs.
   * - "1": RAWINPUT driver will also pull data from XInput and
   *   Windows.Gaming.Input, providing better trigger axes, guide button
   *   presses, and rumble support for Xbox controllers. (default)
   *
   * This hint should be set before a gamepad is opened.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_JOYSTICK_RAWINPUT_CORRELATE_XINPUT = 'SDL_JOYSTICK_RAWINPUT_CORRELATE_XINPUT';

  (**
   * A variable controlling whether the ROG Chakram mice should show up as
   * joysticks.
   *
   * The variable can be set to the following values:
   *
   * - "0": ROG Chakram mice do not show up as joysticks. (default)
   * - "1": ROG Chakram mice show up as joysticks.
   *
   * This hint should be set before SDL is initialized.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_JOYSTICK_ROG_CHAKRAM = 'SDL_JOYSTICK_ROG_CHAKRAM';

  (**
   * A variable controlling whether a separate thread should be used for
   * handling joystick detection and raw input messages on Windows.
   *
   * The variable can be set to the following values:
   *
   * - "0": A separate thread is not used.
   * - "1": A separate thread is used for handling raw input messages. (default)
   *
   * This hint should be set before SDL is initialized.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_JOYSTICK_THREAD = 'SDL_JOYSTICK_THREAD';

  (**
   * A variable containing a list of throttle style controllers.
   *
   * The format of the string is a comma separated list of USB VID/PID pairs in
   * hexadecimal form, e.g.
   *
   * `0xAAAA/0xBBBB,0xCCCC/0xDDDD`
   *
   * The variable can also take the form of "@file", in which case the named
   * file will be loaded and interpreted as the value of the variable.
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_JOYSTICK_THROTTLE_DEVICES = 'SDL_JOYSTICK_THROTTLE_DEVICES';

  (**
   * A variable containing a list of devices that are not throttle style
   * controllers.
   *
   * This will override SDL_HINT_JOYSTICK_THROTTLE_DEVICES and the built in
   * device list.
   *
   * The format of the string is a comma separated list of USB VID/PID pairs in
   * hexadecimal form, e.g.
   *
   * `0xAAAA/0xBBBB,0xCCCC/0xDDDD`
   *
   * The variable can also take the form of "@file", in which case the named
   * file will be loaded and interpreted as the value of the variable.
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_JOYSTICK_THROTTLE_DEVICES_EXCLUDED = 'SDL_JOYSTICK_THROTTLE_DEVICES_EXCLUDED';

  (**
   * A variable controlling whether Windows.Gaming.Input should be used for
   * controller handling.
   *
   * The variable can be set to the following values:
   *
   * - "0": WGI is not used.
   * - "1": WGI is used. (default)
   *
   * This hint should be set before SDL is initialized.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_JOYSTICK_WGI = 'SDL_JOYSTICK_WGI';

  (**
   * A variable containing a list of wheel style controllers.
   *
   * The format of the string is a comma separated list of USB VID/PID pairs in
   * hexadecimal form, e.g.
   *
   * `0xAAAA/0xBBBB,0xCCCC/0xDDDD`
   *
   * The variable can also take the form of "@file", in which case the named
   * file will be loaded and interpreted as the value of the variable.
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_JOYSTICK_WHEEL_DEVICES = 'SDL_JOYSTICK_WHEEL_DEVICES';

  (**
   * A variable containing a list of devices that are not wheel style
   * controllers.
   *
   * This will override SDL_HINT_JOYSTICK_WHEEL_DEVICES and the built in device
   * list.
   *
   * The format of the string is a comma separated list of USB VID/PID pairs in
   * hexadecimal form, e.g.
   *
   * `0xAAAA/0xBBBB,0xCCCC/0xDDDD`
   *
   * The variable can also take the form of "@file", in which case the named
   * file will be loaded and interpreted as the value of the variable.
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_JOYSTICK_WHEEL_DEVICES_EXCLUDED = 'SDL_JOYSTICK_WHEEL_DEVICES_EXCLUDED';

  (**
   * A variable containing a list of devices known to have all axes centered at
   * zero.
   *
   * The format of the string is a comma separated list of USB VID/PID pairs in
   * hexadecimal form, e.g.
   *
   * `0xAAAA/0xBBBB,0xCCCC/0xDDDD`
   *
   * The variable can also take the form of "@file", in which case the named
   * file will be loaded and interpreted as the value of the variable.
   *
   * This hint should be set before a controller is opened.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_JOYSTICK_ZERO_CENTERED_DEVICES = 'SDL_JOYSTICK_ZERO_CENTERED_DEVICES';

  (**
   * A variable containing a list of devices and their desired number of haptic
   * (force feedback) enabled axis.
   *
   * The format of the string is a comma separated list of USB VID/PID pairs in
   * hexadecimal form plus the number of desired axes, e.g.
   *
   * `0xAAAA/0xBBBB/1,0xCCCC/0xDDDD/3`
   *
   * This hint supports a "wildcard" device that will set the number of haptic
   * axes on all initialized haptic devices which were not defined explicitly in
   * this hint.
   *
   * `0xFFFF/0xFFFF/1`
   *
   * This hint should be set before a controller is opened. The number of haptic
   * axes won't exceed the number of real axes found on the device.
   *
   * \since This hint is available since SDL 3.2.5.
   *)
  SDL_HINT_JOYSTICK_HAPTIC_AXES = 'SDL_JOYSTICK_HAPTIC_AXES';

  (**
   * A variable that controls keycode representation in keyboard events.
   *
   * This variable is a comma separated set of options for translating keycodes
   * in events:
   *
   * - "none": Keycode options are cleared, this overrides other options.
   * - "hide_numpad": The numpad keysyms will be translated into their
   *   non-numpad versions based on the current NumLock state. For example,
   *   SDLK_KP_4 would become SDLK_4 if SDL_KMOD_NUM is set in the event
   *   modifiers, and SDLK_LEFT if it is unset.
   * - "french_numbers": The number row on French keyboards is inverted, so
   *   pressing the 1 key would yield the keycode SDLK_1, or '1', instead of
   *   SDLK_AMPERSAND, or '&'
   * - "latin_letters": For keyboards using non-Latin letters, such as Russian
   *   or Thai, the letter keys generate keycodes as though it had an en_US
   *   layout. e.g. pressing the key associated with SDL_SCANCODE_A on a Russian
   *   keyboard would yield 'a' instead of a Cyrillic letter.
   *
   * The default value for this hint is "french_numbers,latin_letters"
   *
   * Some platforms like Emscripten only provide modified keycodes and the
   * options are not used.
   *
   * These options do not affect the return value of SDL_GetKeyFromScancode() or
   * SDL_GetScancodeFromKey(), they just apply to the keycode included in key
   * events.
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_KEYCODE_OPTIONS = 'SDL_KEYCODE_OPTIONS';

  (**
   * A variable that controls what KMSDRM device to use.
   *
   * SDL might open something like "/dev/dri/cardNN" to access KMSDRM
   * functionality, where "NN" is a device index number. SDL makes a guess at
   * the best index to use (usually zero), but the app or user can set this hint
   * to a number between 0 and 99 to force selection.
   *
   * This hint should be set before SDL is initialized.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_KMSDRM_DEVICE_INDEX = 'SDL_KMSDRM_DEVICE_INDEX';

  (**
   * A variable that controls whether SDL requires DRM master access in order to
   * initialize the KMSDRM video backend.
   *
   * The DRM subsystem has a concept of a "DRM master" which is a DRM client
   * that has the ability to set planes, set cursor, etc. When SDL is DRM
   * master, it can draw to the screen using the SDL rendering APIs. Without DRM
   * master, SDL is still able to process input and query attributes of attached
   * displays, but it cannot change display state or draw to the screen
   * directly.
   *
   * In some cases, it can be useful to have the KMSDRM backend even if it
   * cannot be used for rendering. An app may want to use SDL for input
   * processing while using another rendering API (such as an MMAL overlay on
   * Raspberry Pi) or using its own code to render to DRM overlays that SDL
   * doesn't support.
   *
   * The variable can be set to the following values:
   *
   * - "0": SDL will allow usage of the KMSDRM backend without DRM master.
   * - "1": SDL Will require DRM master to use the KMSDRM backend. (default)
   *
   * This hint should be set before SDL is initialized.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_KMSDRM_REQUIRE_DRM_MASTER = 'SDL_KMSDRM_REQUIRE_DRM_MASTER';

  (**
   * A variable controlling the default SDL log levels.
   *
   * This variable is a comma separated set of category=level tokens that define
   * the default logging levels for SDL applications.
   *
   * The category can be a numeric category, one of "app", "error", "assert",
   * "system", "audio", "video", "render", "input", "test", or `*` for any
   * unspecified category.
   *
   * The level can be a numeric level, one of "verbose", "debug", "info",
   * "warn", "error", "critical", or "quiet" to disable that category.
   *
   * You can omit the category if you want to set the logging level for all
   * categories.
   *
   * If this hint isn't set, the default log levels are equivalent to:
   *
   * `app=info,assert=warn,test=verbose,*=error`
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_LOGGING = 'SDL_LOGGING';

  (**
   * A variable controlling whether to force the application to become the
   * foreground process when launched on macOS.
   *
   * The variable can be set to the following values:
   *
   * - "0": The application is brought to the foreground when launched.
   *   (default)
   * - "1": The application may remain in the background when launched.
   *
   * This hint needs to be set before SDL_Init().
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_MAC_BACKGROUND_APP = 'SDL_MAC_BACKGROUND_APP';

  (**
   * A variable that determines whether Ctrl+Click should generate a right-click
   * event on macOS.
   *
   * The variable can be set to the following values:
   *
   * - "0": Ctrl+Click does not generate a right mouse button click event.
   *   (default)
   * - "1": Ctrl+Click generated a right mouse button click event.
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_MAC_CTRL_CLICK_EMULATE_RIGHT_CLICK = 'SDL_MAC_CTRL_CLICK_EMULATE_RIGHT_CLICK';

  (**
   * A variable controlling whether dispatching OpenGL context updates should
   * block the dispatching thread until the main thread finishes processing on
   * macOS.
   *
   * The variable can be set to the following values:
   *
   * - "0": Dispatching OpenGL context updates will block the dispatching thread
   *   until the main thread finishes processing. (default)
   * - "1": Dispatching OpenGL context updates will allow the dispatching thread
   *   to continue execution.
   *
   * Generally you want the default, but if you have OpenGL code in a background
   * thread on a Mac, and the main thread hangs because it's waiting for that
   * background thread, but that background thread is also hanging because it's
   * waiting for the main thread to do an update, this might fix your issue.
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_MAC_OPENGL_ASYNC_DISPATCH = 'SDL_MAC_OPENGL_ASYNC_DISPATCH';

  (**
   * A variable controlling whether the Option (⌥) key on macOS should be
   * remapped to act as the Alt key.
   *
   * The variable can be set to the following values:
   *
   * - "none": The Option key is not remapped to Alt. (default)
   * - "only_left": Only the left Option key is remapped to Alt.
   * - "only_right": Only the right Option key is remapped to Alt.
   * - "both": Both Option keys are remapped to Alt.
   *
   * This will prevent the triggering of key compositions that rely on the
   * Option key, but will still send the Alt modifier for keyboard events. In
   * the case that both Alt and Option are pressed, the Option key will be
   * ignored. This is particularly useful for applications like terminal
   * emulators and graphical user interfaces (GUIs) that rely on Alt key
   * functionality for shortcuts or navigation. This does not apply to
   * SDL_GetKeyFromScancode and only has an effect if IME is enabled.
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_MAC_OPTION_AS_ALT = 'SDL_MAC_OPTION_AS_ALT';

  (**
   * A variable controlling whether SDL_EVENT_MOUSE_WHEEL event values will have
   * momentum on macOS.
   *
   * The variable can be set to the following values:
   *
   * - "0": The mouse wheel events will have no momentum. (default)
   * - "1": The mouse wheel events will have momentum.
   *
   * This hint needs to be set before SDL_Init().
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_MAC_SCROLL_MOMENTUM = 'SDL_MAC_SCROLL_MOMENTUM';

  (**
   * Request SDL_AppIterate() be called at a specific rate.
   *
   * If this is set to a number, it represents Hz, so "60" means try to iterate
   * 60 times per second. "0" means to iterate as fast as possible. Negative
   * values are illegal, but reserved, in case they are useful in a future
   * revision of SDL.
   *
   * There are other strings that have special meaning. If set to "waitevent",
   * SDL_AppIterate will not be called until new event(s) have arrived (and been
   * processed by SDL_AppEvent). This can be useful for apps that are completely
   * idle except in response to input.
   *
   * On some platforms, or if you are using SDL_main instead of SDL_AppIterate,
   * this hint is ignored. When the hint can be used, it is allowed to be
   * changed at any time.
   *
   * This defaults to 0, and specifying NULL for the hint's value will restore
   * the default.
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_MAIN_CALLBACK_RATE = 'SDL_MAIN_CALLBACK_RATE';

  (**
   * A variable controlling whether the mouse is captured while mouse buttons
   * are pressed.
   *
   * The variable can be set to the following values:
   *
   * - "0": The mouse is not captured while mouse buttons are pressed.
   * - "1": The mouse is captured while mouse buttons are pressed.
   *
   * By default the mouse is captured while mouse buttons are pressed so if the
   * mouse is dragged outside the window, the application continues to receive
   * mouse events until the button is released.
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_MOUSE_AUTO_CAPTURE = 'SDL_MOUSE_AUTO_CAPTURE';

  (**
   * A variable setting the double click radius, in pixels.
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_MOUSE_DOUBLE_CLICK_RADIUS = 'SDL_MOUSE_DOUBLE_CLICK_RADIUS';

  (**
   * A variable setting the double click time, in milliseconds.
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_MOUSE_DOUBLE_CLICK_TIME = 'SDL_MOUSE_DOUBLE_CLICK_TIME';

  (**
   * A variable setting which system cursor to use as the default cursor.
   *
   * This should be an integer corresponding to the SDL_SystemCursor enum. The
   * default value is zero (SDL_SYSTEM_CURSOR_DEFAULT).
   *
   * This hint needs to be set before SDL_Init().
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_MOUSE_DEFAULT_SYSTEM_CURSOR = 'SDL_MOUSE_DEFAULT_SYSTEM_CURSOR';

  (**
   * A variable controlling whether warping a hidden mouse cursor will activate
   * relative mouse mode.
   *
   * When this hint is set, the mouse cursor is hidden, and multiple warps to
   * the window center occur within a short time period, SDL will emulate mouse
   * warps using relative mouse mode. This can provide smoother and more
   * reliable mouse motion for some older games, which continuously calculate
   * the distance travelled by the mouse pointer and warp it back to the center
   * of the window, rather than using relative mouse motion.
   *
   * Note that relative mouse mode may have different mouse acceleration
   * behavior than pointer warps.
   *
   * If your application needs to repeatedly warp the hidden mouse cursor at a
   * high-frequency for other purposes, it should disable this hint.
   *
   * The variable can be set to the following values:
   *
   * - "0": Attempts to warp the mouse will always be made.
   * - "1": Some mouse warps will be emulated by forcing relative mouse mode.
   *   (default)
   *
   * If not set, this is automatically enabled unless an application uses
   * relative mouse mode directly.
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_MOUSE_EMULATE_WARP_WITH_RELATIVE = 'SDL_MOUSE_EMULATE_WARP_WITH_RELATIVE';

  (**
   * Allow mouse click events when clicking to focus an SDL window.
   *
   * The variable can be set to the following values:
   *
   * - "0": Ignore mouse clicks that activate a window. (default)
   * - "1": Generate events for mouse clicks that activate a window.
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH = 'SDL_MOUSE_FOCUS_CLICKTHROUGH';

  (**
   * A variable setting the speed scale for mouse motion, in floating point,
   * when the mouse is not in relative mode.
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_MOUSE_NORMAL_SPEED_SCALE = 'SDL_MOUSE_NORMAL_SPEED_SCALE';

  (**
   * A variable controlling whether relative mouse mode constrains the mouse to
   * the center of the window.
   *
   * Constraining to the center of the window works better for FPS games and
   * when the application is running over RDP. Constraining to the whole window
   * works better for 2D games and increases the chance that the mouse will be
   * in the correct position when using high DPI mice.
   *
   * The variable can be set to the following values:
   *
   * - "0": Relative mouse mode constrains the mouse to the window.
   * - "1": Relative mouse mode constrains the mouse to the center of the
   *   window. (default)
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_MOUSE_RELATIVE_MODE_CENTER = 'SDL_MOUSE_RELATIVE_MODE_CENTER';

  (**
   * A variable setting the scale for mouse motion, in floating point, when the
   * mouse is in relative mode.
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_MOUSE_RELATIVE_SPEED_SCALE = 'SDL_MOUSE_RELATIVE_SPEED_SCALE';

  (**
   * A variable controlling whether the system mouse acceleration curve is used
   * for relative mouse motion.
   *
   * The variable can be set to the following values:
   *
   * - "0": Relative mouse motion will be unscaled. (default)
   * - "1": Relative mouse motion will be scaled using the system mouse
   *   acceleration curve.
   *
   * If SDL_HINT_MOUSE_RELATIVE_SPEED_SCALE is set, that will be applied after
   * system speed scale.
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_MOUSE_RELATIVE_SYSTEM_SCALE = 'SDL_MOUSE_RELATIVE_SYSTEM_SCALE';

  (**
   * A variable controlling whether a motion event should be generated for mouse
   * warping in relative mode.
   *
   * The variable can be set to the following values:
   *
   * - "0": Warping the mouse will not generate a motion event in relative mode
   * - "1": Warping the mouse will generate a motion event in relative mode
   *
   * By default warping the mouse will not generate motion events in relative
   * mode. This avoids the application having to filter out large relative
   * motion due to warping.
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_MOUSE_RELATIVE_WARP_MOTION = 'SDL_MOUSE_RELATIVE_WARP_MOTION';

  (**
   * A variable controlling whether the hardware cursor stays visible when
   * relative mode is active.
   *
   * This variable can be set to the following values:
   *
   * - "0": The cursor will be hidden while relative mode is active (default)
   * - "1": The cursor will remain visible while relative mode is active
   *
   * Note that for systems without raw hardware inputs, relative mode is
   * implemented using warping, so the hardware cursor will visibly warp between
   * frames if this is enabled on those systems.
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_MOUSE_RELATIVE_CURSOR_VISIBLE = 'SDL_MOUSE_RELATIVE_CURSOR_VISIBLE';

  (**
   * A variable controlling whether mouse events should generate synthetic touch
   * events.
   *
   * The variable can be set to the following values:
   *
   * - "0": Mouse events will not generate touch events. (default for desktop
   *   platforms)
   * - "1": Mouse events will generate touch events. (default for mobile
   *   platforms, such as Android and iOS)
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_MOUSE_TOUCH_EVENTS = 'SDL_MOUSE_TOUCH_EVENTS';

  (**
   * A variable controlling whether the keyboard should be muted on the console.
   *
   * Normally the keyboard is muted while SDL applications are running so that
   * keyboard input doesn't show up as key strokes on the console. This hint
   * allows you to turn that off for debugging purposes.
   *
   * The variable can be set to the following values:
   *
   * - "0": Allow keystrokes to go through to the console.
   * - "1": Mute keyboard input so it doesn't show up on the console. (default)
   *
   * This hint should be set before SDL is initialized.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_MUTE_CONSOLE_KEYBOARD = 'SDL_MUTE_CONSOLE_KEYBOARD';

  (**
   * Tell SDL not to catch the SIGINT or SIGTERM signals on POSIX platforms.
   *
   * The variable can be set to the following values:
   *
   * - "0": SDL will install a SIGINT and SIGTERM handler, and when it catches a
   *   signal, convert it into an SDL_EVENT_QUIT event. (default)
   * - "1": SDL will not install a signal handler at all.
   *
   * This hint should be set before SDL is initialized.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_NO_SIGNAL_HANDLERS = 'SDL_NO_SIGNAL_HANDLERS';

  (**
   * Specify the OpenGL library to load.
   *
   * This hint should be set before creating an OpenGL window or creating an
   * OpenGL context. If this hint isn't set, SDL will choose a reasonable
   * default.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_OPENGL_LIBRARY = 'SDL_OPENGL_LIBRARY';

  (**
   * Specify the EGL library to load.
   *
   * This hint should be set before creating an OpenGL window or creating an
   * OpenGL context. This hint is only considered if SDL is using EGL to manage
   * OpenGL contexts. If this hint isn't set, SDL will choose a reasonable
   * default.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_EGL_LIBRARY = 'SDL_EGL_LIBRARY';

  (**
   * A variable controlling what driver to use for OpenGL ES contexts.
   *
   * On some platforms, currently Windows and X11, OpenGL drivers may support
   * creating contexts with an OpenGL ES profile. By default SDL uses these
   * profiles, when available, otherwise it attempts to load an OpenGL ES
   * library, e.g. that provided by the ANGLE project. This variable controls
   * whether SDL follows this default behaviour or will always load an OpenGL ES
   * library.
   *
   * Circumstances where this is useful include - Testing an app with a
   * particular OpenGL ES implementation, e.g ANGLE, or emulator, e.g. those
   * from ARM, Imagination or Qualcomm. - Resolving OpenGL ES function addresses
   * at link time by linking with the OpenGL ES library instead of querying them
   * at run time with SDL_GL_GetProcAddress().
   *
   * Caution: for an application to work with the default behaviour across
   * different OpenGL drivers it must query the OpenGL ES function addresses at
   * run time using SDL_GL_GetProcAddress().
   *
   * This variable is ignored on most platforms because OpenGL ES is native or
   * not supported.
   *
   * The variable can be set to the following values:
   *
   * - "0": Use ES profile of OpenGL, if available. (default)
   * - "1": Load OpenGL ES library using the default library names.
   *
   * This hint should be set before SDL is initialized.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_OPENGL_ES_DRIVER = 'SDL_OPENGL_ES_DRIVER';

  (**
   * Mechanism to specify openvr_api library location
   *
   * By default, when using the OpenVR driver, it will search for the API
   * library in the current folder. But, if you wish to use a system API you can
   * specify that by using this hint. This should be the full or relative path
   * to a .dll on Windows or .so on Linux.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_OPENVR_LIBRARY              = 'SDL_OPENVR_LIBRARY';

  (**
   * A variable controlling which orientations are allowed on iOS/Android.
   *
   * In some circumstances it is necessary to be able to explicitly control
   * which UI orientations are allowed.
   *
   * This variable is a space delimited list of the following values:
   *
   * - "LandscapeLeft"
   * - "LandscapeRight"
   * - "Portrait"
   * - "PortraitUpsideDown"
   *
   * This hint should be set before SDL is initialized.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_ORIENTATIONS = 'SDL_ORIENTATIONS';

  (**
   * A variable controlling the use of a sentinel event when polling the event
   * queue.
   *
   * When polling for events, SDL_PumpEvents is used to gather new events from
   * devices. If a device keeps producing new events between calls to
   * SDL_PumpEvents, a poll loop will become stuck until the new events stop.
   * This is most noticeable when moving a high frequency mouse.
   *
   * The variable can be set to the following values:
   *
   * - "0": Disable poll sentinels.
   * - "1": Enable poll sentinels. (default)
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_POLL_SENTINEL = 'SDL_POLL_SENTINEL';

  (**
   * Override for SDL_GetPreferredLocales().
   *
   * If set, this will be favored over anything the OS might report for the
   * user's preferred locales. Changing this hint at runtime will not generate a
   * SDL_EVENT_LOCALE_CHANGED event (but if you can change the hint, you can
   * push your own event, if you want).
   *
   * The format of this hint is a comma-separated list of language and locale,
   * combined with an underscore, as is a common format: "en_GB". Locale is
   * optional: "en". So you might have a list like this: "en_GB,jp,es_PT"
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_PREFERRED_LOCALES = 'SDL_PREFERRED_LOCALES';

  (**
   * A variable that decides whether to send SDL_EVENT_QUIT when closing the
   * last window.
   *
   * The variable can be set to the following values:
   *
   * - "0": SDL will not send an SDL_EVENT_QUIT event when the last window is
   *   requesting to close. Note that in this case, there are still other
   *   legitimate reasons one might get an SDL_EVENT_QUIT event: choosing "Quit"
   *   from the macOS menu bar, sending a SIGINT (ctrl-c) on Unix, etc.
   * - "1": SDL will send a quit event when the last window is requesting to
   *   close. (default)
   *
   * If there is at least one active system tray icon, SDL_EVENT_QUIT will
   * instead be sent when both the last window will be closed and the last tray
   * icon will be destroyed.
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_QUIT_ON_LAST_WINDOW_CLOSE = 'SDL_QUIT_ON_LAST_WINDOW_CLOSE';

  (**
   * A variable controlling whether the Direct3D device is initialized for
   * thread-safe operations.
   *
   * The variable can be set to the following values:
   *
   * - "0": Thread-safety is not enabled. (default)
   * - "1": Thread-safety is enabled.
   *
   * This hint should be set before creating a renderer.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_RENDER_DIRECT3D_THREADSAFE = 'SDL_RENDER_DIRECT3D_THREADSAFE';

  (**
   * A variable controlling whether to enable Direct3D 11+'s Debug Layer.
   *
   * This variable does not have any effect on the Direct3D 9 based renderer.
   *
   * The variable can be set to the following values:
   *
   * - "0": Disable Debug Layer use. (default)
   * - "1": Enable Debug Layer use.
   *
   * This hint should be set before creating a renderer.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_RENDER_DIRECT3D11_DEBUG = 'SDL_RENDER_DIRECT3D11_DEBUG';

  (**
   * A variable controlling whether to enable Vulkan Validation Layers.
   *
   * This variable can be set to the following values:
   *
   * - "0": Disable Validation Layer use
   * - "1": Enable Validation Layer use
   *
   * By default, SDL does not use Vulkan Validation Layers.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_RENDER_VULKAN_DEBUG = 'SDL_RENDER_VULKAN_DEBUG';

  (**
   * A variable controlling whether to create the GPU device in debug mode.
   *
   * This variable can be set to the following values:
   *
   * - "0": Disable debug mode use (default)
   * - "1": Enable debug mode use
   *
   * This hint should be set before creating a renderer.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_RENDER_GPU_DEBUG = 'SDL_RENDER_GPU_DEBUG';

  (**
   * A variable controlling whether to prefer a low-power GPU on multi-GPU
   * systems.
   *
   * This variable can be set to the following values:
   *
   * - "0": Prefer high-performance GPU (default)
   * - "1": Prefer low-power GPU
   *
   * This hint should be set before creating a renderer.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_RENDER_GPU_LOW_POWER = 'SDL_RENDER_GPU_LOW_POWER';

  (**
   * A variable specifying which render driver to use.
   *
   * If the application doesn't pick a specific renderer to use, this variable
   * specifies the name of the preferred renderer. If the preferred renderer
   * can't be initialized, creating a renderer will fail.
   *
   * This variable is case insensitive and can be set to the following values:
   *
   * - "direct3d"
   * - "direct3d11"
   * - "direct3d12"
   * - "opengl"
   * - "opengles2"
   * - "opengles"
   * - "metal"
   * - "vulkan"
   * - "gpu"
   * - "software"
   *
   * This hint accepts a comma-separated list of driver names, and each will be
   * tried in the order listed when creating a renderer until one succeeds or
   * all of them fail.
   *
   * The default varies by platform, but it's the first one in the list that is
   * available on the current platform.
   *
   * This hint should be set before creating a renderer.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_RENDER_DRIVER = 'SDL_RENDER_DRIVER';

  (**
   * A variable controlling how the 2D render API renders lines.
   *
   * The variable can be set to the following values:
   *
   * - "0": Use the default line drawing method (Bresenham's line algorithm)
   * - "1": Use the driver point API using Bresenham's line algorithm (correct,
   *   draws many points)
   * - "2": Use the driver line API (occasionally misses line endpoints based on
   *   hardware driver quirks
   * - "3": Use the driver geometry API (correct, draws thicker diagonal lines)
   *
   * This hint should be set before creating a renderer.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_RENDER_LINE_METHOD = 'SDL_RENDER_LINE_METHOD';

  (**
   * A variable controlling whether the Metal render driver select low power
   * device over default one.
   *
   * The variable can be set to the following values:
   *
   * - "0": Use the preferred OS device. (default)
   * - "1": Select a low power device.
   *
   * This hint should be set before creating a renderer.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_RENDER_METAL_PREFER_LOW_POWER_DEVICE = 'SDL_RENDER_METAL_PREFER_LOW_POWER_DEVICE';

  (**
   * A variable controlling whether updates to the SDL screen surface should be
   * synchronized with the vertical refresh, to avoid tearing.
   *
   * This hint overrides the application preference when creating a renderer.
   *
   * The variable can be set to the following values:
   *
   * - "0": Disable vsync. (default)
   * - "1": Enable vsync.
   *
   * This hint should be set before creating a renderer.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_RENDER_VSYNC = 'SDL_RENDER_VSYNC';

  (**
   * A variable to control whether the return key on the soft keyboard should
   * hide the soft keyboard on Android and iOS.
   *
   * This hint sets the default value of SDL_PROP_TEXTINPUT_MULTILINE_BOOLEAN.
   *
   * The variable can be set to the following values:
   *
   * - "0": The return key will be handled as a key event. (default)
   * - "1": The return key will hide the keyboard.
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_RETURN_KEY_HIDES_IME = 'SDL_RETURN_KEY_HIDES_IME';

  (**
   * A variable containing a list of ROG gamepad capable mice.
   *
   * The format of the string is a comma separated list of USB VID/PID pairs in
   * hexadecimal form, e.g.
   *
   * `0xAAAA/0xBBBB,0xCCCC/0xDDDD`
   *
   * The variable can also take the form of "@file", in which case the named
   * file will be loaded and interpreted as the value of the variable.
   *
   * This hint should be set before SDL is initialized.
   *
   * \since This hint is available since SDL 3.2.0.
   *
   * \sa SDL_HINT_ROG_GAMEPAD_MICE_EXCLUDED
   *)
  SDL_HINT_ROG_GAMEPAD_MICE = 'SDL_ROG_GAMEPAD_MICE';

  (**
   * A variable containing a list of devices that are not ROG gamepad capable
   * mice.
   *
   * This will override SDL_HINT_ROG_GAMEPAD_MICE and the built in device list.
   *
   * The format of the string is a comma separated list of USB VID/PID pairs in
   * hexadecimal form, e.g.
   *
   * `0xAAAA/0xBBBB,0xCCCC/0xDDDD`
   *
   * The variable can also take the form of "@file", in which case the named
   * file will be loaded and interpreted as the value of the variable.
   *
   * This hint should be set before SDL is initialized.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_ROG_GAMEPAD_MICE_EXCLUDED = 'SDL_ROG_GAMEPAD_MICE_EXCLUDED';

  (**
   * A variable controlling which Dispmanx layer to use on a Raspberry PI.
   *
   * Also known as Z-order. The variable can take a negative or positive value.
   * The default is 10000.
   *
   * This hint should be set before SDL is initialized.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_RPI_VIDEO_LAYER = 'SDL_RPI_VIDEO_LAYER';

  (**
   * Specify an "activity name" for screensaver inhibition.
   *
   * Some platforms, notably Linux desktops, list the applications which are
   * inhibiting the screensaver or other power-saving features.
   *
   * This hint lets you specify the "activity name" sent to the OS when
   * SDL_DisableScreenSaver() is used (or the screensaver is automatically
   * disabled). The contents of this hint are used when the screensaver is
   * disabled. You should use a string that describes what your program is doing
   * (and, therefore, why the screensaver is disabled). For example, "Playing a
   * game" or "Watching a video".
   *
   * Setting this to "" or leaving it unset will have SDL use a reasonable
   * default: "Playing a game" or something similar.
   *
   * This hint should be set before calling SDL_DisableScreenSaver()
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_SCREENSAVER_INHIBIT_ACTIVITY_NAME = 'SDL_SCREENSAVER_INHIBIT_ACTIVITY_NAME';

  (**
   * A variable controlling whether SDL calls dbus_shutdown() on quit.
   *
   * This is useful as a debug tool to validate memory leaks, but shouldn't ever
   * be set in production applications, as other libraries used by the
   * application might use dbus under the hood and this can cause crashes if
   * they continue after SDL_Quit().
   *
   * The variable can be set to the following values:
   *
   * - "0": SDL will not call dbus_shutdown() on quit. (default)
   * - "1": SDL will call dbus_shutdown() on quit.
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_SHUTDOWN_DBUS_ON_QUIT = 'SDL_SHUTDOWN_DBUS_ON_QUIT';

  (**
   * A variable that specifies a backend to use for title storage.
   *
   * By default, SDL will try all available storage backends in a reasonable
   * order until it finds one that can work, but this hint allows the app or
   * user to force a specific target, such as "pc" if, say, you are on Steam but
   * want to avoid SteamRemoteStorage for title data.
   *
   * This hint should be set before SDL is initialized.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_STORAGE_TITLE_DRIVER = 'SDL_STORAGE_TITLE_DRIVER';

  (**
   * A variable that specifies a backend to use for user storage.
   *
   * By default, SDL will try all available storage backends in a reasonable
   * order until it finds one that can work, but this hint allows the app or
   * user to force a specific target, such as "pc" if, say, you are on Steam but
   * want to avoid SteamRemoteStorage for user data.
   *
   * This hint should be set before SDL is initialized.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_STORAGE_USER_DRIVER = 'SDL_STORAGE_USER_DRIVER';

  (**
   * Specifies whether SDL_THREAD_PRIORITY_TIME_CRITICAL should be treated as
   * realtime.
   *
   * On some platforms, like Linux, a realtime priority thread may be subject to
   * restrictions that require special handling by the application. This hint
   * exists to let SDL know that the app is prepared to handle said
   * restrictions.
   *
   * On Linux, SDL will apply the following configuration to any thread that
   * becomes realtime:
   *
   * - The SCHED_RESET_ON_FORK bit will be set on the scheduling policy,
   * - An RLIMIT_RTTIME budget will be configured to the rtkit specified limit.
   * - Exceeding this limit will result in the kernel sending SIGKILL to the
   *   app, refer to the man pages for more information.
   *
   * The variable can be set to the following values:
   *
   * - "0": default platform specific behaviour
   * - "1": Force SDL_THREAD_PRIORITY_TIME_CRITICAL to a realtime scheduling
   *   policy
   *
   * This hint should be set before calling SDL_SetCurrentThreadPriority()
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_THREAD_FORCE_REALTIME_TIME_CRITICAL = 'SDL_THREAD_FORCE_REALTIME_TIME_CRITICAL';

  (**
   * A string specifying additional information to use with
   * SDL_SetCurrentThreadPriority.
   *
   * By default SDL_SetCurrentThreadPriority will make appropriate system
   * changes in order to apply a thread priority. For example on systems using
   * pthreads the scheduler policy is changed automatically to a policy that
   * works well with a given priority. Code which has specific requirements can
   * override SDL's default behavior with this hint.
   *
   * pthread hint values are "current", "other", "fifo" and "rr". Currently no
   * other platform hint values are defined but may be in the future.
   *
   * On Linux, the kernel may send SIGKILL to realtime tasks which exceed the
   * distro configured execution budget for rtkit. This budget can be queried
   * through RLIMIT_RTTIME after calling SDL_SetCurrentThreadPriority().
   *
   * This hint should be set before calling SDL_SetCurrentThreadPriority()
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_THREAD_PRIORITY_POLICY = 'SDL_THREAD_PRIORITY_POLICY';

  (**
   * A variable that controls the timer resolution, in milliseconds.
   *
   * The higher resolution the timer, the more frequently the CPU services timer
   * interrupts, and the more precise delays are, but this takes up power and
   * CPU time. This hint is only used on Windows.
   *
   * See this blog post for more information:
   * http://randomascii.wordpress.com/2013/07/08/windows-timer-resolution-megawatts-wasted/
   *
   * The default value is "1".
   *
   * If this variable is set to "0", the system timer resolution is not set.
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_TIMER_RESOLUTION = 'SDL_TIMER_RESOLUTION';

  (**
   * A variable controlling whether touch events should generate synthetic mouse
   * events.
   *
   * The variable can be set to the following values:
   *
   * - "0": Touch events will not generate mouse events.
   * - "1": Touch events will generate mouse events. (default)
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_TOUCH_MOUSE_EVENTS = 'SDL_TOUCH_MOUSE_EVENTS';

  (**
   * A variable controlling whether trackpads should be treated as touch
   * devices.
   *
   * On macOS (and possibly other platforms in the future), SDL will report
   * touches on a trackpad as mouse input, which is generally what users expect
   * from this device; however, these are often actually full multitouch-capable
   * touch devices, so it might be preferable to some apps to treat them as
   * such.
   *
   * The variable can be set to the following values:
   *
   * - "0": Trackpad will send mouse events. (default)
   * - "1": Trackpad will send touch events.
   *
   * This hint should be set before SDL is initialized.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_TRACKPAD_IS_TOUCH_ONLY = 'SDL_TRACKPAD_IS_TOUCH_ONLY';

  (**
   * A variable controlling whether the Android / tvOS remotes should be listed
   * as joystick devices, instead of sending keyboard events.
   *
   * The variable can be set to the following values:
   *
   * - "0": Remotes send enter/escape/arrow key events.
   * - "1": Remotes are available as 2 axis, 2 button joysticks. (default)
   *
   * This hint should be set before SDL is initialized.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_TV_REMOTE_AS_JOYSTICK = 'SDL_TV_REMOTE_AS_JOYSTICK';

  (**
   * A variable controlling whether the screensaver is enabled.
   *
   * The variable can be set to the following values:
   *
   * - "0": Disable screensaver. (default)
   * - "1": Enable screensaver.
   *
   * This hint should be set before SDL is initialized.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_VIDEO_ALLOW_SCREENSAVER = 'SDL_VIDEO_ALLOW_SCREENSAVER';

  (**
   * A comma separated list containing the names of the displays that SDL should
   * sort to the front of the display list.
   *
   * When this hint is set, displays with matching name strings will be
   * prioritized in the list of displays, as exposed by calling
   * SDL_GetDisplays(), with the first listed becoming the primary display. The
   * naming convention can vary depending on the environment, but it is usually
   * a connector name (e.g. 'DP-1', 'DP-2', 'HDMI-A-1',etc...).
   *
   * On Wayland and X11 desktops, the connector names associated with displays
   * can typically be found by using the `xrandr` utility.
   *
   * This hint is currently supported on the following drivers:
   *
   * - KMSDRM (kmsdrm)
   * - Wayland (wayland)
   * - X11 (x11)
   *
   * This hint should be set before SDL is initialized.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_VIDEO_DISPLAY_PRIORITY = 'SDL_VIDEO_DISPLAY_PRIORITY';

  (**
   * Tell the video driver that we only want a double buffer.
   *
   * By default, most lowlevel 2D APIs will use a triple buffer scheme that
   * wastes no CPU time on waiting for vsync after issuing a flip, but
   * introduces a frame of latency. On the other hand, using a double buffer
   * scheme instead is recommended for cases where low latency is an important
   * factor because we save a whole frame of latency.
   *
   * We do so by waiting for vsync immediately after issuing a flip, usually
   * just after eglSwapBuffers call in the backend's *_SwapWindow function.
   *
   * This hint is currently supported on the following drivers:
   *
   * - Raspberry Pi (raspberrypi)
   * - Wayland (wayland)
   *
   * This hint should be set before SDL is initialized.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_VIDEO_DOUBLE_BUFFER = 'SDL_VIDEO_DOUBLE_BUFFER';

  (**
   * A variable that specifies a video backend to use.
   *
   * By default, SDL will try all available video backends in a reasonable order
   * until it finds one that can work, but this hint allows the app or user to
   * force a specific target, such as "x11" if, say, you are on Wayland but want
   * to try talking to the X server instead.
   *
   * This hint accepts a comma-separated list of driver names, and each will be
   * tried in the order listed during init, until one succeeds or all of them
   * fail.
   *
   * This hint should be set before SDL is initialized.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_VIDEO_DRIVER = 'SDL_VIDEO_DRIVER';

  (**
   * A variable controlling whether the dummy video driver saves output frames.
   *
   * - "0": Video frames are not saved to disk. (default)
   * - "1": Video frames are saved to files in the format "SDL_windowX-Y.bmp",
   *   where X is the window ID, and Y is the frame number.
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_VIDEO_DUMMY_SAVE_FRAMES = 'SDL_VIDEO_DUMMY_SAVE_FRAMES';

  (**
   * If eglGetPlatformDisplay fails, fall back to calling eglGetDisplay.
   *
   * The variable can be set to one of the following values:
   *
   * - "0": Do not fall back to eglGetDisplay.
   * - "1": Fall back to eglGetDisplay if eglGetPlatformDisplay fails. (default)
   *
   * This hint should be set before SDL is initialized.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_VIDEO_EGL_ALLOW_GETDISPLAY_FALLBACK = 'SDL_VIDEO_EGL_ALLOW_GETDISPLAY_FALLBACK';

  (**
   * A variable controlling whether the OpenGL context should be created with
   * EGL.
   *
   * The variable can be set to the following values:
   *
   * - "0": Use platform-specific GL context creation API (GLX, WGL, CGL, etc).
   *   (default)
   * - "1": Use EGL
   *
   * This hint should be set before SDL is initialized.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_VIDEO_FORCE_EGL = 'SDL_VIDEO_FORCE_EGL';

  (**
   * A variable that specifies the policy for fullscreen Spaces on macOS.
   *
   * The variable can be set to the following values:
   *
   * - "0": Disable Spaces support (FULLSCREEN_DESKTOP won't use them and
   *   SDL_WINDOW_RESIZABLE windows won't offer the "fullscreen" button on their
   *   titlebars).
   * - "1": Enable Spaces support (FULLSCREEN_DESKTOP will use them and
   *   SDL_WINDOW_RESIZABLE windows will offer the "fullscreen" button on their
   *   titlebars). (default)
   *
   * This hint should be set before creating a window.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_VIDEO_MAC_FULLSCREEN_SPACES = 'SDL_VIDEO_MAC_FULLSCREEN_SPACES';

  (**
   * A variable that specifies the menu visibility when a window is fullscreen
   * in Spaces on macOS.
   *
   * The variable can be set to the following values:
   *
   * - "0": The menu will be hidden when the window is in a fullscreen space,
   *   and not accessible by moving the mouse to the top of the screen.
   * - "1": The menu will be accessible when the window is in a fullscreen
   *   space.
   * - "auto": The menu will be hidden if fullscreen mode was toggled on
   *   programmatically via `SDL_SetWindowFullscreen()`, and accessible if
   *   fullscreen was entered via the "fullscreen" button on the window title
   *   bar. (default)
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_VIDEO_MAC_FULLSCREEN_MENU_VISIBILITY = 'SDL_VIDEO_MAC_FULLSCREEN_MENU_VISIBILITY';

  (**
   * A variable controlling whether fullscreen windows are minimized when they
   * lose focus.
   *
   * The variable can be set to the following values:
   *
   * - "0": Fullscreen windows will not be minimized when they lose focus.
   *   (default)
   * - "1": Fullscreen windows are minimized when they lose focus.
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_VIDEO_MINIMIZE_ON_FOCUS_LOSS = 'SDL_VIDEO_MINIMIZE_ON_FOCUS_LOSS';

  (**
   * A variable controlling whether the offscreen video driver saves output
   * frames.
   *
   * This only saves frames that are generated using software rendering, not
   * accelerated OpenGL rendering.
   *
   * - "0": Video frames are not saved to disk. (default)
   * - "1": Video frames are saved to files in the format "SDL_windowX-Y.bmp",
   *   where X is the window ID, and Y is the frame number.
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_VIDEO_OFFSCREEN_SAVE_FRAMES = 'SDL_VIDEO_OFFSCREEN_SAVE_FRAMES';

  (**
   * A variable controlling whether all window operations will block until
   * complete.
   *
   * Window systems that run asynchronously may not have the results of window
   * operations that resize or move the window applied immediately upon the
   * return of the requesting function. Setting this hint will cause such
   * operations to block after every call until the pending operation has
   * completed. Setting this to '1' is the equivalent of calling
   * SDL_SyncWindow() after every function call.
   *
   * Be aware that amount of time spent blocking while waiting for window
   * operations to complete can be quite lengthy, as animations may have to
   * complete, which can take upwards of multiple seconds in some cases.
   *
   * The variable can be set to the following values:
   *
   * - "0": Window operations are non-blocking. (default)
   * - "1": Window operations will block until completed.
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_VIDEO_SYNC_WINDOW_OPERATIONS = 'SDL_VIDEO_SYNC_WINDOW_OPERATIONS';

  (**
   * A variable controlling whether the libdecor Wayland backend is allowed to
   * be used.
   *
   * libdecor is used over xdg-shell when xdg-decoration protocol is
   * unavailable.
   *
   * The variable can be set to the following values:
   *
   * - "0": libdecor use is disabled.
   * - "1": libdecor use is enabled. (default)
   *
   * This hint should be set before SDL is initialized.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_VIDEO_WAYLAND_ALLOW_LIBDECOR = 'SDL_VIDEO_WAYLAND_ALLOW_LIBDECOR';

  (**
   * A variable controlling whether video mode emulation is enabled under
   * Wayland.
   *
   * When this hint is set, a standard set of emulated CVT video modes will be
   * exposed for use by the application. If it is disabled, the only modes
   * exposed will be the logical desktop size and, in the case of a scaled
   * desktop, the native display resolution.
   *
   * The variable can be set to the following values:
   *
   * - "0": Video mode emulation is disabled.
   * - "1": Video mode emulation is enabled. (default)
   *
   * This hint should be set before SDL is initialized.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_VIDEO_WAYLAND_MODE_EMULATION = 'SDL_VIDEO_WAYLAND_MODE_EMULATION';

  (**
   * A variable controlling how modes with a non-native aspect ratio are
   * displayed under Wayland.
   *
   * When this hint is set, the requested scaling will be used when displaying
   * fullscreen video modes that don't match the display's native aspect ratio.
   * This is contingent on compositor viewport support.
   *
   * The variable can be set to the following values:
   *
   * - "aspect" - Video modes will be displayed scaled, in their proper aspect
   *   ratio, with black bars.
   * - "stretch" - Video modes will be scaled to fill the entire display.
   *   (default)
   * - "none" - Video modes will be displayed as 1:1 with no scaling.
   *
   * This hint should be set before creating a window.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_VIDEO_WAYLAND_MODE_SCALING = 'SDL_VIDEO_WAYLAND_MODE_SCALING';

  (**
   * A variable controlling whether the libdecor Wayland backend is preferred
   * over native decorations.
   *
   * When this hint is set, libdecor will be used to provide window decorations,
   * even if xdg-decoration is available. (Note that, by default, libdecor will
   * use xdg-decoration itself if available).
   *
   * The variable can be set to the following values:
   *
   * - "0": libdecor is enabled only if server-side decorations are unavailable.
   *   (default)
   * - "1": libdecor is always enabled if available.
   *
   * This hint should be set before SDL is initialized.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_VIDEO_WAYLAND_PREFER_LIBDECOR = 'SDL_VIDEO_WAYLAND_PREFER_LIBDECOR';

  (**
   * A variable forcing non-DPI-aware Wayland windows to output at 1:1 scaling.
   *
   * This must be set before initializing the video subsystem.
   *
   * When this hint is set, Wayland windows that are not flagged as being
   * DPI-aware will be output with scaling designed to force 1:1 pixel mapping.
   *
   * This is intended to allow legacy applications to be displayed without
   * desktop scaling being applied, and has issues with certain display
   * configurations, as this forces the window to behave in a way that Wayland
   * desktops were not designed to accommodate:
   *
   * - Rounding errors can result with odd window sizes and/or desktop scales,
   *   which can cause the window contents to appear slightly blurry.
   * - Positioning the window may be imprecise due to unit conversions and
   *   rounding.
   * - The window may be unusably small on scaled desktops.
   * - The window may jump in size when moving between displays of different
   *   scale factors.
   * - Displays may appear to overlap when using a multi-monitor setup with
   *   scaling enabled.
   * - Possible loss of cursor precision due to the logical size of the window
   *   being reduced.
   *
   * New applications should be designed with proper DPI awareness handling
   * instead of enabling this.
   *
   * The variable can be set to the following values:
   *
   * - "0": Windows will be scaled normally.
   * - "1": Windows will be forced to scale to achieve 1:1 output.
   *
   * This hint should be set before creating a window.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_VIDEO_WAYLAND_SCALE_TO_DISPLAY = 'SDL_VIDEO_WAYLAND_SCALE_TO_DISPLAY';

  (**
   * A variable specifying which shader compiler to preload when using the
   * Chrome ANGLE binaries.
   *
   * SDL has EGL and OpenGL ES2 support on Windows via the ANGLE project. It can
   * use two different sets of binaries, those compiled by the user from source
   * or those provided by the Chrome browser. In the later case, these binaries
   * require that SDL loads a DLL providing the shader compiler.
   *
   * The variable can be set to the following values:
   *
   * - "d3dcompiler_46.dll" - best for Vista or later. (default)
   * - "d3dcompiler_43.dll" - for XP support.
   * - "none" - do not load any library, useful if you compiled ANGLE from
   *   source and included the compiler in your binaries.
   *
   * This hint should be set before SDL is initialized.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_VIDEO_WIN_D3DCOMPILER = 'SDL_VIDEO_WIN_D3DCOMPILER';

  (**
   * A variable controlling whether the X11 _NET_WM_BYPASS_COMPOSITOR hint
   * should be used.
   *
   * The variable can be set to the following values:
   *
   * - "0": Disable _NET_WM_BYPASS_COMPOSITOR.
   * - "1": Enable _NET_WM_BYPASS_COMPOSITOR. (default)
   *
   * This hint should be set before creating a window.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR = 'SDL_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR';

  (**
   * A variable controlling whether the X11 _NET_WM_PING protocol should be
   * supported.
   *
   * By default SDL will use _NET_WM_PING, but for applications that know they
   * will not always be able to respond to ping requests in a timely manner they
   * can turn it off to avoid the window manager thinking the app is hung.
   *
   * The variable can be set to the following values:
   *
   * - "0": Disable _NET_WM_PING.
   * - "1": Enable _NET_WM_PING. (default)
   *
   * This hint should be set before creating a window.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_VIDEO_X11_NET_WM_PING = 'SDL_VIDEO_X11_NET_WM_PING';

  (**
   * A variable controlling whether SDL uses DirectColor visuals.
   *
   * The variable can be set to the following values:
   *
   * - "0": Disable DirectColor visuals.
   * - "1": Enable DirectColor visuals. (default)
   *
   * This hint should be set before initializing the video subsystem.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_VIDEO_X11_NODIRECTCOLOR = 'SDL_VIDEO_X11_NODIRECTCOLOR';

  (**
   * A variable forcing the content scaling factor for X11 displays.
   *
   * The variable can be set to a floating point value in the range 1.0-10.0f
   *
   * This hint should be set before SDL is initialized.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_VIDEO_X11_SCALING_FACTOR = 'SDL_VIDEO_X11_SCALING_FACTOR';

  (**
   * A variable forcing the visual ID used for X11 display modes.
   *
   * This hint should be set before initializing the video subsystem.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_VIDEO_X11_VISUALID = 'SDL_VIDEO_X11_VISUALID';

  (**
   * A variable forcing the visual ID chosen for new X11 windows.
   *
   * This hint should be set before creating a window.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_VIDEO_X11_WINDOW_VISUALID = 'SDL_VIDEO_X11_WINDOW_VISUALID';

  (**
   * A variable controlling whether the X11 XRandR extension should be used.
   *
   * The variable can be set to the following values:
   *
   * - "0": Disable XRandR.
   * - "1": Enable XRandR. (default)
   *
   * This hint should be set before SDL is initialized.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_VIDEO_X11_XRANDR = 'SDL_VIDEO_X11_XRANDR';

  (**
   * A variable controlling whether touch should be enabled on the back panel of
   * the PlayStation Vita.
   *
   * The variable can be set to the following values:
   *
   * - "0": Disable touch on the back panel.
   * - "1": Enable touch on the back panel. (default)
   *
   * This hint should be set before SDL is initialized.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_VITA_ENABLE_BACK_TOUCH = 'SDL_VITA_ENABLE_BACK_TOUCH';

  (**
   * A variable controlling whether touch should be enabled on the front panel
   * of the PlayStation Vita.
   *
   * The variable can be set to the following values:
   *
   * - "0": Disable touch on the front panel.
   * - "1": Enable touch on the front panel. (default)
   *
   * This hint should be set before SDL is initialized.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_VITA_ENABLE_FRONT_TOUCH = 'SDL_VITA_ENABLE_FRONT_TOUCH';

  (**
   * A variable controlling the module path on the PlayStation Vita.
   *
   * This hint defaults to "app0:module"
   *
   * This hint should be set before SDL is initialized.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_VITA_MODULE_PATH = 'SDL_VITA_MODULE_PATH';

  (**
   * A variable controlling whether to perform PVR initialization on the
   * PlayStation Vita.
   *
   * - "0": Skip PVR initialization.
   * - "1": Perform the normal PVR initialization. (default)
   *
   * This hint should be set before SDL is initialized.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_VITA_PVR_INIT = 'SDL_VITA_PVR_INIT';

  (**
   * A variable overriding the resolution reported on the PlayStation Vita.
   *
   * The variable can be set to the following values:
   *
   * - "544": 544p (default)
   * - "720": 725p for PSTV
   * - "1080": 1088i for PSTV
   *
   * This hint should be set before SDL is initialized.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_VITA_RESOLUTION = 'SDL_VITA_RESOLUTION';

  (**
   * A variable controlling whether OpenGL should be used instead of OpenGL ES
   * on the PlayStation Vita.
   *
   * The variable can be set to the following values:
   *
   * - "0": Use OpenGL ES. (default)
   * - "1": Use OpenGL.
   *
   * This hint should be set before SDL is initialized.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_VITA_PVR_OPENGL = 'SDL_VITA_PVR_OPENGL';

  (**
   * A variable controlling which touchpad should generate synthetic mouse
   * events.
   *
   * The variable can be set to the following values:
   *
   * - "0": Only front touchpad should generate mouse events. (default)
   * - "1": Only back touchpad should generate mouse events.
   * - "2": Both touchpads should generate mouse events.
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_VITA_TOUCH_MOUSE_DEVICE = 'SDL_VITA_TOUCH_MOUSE_DEVICE';

  (**
   * A variable overriding the display index used in SDL_Vulkan_CreateSurface()
   *
   * The display index starts at 0, which is the default.
   *
   * This hint should be set before calling SDL_Vulkan_CreateSurface()
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_VULKAN_DISPLAY = 'SDL_VULKAN_DISPLAY';

  (**
   * Specify the Vulkan library to load.
   *
   * This hint should be set before creating a Vulkan window or calling
   * SDL_Vulkan_LoadLibrary().
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_VULKAN_LIBRARY = 'SDL_VULKAN_LIBRARY';

  (**
   * A variable controlling how the fact chunk affects the loading of a WAVE
   * file.
   *
   * The fact chunk stores information about the number of samples of a WAVE
   * file. The Standards Update from Microsoft notes that this value can be used
   * to 'determine the length of the data in seconds'. This is especially useful
   * for compressed formats (for which this is a mandatory chunk) if they
   * produce multiple sample frames per block and truncating the block is not
   * allowed. The fact chunk can exactly specify how many sample frames there
   * should be in this case.
   *
   * Unfortunately, most application seem to ignore the fact chunk and so SDL
   * ignores it by default as well.
   *
   * The variable can be set to the following values:
   *
   * - "truncate" - Use the number of samples to truncate the wave data if the
   *   fact chunk is present and valid.
   * - "strict" - Like "truncate", but raise an error if the fact chunk is
   *   invalid, not present for non-PCM formats, or if the data chunk doesn't
   *   have that many samples.
   * - "ignorezero" - Like "truncate", but ignore fact chunk if the number of
   *   samples is zero.
   * - "ignore" - Ignore fact chunk entirely. (default)
   *
   * This hint should be set before calling SDL_LoadWAV() or SDL_LoadWAV_IO()
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_WAVE_FACT_CHUNK = 'SDL_WAVE_FACT_CHUNK';

  (**
   * A variable controlling the maximum number of chunks in a WAVE file.
   *
   * This sets an upper bound on the number of chunks in a WAVE file to avoid
   * wasting time on malformed or corrupt WAVE files. This defaults to "10000".
   *
   * This hint should be set before calling SDL_LoadWAV() or SDL_LoadWAV_IO()
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_WAVE_CHUNK_LIMIT = 'SDL_WAVE_CHUNK_LIMIT';

  (**
   * A variable controlling how the size of the RIFF chunk affects the loading
   * of a WAVE file.
   *
   * The size of the RIFF chunk (which includes all the sub-chunks of the WAVE
   * file) is not always reliable. In case the size is wrong, it's possible to
   * just ignore it and step through the chunks until a fixed limit is reached.
   *
   * Note that files that have trailing data unrelated to the WAVE file or
   * corrupt files may slow down the loading process without a reliable
   * boundary. By default, SDL stops after 10000 chunks to prevent wasting time.
   * Use SDL_HINT_WAVE_CHUNK_LIMIT to adjust this value.
   *
   * The variable can be set to the following values:
   *
   * - "force" - Always use the RIFF chunk size as a boundary for the chunk
   *   search.
   * - "ignorezero" - Like "force", but a zero size searches up to 4 GiB.
   *   (default)
   * - "ignore" - Ignore the RIFF chunk size and always search up to 4 GiB.
   * - "maximum" - Search for chunks until the end of file. (not recommended)
   *
   * This hint should be set before calling SDL_LoadWAV() or SDL_LoadWAV_IO()
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_WAVE_RIFF_CHUNK_SIZE = 'SDL_WAVE_RIFF_CHUNK_SIZE';

  (**
   * A variable controlling how a truncated WAVE file is handled.
   *
   * A WAVE file is considered truncated if any of the chunks are incomplete or
   * the data chunk size is not a multiple of the block size. By default, SDL
   * decodes until the first incomplete block, as most applications seem to do.
   *
   * The variable can be set to the following values:
   *
   * - "verystrict" - Raise an error if the file is truncated.
   * - "strict" - Like "verystrict", but the size of the RIFF chunk is ignored.
   * - "dropframe" - Decode until the first incomplete sample frame.
   * - "dropblock" - Decode until the first incomplete block. (default)
   *
   * This hint should be set before calling SDL_LoadWAV() or SDL_LoadWAV_IO()
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_WAVE_TRUNCATION = 'SDL_WAVE_TRUNCATION';

  (**
   * A variable controlling whether the window is activated when the
   * SDL_RaiseWindow function is called.
   *
   * The variable can be set to the following values:
   *
   * - "0": The window is not activated when the SDL_RaiseWindow function is
   *   called.
   * - "1": The window is activated when the SDL_RaiseWindow function is called.
   *   (default)
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_WINDOW_ACTIVATE_WHEN_RAISED = 'SDL_WINDOW_ACTIVATE_WHEN_RAISED';

  (**
   * A variable controlling whether the window is activated when the
   * SDL_ShowWindow function is called.
   *
   * The variable can be set to the following values:
   *
   * - "0": The window is not activated when the SDL_ShowWindow function is
   *   called.
   * - "1": The window is activated when the SDL_ShowWindow function is called.
   *   (default)
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_WINDOW_ACTIVATE_WHEN_SHOWN = 'SDL_WINDOW_ACTIVATE_WHEN_SHOWN';

  (**
   * If set to "0" then never set the top-most flag on an SDL Window even if the
   * application requests it.
   *
   * This is a debugging aid for developers and not expected to be used by end
   * users.
   *
   * The variable can be set to the following values:
   *
   * - "0": don't allow topmost
   * - "1": allow topmost (default)
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_WINDOW_ALLOW_TOPMOST = 'SDL_WINDOW_ALLOW_TOPMOST';

  (**
   * A variable controlling whether the window frame and title bar are
   * interactive when the cursor is hidden.
   *
   * The variable can be set to the following values:
   *
   * - "0": The window frame is not interactive when the cursor is hidden (no
   *   move, resize, etc).
   * - "1": The window frame is interactive when the cursor is hidden. (default)
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_WINDOW_FRAME_USABLE_WHILE_CURSOR_HIDDEN = 'SDL_WINDOW_FRAME_USABLE_WHILE_CURSOR_HIDDEN';

  (**
   * A variable controlling whether SDL generates window-close events for Alt+F4
   * on Windows.
   *
   * The variable can be set to the following values:
   *
   * - "0": SDL will only do normal key handling for Alt+F4.
   * - "1": SDL will generate a window-close event when it sees Alt+F4.
   *   (default)
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_WINDOWS_CLOSE_ON_ALT_F4 = 'SDL_WINDOWS_CLOSE_ON_ALT_F4';

  (**
   * A variable controlling whether menus can be opened with their keyboard
   * shortcut (Alt+mnemonic).
   *
   * If the mnemonics are enabled, then menus can be opened by pressing the Alt
   * key and the corresponding mnemonic (for example, Alt+F opens the File
   * menu). However, in case an invalid mnemonic is pressed, Windows makes an
   * audible beep to convey that nothing happened. This is true even if the
   * window has no menu at all!
   *
   * Because most SDL applications don't have menus, and some want to use the
   * Alt key for other purposes, SDL disables mnemonics (and the beeping) by
   * default.
   *
   * Note: This also affects keyboard events: with mnemonics enabled, when a
   * menu is opened from the keyboard, you will not receive a KEYUP event for
   * the mnemonic key, and *might* not receive one for Alt.
   *
   * The variable can be set to the following values:
   *
   * - "0": Alt+mnemonic does nothing, no beeping. (default)
   * - "1": Alt+mnemonic opens menus, invalid mnemonics produce a beep.
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_WINDOWS_ENABLE_MENU_MNEMONICS = 'SDL_WINDOWS_ENABLE_MENU_MNEMONICS';

  (**
   * A variable controlling whether the windows message loop is processed by
   * SDL.
   *
   * The variable can be set to the following values:
   *
   * - "0": The window message loop is not run.
   * - "1": The window message loop is processed in SDL_PumpEvents(). (default)
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_WINDOWS_ENABLE_MESSAGELOOP = 'SDL_WINDOWS_ENABLE_MESSAGELOOP';

  (**
   * A variable controlling whether GameInput is used for raw keyboard and mouse
   * on Windows.
   *
   * The variable can be set to the following values:
   *
   * - "0": GameInput is not used for raw keyboard and mouse events.
   * - "1": GameInput is used for raw keyboard and mouse events, if available.
   *   (default)
   *
   * This hint should be set before SDL is initialized.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_WINDOWS_GAMEINPUT   = 'SDL_WINDOWS_GAMEINPUT';

  (**
   * A variable controlling whether raw keyboard events are used on Windows.
   *
   * The variable can be set to the following values:
   *
   * - "0": The Windows message loop is used for keyboard events. (default)
   * - "1": Low latency raw keyboard events are used.
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_WINDOWS_RAW_KEYBOARD = 'SDL_WINDOWS_RAW_KEYBOARD';

  (**
   * A variable controlling whether SDL uses Kernel Semaphores on Windows.
   *
   * Kernel Semaphores are inter-process and require a context switch on every
   * interaction. On Windows 8 and newer, the WaitOnAddress API is available.
   * Using that and atomics to implement semaphores increases performance. SDL
   * will fall back to Kernel Objects on older OS versions or if forced to by
   * this hint.
   *
   * The variable can be set to the following values:
   *
   * - "0": Use Atomics and WaitOnAddress API when available, otherwise fall
   *   back to Kernel Objects. (default)
   * - "1": Force the use of Kernel Objects in all cases.
   *
   * This hint should be set before SDL is initialized.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_WINDOWS_FORCE_SEMAPHORE_KERNEL = 'SDL_WINDOWS_FORCE_SEMAPHORE_KERNEL';

  (**
   * A variable to specify custom icon resource id from RC file on Windows
   * platform.
   *
   * This hint should be set before SDL is initialized.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_WINDOWS_INTRESOURCE_ICON       = 'SDL_WINDOWS_INTRESOURCE_ICON';

  (**
   * A variable to specify custom icon resource id from RC file on Windows
   * platform.
   *
   * This hint should be set before SDL is initialized.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_WINDOWS_INTRESOURCE_ICON_SMALL = 'SDL_WINDOWS_INTRESOURCE_ICON_SMALL';

  (**
   * A variable controlling whether SDL uses the D3D9Ex API introduced in
   * Windows Vista, instead of normal D3D9.
   *
   * Direct3D 9Ex contains changes to state management that can eliminate device
   * loss errors during scenarios like Alt+Tab or UAC prompts. D3D9Ex may
   * require some changes to your application to cope with the new behavior, so
   * this is disabled by default.
   *
   * For more information on Direct3D 9Ex, see:
   *
   * - https://docs.microsoft.com/en-us/windows/win32/direct3darticles/graphics-apis-in-windows-vista#direct3d-9ex
   * - https://docs.microsoft.com/en-us/windows/win32/direct3darticles/direct3d-9ex-improvements
   *
   * The variable can be set to the following values:
   *
   * - "0": Use the original Direct3D 9 API. (default)
   * - "1": Use the Direct3D 9Ex API on Vista and later (and fall back if D3D9Ex
   *   is unavailable)
   *
   * This hint should be set before SDL is initialized.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_WINDOWS_USE_D3D9EX = 'SDL_WINDOWS_USE_D3D9EX';

  (**
   * A variable controlling whether SDL will clear the window contents when the
   * WM_ERASEBKGND message is received.
   *
   * The variable can be set to the following values:
   *
   * - "0"/"never": Never clear the window.
   * - "1"/"initial": Clear the window when the first WM_ERASEBKGND event fires.
   *   (default)
   * - "2"/"always": Clear the window on every WM_ERASEBKGND event.
   *
   * This hint should be set before creating a window.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_WINDOWS_ERASE_BACKGROUND_MODE = 'SDL_WINDOWS_ERASE_BACKGROUND_MODE';

  (**
   * A variable controlling whether X11 windows are marked as override-redirect.
   *
   * If set, this _might_ increase framerate at the expense of the desktop not
   * working as expected. Override-redirect windows aren't noticed by the window
   * manager at all.
   *
   * You should probably only use this for fullscreen windows, and you probably
   * shouldn't even use it for that. But it's here if you want to try!
   *
   * The variable can be set to the following values:
   *
   * - "0": Do not mark the window as override-redirect. (default)
   * - "1": Mark the window as override-redirect.
   *
   * This hint should be set before creating a window.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_X11_FORCE_OVERRIDE_REDIRECT = 'SDL_X11_FORCE_OVERRIDE_REDIRECT';

  (**
   * A variable specifying the type of an X11 window.
   *
   * During SDL_CreateWindow, SDL uses the _NET_WM_WINDOW_TYPE X11 property to
   * report to the window manager the type of window it wants to create. This
   * might be set to various things if SDL_WINDOW_TOOLTIP or
   * SDL_WINDOW_POPUP_MENU, etc, were specified. For "normal" windows that
   * haven't set a specific type, this hint can be used to specify a custom
   * type. For example, a dock window might set this to
   * "_NET_WM_WINDOW_TYPE_DOCK".
   *
   * This hint should be set before creating a window.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_X11_WINDOW_TYPE = 'SDL_X11_WINDOW_TYPE';

  (**
   * Specify the XCB library to load for the X11 driver.
   *
   * The default is platform-specific, often "libX11-xcb.so.1".
   *
   * This hint should be set before initializing the video subsystem.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_X11_XCB_LIBRARY = 'SDL_X11_XCB_LIBRARY';

  (**
   * A variable controlling whether XInput should be used for controller
   * handling.
   *
   * The variable can be set to the following values:
   *
   * - "0": XInput is not enabled.
   * - "1": XInput is enabled. (default)
   *
   * This hint should be set before SDL is initialized.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_XINPUT_ENABLED = 'SDL_XINPUT_ENABLED';

  (**
   * A variable controlling response to SDL_assert failures.
   *
   * The variable can be set to the following case-sensitive values:
   *
   * - "abort": Program terminates immediately.
   * - "break": Program triggers a debugger breakpoint.
   * - "retry": Program reruns the SDL_assert's test again.
   * - "ignore": Program continues on, ignoring this assertion failure this
   *   time.
   * - "always_ignore": Program continues on, ignoring this assertion failure
   *   for the rest of the run.
   *
   * Note that SDL_SetAssertionHandler offers a programmatic means to deal with
   * assertion failures through a callback, and this hint is largely intended to
   * be used via environment variables by end users and automated tools.
   *
   * This hint should be set before an assertion failure is triggered and can be
   * changed at any time.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_ASSERT = 'SDL_ASSERT';

  (**
   * A variable controlling whether pen events should generate synthetic mouse
   * events.
   *
   * The variable can be set to the following values:
   *
   * - "0": Pen events will not generate mouse events.
   * - "1": Pen events will generate mouse events. (default)
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_PEN_MOUSE_EVENTS = 'SDL_PEN_MOUSE_EVENTS';

  (**
   * A variable controlling whether pen events should generate synthetic touch
   * events.
   *
   * The variable can be set to the following values:
   *
   * - "0": Pen events will not generate touch events.
   * - "1": Pen events will generate touch events. (default)
   *
   * This hint can be set anytime.
   *
   * \since This hint is available since SDL 3.2.0.
   *)
  SDL_HINT_PEN_TOUCH_EVENTS = 'SDL_PEN_TOUCH_EVENTS';

(**
 * An enumeration of hint priorities.
 *
 * \since This enum is available since SDL 3.2.0.
 *)
type
  SDL_HintPriority = Integer;

const
  SDL_HINT_DEFAULT = 0;
  SDL_HINT_NORMAL = 1;
  SDL_HINT_OVERRIDE = 2;

(**
 * Set a hint with a specific priority.
 *
 * The priority controls the behavior when setting a hint that already has a
 * value. Hints will replace existing hints of their priority and lower.
 * Environment variables are considered to have override priority.
 *
 * \param name the hint to set.
 * \param value the value of the hint variable.
 * \param priority the SDL_HintPriority level for the hint.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetHint
 * \sa SDL_ResetHint
 * \sa SDL_SetHint
 *)
function SDL_SetHintWithPriority(const name: PUTF8Char; const value: PUTF8Char; priority: SDL_HintPriority): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetHintWithPriority';

(**
 * Set a hint with normal priority.
 *
 * Hints will not be set if there is an existing override hint or environment
 * variable that takes precedence. You can use SDL_SetHintWithPriority() to
 * set the hint with override priority instead.
 *
 * \param name the hint to set.
 * \param value the value of the hint variable.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetHint
 * \sa SDL_ResetHint
 * \sa SDL_SetHintWithPriority
 *)
function SDL_SetHint(const name: PUTF8Char; const value: PUTF8Char): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetHint';

(**
 * Reset a hint to the default value.
 *
 * This will reset a hint to the value of the environment variable, or NULL if
 * the environment isn't set. Callbacks will be called normally with this
 * change.
 *
 * \param name the hint to set.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetHint
 * \sa SDL_ResetHints
 *)
function SDL_ResetHint(const name: PUTF8Char): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_ResetHint';

(**
 * Reset all hints to the default values.
 *
 * This will reset all hints to the value of the associated environment
 * variable, or NULL if the environment isn't set. Callbacks will be called
 * normally with this change.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_ResetHint
 *)
procedure SDL_ResetHints(); cdecl;
  external LIB_SDL3 name _PU + 'SDL_ResetHints';

(**
 * Get the value of a hint.
 *
 * \param name the hint to query.
 * \returns the string value of a hint or NULL if the hint isn't set.
 *
 * \threadsafety It is safe to call this function from any thread, however the
 *               return value only remains valid until the hint is changed; if
 *               another thread might do so, the app should supply locks
 *               and/or make a copy of the string. Note that using a hint
 *               callback instead is always thread-safe, as SDL holds a lock
 *               on the thread subsystem during the callback.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetHint
 * \sa SDL_SetHintWithPriority
 *)
function SDL_GetHint(const name: PUTF8Char): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetHint';

(**
 * Get the boolean value of a hint variable.
 *
 * \param name the name of the hint to get the boolean value from.
 * \param default_value the value to return if the hint does not exist.
 * \returns the boolean value of a hint or the provided default value if the
 *          hint does not exist.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetHint
 * \sa SDL_SetHint
 *)
function SDL_GetHintBoolean(const name: PUTF8Char; default_value: Boolean): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetHintBoolean';

type
  (**
   * A callback used to send notifications of hint value changes.
   *
   * This is called an initial time during SDL_AddHintCallback with the hint's
   * current value, and then again each time the hint's value changes.
   *
   * \param userdata what was passed as `userdata` to SDL_AddHintCallback().
   * \param name what was passed as `name` to SDL_AddHintCallback().
   * \param oldValue the previous hint value.
   * \param newValue the new value hint is to be set to.
   *
   * \threadsafety This callback is fired from whatever thread is setting a new
   *               hint value. SDL holds a lock on the hint subsystem when
   *               calling this callback.
   *
   * \since This datatype is available since SDL 3.2.0.
   *
   * \sa SDL_AddHintCallback
   *)
  SDL_HintCallback = procedure(userdata: Pointer; const name: PUTF8Char; const oldValue: PUTF8Char; const newValue: PUTF8Char); cdecl;

(**
 * Add a function to watch a particular hint.
 *
 * The callback function is called _during_ this function, to provide it an
 * initial value, and again each time the hint's value changes.
 *
 * \param name the hint to watch.
 * \param callback An SDL_HintCallback function that will be called when the
 *                 hint value changes.
 * \param userdata a pointer to pass to the callback function.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_RemoveHintCallback
 *)
function SDL_AddHintCallback(const name: PUTF8Char; callback: SDL_HintCallback; userdata: Pointer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_AddHintCallback';

(**
 * Remove a function watching a particular hint.
 *
 * \param name the hint being watched.
 * \param callback an SDL_HintCallback function that will be called when the
 *                 hint value changes.
 * \param userdata a pointer being passed to the callback function.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_AddHintCallback
 *)
procedure SDL_RemoveHintCallback(const name: PUTF8Char; callback: SDL_HintCallback; userdata: Pointer); cdecl;
  external LIB_SDL3 name _PU + 'SDL_RemoveHintCallback';
{$ENDREGION 'SDL_hints.h'}

{$REGION 'SDL_init.h'}
(**
 * # CategoryInit
 *
 * All SDL programs need to initialize the library before starting to work
 * with it.
 *
 * Almost everything can simply call SDL_Init() near startup, with a handful
 * of flags to specify subsystems to touch. These are here to make sure SDL
 * does not even attempt to touch low-level pieces of the operating system
 * that you don't intend to use. For example, you might be using SDL for video
 * and input but chose an external library for audio, and in this case you
 * would just need to leave off the `SDL_INIT_AUDIO` flag to make sure that
 * external library has complete control.
 *
 * Most apps, when terminating, should call SDL_Quit(). This will clean up
 * (nearly) everything that SDL might have allocated, and crucially, it'll
 * make sure that the display's resolution is back to what the user expects if
 * you had previously changed it for your game.
 *
 * SDL3 apps are strongly encouraged to call SDL_SetAppMetadata() at startup
 * to fill in details about the program. This is completely optional, but it
 * helps in small ways (we can provide an About dialog box for the macOS menu,
 * we can name the app in the system's audio mixer, etc). Those that want to
 * provide a _lot_ of information should look at the more-detailed
 * SDL_SetAppMetadataProperty().
 *)

type
  (**
   * Initialization flags for SDL_Init and/or SDL_InitSubSystem
   *
   * These are the flags which may be passed to SDL_Init(). You should specify
   * the subsystems which you will be using in your application.
   *
   * \since This datatype is available since SDL 3.2.0.
   *
   * \sa SDL_Init
   * \sa SDL_Quit
   * \sa SDL_InitSubSystem
   * \sa SDL_QuitSubSystem
   * \sa SDL_WasInit
   *)
  SDL_InitFlags = Uint32;

const
  SDL_INIT_AUDIO    = $00000010; // `SDL_INIT_AUDIO` implies `SDL_INIT_EVENTS`
  SDL_INIT_VIDEO    = $00000020; // `SDL_INIT_VIDEO` implies `SDL_INIT_EVENTS`, should be initialized on the main thread
  SDL_INIT_JOYSTICK = $00000200; // `SDL_INIT_JOYSTICK` implies `SDL_INIT_EVENTS`, should be initialized on the same thread as SDL_INIT_VIDEO on Windows if you don't set SDL_HINT_JOYSTICK_THREAD
  SDL_INIT_HAPTIC   = $00001000;
  SDL_INIT_GAMEPAD  = $00002000; // `SDL_INIT_GAMEPAD` implies `SDL_INIT_JOYSTICK
  SDL_INIT_EVENTS   = $00004000;
  SDL_INIT_SENSOR   = $00008000; // `SDL_INIT_SENSOR` implies `SDL_INIT_EVENTS`
  SDL_INIT_CAMERA   = $00010000; // `SDL_INIT_CAMERA` implies `SDL_INIT_EVENTS`

(**
 * Return values for optional main callbacks.
 *
 * Returning SDL_APP_SUCCESS or SDL_APP_FAILURE from SDL_AppInit,
 * SDL_AppEvent, or SDL_AppIterate will terminate the program and report
 * success/failure to the operating system. What that means is
 * platform-dependent. On Unix, for example, on success, the process error
 * code will be zero, and on failure it will be 1. This interface doesn't
 * allow you to return specific exit codes, just whether there was an error
 * generally or not.
 *
 * Returning SDL_APP_CONTINUE from these functions will let the app continue
 * to run.
 *
 * See
 * [Main callbacks in SDL3](https://wiki.libsdl.org/SDL3/README/main-functions#main-callbacks-in-sdl3)
 * for complete details.
 *
 * \since This enum is available since SDL 3.2.0.
 *)
type
  SDL_AppResult = Integer;

const
  (** Value that requests that the app continue from the main callbacks. *)
  SDL_APP_CONTINUE = 0;
  (** Value that requests termination with success from the main callbacks. *)
  SDL_APP_SUCCESS = 1;
  (** Value that requests termination with error from the main callbacks. *)
  SDL_APP_FAILURE = 2;

type
  (**
   * Function pointer typedef for SDL_AppInit.
   *
   * These are used by SDL_EnterAppMainCallbacks. This mechanism operates behind
   * the scenes for apps using the optional main callbacks. Apps that want to
   * use this should just implement SDL_AppInit directly.
   *
   * \param appstate a place where the app can optionally store a pointer for
   *                 future use.
   * \param argc the standard ANSI C main's argc; number of elements in `argv`.
   * \param argv the standard ANSI C main's argv; array of command line
   *             arguments.
   * \returns SDL_APP_FAILURE to terminate with an error, SDL_APP_SUCCESS to
   *          terminate with success, SDL_APP_CONTINUE to continue.
   *
   * \since This datatype is available since SDL 3.2.0.
   *)
  SDL_AppInit_func = function(appstate: PPointer; argc: Integer; argv: PPUTF8Char): SDL_AppResult; cdecl;

  (**
   * Function pointer typedef for SDL_AppIterate.
   *
   * These are used by SDL_EnterAppMainCallbacks. This mechanism operates behind
   * the scenes for apps using the optional main callbacks. Apps that want to
   * use this should just implement SDL_AppIterate directly.
   *
   * \param appstate an optional pointer, provided by the app in SDL_AppInit.
   * \returns SDL_APP_FAILURE to terminate with an error, SDL_APP_SUCCESS to
   *          terminate with success, SDL_APP_CONTINUE to continue.
   *
   * \since This datatype is available since SDL 3.2.0.
   *)
  SDL_AppIterate_func = function(appstate: Pointer): SDL_AppResult; cdecl;

  (**
   * Function pointer typedef for SDL_AppEvent.
   *
   * These are used by SDL_EnterAppMainCallbacks. This mechanism operates behind
   * the scenes for apps using the optional main callbacks. Apps that want to
   * use this should just implement SDL_AppEvent directly.
   *
   * \param appstate an optional pointer, provided by the app in SDL_AppInit.
   * \param event the new event for the app to examine.
   * \returns SDL_APP_FAILURE to terminate with an error, SDL_APP_SUCCESS to
   *          terminate with success, SDL_APP_CONTINUE to continue.
   *
   * \since This datatype is available since SDL 3.2.0.
   *)
  SDL_AppEvent_func = function(appstate: Pointer; event: PSDL_Event): SDL_AppResult; cdecl;

  (**
   * Function pointer typedef for SDL_AppQuit.
   *
   * These are used by SDL_EnterAppMainCallbacks. This mechanism operates behind
   * the scenes for apps using the optional main callbacks. Apps that want to
   * use this should just implement SDL_AppEvent directly.
   *
   * \param appstate an optional pointer, provided by the app in SDL_AppInit.
   * \param result the result code that terminated the app (success or failure).
   *
   * \since This datatype is available since SDL 3.2.0.
   *)
  SDL_AppQuit_func = procedure(appstate: Pointer; result: SDL_AppResult); cdecl;

(**
 * Initialize the SDL library.
 *
 * SDL_Init() simply forwards to calling SDL_InitSubSystem(). Therefore, the
 * two may be used interchangeably. Though for readability of your code
 * SDL_InitSubSystem() might be preferred.
 *
 * The file I/O (for example: SDL_IOFromFile) and threading (SDL_CreateThread)
 * subsystems are initialized by default. Message boxes
 * (SDL_ShowSimpleMessageBox) also attempt to work without initializing the
 * video subsystem, in hopes of being useful in showing an error dialog when
 * SDL_Init fails. You must specifically initialize other subsystems if you
 * use them in your application.
 *
 * Logging (such as SDL_Log) works without initialization, too.
 *
 * `flags` may be any of the following OR'd together:
 *
 * - `SDL_INIT_AUDIO`: audio subsystem; automatically initializes the events
 *   subsystem
 * - `SDL_INIT_VIDEO`: video subsystem; automatically initializes the events
 *   subsystem, should be initialized on the main thread.
 * - `SDL_INIT_JOYSTICK`: joystick subsystem; automatically initializes the
 *   events subsystem
 * - `SDL_INIT_HAPTIC`: haptic (force feedback) subsystem
 * - `SDL_INIT_GAMEPAD`: gamepad subsystem; automatically initializes the
 *   joystick subsystem
 * - `SDL_INIT_EVENTS`: events subsystem
 * - `SDL_INIT_SENSOR`: sensor subsystem; automatically initializes the events
 *   subsystem
 * - `SDL_INIT_CAMERA`: camera subsystem; automatically initializes the events
 *   subsystem
 *
 * Subsystem initialization is ref-counted, you must call SDL_QuitSubSystem()
 * for each SDL_InitSubSystem() to correctly shutdown a subsystem manually (or
 * call SDL_Quit() to force shutdown). If a subsystem is already loaded then
 * this call will increase the ref-count and return.
 *
 * Consider reporting some basic metadata about your application before
 * calling SDL_Init, using either SDL_SetAppMetadata() or
 * SDL_SetAppMetadataProperty().
 *
 * \param flags subsystem initialization flags.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetAppMetadata
 * \sa SDL_SetAppMetadataProperty
 * \sa SDL_InitSubSystem
 * \sa SDL_Quit
 * \sa SDL_SetMainReady
 * \sa SDL_WasInit
 *)
function SDL_Init(flags: SDL_InitFlags): Boolean;

(**
 * Compatibility function to initialize the SDL library.
 *
 * This function and SDL_Init() are interchangeable.
 *
 * \param flags any of the flags used by SDL_Init(); see SDL_Init for details.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_Init
 * \sa SDL_Quit
 * \sa SDL_QuitSubSystem
 *)
function SDL_InitSubSystem(flags: SDL_InitFlags): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_InitSubSystem';

(**
 * Shut down specific SDL subsystems.
 *
 * You still need to call SDL_Quit() even if you close all open subsystems
 * with SDL_QuitSubSystem().
 *
 * \param flags any of the flags used by SDL_Init(); see SDL_Init for details.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_InitSubSystem
 * \sa SDL_Quit
 *)
procedure SDL_QuitSubSystem(flags: SDL_InitFlags); cdecl;
  external LIB_SDL3 name _PU + 'SDL_QuitSubSystem';

(**
 * Get a mask of the specified subsystems which are currently initialized.
 *
 * \param flags any of the flags used by SDL_Init(); see SDL_Init for details.
 * \returns a mask of all initialized subsystems if `flags` is 0, otherwise it
 *          returns the initialization status of the specified subsystems.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_Init
 * \sa SDL_InitSubSystem
 *)
function SDL_WasInit(flags: SDL_InitFlags): SDL_InitFlags; cdecl;
  external LIB_SDL3 name _PU + 'SDL_WasInit';

(**
 * Clean up all initialized subsystems.
 *
 * You should call this function even if you have already shutdown each
 * initialized subsystem with SDL_QuitSubSystem(). It is safe to call this
 * function even in the case of errors in initialization.
 *
 * You can use this function with atexit() to ensure that it is run when your
 * application is shutdown, but it is not wise to do this from a library or
 * other dynamically loaded code.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_Init
 * \sa SDL_QuitSubSystem
 *)
procedure SDL_Quit(); cdecl;
  external LIB_SDL3 name _PU + 'SDL_Quit';

(**
 * Return whether this is the main thread.
 *
 * On Apple platforms, the main thread is the thread that runs your program's
 * main() entry point. On other platforms, the main thread is the one that
 * calls SDL_Init(SDL_INIT_VIDEO), which should usually be the one that runs
 * your program's main() entry point. If you are using the main callbacks,
 * SDL_AppInit(), SDL_AppIterate(), and SDL_AppQuit() are all called on the
 * main thread.
 *
 * \returns true if this thread is the main thread, or false otherwise.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_RunOnMainThread
 *)
function SDL_IsMainThread(): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_IsMainThread';

type
  (**
   * Callback run on the main thread.
   *
   * \param userdata an app-controlled pointer that is passed to the callback.
   *
   * \since This datatype is available since SDL 3.2.0.
   *
   * \sa SDL_RunOnMainThread
   *)
  SDL_MainThreadCallback = procedure(userdata: Pointer); cdecl;

(**
 * Call a function on the main thread during event processing.
 *
 * If this is called on the main thread, the callback is executed immediately.
 * If this is called on another thread, this callback is queued for execution
 * on the main thread during event processing.
 *
 * Be careful of deadlocks when using this functionality. You should not have
 * the main thread wait for the current thread while this function is being
 * called with `wait_complete` true.
 *
 * \param callback the callback to call on the main thread.
 * \param userdata a pointer that is passed to `callback`.
 * \param wait_complete true to wait for the callback to complete, false to
 *                      return immediately.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_IsMainThread
 *)
function SDL_RunOnMainThread(callback: SDL_MainThreadCallback; userdata: Pointer; wait_complete: Boolean): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_RunOnMainThread';

(**
 * Specify basic metadata about your app.
 *
 * You can optionally provide metadata about your app to SDL. This is not
 * required, but strongly encouraged.
 *
 * There are several locations where SDL can make use of metadata (an "About"
 * box in the macOS menu bar, the name of the app can be shown on some audio
 * mixers, etc). Any piece of metadata can be left as NULL, if a specific
 * detail doesn't make sense for the app.
 *
 * This function should be called as early as possible, before SDL_Init.
 * Multiple calls to this function are allowed, but various state might not
 * change once it has been set up with a previous call to this function.
 *
 * Passing a NULL removes any previous metadata.
 *
 * This is a simplified interface for the most important information. You can
 * supply significantly more detailed metadata with
 * SDL_SetAppMetadataProperty().
 *
 * \param appname The name of the application ("My Game 2: Bad Guy's
 *                Revenge!").
 * \param appversion The version of the application ("1.0.0beta5" or a git
 *                   hash, or whatever makes sense).
 * \param appidentifier A unique string in reverse-domain format that
 *                      identifies this app ("com.example.mygame2").
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetAppMetadataProperty
 *)
function SDL_SetAppMetadata(const appname: PUTF8Char; const appversion: PUTF8Char; const appidentifier: PUTF8Char): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetAppMetadata';

(**
 * Specify metadata about your app through a set of properties.
 *
 * You can optionally provide metadata about your app to SDL. This is not
 * required, but strongly encouraged.
 *
 * There are several locations where SDL can make use of metadata (an "About"
 * box in the macOS menu bar, the name of the app can be shown on some audio
 * mixers, etc). Any piece of metadata can be left out, if a specific detail
 * doesn't make sense for the app.
 *
 * This function should be called as early as possible, before SDL_Init.
 * Multiple calls to this function are allowed, but various state might not
 * change once it has been set up with a previous call to this function.
 *
 * Once set, this metadata can be read using SDL_GetAppMetadataProperty().
 *
 * These are the supported properties:
 *
 * - `SDL_PROP_APP_METADATA_NAME_STRING`: The human-readable name of the
 *   application, like "My Game 2: Bad Guy's Revenge!". This will show up
 *   anywhere the OS shows the name of the application separately from window
 *   titles, such as volume control applets, etc. This defaults to "SDL
 *   Application".
 * - `SDL_PROP_APP_METADATA_VERSION_STRING`: The version of the app that is
 *   running; there are no rules on format, so "1.0.3beta2" and "April 22nd,
 *   2024" and a git hash are all valid options. This has no default.
 * - `SDL_PROP_APP_METADATA_IDENTIFIER_STRING`: A unique string that
 *   identifies this app. This must be in reverse-domain format, like
 *   "com.example.mygame2". This string is used by desktop compositors to
 *   identify and group windows together, as well as match applications with
 *   associated desktop settings and icons. If you plan to package your
 *   application in a container such as Flatpak, the app ID should match the
 *   name of your Flatpak container as well. This has no default.
 * - `SDL_PROP_APP_METADATA_CREATOR_STRING`: The human-readable name of the
 *   creator/developer/maker of this app, like "MojoWorkshop, LLC"
 * - `SDL_PROP_APP_METADATA_COPYRIGHT_STRING`: The human-readable copyright
 *   notice, like "Copyright (c) 2024 MojoWorkshop, LLC" or whatnot. Keep this
 *   to one line, don't paste a copy of a whole software license in here. This
 *   has no default.
 * - `SDL_PROP_APP_METADATA_URL_STRING`: A URL to the app on the web. Maybe a
 *   product page, or a storefront, or even a GitHub repository, for user's
 *   further information This has no default.
 * - `SDL_PROP_APP_METADATA_TYPE_STRING`: The type of application this is.
 *   Currently this string can be "game" for a video game, "mediaplayer" for a
 *   media player, or generically "application" if nothing else applies.
 *   Future versions of SDL might add new types. This defaults to
 *   "application".
 *
 * \param name the name of the metadata property to set.
 * \param value the value of the property, or NULL to remove that property.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetAppMetadataProperty
 * \sa SDL_SetAppMetadata
 *)
function SDL_SetAppMetadataProperty(const name: PUTF8Char; const value: PUTF8Char): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetAppMetadataProperty';

const
  SDL_PROP_APP_METADATA_NAME_STRING = 'SDL.app.metadata.name';
  SDL_PROP_APP_METADATA_VERSION_STRING = 'SDL.app.metadata.version';
  SDL_PROP_APP_METADATA_IDENTIFIER_STRING = 'SDL.app.metadata.identifier';
  SDL_PROP_APP_METADATA_CREATOR_STRING = 'SDL.app.metadata.creator';
  SDL_PROP_APP_METADATA_COPYRIGHT_STRING = 'SDL.app.metadata.copyright';
  SDL_PROP_APP_METADATA_URL_STRING = 'SDL.app.metadata.url';
  SDL_PROP_APP_METADATA_TYPE_STRING = 'SDL.app.metadata.type';

(**
 * Get metadata about your app.
 *
 * This returns metadata previously set using SDL_SetAppMetadata() or
 * SDL_SetAppMetadataProperty(). See SDL_SetAppMetadataProperty() for the list
 * of available properties and their meanings.
 *
 * \param name the name of the metadata property to get.
 * \returns the current value of the metadata property, or the default if it
 *          is not set, NULL for properties with no default.
 *
 * \threadsafety It is safe to call this function from any thread, although
 *               the string returned is not protected and could potentially be
 *               freed if you call SDL_SetAppMetadataProperty() to set that
 *               property from another thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetAppMetadata
 * \sa SDL_SetAppMetadataProperty
 *)
function SDL_GetAppMetadataProperty(const name: PUTF8Char): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetAppMetadataProperty';
{$ENDREGION 'SDL_init.h'}

{$REGION 'SDL_loadso.h'}
(**
 * # CategorySharedObject
 *
 * System-dependent library loading routines.
 *
 * Shared objects are code that is programmatically loadable at runtime.
 * Windows calls these "DLLs", Linux calls them "shared libraries", etc.
 *
 * To use them, build such a library, then call SDL_LoadObject() on it. Once
 * loaded, you can use SDL_LoadFunction() on that object to find the address
 * of its exported symbols. When done with the object, call SDL_UnloadObject()
 * to dispose of it.
 *
 * Some things to keep in mind:
 *
 * - These functions only work on C function names. Other languages may have
 *   name mangling and intrinsic language support that varies from compiler to
 *   compiler.
 * - Make sure you declare your function pointers with the same calling
 *   convention as the actual library function. Your code will crash
 *   mysteriously if you do not do this.
 * - Avoid namespace collisions. If you load a symbol from the library, it is
 *   not defined whether or not it goes into the global symbol namespace for
 *   the application. If it does and it conflicts with symbols in your code or
 *   other shared libraries, you will not get the results you expect. :)
 * - Once a library is unloaded, all pointers into it obtained through
 *   SDL_LoadFunction() become invalid, even if the library is later reloaded.
 *   Don't unload a library if you plan to use these pointers in the future.
 *   Notably: beware of giving one of these pointers to atexit(), since it may
 *   call that pointer after the library unloads.
 *)

type
  (**
   * An opaque datatype that represents a loaded shared object.
   *
   * \since This datatype is available since SDL 3.2.0.
   *
   * \sa SDL_LoadObject
   * \sa SDL_LoadFunction
   * \sa SDL_UnloadObject
   *)
  SDL_SharedObject = THandle;

(**
 * Dynamically load a shared object.
 *
 * \param sofile a system-dependent name of the object file.
 * \returns an opaque pointer to the object handle or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_LoadFunction
 * \sa SDL_UnloadObject
 *)
function SDL_LoadObject(const sofile: PUTF8Char): SDL_SharedObject; cdecl;
  external LIB_SDL3 name _PU + 'SDL_LoadObject';

(**
 * Look up the address of the named function in a shared object.
 *
 * This function pointer is no longer valid after calling SDL_UnloadObject().
 *
 * This function can only look up C function names. Other languages may have
 * name mangling and intrinsic language support that varies from compiler to
 * compiler.
 *
 * Make sure you declare your function pointers with the same calling
 * convention as the actual library function. Your code will crash
 * mysteriously if you do not do this.
 *
 * If the requested function doesn't exist, NULL is returned.
 *
 * \param handle a valid shared object handle returned by SDL_LoadObject().
 * \param name the name of the function to look up.
 * \returns a pointer to the function or NULL on failure; call SDL_GetError()
 *          for more information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_LoadObject
 *)
function SDL_LoadFunction(handle: SDL_SharedObject; const name: PUTF8Char): SDL_FunctionPointer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_LoadFunction';

(**
 * Unload a shared object from memory.
 *
 * Note that any pointers from this object looked up through
 * SDL_LoadFunction() will no longer be valid.
 *
 * \param handle a valid shared object handle returned by SDL_LoadObject().
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_LoadObject
 *)
procedure SDL_UnloadObject(handle: SDL_SharedObject); cdecl;
  external LIB_SDL3 name _PU + 'SDL_UnloadObject';
{$ENDREGION 'SDL_loadso.h'}

{$REGION 'SDL_locale.h'}
(**
 * # CategoryLocale
 *
 * SDL locale services.
 *
 * This provides a way to get a list of preferred locales (language plus
 * country) for the user. There is exactly one function:
 * SDL_GetPreferredLocales(), which handles all the heavy lifting, and offers
 * documentation on all the strange ways humans might have configured their
 * language settings.
 *)

type
  (**
   * A struct to provide locale data.
   *
   * Locale data is split into a spoken language, like English, and an optional
   * country, like Canada. The language will be in ISO-639 format (so English
   * would be "en"), and the country, if not NULL, will be an ISO-3166 country
   * code (so Canada would be "CA").
   *
   * \since This function is available since SDL 3.2.0.
   *
   * \sa SDL_GetPreferredLocales
   *)
  SDL_Locale = record
    (** A language name, like "en" for English. *)
    language: PUTF8Char;
    (** A country, like "US" for America. Can be NULL. *)
    country: PUTF8Char;
  end;
  PSDL_Locale = ^SDL_Locale;
  PPSDL_Locale = ^PSDL_Locale;

(**
 * Report the user's preferred locale.
 *
 * Returned language strings are in the format xx, where 'xx' is an ISO-639
 * language specifier (such as "en" for English, "de" for German, etc).
 * Country strings are in the format YY, where "YY" is an ISO-3166 country
 * code (such as "US" for the United States, "CA" for Canada, etc). Country
 * might be NULL if there's no specific guidance on them (so you might get {
 * "en", "US" } for American English, but { "en", NULL } means "English
 * language, generically"). Language strings are never NULL, except to
 * terminate the array.
 *
 * Please note that not all of these strings are 2 characters; some are three
 * or more.
 *
 * The returned list of locales are in the order of the user's preference. For
 * example, a German citizen that is fluent in US English and knows enough
 * Japanese to navigate around Tokyo might have a list like: { "de", "en_US",
 * "jp", NULL }. Someone from England might prefer British English (where
 * "color" is spelled "colour", etc), but will settle for anything like it: {
 * "en_GB", "en", NULL }.
 *
 * This function returns NULL on error, including when the platform does not
 * supply this information at all.
 *
 * This might be a "slow" call that has to query the operating system. It's
 * best to ask for this once and save the results. However, this list can
 * change, usually because the user has changed a system preference outside of
 * your program; SDL will send an SDL_EVENT_LOCALE_CHANGED event in this case,
 * if possible, and you can call this function again to get an updated copy of
 * preferred locales.
 *
 * \param count a pointer filled in with the number of locales returned, may
 *              be NULL.
 * \returns a NULL terminated array of locale pointers, or NULL on failure;
 *          call SDL_GetError() for more information. This is a single
 *          allocation that should be freed with SDL_free() when it is no
 *          longer needed.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetPreferredLocales(count: PInteger): PPSDL_Locale; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetPreferredLocales';
{$ENDREGION 'SDL_locale.h'}

{$REGION 'SDL_log.h'}
(**
 * # CategoryLog
 *
 * Simple log messages with priorities and categories. A message's
 * SDL_LogPriority signifies how important the message is. A message's
 * SDL_LogCategory signifies from what domain it belongs to. Every category
 * has a minimum priority specified: when a message belongs to that category,
 * it will only be sent out if it has that minimum priority or higher.
 *
 * SDL's own logs are sent below the default priority threshold, so they are
 * quiet by default.
 *
 * You can change the log verbosity programmatically using
 * SDL_SetLogPriority() or with SDL_SetHint(SDL_HINT_LOGGING, ...), or with
 * the "SDL_LOGGING" environment variable. This variable is a comma separated
 * set of category=level tokens that define the default logging levels for SDL
 * applications.
 *
 * The category can be a numeric category, one of "app", "error", "assert",
 * "system", "audio", "video", "render", "input", "test", or `*` for any
 * unspecified category.
 *
 * The level can be a numeric level, one of "verbose", "debug", "info",
 * "warn", "error", "critical", or "quiet" to disable that category.
 *
 * You can omit the category if you want to set the logging level for all
 * categories.
 *
 * If this hint isn't set, the default log levels are equivalent to:
 *
 * `app=info,assert=warn,test=verbose,*=error`
 *
 * Here's where the messages go on different platforms:
 *
 * - Windows: debug output stream
 * - Android: log output
 * - Others: standard error output (stderr)
 *)
(**
 * The predefined log categories
 *
 * By default the application and gpu categories are enabled at the INFO
 * level, the assert category is enabled at the WARN level, test is enabled at
 * the VERBOSE level and all other categories are enabled at the ERROR level.
 *
 * \since This enum is available since SDL 3.2.0.
 *)

type
  (**
   * The predefined log categories
   *
   * By default the application and gpu categories are enabled at the INFO
   * level, the assert category is enabled at the WARN level, test is enabled at
   * the VERBOSE level and all other categories are enabled at the ERROR level.
   *
   * \since This enum is available since SDL 3.2.0.
   *)
  SDL_LogCategory = Integer;

const
  SDL_LOG_CATEGORY_APPLICATION = 0;
  SDL_LOG_CATEGORY_ERROR = 1;
  SDL_LOG_CATEGORY_ASSERT = 2;
  SDL_LOG_CATEGORY_SYSTEM = 3;
  SDL_LOG_CATEGORY_AUDIO = 4;
  SDL_LOG_CATEGORY_VIDEO = 5;
  SDL_LOG_CATEGORY_RENDER = 6;
  SDL_LOG_CATEGORY_INPUT = 7;
  SDL_LOG_CATEGORY_TEST = 8;
  SDL_LOG_CATEGORY_GPU = 9;

  // Reserved for future SDL library use
  SDL_LOG_CATEGORY_RESERVED2 = 10;
  SDL_LOG_CATEGORY_RESERVED3 = 11;
  SDL_LOG_CATEGORY_RESERVED4 = 12;
  SDL_LOG_CATEGORY_RESERVED5 = 13;
  SDL_LOG_CATEGORY_RESERVED6 = 14;
  SDL_LOG_CATEGORY_RESERVED7 = 15;
  SDL_LOG_CATEGORY_RESERVED8 = 16;
  SDL_LOG_CATEGORY_RESERVED9 = 17;
  SDL_LOG_CATEGORY_RESERVED10 = 18;
  (* Beyond this point is reserved for application use, e.g.
     enum {
         MYAPP_CATEGORY_AWESOME1 = SDL_LOG_CATEGORY_CUSTOM,
         MYAPP_CATEGORY_AWESOME2,
         MYAPP_CATEGORY_AWESOME3,
         ...
     };
   *)
  SDL_LOG_CATEGORY_CUSTOM = 19;

(**
 * The predefined log priorities
 *
 * \since This enum is available since SDL 3.2.0.
 *)
type
  SDL_LogPriority = Integer;

const
  SDL_LOG_PRIORITY_INVALID = 0;
  SDL_LOG_PRIORITY_TRACE = 1;
  SDL_LOG_PRIORITY_VERBOSE = 2;
  SDL_LOG_PRIORITY_DEBUG = 3;
  SDL_LOG_PRIORITY_INFO = 4;
  SDL_LOG_PRIORITY_WARN = 5;
  SDL_LOG_PRIORITY_ERROR = 6;
  SDL_LOG_PRIORITY_CRITICAL = 7;
  SDL_LOG_PRIORITY_COUNT = 8;

(**
 * Set the priority of all log categories.
 *
 * \param priority the SDL_LogPriority to assign.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_ResetLogPriorities
 * \sa SDL_SetLogPriority
 *)
procedure SDL_SetLogPriorities(priority: SDL_LogPriority); cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetLogPriorities';

(**
 * Set the priority of a particular log category.
 *
 * \param category the category to assign a priority to.
 * \param priority the SDL_LogPriority to assign.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetLogPriority
 * \sa SDL_ResetLogPriorities
 * \sa SDL_SetLogPriorities
 *)
procedure SDL_SetLogPriority(category: Integer; priority: SDL_LogPriority); cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetLogPriority';

(**
 * Get the priority of a particular log category.
 *
 * \param category the category to query.
 * \returns the SDL_LogPriority for the requested category.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetLogPriority
 *)
function SDL_GetLogPriority(category: Integer): SDL_LogPriority; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetLogPriority';

(**
 * Reset all priorities to default.
 *
 * This is called by SDL_Quit().
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetLogPriorities
 * \sa SDL_SetLogPriority
 *)
procedure SDL_ResetLogPriorities(); cdecl;
  external LIB_SDL3 name _PU + 'SDL_ResetLogPriorities';

(**
 * Set the text prepended to log messages of a given priority.
 *
 * By default SDL_LOG_PRIORITY_INFO and below have no prefix, and
 * SDL_LOG_PRIORITY_WARN and higher have a prefix showing their priority, e.g.
 * "WARNING: ".
 *
 * \param priority the SDL_LogPriority to modify.
 * \param prefix the prefix to use for that log priority, or NULL to use no
 *               prefix.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetLogPriorities
 * \sa SDL_SetLogPriority
 *)
function SDL_SetLogPriorityPrefix(priority: SDL_LogPriority; const prefix: PUTF8Char): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetLogPriorityPrefix';

(**
 * Log a message with SDL_LOG_CATEGORY_APPLICATION and SDL_LOG_PRIORITY_INFO.
 *
 * \param fmt a printf() style message format string.
 * \param ... additional parameters matching % tokens in the `fmt` string, if
 *            any.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_LogCritical
 * \sa SDL_LogDebug
 * \sa SDL_LogError
 * \sa SDL_LogInfo
 * \sa SDL_LogMessage
 * \sa SDL_LogMessageV
 * \sa SDL_LogTrace
 * \sa SDL_LogVerbose
 * \sa SDL_LogWarn
 *)
procedure SDL_Log(const fmt: PUTF8Char) varargs; overload; cdecl;
  external LIB_SDL3 name _PU + 'SDL_Log';

(**
 * Log a message with SDL_LOG_PRIORITY_TRACE.
 *
 * \param category the category of the message.
 * \param fmt a printf() style message format string.
 * \param ... additional parameters matching % tokens in the **fmt** string,
 *            if any.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_Log
 * \sa SDL_LogCritical
 * \sa SDL_LogDebug
 * \sa SDL_LogError
 * \sa SDL_LogInfo
 * \sa SDL_LogMessage
 * \sa SDL_LogMessageV
 * \sa SDL_LogTrace
 * \sa SDL_LogVerbose
 * \sa SDL_LogWarn
 *)
procedure SDL_LogTrace(category: Integer; const fmt: PUTF8Char) varargs; cdecl;
  external LIB_SDL3 name _PU + 'SDL_LogTrace';

(**
 * Log a message with SDL_LOG_PRIORITY_VERBOSE.
 *
 * \param category the category of the message.
 * \param fmt a printf() style message format string.
 * \param ... additional parameters matching % tokens in the **fmt** string,
 *            if any.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_Log
 * \sa SDL_LogCritical
 * \sa SDL_LogDebug
 * \sa SDL_LogError
 * \sa SDL_LogInfo
 * \sa SDL_LogMessage
 * \sa SDL_LogMessageV
 * \sa SDL_LogWarn
 *)
procedure SDL_LogVerbose(category: Integer; const fmt: PUTF8Char) varargs; cdecl;
  external LIB_SDL3 name _PU + 'SDL_LogVerbose';

(**
 * Log a message with SDL_LOG_PRIORITY_DEBUG.
 *
 * \param category the category of the message.
 * \param fmt a printf() style message format string.
 * \param ... additional parameters matching % tokens in the **fmt** string,
 *            if any.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_Log
 * \sa SDL_LogCritical
 * \sa SDL_LogError
 * \sa SDL_LogInfo
 * \sa SDL_LogMessage
 * \sa SDL_LogMessageV
 * \sa SDL_LogTrace
 * \sa SDL_LogVerbose
 * \sa SDL_LogWarn
 *)
procedure SDL_LogDebug(category: Integer; const fmt: PUTF8Char) varargs; cdecl;
  external LIB_SDL3 name _PU + 'SDL_LogDebug';

(**
 * Log a message with SDL_LOG_PRIORITY_INFO.
 *
 * \param category the category of the message.
 * \param fmt a printf() style message format string.
 * \param ... additional parameters matching % tokens in the **fmt** string,
 *            if any.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_Log
 * \sa SDL_LogCritical
 * \sa SDL_LogDebug
 * \sa SDL_LogError
 * \sa SDL_LogMessage
 * \sa SDL_LogMessageV
 * \sa SDL_LogTrace
 * \sa SDL_LogVerbose
 * \sa SDL_LogWarn
 *)
procedure SDL_LogInfo(category: Integer; const fmt: PUTF8Char) varargs; cdecl;
  external LIB_SDL3 name _PU + 'SDL_LogInfo';

(**
 * Log a message with SDL_LOG_PRIORITY_WARN.
 *
 * \param category the category of the message.
 * \param fmt a printf() style message format string.
 * \param ... additional parameters matching % tokens in the **fmt** string,
 *            if any.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_Log
 * \sa SDL_LogCritical
 * \sa SDL_LogDebug
 * \sa SDL_LogError
 * \sa SDL_LogInfo
 * \sa SDL_LogMessage
 * \sa SDL_LogMessageV
 * \sa SDL_LogTrace
 * \sa SDL_LogVerbose
 *)
procedure SDL_LogWarn(category: Integer; const fmt: PUTF8Char) varargs; cdecl;
  external LIB_SDL3 name _PU + 'SDL_LogWarn';

(**
 * Log a message with SDL_LOG_PRIORITY_ERROR.
 *
 * \param category the category of the message.
 * \param fmt a printf() style message format string.
 * \param ... additional parameters matching % tokens in the **fmt** string,
 *            if any.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_Log
 * \sa SDL_LogCritical
 * \sa SDL_LogDebug
 * \sa SDL_LogInfo
 * \sa SDL_LogMessage
 * \sa SDL_LogMessageV
 * \sa SDL_LogTrace
 * \sa SDL_LogVerbose
 * \sa SDL_LogWarn
 *)
procedure SDL_LogError(category: Integer; const fmt: PUTF8Char) varargs; cdecl;
  external LIB_SDL3 name _PU + 'SDL_LogError';

(**
 * Log a message with SDL_LOG_PRIORITY_CRITICAL.
 *
 * \param category the category of the message.
 * \param fmt a printf() style message format string.
 * \param ... additional parameters matching % tokens in the **fmt** string,
 *            if any.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_Log
 * \sa SDL_LogDebug
 * \sa SDL_LogError
 * \sa SDL_LogInfo
 * \sa SDL_LogMessage
 * \sa SDL_LogMessageV
 * \sa SDL_LogTrace
 * \sa SDL_LogVerbose
 * \sa SDL_LogWarn
 *)
procedure SDL_LogCritical(category: Integer; const fmt: PUTF8Char) varargs; cdecl;
  external LIB_SDL3 name _PU + 'SDL_LogCritical';

(**
 * Log a message with the specified category and priority.
 *
 * \param category the category of the message.
 * \param priority the priority of the message.
 * \param fmt a printf() style message format string.
 * \param ... additional parameters matching % tokens in the **fmt** string,
 *            if any.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_Log
 * \sa SDL_LogCritical
 * \sa SDL_LogDebug
 * \sa SDL_LogError
 * \sa SDL_LogInfo
 * \sa SDL_LogMessageV
 * \sa SDL_LogTrace
 * \sa SDL_LogVerbose
 * \sa SDL_LogWarn
 *)
procedure SDL_LogMessage(category: Integer; priority: SDL_LogPriority; const fmt: PUTF8Char) varargs; cdecl;
  external LIB_SDL3 name _PU + 'SDL_LogMessage';

(**
 * Log a message with the specified category and priority.
 *
 * \param category the category of the message.
 * \param priority the priority of the message.
 * \param fmt a printf() style message format string.
 * \param ap a variable argument list.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_Log
 * \sa SDL_LogCritical
 * \sa SDL_LogDebug
 * \sa SDL_LogError
 * \sa SDL_LogInfo
 * \sa SDL_LogMessage
 * \sa SDL_LogTrace
 * \sa SDL_LogVerbose
 * \sa SDL_LogWarn
 *)
procedure SDL_LogMessageV(category: Integer; priority: SDL_LogPriority; const fmt: PUTF8Char; ap: Pointer); cdecl;
  external LIB_SDL3 name _PU + 'SDL_LogMessageV';

type
  (**
   * The prototype for the log output callback function.
   *
   * This function is called by SDL when there is new text to be logged. A mutex
   * is held so that this function is never called by more than one thread at
   * once.
   *
   * \param userdata what was passed as `userdata` to
   *                 SDL_SetLogOutputFunction().
   * \param category the category of the message.
   * \param priority the priority of the message.
   * \param message the message being output.
   *
   * \since This datatype is available since SDL 3.2.0.
   *)
  SDL_LogOutputFunction = procedure(userdata: Pointer; category: Integer; priority: SDL_LogPriority; const &message: PUTF8Char); cdecl;
  PSDL_LogOutputFunction = ^SDL_LogOutputFunction;

(**
 * Get the default log output function.
 *
 * \returns the default log output callback.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetLogOutputFunction
 * \sa SDL_GetLogOutputFunction
 *)
function SDL_GetDefaultLogOutputFunction(): SDL_LogOutputFunction; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetDefaultLogOutputFunction';

(**
 * Get the current log output function.
 *
 * \param callback an SDL_LogOutputFunction filled in with the current log
 *                 callback.
 * \param userdata a pointer filled in with the pointer that is passed to
 *                 `callback`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetDefaultLogOutputFunction
 * \sa SDL_SetLogOutputFunction
 *)
procedure SDL_GetLogOutputFunction(callback: PSDL_LogOutputFunction; userdata: PPointer); cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetLogOutputFunction';

(**
 * Replace the default log output function with one of your own.
 *
 * \param callback an SDL_LogOutputFunction to call instead of the default.
 * \param userdata a pointer that is passed to `callback`.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetDefaultLogOutputFunction
 * \sa SDL_GetLogOutputFunction
 *)
procedure SDL_SetLogOutputFunction(callback: SDL_LogOutputFunction; userdata: Pointer); cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetLogOutputFunction';
{$ENDREGION 'SDL_log.h'}

{$REGION 'SDL_messagebox.h'}
(**
 * # CategoryMessagebox
 *
 * SDL offers a simple message box API, which is useful for simple alerts,
 * such as informing the user when something fatal happens at startup without
 * the need to build a UI for it (or informing the user _before_ your UI is
 * ready).
 *
 * These message boxes are native system dialogs where possible.
 *
 * There is both a customizable function (SDL_ShowMessageBox()) that offers
 * lots of options for what to display and reports on what choice the user
 * made, and also a much-simplified version (SDL_ShowSimpleMessageBox()),
 * merely takes a text message and title, and waits until the user presses a
 * single "OK" UI button. Often, this is all that is necessary.
 *)

type
  (**
   * Message box flags.
   *
   * If supported will display warning icon, etc.
   *
   * \since This datatype is available since SDL 3.2.0.
   *)
  SDL_MessageBoxFlags = Uint32;

const
  SDL_MESSAGEBOX_ERROR                 = $00000010; // error dialog
  SDL_MESSAGEBOX_WARNING               = $00000020; // warning dialog
  SDL_MESSAGEBOX_INFORMATION           = $00000040; // informational dialog
  SDL_MESSAGEBOX_BUTTONS_LEFT_TO_RIGHT = $00000080; // buttons placed left to right
  SDL_MESSAGEBOX_BUTTONS_RIGHT_TO_LEFT = $00000100; // buttons placed right to left

type
  (**
   * SDL_MessageBoxButtonData flags.
   *
   * \since This datatype is available since SDL 3.2.0.
   *)
  SDL_MessageBoxButtonFlags = Uint32;

const
  SDL_MESSAGEBOX_BUTTON_RETURNKEY_DEFAULT = $00000001; // Marks the default button when return is hit
  SDL_MESSAGEBOX_BUTTON_ESCAPEKEY_DEFAULT = $00000002; // Marks the default button when escape is hit

type
  (**
   * Individual button data.
   *
   * \since This struct is available since SDL 3.2.0.
   *)
  SDL_MessageBoxButtonData = record
    flags: SDL_MessageBoxButtonFlags;
    (** User defined button id (value returned via SDL_ShowMessageBox) *)
    buttonID: Integer;
    (** The UTF-8 button text *)
    text: PUTF8Char;
  end;
  PSDL_MessageBoxButtonData = ^SDL_MessageBoxButtonData;

type
  (**
   * RGB value used in a message box color scheme
   *
   * \since This struct is available since SDL 3.2.0.
   *)
  SDL_MessageBoxColor = record
    r: Uint8;
    g: Uint8;
    b: Uint8;
  end;

(**
 * An enumeration of indices inside the colors array of
 * SDL_MessageBoxColorScheme.
 *)
type
  SDL_MessageBoxColorType = Integer;

const
  SDL_MESSAGEBOX_COLOR_BACKGROUND = 0;
  SDL_MESSAGEBOX_COLOR_TEXT = 1;
  SDL_MESSAGEBOX_COLOR_BUTTON_BORDER = 2;
  SDL_MESSAGEBOX_COLOR_BUTTON_BACKGROUND = 3;
  SDL_MESSAGEBOX_COLOR_BUTTON_SELECTED = 4;
  (** Size of the colors array of SDL_MessageBoxColorScheme. *)
  SDL_MESSAGEBOX_COLOR_COUNT = 5;

type
  (**
   * A set of colors to use for message box dialogs
   *
   * \since This struct is available since SDL 3.2.0.
   *)
  SDL_MessageBoxColorScheme = record
    colors: array [0..4] of SDL_MessageBoxColor;
  end;
  PSDL_MessageBoxColorScheme = ^SDL_MessageBoxColorScheme;

type
  (**
   * MessageBox structure containing title, text, window, etc.
   *
   * \since This struct is available since SDL 3.2.0.
   *)
  SDL_MessageBoxData = record
    flags: SDL_MessageBoxFlags;
    (** Parent window, can be NULL *)
    window: SDL_Window;
    (** UTF-8 title *)
    title: PUTF8Char;
    (** UTF-8 message text *)
    &message: PUTF8Char;
    numbuttons: Integer;
    buttons: PSDL_MessageBoxButtonData;
    (** SDL_MessageBoxColorScheme, can be NULL to use system settings *)
    colorScheme: PSDL_MessageBoxColorScheme;
  end;
  PSDL_MessageBoxData = ^SDL_MessageBoxData;

(**
 * Create a modal message box.
 *
 * If your needs aren't complex, it might be easier to use
 * SDL_ShowSimpleMessageBox.
 *
 * This function should be called on the thread that created the parent
 * window, or on the main thread if the messagebox has no parent. It will
 * block execution of that thread until the user clicks a button or closes the
 * messagebox.
 *
 * This function may be called at any time, even before SDL_Init(). This makes
 * it useful for reporting errors like a failure to create a renderer or
 * OpenGL context.
 *
 * On X11, SDL rolls its own dialog box with X11 primitives instead of a
 * formal toolkit like GTK+ or Qt.
 *
 * Note that if SDL_Init() would fail because there isn't any available video
 * target, this function is likely to fail for the same reasons. If this is a
 * concern, check the return value from this function and fall back to writing
 * to stderr if you can.
 *
 * \param messageboxdata the SDL_MessageBoxData structure with title, text and
 *                       other options.
 * \param buttonid the pointer to which user id of hit button should be
 *                 copied.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_ShowSimpleMessageBox
 *)
function SDL_ShowMessageBox(const messageboxdata: PSDL_MessageBoxData; buttonid: PInteger): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_ShowMessageBox';

(**
 * Display a simple modal message box.
 *
 * If your needs aren't complex, this function is preferred over
 * SDL_ShowMessageBox.
 *
 * `flags` may be any of the following:
 *
 * - `SDL_MESSAGEBOX_ERROR`: error dialog
 * - `SDL_MESSAGEBOX_WARNING`: warning dialog
 * - `SDL_MESSAGEBOX_INFORMATION`: informational dialog
 *
 * This function should be called on the thread that created the parent
 * window, or on the main thread if the messagebox has no parent. It will
 * block execution of that thread until the user clicks a button or closes the
 * messagebox.
 *
 * This function may be called at any time, even before SDL_Init(). This makes
 * it useful for reporting errors like a failure to create a renderer or
 * OpenGL context.
 *
 * On X11, SDL rolls its own dialog box with X11 primitives instead of a
 * formal toolkit like GTK+ or Qt.
 *
 * Note that if SDL_Init() would fail because there isn't any available video
 * target, this function is likely to fail for the same reasons. If this is a
 * concern, check the return value from this function and fall back to writing
 * to stderr if you can.
 *
 * \param flags an SDL_MessageBoxFlags value.
 * \param title UTF-8 title text.
 * \param message UTF-8 message text.
 * \param window the parent window, or NULL for no parent.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_ShowMessageBox
 *)
function SDL_ShowSimpleMessageBox(flags: SDL_MessageBoxFlags; const title: PUTF8Char; const &message: PUTF8Char; window: SDL_Window): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_ShowSimpleMessageBox';
{$ENDREGION 'SDL_messagebox.h'}

{$REGION 'SDL_metal.h'}
(**
 * # CategoryMetal
 *
 * Functions to creating Metal layers and views on SDL windows.
 *
 * This provides some platform-specific glue for Apple platforms. Most macOS
 * and iOS apps can use SDL without these functions, but this API they can be
 * useful for specific OS-level integration tasks.
 *)

type
  (**
   * A handle to a CAMetalLayer-backed NSView (macOS) or UIView (iOS/tvOS).
   *
   * \since This datatype is available since SDL 3.2.0.
   *)
  SDL_MetalView = THandle;

(**
 * Create a CAMetalLayer-backed NSView/UIView and attach it to the specified
 * window.
 *
 * On macOS, this does *not* associate a MTLDevice with the CAMetalLayer on
 * its own. It is up to user code to do that.
 *
 * The returned handle can be casted directly to a NSView or UIView. To access
 * the backing CAMetalLayer, call SDL_Metal_GetLayer().
 *
 * \param window the window.
 * \returns handle NSView or UIView.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_Metal_DestroyView
 * \sa SDL_Metal_GetLayer
 *)
function SDL_Metal_CreateView(window: SDL_Window): SDL_MetalView; cdecl;
  external LIB_SDL3 name _PU + 'SDL_Metal_CreateView';

(**
 * Destroy an existing SDL_MetalView object.
 *
 * This should be called before SDL_DestroyWindow, if SDL_Metal_CreateView was
 * called after SDL_CreateWindow.
 *
 * \param view the SDL_MetalView object.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_Metal_CreateView
 *)
procedure SDL_Metal_DestroyView(view: SDL_MetalView); cdecl;
  external LIB_SDL3 name _PU + 'SDL_Metal_DestroyView';

(**
 * Get a pointer to the backing CAMetalLayer for the given view.
 *
 * \param view the SDL_MetalView object.
 * \returns a pointer.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_Metal_GetLayer(view: SDL_MetalView): Pointer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_Metal_GetLayer';
{$ENDREGION 'SDL_metal.h'}

{$REGION 'SDL_misc.h'}
(**
 * # CategoryMisc
 *
 * SDL API functions that don't fit elsewhere.
 *)

(**
 * Open a URL/URI in the browser or other appropriate external application.
 *
 * Open a URL in a separate, system-provided application. How this works will
 * vary wildly depending on the platform. This will likely launch what makes
 * sense to handle a specific URL's protocol (a web browser for `http://`,
 * etc), but it might also be able to launch file managers for directories and
 * other things.
 *
 * What happens when you open a URL varies wildly as well: your game window
 * may lose focus (and may or may not lose focus if your game was fullscreen
 * or grabbing input at the time). On mobile devices, your app will likely
 * move to the background or your process might be paused. Any given platform
 * may or may not handle a given URL.
 *
 * If this is unimplemented (or simply unavailable) for a platform, this will
 * fail with an error. A successful result does not mean the URL loaded, just
 * that we launched _something_ to handle it (or at least believe we did).
 *
 * All this to say: this function can be useful, but you should definitely
 * test it on every platform you target.
 *
 * \param url a valid URL/URI to open. Use `file:///full/path/to/file` for
 *            local files, if supported.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_OpenURL(const url: PUTF8Char): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_OpenURL';
{$ENDREGION 'SDL_misc.h'}

{$REGION 'SDL_thread.h'}
(**
 * # CategoryThread
 *
 * SDL offers cross-platform thread management functions. These are mostly
 * concerned with starting threads, setting their priority, and dealing with
 * their termination.
 *
 * In addition, there is support for Thread Local Storage (data that is unique
 * to each thread, but accessed from a single key).
 *
 * On platforms without thread support (such as Emscripten when built without
 * pthreads), these functions still exist, but things like SDL_CreateThread()
 * will report failure without doing anything.
 *
 * If you're going to work with threads, you almost certainly need to have a
 * good understanding of [CategoryMutex](CategoryMutex) as well.
 *)

type
  (**
   * The SDL thread object.
   *
   * These are opaque data.
   *
   * \since This datatype is available since SDL 3.2.0.
   *
   * \sa SDL_CreateThread
   * \sa SDL_WaitThread
   *)
  SDL_Thread = THandle;

  (**
   * A unique numeric ID that identifies a thread.
   *
   * These are different from SDL_Thread objects, which are generally what an
   * application will operate on, but having a way to uniquely identify a thread
   * can be useful at times.
   *
   * \since This datatype is available since SDL 3.2.0.
   *
   * \sa SDL_GetThreadID
   * \sa SDL_GetCurrentThreadID
   *)
  SDL_ThreadID = Uint64;

  (**
   * Thread local storage ID.
   *
   * 0 is the invalid ID. An app can create these and then set data for these
   * IDs that is unique to each thread.
   *
   * \since This datatype is available since SDL 3.2.0.
   *
   * \sa SDL_GetTLS
   * \sa SDL_SetTLS
   *)
  SDL_TLSID = SDL_AtomicInt;
  PSDL_TLSID = ^SDL_TLSID;

(**
 * The SDL thread priority.
 *
 * SDL will make system changes as necessary in order to apply the thread
 * priority. Code which attempts to control thread state related to priority
 * should be aware that calling SDL_SetCurrentThreadPriority may alter such
 * state. SDL_HINT_THREAD_PRIORITY_POLICY can be used to control aspects of
 * this behavior.
 *
 * \since This enum is available since SDL 3.2.0.
 *)
type
  SDL_ThreadPriority = Integer;

const
  SDL_THREAD_PRIORITY_LOW = 0;
  SDL_THREAD_PRIORITY_NORMAL = 1;
  SDL_THREAD_PRIORITY_HIGH = 2;
  SDL_THREAD_PRIORITY_TIME_CRITICAL = 3;

(**
 * The SDL thread state.
 *
 * The current state of a thread can be checked by calling SDL_GetThreadState.
 *
 * \since This enum is available since SDL 3.2.0.
 *
 * \sa SDL_GetThreadState
 *)
type
  SDL_ThreadState = Integer;

const
  (** The thread is not valid *)
  SDL_THREAD_UNKNOWN = 0;
  (** The thread is currently running *)
  SDL_THREAD_ALIVE = 1;
  (** The thread is detached and can't be waited on *)
  SDL_THREAD_DETACHED = 2;
  (** The thread has finished and should be cleaned up with SDL_WaitThread() *)
  SDL_THREAD_COMPLETE = 3;

type
  (**
   * The function passed to SDL_CreateThread() as the new thread's entry point.
   *
   * \param data what was passed as `data` to SDL_CreateThread().
   * \returns a value that can be reported through SDL_WaitThread().
   *
   * \since This datatype is available since SDL 3.2.0.
   *)
  SDL_ThreadFunction = function(data: Pointer): Integer; cdecl;

(**
 * The actual entry point for SDL_CreateThread.
 *
 * \param fn the SDL_ThreadFunction function to call in the new thread
 * \param name the name of the thread
 * \param data a pointer that is passed to `fn`
 * \param pfnBeginThread the C runtime's _beginthreadex (or whatnot). Can be NULL.
 * \param pfnEndThread the C runtime's _endthreadex (or whatnot). Can be NULL.
 * \returns an opaque pointer to the new thread object on success, NULL if the
 *          new thread could not be created; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_CreateThreadRuntime(fn: SDL_ThreadFunction; const name: PUTF8Char; data: Pointer; pfnBeginThread: SDL_FunctionPointer; pfnEndThread: SDL_FunctionPointer): SDL_Thread; cdecl;
  external LIB_SDL3 name _PU + 'SDL_CreateThreadRuntime';

(**
 * The actual entry point for SDL_CreateThreadWithProperties.
 *
 * \param props the properties to use
 * \param pfnBeginThread the C runtime's _beginthreadex (or whatnot). Can be NULL.
 * \param pfnEndThread the C runtime's _endthreadex (or whatnot). Can be NULL.
 * \returns an opaque pointer to the new thread object on success, NULL if the
 *          new thread could not be created; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_CreateThreadWithPropertiesRuntime(props: SDL_PropertiesID; pfnBeginThread: SDL_FunctionPointer; pfnEndThread: SDL_FunctionPointer): SDL_Thread; cdecl;
  external LIB_SDL3 name _PU + 'SDL_CreateThreadWithPropertiesRuntime';

function SDL_CreateThread(fn: SDL_ThreadFunction; const name: PUTF8Char; data: Pointer): SDL_Thread; inline;

function SDL_CreateThreadWithProperties(props: SDL_PropertiesID): SDL_Thread; inline;

const
  SDL_PROP_THREAD_CREATE_ENTRY_FUNCTION_POINTER = 'SDL.thread.create.entry_function';
  SDL_PROP_THREAD_CREATE_NAME_STRING = 'SDL.thread.create.name';
  SDL_PROP_THREAD_CREATE_USERDATA_POINTER = 'SDL.thread.create.userdata';
  SDL_PROP_THREAD_CREATE_STACKSIZE_NUMBER = 'SDL.thread.create.stacksize';

(**
 * Get the thread name as it was specified in SDL_CreateThread().
 *
 * \param thread the thread to query.
 * \returns a pointer to a UTF-8 string that names the specified thread, or
 *          NULL if it doesn't have a name.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetThreadName(thread: SDL_Thread): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetThreadName';

(**
 * Get the thread identifier for the current thread.
 *
 * This thread identifier is as reported by the underlying operating system.
 * If SDL is running on a platform that does not support threads the return
 * value will always be zero.
 *
 * This function also returns a valid thread ID when called from the main
 * thread.
 *
 * \returns the ID of the current thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetThreadID
 *)
function SDL_GetCurrentThreadID(): SDL_ThreadID; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetCurrentThreadID';

(**
 * Get the thread identifier for the specified thread.
 *
 * This thread identifier is as reported by the underlying operating system.
 * If SDL is running on a platform that does not support threads the return
 * value will always be zero.
 *
 * \param thread the thread to query.
 * \returns the ID of the specified thread, or the ID of the current thread if
 *          `thread` is NULL.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetCurrentThreadID
 *)
function SDL_GetThreadID(thread: SDL_Thread): SDL_ThreadID; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetThreadID';

(**
 * Set the priority for the current thread.
 *
 * Note that some platforms will not let you alter the priority (or at least,
 * promote the thread to a higher priority) at all, and some require you to be
 * an administrator account. Be prepared for this to fail.
 *
 * \param priority the SDL_ThreadPriority to set.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_SetCurrentThreadPriority(priority: SDL_ThreadPriority): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetCurrentThreadPriority';

(**
 * Wait for a thread to finish.
 *
 * Threads that haven't been detached will remain until this function cleans
 * them up. Not doing so is a resource leak.
 *
 * Once a thread has been cleaned up through this function, the SDL_Thread
 * that references it becomes invalid and should not be referenced again. As
 * such, only one thread may call SDL_WaitThread() on another.
 *
 * The return code from the thread function is placed in the area pointed to
 * by `status`, if `status` is not NULL.
 *
 * You may not wait on a thread that has been used in a call to
 * SDL_DetachThread(). Use either that function or this one, but not both, or
 * behavior is undefined.
 *
 * It is safe to pass a NULL thread to this function; it is a no-op.
 *
 * Note that the thread pointer is freed by this function and is not valid
 * afterward.
 *
 * \param thread the SDL_Thread pointer that was returned from the
 *               SDL_CreateThread() call that started this thread.
 * \param status a pointer filled in with the value returned from the thread
 *               function by its 'return', or -1 if the thread has been
 *               detached or isn't valid, may be NULL.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CreateThread
 * \sa SDL_DetachThread
 *)
procedure SDL_WaitThread(thread: SDL_Thread; status: PInteger); cdecl;
  external LIB_SDL3 name _PU + 'SDL_WaitThread';

(**
 * Get the current state of a thread.
 *
 * \param thread the thread to query.
 * \returns the current state of a thread, or SDL_THREAD_UNKNOWN if the thread
 *          isn't valid.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_ThreadState
 *)
function SDL_GetThreadState(thread: SDL_Thread): SDL_ThreadState; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetThreadState';

(**
 * Let a thread clean up on exit without intervention.
 *
 * A thread may be "detached" to signify that it should not remain until
 * another thread has called SDL_WaitThread() on it. Detaching a thread is
 * useful for long-running threads that nothing needs to synchronize with or
 * further manage. When a detached thread is done, it simply goes away.
 *
 * There is no way to recover the return code of a detached thread. If you
 * need this, don't detach the thread and instead use SDL_WaitThread().
 *
 * Once a thread is detached, you should usually assume the SDL_Thread isn't
 * safe to reference again, as it will become invalid immediately upon the
 * detached thread's exit, instead of remaining until someone has called
 * SDL_WaitThread() to finally clean it up. As such, don't detach the same
 * thread more than once.
 *
 * If a thread has already exited when passed to SDL_DetachThread(), it will
 * stop waiting for a call to SDL_WaitThread() and clean up immediately. It is
 * not safe to detach a thread that might be used with SDL_WaitThread().
 *
 * You may not call SDL_WaitThread() on a thread that has been detached. Use
 * either that function or this one, but not both, or behavior is undefined.
 *
 * It is safe to pass NULL to this function; it is a no-op.
 *
 * \param thread the SDL_Thread pointer that was returned from the
 *               SDL_CreateThread() call that started this thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CreateThread
 * \sa SDL_WaitThread
 *)
procedure SDL_DetachThread(thread: SDL_Thread); cdecl;
  external LIB_SDL3 name _PU + 'SDL_DetachThread';

(**
 * Get the current thread's value associated with a thread local storage ID.
 *
 * \param id a pointer to the thread local storage ID, may not be NULL.
 * \returns the value associated with the ID for the current thread or NULL if
 *          no value has been set; call SDL_GetError() for more information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetTLS
 *)
function SDL_GetTLS(id: PSDL_TLSID): Pointer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetTLS';

type
  (**
   * The callback used to cleanup data passed to SDL_SetTLS.
   *
   * This is called when a thread exits, to allow an app to free any resources.
   *
   * \param value a pointer previously handed to SDL_SetTLS.
   *
   * \since This datatype is available since SDL 3.2.0.
   *
   * \sa SDL_SetTLS
   *)
  SDL_TLSDestructorCallback = procedure(value: Pointer); cdecl;

(**
 * Set the current thread's value associated with a thread local storage ID.
 *
 * If the thread local storage ID is not initialized (the value is 0), a new
 * ID will be created in a thread-safe way, so all calls using a pointer to
 * the same ID will refer to the same local storage.
 *
 * Note that replacing a value from a previous call to this function on the
 * same thread does _not_ call the previous value's destructor!
 *
 * `destructor` can be NULL; it is assumed that `value` does not need to be
 * cleaned up if so.
 *
 * \param id a pointer to the thread local storage ID, may not be NULL.
 * \param value the value to associate with the ID for the current thread.
 * \param destructor a function called when the thread exits, to free the
 *                   value, may be NULL.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetTLS
 *)
function SDL_SetTLS(id: PSDL_TLSID; const value: Pointer; &destructor: SDL_TLSDestructorCallback): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetTLS';

(**
 * Cleanup all TLS data for this thread.
 *
 * If you are creating your threads outside of SDL and then calling SDL
 * functions, you should call this function before your thread exits, to
 * properly clean up SDL memory.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_CleanupTLS(); cdecl;
  external LIB_SDL3 name _PU + 'SDL_CleanupTLS';
{$ENDREGION 'SDL_thread.h'}

{$REGION 'SDL_mutex.h'}
(**
 * # CategoryMutex
 *
 * SDL offers several thread synchronization primitives. This document can't
 * cover the complicated topic of thread safety, but reading up on what each
 * of these primitives are, why they are useful, and how to correctly use them
 * is vital to writing correct and safe multithreaded programs.
 *
 * - Mutexes: SDL_CreateMutex()
 * - Read/Write locks: SDL_CreateRWLock()
 * - Semaphores: SDL_CreateSemaphore()
 * - Condition variables: SDL_CreateCondition()
 *
 * SDL also offers a datatype, SDL_InitState, which can be used to make sure
 * only one thread initializes/deinitializes some resource that several
 * threads might try to use for the first time simultaneously.
 *)

type
  (**
   * A means to serialize access to a resource between threads.
   *
   * Mutexes (short for "mutual exclusion") are a synchronization primitive that
   * allows exactly one thread to proceed at a time.
   *
   * Wikipedia has a thorough explanation of the concept:
   *
   * https://en.wikipedia.org/wiki/Mutex
   *
   * \since This struct is available since SDL 3.2.0.
   *)
  SDL_Mutex = THandle;

(**
 * Create a new mutex.
 *
 * All newly-created mutexes begin in the _unlocked_ state.
 *
 * Calls to SDL_LockMutex() will not return while the mutex is locked by
 * another thread. See SDL_TryLockMutex() to attempt to lock without blocking.
 *
 * SDL mutexes are reentrant.
 *
 * \returns the initialized and unlocked mutex or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_DestroyMutex
 * \sa SDL_LockMutex
 * \sa SDL_TryLockMutex
 * \sa SDL_UnlockMutex
 *)
function SDL_CreateMutex(): SDL_Mutex; cdecl;
  external LIB_SDL3 name _PU + 'SDL_CreateMutex';

(**
 * Lock the mutex.
 *
 * This will block until the mutex is available, which is to say it is in the
 * unlocked state and the OS has chosen the caller as the next thread to lock
 * it. Of all threads waiting to lock the mutex, only one may do so at a time.
 *
 * It is legal for the owning thread to lock an already-locked mutex. It must
 * unlock it the same number of times before it is actually made available for
 * other threads in the system (this is known as a "recursive mutex").
 *
 * This function does not fail; if mutex is NULL, it will return immediately
 * having locked nothing. If the mutex is valid, this function will always
 * block until it can lock the mutex, and return with it locked.
 *
 * \param mutex the mutex to lock.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_TryLockMutex
 * \sa SDL_UnlockMutex
 *)
procedure SDL_LockMutex(mutex: SDL_Mutex); cdecl;
  external LIB_SDL3 name _PU + 'SDL_LockMutex';

(**
 * Try to lock a mutex without blocking.
 *
 * This works just like SDL_LockMutex(), but if the mutex is not available,
 * this function returns false immediately.
 *
 * This technique is useful if you need exclusive access to a resource but
 * don't want to wait for it, and will return to it to try again later.
 *
 * This function returns true if passed a NULL mutex.
 *
 * \param mutex the mutex to try to lock.
 * \returns true on success, false if the mutex would block.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_LockMutex
 * \sa SDL_UnlockMutex
 *)
function SDL_TryLockMutex(mutex: SDL_Mutex): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_TryLockMutex';

(**
 * Unlock the mutex.
 *
 * It is legal for the owning thread to lock an already-locked mutex. It must
 * unlock it the same number of times before it is actually made available for
 * other threads in the system (this is known as a "recursive mutex").
 *
 * It is illegal to unlock a mutex that has not been locked by the current
 * thread, and doing so results in undefined behavior.
 *
 * \param mutex the mutex to unlock.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_LockMutex
 * \sa SDL_TryLockMutex
 *)
procedure SDL_UnlockMutex(mutex: SDL_Mutex); cdecl;
  external LIB_SDL3 name _PU + 'SDL_UnlockMutex';

(**
 * Destroy a mutex created with SDL_CreateMutex().
 *
 * This function must be called on any mutex that is no longer needed. Failure
 * to destroy a mutex will result in a system memory or resource leak. While
 * it is safe to destroy a mutex that is _unlocked_, it is not safe to attempt
 * to destroy a locked mutex, and may result in undefined behavior depending
 * on the platform.
 *
 * \param mutex the mutex to destroy.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CreateMutex
 *)
procedure SDL_DestroyMutex(mutex: SDL_Mutex); cdecl;
  external LIB_SDL3 name _PU + 'SDL_DestroyMutex';

type
  (**
   * A mutex that allows read-only threads to run in parallel.
   *
   * A rwlock is roughly the same concept as SDL_Mutex, but allows threads that
   * request read-only access to all hold the lock at the same time. If a thread
   * requests write access, it will block until all read-only threads have
   * released the lock, and no one else can hold the thread (for reading or
   * writing) at the same time as the writing thread.
   *
   * This can be more efficient in cases where several threads need to access
   * data frequently, but changes to that data are rare.
   *
   * There are other rules that apply to rwlocks that don't apply to mutexes,
   * about how threads are scheduled and when they can be recursively locked.
   * These are documented in the other rwlock functions.
   *
   * \since This struct is available since SDL 3.2.0.
   *)
  SDL_RWLock = THandle;

(**
 * Create a new read/write lock.
 *
 * A read/write lock is useful for situations where you have multiple threads
 * trying to access a resource that is rarely updated. All threads requesting
 * a read-only lock will be allowed to run in parallel; if a thread requests a
 * write lock, it will be provided exclusive access. This makes it safe for
 * multiple threads to use a resource at the same time if they promise not to
 * change it, and when it has to be changed, the rwlock will serve as a
 * gateway to make sure those changes can be made safely.
 *
 * In the right situation, a rwlock can be more efficient than a mutex, which
 * only lets a single thread proceed at a time, even if it won't be modifying
 * the data.
 *
 * All newly-created read/write locks begin in the _unlocked_ state.
 *
 * Calls to SDL_LockRWLockForReading() and SDL_LockRWLockForWriting will not
 * return while the rwlock is locked _for writing_ by another thread. See
 * SDL_TryLockRWLockForReading() and SDL_TryLockRWLockForWriting() to attempt
 * to lock without blocking.
 *
 * SDL read/write locks are only recursive for read-only locks! They are not
 * guaranteed to be fair, or provide access in a FIFO manner! They are not
 * guaranteed to favor writers. You may not lock a rwlock for both read-only
 * and write access at the same time from the same thread (so you can't
 * promote your read-only lock to a write lock without unlocking first).
 *
 * \returns the initialized and unlocked read/write lock or NULL on failure;
 *          call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_DestroyRWLock
 * \sa SDL_LockRWLockForReading
 * \sa SDL_LockRWLockForWriting
 * \sa SDL_TryLockRWLockForReading
 * \sa SDL_TryLockRWLockForWriting
 * \sa SDL_UnlockRWLock
 *)
function SDL_CreateRWLock(): SDL_RWLock; cdecl;
  external LIB_SDL3 name _PU + 'SDL_CreateRWLock';

(**
 * Lock the read/write lock for _read only_ operations.
 *
 * This will block until the rwlock is available, which is to say it is not
 * locked for writing by any other thread. Of all threads waiting to lock the
 * rwlock, all may do so at the same time as long as they are requesting
 * read-only access; if a thread wants to lock for writing, only one may do so
 * at a time, and no other threads, read-only or not, may hold the lock at the
 * same time.
 *
 * It is legal for the owning thread to lock an already-locked rwlock for
 * reading. It must unlock it the same number of times before it is actually
 * made available for other threads in the system (this is known as a
 * "recursive rwlock").
 *
 * Note that locking for writing is not recursive (this is only available to
 * read-only locks).
 *
 * It is illegal to request a read-only lock from a thread that already holds
 * the write lock. Doing so results in undefined behavior. Unlock the write
 * lock before requesting a read-only lock. (But, of course, if you have the
 * write lock, you don't need further locks to read in any case.)
 *
 * This function does not fail; if rwlock is NULL, it will return immediately
 * having locked nothing. If the rwlock is valid, this function will always
 * block until it can lock the mutex, and return with it locked.
 *
 * \param rwlock the read/write lock to lock.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_LockRWLockForWriting
 * \sa SDL_TryLockRWLockForReading
 * \sa SDL_UnlockRWLock
 *)
procedure SDL_LockRWLockForReading(rwlock: SDL_RWLock); cdecl;
  external LIB_SDL3 name _PU + 'SDL_LockRWLockForReading';

(**
 * Lock the read/write lock for _write_ operations.
 *
 * This will block until the rwlock is available, which is to say it is not
 * locked for reading or writing by any other thread. Only one thread may hold
 * the lock when it requests write access; all other threads, whether they
 * also want to write or only want read-only access, must wait until the
 * writer thread has released the lock.
 *
 * It is illegal for the owning thread to lock an already-locked rwlock for
 * writing (read-only may be locked recursively, writing can not). Doing so
 * results in undefined behavior.
 *
 * It is illegal to request a write lock from a thread that already holds a
 * read-only lock. Doing so results in undefined behavior. Unlock the
 * read-only lock before requesting a write lock.
 *
 * This function does not fail; if rwlock is NULL, it will return immediately
 * having locked nothing. If the rwlock is valid, this function will always
 * block until it can lock the mutex, and return with it locked.
 *
 * \param rwlock the read/write lock to lock.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_LockRWLockForReading
 * \sa SDL_TryLockRWLockForWriting
 * \sa SDL_UnlockRWLock
 *)
procedure SDL_LockRWLockForWriting(rwlock: SDL_RWLock); cdecl;
  external LIB_SDL3 name _PU + 'SDL_LockRWLockForWriting';

(**
 * Try to lock a read/write lock _for reading_ without blocking.
 *
 * This works just like SDL_LockRWLockForReading(), but if the rwlock is not
 * available, then this function returns false immediately.
 *
 * This technique is useful if you need access to a resource but don't want to
 * wait for it, and will return to it to try again later.
 *
 * Trying to lock for read-only access can succeed if other threads are
 * holding read-only locks, as this won't prevent access.
 *
 * This function returns true if passed a NULL rwlock.
 *
 * \param rwlock the rwlock to try to lock.
 * \returns true on success, false if the lock would block.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_LockRWLockForReading
 * \sa SDL_TryLockRWLockForWriting
 * \sa SDL_UnlockRWLock
 *)
function SDL_TryLockRWLockForReading(rwlock: SDL_RWLock): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_TryLockRWLockForReading';

(**
 * Try to lock a read/write lock _for writing_ without blocking.
 *
 * This works just like SDL_LockRWLockForWriting(), but if the rwlock is not
 * available, then this function returns false immediately.
 *
 * This technique is useful if you need exclusive access to a resource but
 * don't want to wait for it, and will return to it to try again later.
 *
 * It is illegal for the owning thread to lock an already-locked rwlock for
 * writing (read-only may be locked recursively, writing can not). Doing so
 * results in undefined behavior.
 *
 * It is illegal to request a write lock from a thread that already holds a
 * read-only lock. Doing so results in undefined behavior. Unlock the
 * read-only lock before requesting a write lock.
 *
 * This function returns true if passed a NULL rwlock.
 *
 * \param rwlock the rwlock to try to lock.
 * \returns true on success, false if the lock would block.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_LockRWLockForWriting
 * \sa SDL_TryLockRWLockForReading
 * \sa SDL_UnlockRWLock
 *)
function SDL_TryLockRWLockForWriting(rwlock: SDL_RWLock): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_TryLockRWLockForWriting';

(**
 * Unlock the read/write lock.
 *
 * Use this function to unlock the rwlock, whether it was locked for read-only
 * or write operations.
 *
 * It is legal for the owning thread to lock an already-locked read-only lock.
 * It must unlock it the same number of times before it is actually made
 * available for other threads in the system (this is known as a "recursive
 * rwlock").
 *
 * It is illegal to unlock a rwlock that has not been locked by the current
 * thread, and doing so results in undefined behavior.
 *
 * \param rwlock the rwlock to unlock.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_LockRWLockForReading
 * \sa SDL_LockRWLockForWriting
 * \sa SDL_TryLockRWLockForReading
 * \sa SDL_TryLockRWLockForWriting
 *)
procedure SDL_UnlockRWLock(rwlock: SDL_RWLock); cdecl;
  external LIB_SDL3 name _PU + 'SDL_UnlockRWLock';

(**
 * Destroy a read/write lock created with SDL_CreateRWLock().
 *
 * This function must be called on any read/write lock that is no longer
 * needed. Failure to destroy a rwlock will result in a system memory or
 * resource leak. While it is safe to destroy a rwlock that is _unlocked_, it
 * is not safe to attempt to destroy a locked rwlock, and may result in
 * undefined behavior depending on the platform.
 *
 * \param rwlock the rwlock to destroy.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CreateRWLock
 *)
procedure SDL_DestroyRWLock(rwlock: SDL_RWLock); cdecl;
  external LIB_SDL3 name _PU + 'SDL_DestroyRWLock';

type
  (**
   * A means to manage access to a resource, by count, between threads.
   *
   * Semaphores (specifically, "counting semaphores"), let X number of threads
   * request access at the same time, each thread granted access decrementing a
   * counter. When the counter reaches zero, future requests block until a prior
   * thread releases their request, incrementing the counter again.
   *
   * Wikipedia has a thorough explanation of the concept:
   *
   * https://en.wikipedia.org/wiki/Semaphore_(programming)
   *
   * \since This struct is available since SDL 3.2.0.
   *)
  SDL_Semaphore = THandle;

(**
 * Create a semaphore.
 *
 * This function creates a new semaphore and initializes it with the value
 * `initial_value`. Each wait operation on the semaphore will atomically
 * decrement the semaphore value and potentially block if the semaphore value
 * is 0. Each post operation will atomically increment the semaphore value and
 * wake waiting threads and allow them to retry the wait operation.
 *
 * \param initial_value the starting value of the semaphore.
 * \returns a new semaphore or NULL on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_DestroySemaphore
 * \sa SDL_SignalSemaphore
 * \sa SDL_TryWaitSemaphore
 * \sa SDL_GetSemaphoreValue
 * \sa SDL_WaitSemaphore
 * \sa SDL_WaitSemaphoreTimeout
 *)
function SDL_CreateSemaphore(initial_value: Uint32): SDL_Semaphore; cdecl;
  external LIB_SDL3 name _PU + 'SDL_CreateSemaphore';

(**
 * Destroy a semaphore.
 *
 * It is not safe to destroy a semaphore if there are threads currently
 * waiting on it.
 *
 * \param sem the semaphore to destroy.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CreateSemaphore
 *)
procedure SDL_DestroySemaphore(sem: SDL_Semaphore); cdecl;
  external LIB_SDL3 name _PU + 'SDL_DestroySemaphore';

(**
 * Wait until a semaphore has a positive value and then decrements it.
 *
 * This function suspends the calling thread until the semaphore pointed to by
 * `sem` has a positive value, and then atomically decrement the semaphore
 * value.
 *
 * This function is the equivalent of calling SDL_WaitSemaphoreTimeout() with
 * a time length of -1.
 *
 * \param sem the semaphore wait on.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SignalSemaphore
 * \sa SDL_TryWaitSemaphore
 * \sa SDL_WaitSemaphoreTimeout
 *)
procedure SDL_WaitSemaphore(sem: SDL_Semaphore); cdecl;
  external LIB_SDL3 name _PU + 'SDL_WaitSemaphore';

(**
 * See if a semaphore has a positive value and decrement it if it does.
 *
 * This function checks to see if the semaphore pointed to by `sem` has a
 * positive value and atomically decrements the semaphore value if it does. If
 * the semaphore doesn't have a positive value, the function immediately
 * returns false.
 *
 * \param sem the semaphore to wait on.
 * \returns true if the wait succeeds, false if the wait would block.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SignalSemaphore
 * \sa SDL_WaitSemaphore
 * \sa SDL_WaitSemaphoreTimeout
 *)
function SDL_TryWaitSemaphore(sem: SDL_Semaphore): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_TryWaitSemaphore';

(**
 * Wait until a semaphore has a positive value and then decrements it.
 *
 * This function suspends the calling thread until either the semaphore
 * pointed to by `sem` has a positive value or the specified time has elapsed.
 * If the call is successful it will atomically decrement the semaphore value.
 *
 * \param sem the semaphore to wait on.
 * \param timeoutMS the length of the timeout, in milliseconds, or -1 to wait
 *                  indefinitely.
 * \returns true if the wait succeeds or false if the wait times out.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SignalSemaphore
 * \sa SDL_TryWaitSemaphore
 * \sa SDL_WaitSemaphore
 *)
function SDL_WaitSemaphoreTimeout(sem: SDL_Semaphore; timeoutMS: Sint32): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_WaitSemaphoreTimeout';

(**
 * Atomically increment a semaphore's value and wake waiting threads.
 *
 * \param sem the semaphore to increment.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_TryWaitSemaphore
 * \sa SDL_WaitSemaphore
 * \sa SDL_WaitSemaphoreTimeout
 *)
procedure SDL_SignalSemaphore(sem: SDL_Semaphore); cdecl;
  external LIB_SDL3 name _PU + 'SDL_SignalSemaphore';

(**
 * Get the current value of a semaphore.
 *
 * \param sem the semaphore to query.
 * \returns the current value of the semaphore.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetSemaphoreValue(sem: SDL_Semaphore): Uint32; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetSemaphoreValue';

type
  (**
   * A means to block multiple threads until a condition is satisfied.
   *
   * Condition variables, paired with an SDL_Mutex, let an app halt multiple
   * threads until a condition has occurred, at which time the app can release
   * one or all waiting threads.
   *
   * Wikipedia has a thorough explanation of the concept:
   *
   * https://en.wikipedia.org/wiki/Condition_variable
   *
   * \since This struct is available since SDL 3.2.0.
   *)
  SDL_Condition = THandle;

(**
 * Create a condition variable.
 *
 * \returns a new condition variable or NULL on failure; call SDL_GetError()
 *          for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_BroadcastCondition
 * \sa SDL_SignalCondition
 * \sa SDL_WaitCondition
 * \sa SDL_WaitConditionTimeout
 * \sa SDL_DestroyCondition
 *)
function SDL_CreateCondition(): SDL_Condition; cdecl;
  external LIB_SDL3 name _PU + 'SDL_CreateCondition';

(**
 * Destroy a condition variable.
 *
 * \param cond the condition variable to destroy.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CreateCondition
 *)
procedure SDL_DestroyCondition(cond: SDL_Condition); cdecl;
  external LIB_SDL3 name _PU + 'SDL_DestroyCondition';

(**
 * Restart one of the threads that are waiting on the condition variable.
 *
 * \param cond the condition variable to signal.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_BroadcastCondition
 * \sa SDL_WaitCondition
 * \sa SDL_WaitConditionTimeout
 *)
procedure SDL_SignalCondition(cond: SDL_Condition); cdecl;
  external LIB_SDL3 name _PU + 'SDL_SignalCondition';

(**
 * Restart all threads that are waiting on the condition variable.
 *
 * \param cond the condition variable to signal.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SignalCondition
 * \sa SDL_WaitCondition
 * \sa SDL_WaitConditionTimeout
 *)
procedure SDL_BroadcastCondition(cond: SDL_Condition); cdecl;
  external LIB_SDL3 name _PU + 'SDL_BroadcastCondition';

(**
 * Wait until a condition variable is signaled.
 *
 * This function unlocks the specified `mutex` and waits for another thread to
 * call SDL_SignalCondition() or SDL_BroadcastCondition() on the condition
 * variable `cond`. Once the condition variable is signaled, the mutex is
 * re-locked and the function returns.
 *
 * The mutex must be locked before calling this function. Locking the mutex
 * recursively (more than once) is not supported and leads to undefined
 * behavior.
 *
 * This function is the equivalent of calling SDL_WaitConditionTimeout() with
 * a time length of -1.
 *
 * \param cond the condition variable to wait on.
 * \param mutex the mutex used to coordinate thread access.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_BroadcastCondition
 * \sa SDL_SignalCondition
 * \sa SDL_WaitConditionTimeout
 *)
procedure SDL_WaitCondition(cond: SDL_Condition; mutex: SDL_Mutex); cdecl;
  external LIB_SDL3 name _PU + 'SDL_WaitCondition';

(**
 * Wait until a condition variable is signaled or a certain time has passed.
 *
 * This function unlocks the specified `mutex` and waits for another thread to
 * call SDL_SignalCondition() or SDL_BroadcastCondition() on the condition
 * variable `cond`, or for the specified time to elapse. Once the condition
 * variable is signaled or the time elapsed, the mutex is re-locked and the
 * function returns.
 *
 * The mutex must be locked before calling this function. Locking the mutex
 * recursively (more than once) is not supported and leads to undefined
 * behavior.
 *
 * \param cond the condition variable to wait on.
 * \param mutex the mutex used to coordinate thread access.
 * \param timeoutMS the maximum time to wait, in milliseconds, or -1 to wait
 *                  indefinitely.
 * \returns true if the condition variable is signaled, false if the condition
 *          is not signaled in the allotted time.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_BroadcastCondition
 * \sa SDL_SignalCondition
 * \sa SDL_WaitCondition
 *)
function SDL_WaitConditionTimeout(cond: SDL_Condition; mutex: SDL_Mutex; timeoutMS: Sint32): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_WaitConditionTimeout';

(**
 * The current status of an SDL_InitState structure.
 *
 * \since This enum is available since SDL 3.2.0.
 *)
type
  SDL_InitStatus = Integer;

const
  SDL_INIT_STATUS_UNINITIALIZED = 0;
  SDL_INIT_STATUS_INITIALIZING = 1;
  SDL_INIT_STATUS_INITIALIZED = 2;
  SDL_INIT_STATUS_UNINITIALIZING = 3;

type
  (**
   * A structure used for thread-safe initialization and shutdown.
   *
   * Here is an example of using this:
   *
   * ```c
   *    static SDL_AtomicInitState init;
   *
   *    bool InitSystem(void)
   *    {
   *        if (!SDL_ShouldInit(&init)) {
   *            // The system is initialized
   *            return true;
   *        }
   *
   *        // At this point, you should not leave this function without calling SDL_SetInitialized()
   *
   *        bool initialized = DoInitTasks();
   *        SDL_SetInitialized(&init, initialized);
   *        return initialized;
   *    }
   *
   *    bool UseSubsystem(void)
   *    {
   *        if (SDL_ShouldInit(&init)) {
   *            // Error, the subsystem isn't initialized
   *            SDL_SetInitialized(&init, false);
   *            return false;
   *        }
   *
   *        // Do work using the initialized subsystem
   *
   *        return true;
   *    }
   *
   *    void QuitSystem(void)
   *    {
   *        if (!SDL_ShouldQuit(&init)) {
   *            // The system is not initialized
   *            return;
   *        }
   *
   *        // At this point, you should not leave this function without calling SDL_SetInitialized()
   *
   *        DoQuitTasks();
   *        SDL_SetInitialized(&init, false);
   *    }
   * ```
   *
   * Note that this doesn't protect any resources created during initialization,
   * or guarantee that nobody is using those resources during cleanup. You
   * should use other mechanisms to protect those, if that's a concern for your
   * code.
   *
   * \since This struct is available since SDL 3.2.0.
   *)
  SDL_InitState = record
    status: SDL_AtomicInt;
    thread: SDL_ThreadID;
    reserved: Pointer;
  end;
  PSDL_InitState = ^SDL_InitState;

(**
 * Return whether initialization should be done.
 *
 * This function checks the passed in state and if initialization should be
 * done, sets the status to `SDL_INIT_STATUS_INITIALIZING` and returns true.
 * If another thread is already modifying this state, it will wait until
 * that's done before returning.
 *
 * If this function returns true, the calling code must call
 * SDL_SetInitialized() to complete the initialization.
 *
 * \param state the initialization state to check.
 * \returns true if initialization needs to be done, false otherwise.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetInitialized
 * \sa SDL_ShouldQuit
 *)
function SDL_ShouldInit(state: PSDL_InitState): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_ShouldInit';

(**
 * Return whether cleanup should be done.
 *
 * This function checks the passed in state and if cleanup should be done,
 * sets the status to `SDL_INIT_STATUS_UNINITIALIZING` and returns true.
 *
 * If this function returns true, the calling code must call
 * SDL_SetInitialized() to complete the cleanup.
 *
 * \param state the initialization state to check.
 * \returns true if cleanup needs to be done, false otherwise.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetInitialized
 * \sa SDL_ShouldInit
 *)
function SDL_ShouldQuit(state: PSDL_InitState): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_ShouldQuit';

(**
 * Finish an initialization state transition.
 *
 * This function sets the status of the passed in state to
 * `SDL_INIT_STATUS_INITIALIZED` or `SDL_INIT_STATUS_UNINITIALIZED` and allows
 * any threads waiting for the status to proceed.
 *
 * \param state the initialization state to check.
 * \param initialized the new initialization state.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_ShouldInit
 * \sa SDL_ShouldQuit
 *)
procedure SDL_SetInitialized(state: PSDL_InitState; initialized: Boolean); cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetInitialized';
{$ENDREGION 'SDL_mutex.h'}

{$REGION 'SDL_platform.h'}
(**
 * # CategoryPlatform
 *
 * SDL provides a means to identify the app's platform, both at compile time
 * and runtime.
 *)

(**
 * Get the name of the platform.
 *
 * Here are the names returned for some (but not all) supported platforms:
 *
 * - "Windows"
 * - "macOS"
 * - "Linux"
 * - "iOS"
 * - "Android"
 *
 * \returns the name of the platform. If the correct platform name is not
 *          available, returns a string beginning with the text "Unknown".
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetPlatform(): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetPlatform';
{$ENDREGION 'SDL_platform.h'}

{$REGION 'SDL_process.h'}
(**
 * # CategoryProcess
 *
 * Process control support.
 *
 * These functions provide a cross-platform way to spawn and manage OS-level
 * processes.
 *
 * You can create a new subprocess with SDL_CreateProcess() and optionally
 * read and write to it using SDL_ReadProcess() or SDL_GetProcessInput() and
 * SDL_GetProcessOutput(). If more advanced functionality like chaining input
 * between processes is necessary, you can use
 * SDL_CreateProcessWithProperties().
 *
 * You can get the status of a created process with SDL_WaitProcess(), or
 * terminate the process with SDL_KillProcess().
 *
 * Don't forget to call SDL_DestroyProcess() to clean up, whether the process
 * process was killed, terminated on its own, or is still running!
 *)

type
  (**
   * An opaque handle representing a system process.
   *
   * \since This datatype is available since SDL 3.2.0.
   *
   * \sa SDL_CreateProcess
   *)
  SDL_Process = THandle;

(**
 * Create a new process.
 *
 * The path to the executable is supplied in args[0]. args[1..N] are
 * additional arguments passed on the command line of the new process, and the
 * argument list should be terminated with a NULL, e.g.:
 *
 * ```c
 * const char *args[] = { "myprogram", "argument", NULL };
 * ```
 *
 * Setting pipe_stdio to true is equivalent to setting
 * `SDL_PROP_PROCESS_CREATE_STDIN_NUMBER` and
 * `SDL_PROP_PROCESS_CREATE_STDOUT_NUMBER` to `SDL_PROCESS_STDIO_APP`, and
 * will allow the use of SDL_ReadProcess() or SDL_GetProcessInput() and
 * SDL_GetProcessOutput().
 *
 * See SDL_CreateProcessWithProperties() for more details.
 *
 * \param args the path and arguments for the new process.
 * \param pipe_stdio true to create pipes to the process's standard input and
 *                   from the process's standard output, false for the process
 *                   to have no input and inherit the application's standard
 *                   output.
 * \returns the newly created and running process, or NULL if the process
 *          couldn't be created.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CreateProcessWithProperties
 * \sa SDL_GetProcessProperties
 * \sa SDL_ReadProcess
 * \sa SDL_GetProcessInput
 * \sa SDL_GetProcessOutput
 * \sa SDL_KillProcess
 * \sa SDL_WaitProcess
 * \sa SDL_DestroyProcess
 *)
function SDL_CreateProcess(const args: PPUTF8Char; pipe_stdio: Boolean): SDL_Process; cdecl;
  external LIB_SDL3 name _PU + 'SDL_CreateProcess';

(**
 * Description of where standard I/O should be directed when creating a
 * process.
 *
 * If a standard I/O stream is set to SDL_PROCESS_STDIO_INHERITED, it will go
 * to the same place as the application's I/O stream. This is the default for
 * standard output and standard error.
 *
 * If a standard I/O stream is set to SDL_PROCESS_STDIO_NULL, it is connected
 * to `NUL:` on Windows and `/dev/null` on POSIX systems. This is the default
 * for standard input.
 *
 * If a standard I/O stream is set to SDL_PROCESS_STDIO_APP, it is connected
 * to a new SDL_IOStream that is available to the application. Standard input
 * will be available as `SDL_PROP_PROCESS_STDIN_POINTER` and allows
 * SDL_GetProcessInput(), standard output will be available as
 * `SDL_PROP_PROCESS_STDOUT_POINTER` and allows SDL_ReadProcess() and
 * SDL_GetProcessOutput(), and standard error will be available as
 * `SDL_PROP_PROCESS_STDERR_POINTER` in the properties for the created
 * process.
 *
 * If a standard I/O stream is set to SDL_PROCESS_STDIO_REDIRECT, it is
 * connected to an existing SDL_IOStream provided by the application. Standard
 * input is provided using `SDL_PROP_PROCESS_CREATE_STDIN_POINTER`, standard
 * output is provided using `SDL_PROP_PROCESS_CREATE_STDOUT_POINTER`, and
 * standard error is provided using `SDL_PROP_PROCESS_CREATE_STDERR_POINTER`
 * in the creation properties. These existing streams should be closed by the
 * application once the new process is created.
 *
 * In order to use an SDL_IOStream with SDL_PROCESS_STDIO_REDIRECT, it must
 * have `SDL_PROP_IOSTREAM_WINDOWS_HANDLE_POINTER` or
 * `SDL_PROP_IOSTREAM_FILE_DESCRIPTOR_NUMBER` set. This is true for streams
 * representing files and process I/O.
 *
 * \since This enum is available since SDL 3.2.0.
 *
 * \sa SDL_CreateProcessWithProperties
 * \sa SDL_GetProcessProperties
 * \sa SDL_ReadProcess
 * \sa SDL_GetProcessInput
 * \sa SDL_GetProcessOutput
 *)
type
  SDL_ProcessIO = Integer;

const
  (** The I/O stream is inherited from the application. *)
  SDL_PROCESS_STDIO_INHERITED = 0;
  (** The I/O stream is ignored. *)
  SDL_PROCESS_STDIO_NULL = 1;
  (** The I/O stream is connected to a new SDL_IOStream that the application can read or write *)
  SDL_PROCESS_STDIO_APP = 2;
  (** The I/O stream is redirected to an existing SDL_IOStream. *)
  SDL_PROCESS_STDIO_REDIRECT = 3;

(**
 * Create a new process with the specified properties.
 *
 * These are the supported properties:
 *
 * - `SDL_PROP_PROCESS_CREATE_ARGS_POINTER`: an array of strings containing
 *   the program to run, any arguments, and a NULL pointer, e.g. const char
 *   *args[] = { "myprogram", "argument", NULL }. This is a required property.
 * - `SDL_PROP_PROCESS_CREATE_ENVIRONMENT_POINTER`: an SDL_Environment
 *   pointer. If this property is set, it will be the entire environment for
 *   the process, otherwise the current environment is used.
 * - `SDL_PROP_PROCESS_CREATE_STDIN_NUMBER`: an SDL_ProcessIO value describing
 *   where standard input for the process comes from, defaults to
 *   `SDL_PROCESS_STDIO_NULL`.
 * - `SDL_PROP_PROCESS_CREATE_STDIN_POINTER`: an SDL_IOStream pointer used for
 *   standard input when `SDL_PROP_PROCESS_CREATE_STDIN_NUMBER` is set to
 *   `SDL_PROCESS_STDIO_REDIRECT`.
 * - `SDL_PROP_PROCESS_CREATE_STDOUT_NUMBER`: an SDL_ProcessIO value
 *   describing where standard output for the process goes go, defaults to
 *   `SDL_PROCESS_STDIO_INHERITED`.
 * - `SDL_PROP_PROCESS_CREATE_STDOUT_POINTER`: an SDL_IOStream pointer used
 *   for standard output when `SDL_PROP_PROCESS_CREATE_STDOUT_NUMBER` is set
 *   to `SDL_PROCESS_STDIO_REDIRECT`.
 * - `SDL_PROP_PROCESS_CREATE_STDERR_NUMBER`: an SDL_ProcessIO value
 *   describing where standard error for the process goes go, defaults to
 *   `SDL_PROCESS_STDIO_INHERITED`.
 * - `SDL_PROP_PROCESS_CREATE_STDERR_POINTER`: an SDL_IOStream pointer used
 *   for standard error when `SDL_PROP_PROCESS_CREATE_STDERR_NUMBER` is set to
 *   `SDL_PROCESS_STDIO_REDIRECT`.
 * - `SDL_PROP_PROCESS_CREATE_STDERR_TO_STDOUT_BOOLEAN`: true if the error
 *   output of the process should be redirected into the standard output of
 *   the process. This property has no effect if
 *   `SDL_PROP_PROCESS_CREATE_STDERR_NUMBER` is set.
 * - `SDL_PROP_PROCESS_CREATE_BACKGROUND_BOOLEAN`: true if the process should
 *   run in the background. In this case the default input and output is
 *   `SDL_PROCESS_STDIO_NULL` and the exitcode of the process is not
 *   available, and will always be 0.
 *
 * On POSIX platforms, wait() and waitpid(-1, ...) should not be called, and
 * SIGCHLD should not be ignored or handled because those would prevent SDL
 * from properly tracking the lifetime of the underlying process. You should
 * use SDL_WaitProcess() instead.
 *
 * \param props the properties to use.
 * \returns the newly created and running process, or NULL if the process
 *          couldn't be created.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CreateProcess
 * \sa SDL_GetProcessProperties
 * \sa SDL_ReadProcess
 * \sa SDL_GetProcessInput
 * \sa SDL_GetProcessOutput
 * \sa SDL_KillProcess
 * \sa SDL_WaitProcess
 * \sa SDL_DestroyProcess
 *)
function SDL_CreateProcessWithProperties(props: SDL_PropertiesID): SDL_Process; cdecl;
  external LIB_SDL3 name _PU + 'SDL_CreateProcessWithProperties';

const
  SDL_PROP_PROCESS_CREATE_ARGS_POINTER = 'SDL.process.create.args';
  SDL_PROP_PROCESS_CREATE_ENVIRONMENT_POINTER = 'SDL.process.create.environment';
  SDL_PROP_PROCESS_CREATE_STDIN_NUMBER = 'SDL.process.create.stdin_option';
  SDL_PROP_PROCESS_CREATE_STDIN_POINTER = 'SDL.process.create.stdin_source';
  SDL_PROP_PROCESS_CREATE_STDOUT_NUMBER = 'SDL.process.create.stdout_option';
  SDL_PROP_PROCESS_CREATE_STDOUT_POINTER = 'SDL.process.create.stdout_source';
  SDL_PROP_PROCESS_CREATE_STDERR_NUMBER = 'SDL.process.create.stderr_option';
  SDL_PROP_PROCESS_CREATE_STDERR_POINTER = 'SDL.process.create.stderr_source';
  SDL_PROP_PROCESS_CREATE_STDERR_TO_STDOUT_BOOLEAN = 'SDL.process.create.stderr_to_stdout';
  SDL_PROP_PROCESS_CREATE_BACKGROUND_BOOLEAN = 'SDL.process.create.background';

(**
 * Get the properties associated with a process.
 *
 * The following read-only properties are provided by SDL:
 *
 * - `SDL_PROP_PROCESS_PID_NUMBER`: the process ID of the process.
 * - `SDL_PROP_PROCESS_STDIN_POINTER`: an SDL_IOStream that can be used to
 *   write input to the process, if it was created with
 *   `SDL_PROP_PROCESS_CREATE_STDIN_NUMBER` set to `SDL_PROCESS_STDIO_APP`.
 * - `SDL_PROP_PROCESS_STDOUT_POINTER`: a non-blocking SDL_IOStream that can
 *   be used to read output from the process, if it was created with
 *   `SDL_PROP_PROCESS_CREATE_STDOUT_NUMBER` set to `SDL_PROCESS_STDIO_APP`.
 * - `SDL_PROP_PROCESS_STDERR_POINTER`: a non-blocking SDL_IOStream that can
 *   be used to read error output from the process, if it was created with
 *   `SDL_PROP_PROCESS_CREATE_STDERR_NUMBER` set to `SDL_PROCESS_STDIO_APP`.
 * - `SDL_PROP_PROCESS_BACKGROUND_BOOLEAN`: true if the process is running in
 *   the background.
 *
 * \param process the process to query.
 * \returns a valid property ID on success or 0 on failure; call
 *          SDL_GetError() for more information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CreateProcess
 * \sa SDL_CreateProcessWithProperties
 *)
function SDL_GetProcessProperties(process: SDL_Process): SDL_PropertiesID; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetProcessProperties';

const
  SDL_PROP_PROCESS_PID_NUMBER = 'SDL.process.pid';
  SDL_PROP_PROCESS_STDIN_POINTER = 'SDL.process.stdin';
  SDL_PROP_PROCESS_STDOUT_POINTER = 'SDL.process.stdout';
  SDL_PROP_PROCESS_STDERR_POINTER = 'SDL.process.stderr';
  SDL_PROP_PROCESS_BACKGROUND_BOOLEAN = 'SDL.process.background';

(**
 * Read all the output from a process.
 *
 * If a process was created with I/O enabled, you can use this function to
 * read the output. This function blocks until the process is complete,
 * capturing all output, and providing the process exit code.
 *
 * The data is allocated with a zero byte at the end (null terminated) for
 * convenience. This extra byte is not included in the value reported via
 * `datasize`.
 *
 * The data should be freed with SDL_free().
 *
 * \param process The process to read.
 * \param datasize a pointer filled in with the number of bytes read, may be
 *                 NULL.
 * \param exitcode a pointer filled in with the process exit code if the
 *                 process has exited, may be NULL.
 * \returns the data or NULL on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function is not thread safe.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CreateProcess
 * \sa SDL_CreateProcessWithProperties
 * \sa SDL_DestroyProcess
 *)
function SDL_ReadProcess(process: SDL_Process; datasize: PNativeUInt; exitcode: PInteger): Pointer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_ReadProcess';

(**
 * Get the SDL_IOStream associated with process standard input.
 *
 * The process must have been created with SDL_CreateProcess() and pipe_stdio
 * set to true, or with SDL_CreateProcessWithProperties() and
 * `SDL_PROP_PROCESS_CREATE_STDIN_NUMBER` set to `SDL_PROCESS_STDIO_APP`.
 *
 * Writing to this stream can return less data than expected if the process
 * hasn't read its input. It may be blocked waiting for its output to be read,
 * if so you may need to call SDL_GetProcessOutput() and read the output in
 * parallel with writing input.
 *
 * \param process The process to get the input stream for.
 * \returns the input stream or NULL on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CreateProcess
 * \sa SDL_CreateProcessWithProperties
 * \sa SDL_GetProcessOutput
 *)
function SDL_GetProcessInput(process: SDL_Process): SDL_IOStream; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetProcessInput';

(**
 * Get the SDL_IOStream associated with process standard output.
 *
 * The process must have been created with SDL_CreateProcess() and pipe_stdio
 * set to true, or with SDL_CreateProcessWithProperties() and
 * `SDL_PROP_PROCESS_CREATE_STDOUT_NUMBER` set to `SDL_PROCESS_STDIO_APP`.
 *
 * Reading from this stream can return 0 with SDL_GetIOStatus() returning
 * SDL_IO_STATUS_NOT_READY if no output is available yet.
 *
 * \param process The process to get the output stream for.
 * \returns the output stream or NULL on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CreateProcess
 * \sa SDL_CreateProcessWithProperties
 * \sa SDL_GetProcessInput
 *)
function SDL_GetProcessOutput(process: SDL_Process): SDL_IOStream; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetProcessOutput';

(**
 * Stop a process.
 *
 * \param process The process to stop.
 * \param force true to terminate the process immediately, false to try to
 *              stop the process gracefully. In general you should try to stop
 *              the process gracefully first as terminating a process may
 *              leave it with half-written data or in some other unstable
 *              state.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function is not thread safe.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CreateProcess
 * \sa SDL_CreateProcessWithProperties
 * \sa SDL_WaitProcess
 * \sa SDL_DestroyProcess
 *)
function SDL_KillProcess(process: SDL_Process; force: Boolean): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_KillProcess';

(**
 * Wait for a process to finish.
 *
 * This can be called multiple times to get the status of a process.
 *
 * The exit code will be the exit code of the process if it terminates
 * normally, a negative signal if it terminated due to a signal, or -255
 * otherwise. It will not be changed if the process is still running.
 *
 * If you create a process with standard output piped to the application
 * (`pipe_stdio` being true) then you should read all of the process output
 * before calling SDL_WaitProcess(). If you don't do this the process might be
 * blocked indefinitely waiting for output to be read and SDL_WaitProcess()
 * will never return true;
 *
 * \param process The process to wait for.
 * \param block If true, block until the process finishes; otherwise, report
 *              on the process' status.
 * \param exitcode a pointer filled in with the process exit code if the
 *                 process has exited, may be NULL.
 * \returns true if the process exited, false otherwise.
 *
 * \threadsafety This function is not thread safe.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CreateProcess
 * \sa SDL_CreateProcessWithProperties
 * \sa SDL_KillProcess
 * \sa SDL_DestroyProcess
 *)
function SDL_WaitProcess(process: SDL_Process; block: Boolean; exitcode: PInteger): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_WaitProcess';

(**
 * Destroy a previously created process object.
 *
 * Note that this does not stop the process, just destroys the SDL object used
 * to track it. If you want to stop the process you should use
 * SDL_KillProcess().
 *
 * \param process The process object to destroy.
 *
 * \threadsafety This function is not thread safe.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CreateProcess
 * \sa SDL_CreateProcessWithProperties
 * \sa SDL_KillProcess
 *)
procedure SDL_DestroyProcess(process: SDL_Process); cdecl;
  external LIB_SDL3 name _PU + 'SDL_DestroyProcess';
{$ENDREGION 'SDL_process.h'}

{$REGION 'SDL_render.h'}
(**
 * # CategoryRender
 *
 * Header file for SDL 2D rendering functions.
 *
 * This API supports the following features:
 *
 * - single pixel points
 * - single pixel lines
 * - filled rectangles
 * - texture images
 * - 2D polygons
 *
 * The primitives may be drawn in opaque, blended, or additive modes.
 *
 * The texture images may be drawn in opaque, blended, or additive modes. They
 * can have an additional color tint or alpha modulation applied to them, and
 * may also be stretched with linear interpolation.
 *
 * This API is designed to accelerate simple 2D operations. You may want more
 * functionality such as polygons and particle effects and in that case you
 * should use SDL's OpenGL/Direct3D support, the SDL3 GPU API, or one of the
 * many good 3D engines.
 *
 * These functions must be called from the main thread. See this bug for
 * details: https://github.com/libsdl-org/SDL/issues/986
 *)

const
  (**
   * The name of the software renderer.
   *
   * \since This macro is available since SDL 3.2.0.
   *)
  SDL_SOFTWARE_RENDERER = 'software';

type
  (**
   * Vertex structure.
   *
   * \since This struct is available since SDL 3.2.0.
   *)
  SDL_Vertex = record
    (** Vertex position, in SDL_Renderer coordinates  *)
    position: SDL_FPoint;
    (** Vertex color *)
    color: SDL_FColor;
    (** Normalized texture coordinates, if needed *)
    tex_coord: SDL_FPoint;
  end;
  PSDL_Vertex = ^SDL_Vertex;

(**
 * The access pattern allowed for a texture.
 *
 * \since This enum is available since SDL 3.2.0.
 *)
type
  SDL_TextureAccess = Integer;

const
  (** Changes rarely, not lockable *)
  SDL_TEXTUREACCESS_STATIC = 0;
  (** Changes frequently, lockable *)
  SDL_TEXTUREACCESS_STREAMING = 1;
  (** Texture can be used as a render target *)
  SDL_TEXTUREACCESS_TARGET = 2;

(**
 * How the logical size is mapped to the output.
 *
 * \since This enum is available since SDL 3.2.0.
 *)
type
  SDL_RendererLogicalPresentation = Integer;
  PSDL_RendererLogicalPresentation = ^SDL_RendererLogicalPresentation;

const
  (** There is no logical size in effect *)
  SDL_LOGICAL_PRESENTATION_DISABLED = 0;
  (** The rendered content is stretched to the output resolution *)
  SDL_LOGICAL_PRESENTATION_STRETCH = 1;
  (** The rendered content is fit to the largest dimension and the other dimension is letterboxed with black bars *)
  SDL_LOGICAL_PRESENTATION_LETTERBOX = 2;
  (** The rendered content is fit to the smallest dimension and the other dimension extends beyond the output bounds *)
  SDL_LOGICAL_PRESENTATION_OVERSCAN = 3;
  (** The rendered content is scaled up by integer multiples to fit the output resolution *)
  SDL_LOGICAL_PRESENTATION_INTEGER_SCALE = 4;

type
  (**
   * A structure representing rendering state
   *
   * \since This struct is available since SDL 3.2.0.
   *)
  SDL_Renderer = THandle;
  PSDL_Renderer = ^SDL_Renderer;

type
  (**
   * An efficient driver-specific representation of pixel data
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_CreateTexture
   * \sa SDL_CreateTextureFromSurface
   * \sa SDL_CreateTextureWithProperties
   * \sa SDL_DestroyTexture
   *)
  SDL_Texture = record
    (** The format of the texture, read-only *)
    format: SDL_PixelFormat;
    (** The width of the texture, read-only. *)
    w: Integer;
    (** The height of the texture, read-only. *)
    h: Integer;
    (** Application reference count, used when freeing texture *)
    refcount: Integer;
  end;
  PSDL_Texture = ^SDL_Texture;

(**
 * Get the number of 2D rendering drivers available for the current display.
 *
 * A render driver is a set of code that handles rendering and texture
 * management on a particular display. Normally there is only one, but some
 * drivers may have several available with different capabilities.
 *
 * There may be none if SDL was compiled without render support.
 *
 * \returns the number of built in render drivers.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CreateRenderer
 * \sa SDL_GetRenderDriver
 *)
function SDL_GetNumRenderDrivers(): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetNumRenderDrivers';

(**
 * Use this function to get the name of a built in 2D rendering driver.
 *
 * The list of rendering drivers is given in the order that they are normally
 * initialized by default; the drivers that seem more reasonable to choose
 * first (as far as the SDL developers believe) are earlier in the list.
 *
 * The names of drivers are all simple, low-ASCII identifiers, like "opengl",
 * "direct3d12" or "metal". These never have Unicode characters, and are not
 * meant to be proper names.
 *
 * \param index the index of the rendering driver; the value ranges from 0 to
 *              SDL_GetNumRenderDrivers() - 1.
 * \returns the name of the rendering driver at the requested index, or NULL
 *          if an invalid index was specified.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetNumRenderDrivers
 *)
function SDL_GetRenderDriver(index: Integer): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetRenderDriver';

(**
 * Create a window and default renderer.
 *
 * \param title the title of the window, in UTF-8 encoding.
 * \param width the width of the window.
 * \param height the height of the window.
 * \param window_flags the flags used to create the window (see
 *                     SDL_CreateWindow()).
 * \param window a pointer filled with the window, or NULL on error.
 * \param renderer a pointer filled with the renderer, or NULL on error.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CreateRenderer
 * \sa SDL_CreateWindow
 *)
function SDL_CreateWindowAndRenderer(const title: PUTF8Char; width: Integer; height: Integer; window_flags: SDL_WindowFlags; window: PSDL_Window; renderer: PSDL_Renderer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_CreateWindowAndRenderer';

(**
 * Create a 2D rendering context for a window.
 *
 * If you want a specific renderer, you can specify its name here. A list of
 * available renderers can be obtained by calling SDL_GetRenderDriver()
 * multiple times, with indices from 0 to SDL_GetNumRenderDrivers()-1. If you
 * don't need a specific renderer, specify NULL and SDL will attempt to choose
 * the best option for you, based on what is available on the user's system.
 *
 * If `name` is a comma-separated list, SDL will try each name, in the order
 * listed, until one succeeds or all of them fail.
 *
 * By default the rendering size matches the window size in pixels, but you
 * can call SDL_SetRenderLogicalPresentation() to change the content size and
 * scaling options.
 *
 * \param window the window where rendering is displayed.
 * \param name the name of the rendering driver to initialize, or NULL to let
 *             SDL choose one.
 * \returns a valid rendering context or NULL if there was an error; call
 *          SDL_GetError() for more information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CreateRendererWithProperties
 * \sa SDL_CreateSoftwareRenderer
 * \sa SDL_DestroyRenderer
 * \sa SDL_GetNumRenderDrivers
 * \sa SDL_GetRenderDriver
 * \sa SDL_GetRendererName
 *)
function SDL_CreateRenderer(window: SDL_Window; const name: PUTF8Char): SDL_Renderer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_CreateRenderer';

(**
 * Create a 2D rendering context for a window, with the specified properties.
 *
 * These are the supported properties:
 *
 * - `SDL_PROP_RENDERER_CREATE_NAME_STRING`: the name of the rendering driver
 *   to use, if a specific one is desired
 * - `SDL_PROP_RENDERER_CREATE_WINDOW_POINTER`: the window where rendering is
 *   displayed, required if this isn't a software renderer using a surface
 * - `SDL_PROP_RENDERER_CREATE_SURFACE_POINTER`: the surface where rendering
 *   is displayed, if you want a software renderer without a window
 * - `SDL_PROP_RENDERER_CREATE_OUTPUT_COLORSPACE_NUMBER`: an SDL_Colorspace
 *   value describing the colorspace for output to the display, defaults to
 *   SDL_COLORSPACE_SRGB. The direct3d11, direct3d12, and metal renderers
 *   support SDL_COLORSPACE_SRGB_LINEAR, which is a linear color space and
 *   supports HDR output. If you select SDL_COLORSPACE_SRGB_LINEAR, drawing
 *   still uses the sRGB colorspace, but values can go beyond 1.0 and float
 *   (linear) format textures can be used for HDR content.
 * - `SDL_PROP_RENDERER_CREATE_PRESENT_VSYNC_NUMBER`: non-zero if you want
 *   present synchronized with the refresh rate. This property can take any
 *   value that is supported by SDL_SetRenderVSync() for the renderer.
 *
 * With the vulkan renderer:
 *
 * - `SDL_PROP_RENDERER_CREATE_VULKAN_INSTANCE_POINTER`: the VkInstance to use
 *   with the renderer, optional.
 * - `SDL_PROP_RENDERER_CREATE_VULKAN_SURFACE_NUMBER`: the VkSurfaceKHR to use
 *   with the renderer, optional.
 * - `SDL_PROP_RENDERER_CREATE_VULKAN_PHYSICAL_DEVICE_POINTER`: the
 *   VkPhysicalDevice to use with the renderer, optional.
 * - `SDL_PROP_RENDERER_CREATE_VULKAN_DEVICE_POINTER`: the VkDevice to use
 *   with the renderer, optional.
 * - `SDL_PROP_RENDERER_CREATE_VULKAN_GRAPHICS_QUEUE_FAMILY_INDEX_NUMBER`: the
 *   queue family index used for rendering.
 * - `SDL_PROP_RENDERER_CREATE_VULKAN_PRESENT_QUEUE_FAMILY_INDEX_NUMBER`: the
 *   queue family index used for presentation.
 *
 * \param props the properties to use.
 * \returns a valid rendering context or NULL if there was an error; call
 *          SDL_GetError() for more information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CreateProperties
 * \sa SDL_CreateRenderer
 * \sa SDL_CreateSoftwareRenderer
 * \sa SDL_DestroyRenderer
 * \sa SDL_GetRendererName
 *)
function SDL_CreateRendererWithProperties(props: SDL_PropertiesID): SDL_Renderer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_CreateRendererWithProperties';

const
  SDL_PROP_RENDERER_CREATE_NAME_STRING = 'SDL.renderer.create.name';
  SDL_PROP_RENDERER_CREATE_WINDOW_POINTER = 'SDL.renderer.create.window';
  SDL_PROP_RENDERER_CREATE_SURFACE_POINTER = 'SDL.renderer.create.surface';
  SDL_PROP_RENDERER_CREATE_OUTPUT_COLORSPACE_NUMBER = 'SDL.renderer.create.output_colorspace';
  SDL_PROP_RENDERER_CREATE_PRESENT_VSYNC_NUMBER = 'SDL.renderer.create.present_vsync';
  SDL_PROP_RENDERER_CREATE_VULKAN_INSTANCE_POINTER = 'SDL.renderer.create.vulkan.instance';
  SDL_PROP_RENDERER_CREATE_VULKAN_SURFACE_NUMBER = 'SDL.renderer.create.vulkan.surface';
  SDL_PROP_RENDERER_CREATE_VULKAN_PHYSICAL_DEVICE_POINTER = 'SDL.renderer.create.vulkan.physical_device';
  SDL_PROP_RENDERER_CREATE_VULKAN_DEVICE_POINTER = 'SDL.renderer.create.vulkan.device';
  SDL_PROP_RENDERER_CREATE_VULKAN_GRAPHICS_QUEUE_FAMILY_INDEX_NUMBER = 'SDL.renderer.create.vulkan.graphics_queue_family_index';
  SDL_PROP_RENDERER_CREATE_VULKAN_PRESENT_QUEUE_FAMILY_INDEX_NUMBER = 'SDL.renderer.create.vulkan.present_queue_family_index';

(**
 * Create a 2D software rendering context for a surface.
 *
 * Two other API which can be used to create SDL_Renderer:
 * SDL_CreateRenderer() and SDL_CreateWindowAndRenderer(). These can _also_
 * create a software renderer, but they are intended to be used with an
 * SDL_Window as the final destination and not an SDL_Surface.
 *
 * \param surface the SDL_Surface structure representing the surface where
 *                rendering is done.
 * \returns a valid rendering context or NULL if there was an error; call
 *          SDL_GetError() for more information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_DestroyRenderer
 *)
function SDL_CreateSoftwareRenderer(surface: PSDL_Surface): SDL_Renderer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_CreateSoftwareRenderer';

(**
 * Get the renderer associated with a window.
 *
 * \param window the window to query.
 * \returns the rendering context on success or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetRenderer(window: SDL_Window): SDL_Renderer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetRenderer';

(**
 * Get the window associated with a renderer.
 *
 * \param renderer the renderer to query.
 * \returns the window on success or NULL on failure; call SDL_GetError() for
 *          more information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetRenderWindow(renderer: SDL_Renderer): SDL_Window; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetRenderWindow';

(**
 * Get the name of a renderer.
 *
 * \param renderer the rendering context.
 * \returns the name of the selected renderer, or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CreateRenderer
 * \sa SDL_CreateRendererWithProperties
 *)
function SDL_GetRendererName(renderer: SDL_Renderer): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetRendererName';

(**
 * Get the properties associated with a renderer.
 *
 * The following read-only properties are provided by SDL:
 *
 * - `SDL_PROP_RENDERER_NAME_STRING`: the name of the rendering driver
 * - `SDL_PROP_RENDERER_WINDOW_POINTER`: the window where rendering is
 *   displayed, if any
 * - `SDL_PROP_RENDERER_SURFACE_POINTER`: the surface where rendering is
 *   displayed, if this is a software renderer without a window
 * - `SDL_PROP_RENDERER_VSYNC_NUMBER`: the current vsync setting
 * - `SDL_PROP_RENDERER_MAX_TEXTURE_SIZE_NUMBER`: the maximum texture width
 *   and height
 * - `SDL_PROP_RENDERER_TEXTURE_FORMATS_POINTER`: a (const SDL_PixelFormat * )
 *   array of pixel formats, terminated with SDL_PIXELFORMAT_UNKNOWN,
 *   representing the available texture formats for this renderer.
 * - `SDL_PROP_RENDERER_OUTPUT_COLORSPACE_NUMBER`: an SDL_Colorspace value
 *   describing the colorspace for output to the display, defaults to
 *   SDL_COLORSPACE_SRGB.
 * - `SDL_PROP_RENDERER_HDR_ENABLED_BOOLEAN`: true if the output colorspace is
 *   SDL_COLORSPACE_SRGB_LINEAR and the renderer is showing on a display with
 *   HDR enabled. This property can change dynamically when
 *   SDL_EVENT_WINDOW_HDR_STATE_CHANGED is sent.
 * - `SDL_PROP_RENDERER_SDR_WHITE_POINT_FLOAT`: the value of SDR white in the
 *   SDL_COLORSPACE_SRGB_LINEAR colorspace. When HDR is enabled, this value is
 *   automatically multiplied into the color scale. This property can change
 *   dynamically when SDL_EVENT_WINDOW_HDR_STATE_CHANGED is sent.
 * - `SDL_PROP_RENDERER_HDR_HEADROOM_FLOAT`: the additional high dynamic range
 *   that can be displayed, in terms of the SDR white point. When HDR is not
 *   enabled, this will be 1.0. This property can change dynamically when
 *   SDL_EVENT_WINDOW_HDR_STATE_CHANGED is sent.
 *
 * With the direct3d renderer:
 *
 * - `SDL_PROP_RENDERER_D3D9_DEVICE_POINTER`: the IDirect3DDevice9 associated
 *   with the renderer
 *
 * With the direct3d11 renderer:
 *
 * - `SDL_PROP_RENDERER_D3D11_DEVICE_POINTER`: the ID3D11Device associated
 *   with the renderer
 * - `SDL_PROP_RENDERER_D3D11_SWAPCHAIN_POINTER`: the IDXGISwapChain1
 *   associated with the renderer. This may change when the window is resized.
 *
 * With the direct3d12 renderer:
 *
 * - `SDL_PROP_RENDERER_D3D12_DEVICE_POINTER`: the ID3D12Device associated
 *   with the renderer
 * - `SDL_PROP_RENDERER_D3D12_SWAPCHAIN_POINTER`: the IDXGISwapChain4
 *   associated with the renderer.
 * - `SDL_PROP_RENDERER_D3D12_COMMAND_QUEUE_POINTER`: the ID3D12CommandQueue
 *   associated with the renderer
 *
 * With the vulkan renderer:
 *
 * - `SDL_PROP_RENDERER_VULKAN_INSTANCE_POINTER`: the VkInstance associated
 *   with the renderer
 * - `SDL_PROP_RENDERER_VULKAN_SURFACE_NUMBER`: the VkSurfaceKHR associated
 *   with the renderer
 * - `SDL_PROP_RENDERER_VULKAN_PHYSICAL_DEVICE_POINTER`: the VkPhysicalDevice
 *   associated with the renderer
 * - `SDL_PROP_RENDERER_VULKAN_DEVICE_POINTER`: the VkDevice associated with
 *   the renderer
 * - `SDL_PROP_RENDERER_VULKAN_GRAPHICS_QUEUE_FAMILY_INDEX_NUMBER`: the queue
 *   family index used for rendering
 * - `SDL_PROP_RENDERER_VULKAN_PRESENT_QUEUE_FAMILY_INDEX_NUMBER`: the queue
 *   family index used for presentation
 * - `SDL_PROP_RENDERER_VULKAN_SWAPCHAIN_IMAGE_COUNT_NUMBER`: the number of
 *   swapchain images, or potential frames in flight, used by the Vulkan
 *   renderer
 *
 * With the gpu renderer:
 *
 * - `SDL_PROP_RENDERER_GPU_DEVICE_POINTER`: the SDL_GPUDevice associated with
 *   the renderer
 *
 * \param renderer the rendering context.
 * \returns a valid property ID on success or 0 on failure; call
 *          SDL_GetError() for more information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetRendererProperties(renderer: SDL_Renderer): SDL_PropertiesID; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetRendererProperties';

const
  SDL_PROP_RENDERER_NAME_STRING = 'SDL.renderer.name';
  SDL_PROP_RENDERER_WINDOW_POINTER = 'SDL.renderer.window';
  SDL_PROP_RENDERER_SURFACE_POINTER = 'SDL.renderer.surface';
  SDL_PROP_RENDERER_VSYNC_NUMBER = 'SDL.renderer.vsync';
  SDL_PROP_RENDERER_MAX_TEXTURE_SIZE_NUMBER = 'SDL.renderer.max_texture_size';
  SDL_PROP_RENDERER_TEXTURE_FORMATS_POINTER = 'SDL.renderer.texture_formats';
  SDL_PROP_RENDERER_OUTPUT_COLORSPACE_NUMBER = 'SDL.renderer.output_colorspace';
  SDL_PROP_RENDERER_HDR_ENABLED_BOOLEAN = 'SDL.renderer.HDR_enabled';
  SDL_PROP_RENDERER_SDR_WHITE_POINT_FLOAT = 'SDL.renderer.SDR_white_point';
  SDL_PROP_RENDERER_HDR_HEADROOM_FLOAT = 'SDL.renderer.HDR_headroom';
  SDL_PROP_RENDERER_D3D9_DEVICE_POINTER = 'SDL.renderer.d3d9.device';
  SDL_PROP_RENDERER_D3D11_DEVICE_POINTER = 'SDL.renderer.d3d11.device';
  SDL_PROP_RENDERER_D3D11_SWAPCHAIN_POINTER = 'SDL.renderer.d3d11.swap_chain';
  SDL_PROP_RENDERER_D3D12_DEVICE_POINTER = 'SDL.renderer.d3d12.device';
  SDL_PROP_RENDERER_D3D12_SWAPCHAIN_POINTER = 'SDL.renderer.d3d12.swap_chain';
  SDL_PROP_RENDERER_D3D12_COMMAND_QUEUE_POINTER = 'SDL.renderer.d3d12.command_queue';
  SDL_PROP_RENDERER_VULKAN_INSTANCE_POINTER = 'SDL.renderer.vulkan.instance';
  SDL_PROP_RENDERER_VULKAN_SURFACE_NUMBER = 'SDL.renderer.vulkan.surface';
  SDL_PROP_RENDERER_VULKAN_PHYSICAL_DEVICE_POINTER = 'SDL.renderer.vulkan.physical_device';
  SDL_PROP_RENDERER_VULKAN_DEVICE_POINTER = 'SDL.renderer.vulkan.device';
  SDL_PROP_RENDERER_VULKAN_GRAPHICS_QUEUE_FAMILY_INDEX_NUMBER = 'SDL.renderer.vulkan.graphics_queue_family_index';
  SDL_PROP_RENDERER_VULKAN_PRESENT_QUEUE_FAMILY_INDEX_NUMBER = 'SDL.renderer.vulkan.present_queue_family_index';
  SDL_PROP_RENDERER_VULKAN_SWAPCHAIN_IMAGE_COUNT_NUMBER = 'SDL.renderer.vulkan.swapchain_image_count';
  SDL_PROP_RENDERER_GPU_DEVICE_POINTER = 'SDL.renderer.gpu.device';

(**
 * Get the output size in pixels of a rendering context.
 *
 * This returns the true output size in pixels, ignoring any render targets or
 * logical size and presentation.
 *
 * \param renderer the rendering context.
 * \param w a pointer filled in with the width in pixels.
 * \param h a pointer filled in with the height in pixels.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetCurrentRenderOutputSize
 *)
function SDL_GetRenderOutputSize(renderer: SDL_Renderer; w: PInteger; h: PInteger): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetRenderOutputSize';

(**
 * Get the current output size in pixels of a rendering context.
 *
 * If a rendering target is active, this will return the size of the rendering
 * target in pixels, otherwise if a logical size is set, it will return the
 * logical size, otherwise it will return the value of
 * SDL_GetRenderOutputSize().
 *
 * \param renderer the rendering context.
 * \param w a pointer filled in with the current width.
 * \param h a pointer filled in with the current height.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetRenderOutputSize
 *)
function SDL_GetCurrentRenderOutputSize(renderer: SDL_Renderer; w: PInteger; h: PInteger): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetCurrentRenderOutputSize';

(**
 * Create a texture for a rendering context.
 *
 * The contents of a texture when first created are not defined.
 *
 * \param renderer the rendering context.
 * \param format one of the enumerated values in SDL_PixelFormat.
 * \param access one of the enumerated values in SDL_TextureAccess.
 * \param w the width of the texture in pixels.
 * \param h the height of the texture in pixels.
 * \returns the created texture or NULL on failure; call SDL_GetError() for
 *          more information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CreateTextureFromSurface
 * \sa SDL_CreateTextureWithProperties
 * \sa SDL_DestroyTexture
 * \sa SDL_GetTextureSize
 * \sa SDL_UpdateTexture
 *)
function SDL_CreateTexture(renderer: SDL_Renderer; format: SDL_PixelFormat; access: SDL_TextureAccess; w: Integer; h: Integer): PSDL_Texture; cdecl;
  external LIB_SDL3 name _PU + 'SDL_CreateTexture';

(**
 * Create a texture from an existing surface.
 *
 * The surface is not modified or freed by this function.
 *
 * The SDL_TextureAccess hint for the created texture is
 * `SDL_TEXTUREACCESS_STATIC`.
 *
 * The pixel format of the created texture may be different from the pixel
 * format of the surface, and can be queried using the
 * SDL_PROP_TEXTURE_FORMAT_NUMBER property.
 *
 * \param renderer the rendering context.
 * \param surface the SDL_Surface structure containing pixel data used to fill
 *                the texture.
 * \returns the created texture or NULL on failure; call SDL_GetError() for
 *          more information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CreateTexture
 * \sa SDL_CreateTextureWithProperties
 * \sa SDL_DestroyTexture
 *)
function SDL_CreateTextureFromSurface(renderer: SDL_Renderer; surface: PSDL_Surface): PSDL_Texture; cdecl;
  external LIB_SDL3 name _PU + 'SDL_CreateTextureFromSurface';

(**
 * Create a texture for a rendering context with the specified properties.
 *
 * These are the supported properties:
 *
 * - `SDL_PROP_TEXTURE_CREATE_COLORSPACE_NUMBER`: an SDL_Colorspace value
 *   describing the texture colorspace, defaults to SDL_COLORSPACE_SRGB_LINEAR
 *   for floating point textures, SDL_COLORSPACE_HDR10 for 10-bit textures,
 *   SDL_COLORSPACE_SRGB for other RGB textures and SDL_COLORSPACE_JPEG for
 *   YUV textures.
 * - `SDL_PROP_TEXTURE_CREATE_FORMAT_NUMBER`: one of the enumerated values in
 *   SDL_PixelFormat, defaults to the best RGBA format for the renderer
 * - `SDL_PROP_TEXTURE_CREATE_ACCESS_NUMBER`: one of the enumerated values in
 *   SDL_TextureAccess, defaults to SDL_TEXTUREACCESS_STATIC
 * - `SDL_PROP_TEXTURE_CREATE_WIDTH_NUMBER`: the width of the texture in
 *   pixels, required
 * - `SDL_PROP_TEXTURE_CREATE_HEIGHT_NUMBER`: the height of the texture in
 *   pixels, required
 * - `SDL_PROP_TEXTURE_CREATE_SDR_WHITE_POINT_FLOAT`: for HDR10 and floating
 *   point textures, this defines the value of 100% diffuse white, with higher
 *   values being displayed in the High Dynamic Range headroom. This defaults
 *   to 100 for HDR10 textures and 1.0 for floating point textures.
 * - `SDL_PROP_TEXTURE_CREATE_HDR_HEADROOM_FLOAT`: for HDR10 and floating
 *   point textures, this defines the maximum dynamic range used by the
 *   content, in terms of the SDR white point. This would be equivalent to
 *   maxCLL / SDL_PROP_TEXTURE_CREATE_SDR_WHITE_POINT_FLOAT for HDR10 content.
 *   If this is defined, any values outside the range supported by the display
 *   will be scaled into the available HDR headroom, otherwise they are
 *   clipped.
 *
 * With the direct3d11 renderer:
 *
 * - `SDL_PROP_TEXTURE_CREATE_D3D11_TEXTURE_POINTER`: the ID3D11Texture2D
 *   associated with the texture, if you want to wrap an existing texture.
 * - `SDL_PROP_TEXTURE_CREATE_D3D11_TEXTURE_U_POINTER`: the ID3D11Texture2D
 *   associated with the U plane of a YUV texture, if you want to wrap an
 *   existing texture.
 * - `SDL_PROP_TEXTURE_CREATE_D3D11_TEXTURE_V_POINTER`: the ID3D11Texture2D
 *   associated with the V plane of a YUV texture, if you want to wrap an
 *   existing texture.
 *
 * With the direct3d12 renderer:
 *
 * - `SDL_PROP_TEXTURE_CREATE_D3D12_TEXTURE_POINTER`: the ID3D12Resource
 *   associated with the texture, if you want to wrap an existing texture.
 * - `SDL_PROP_TEXTURE_CREATE_D3D12_TEXTURE_U_POINTER`: the ID3D12Resource
 *   associated with the U plane of a YUV texture, if you want to wrap an
 *   existing texture.
 * - `SDL_PROP_TEXTURE_CREATE_D3D12_TEXTURE_V_POINTER`: the ID3D12Resource
 *   associated with the V plane of a YUV texture, if you want to wrap an
 *   existing texture.
 *
 * With the metal renderer:
 *
 * - `SDL_PROP_TEXTURE_CREATE_METAL_PIXELBUFFER_POINTER`: the CVPixelBufferRef
 *   associated with the texture, if you want to create a texture from an
 *   existing pixel buffer.
 *
 * With the opengl renderer:
 *
 * - `SDL_PROP_TEXTURE_CREATE_OPENGL_TEXTURE_NUMBER`: the GLuint texture
 *   associated with the texture, if you want to wrap an existing texture.
 * - `SDL_PROP_TEXTURE_CREATE_OPENGL_TEXTURE_UV_NUMBER`: the GLuint texture
 *   associated with the UV plane of an NV12 texture, if you want to wrap an
 *   existing texture.
 * - `SDL_PROP_TEXTURE_CREATE_OPENGL_TEXTURE_U_NUMBER`: the GLuint texture
 *   associated with the U plane of a YUV texture, if you want to wrap an
 *   existing texture.
 * - `SDL_PROP_TEXTURE_CREATE_OPENGL_TEXTURE_V_NUMBER`: the GLuint texture
 *   associated with the V plane of a YUV texture, if you want to wrap an
 *   existing texture.
 *
 * With the opengles2 renderer:
 *
 * - `SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_NUMBER`: the GLuint texture
 *   associated with the texture, if you want to wrap an existing texture.
 * - `SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_NUMBER`: the GLuint texture
 *   associated with the texture, if you want to wrap an existing texture.
 * - `SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_UV_NUMBER`: the GLuint texture
 *   associated with the UV plane of an NV12 texture, if you want to wrap an
 *   existing texture.
 * - `SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_U_NUMBER`: the GLuint texture
 *   associated with the U plane of a YUV texture, if you want to wrap an
 *   existing texture.
 * - `SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_V_NUMBER`: the GLuint texture
 *   associated with the V plane of a YUV texture, if you want to wrap an
 *   existing texture.
 *
 * With the vulkan renderer:
 *
 * - `SDL_PROP_TEXTURE_CREATE_VULKAN_TEXTURE_NUMBER`: the VkImage with layout
 *   VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL associated with the texture, if
 *   you want to wrap an existing texture.
 *
 * \param renderer the rendering context.
 * \param props the properties to use.
 * \returns the created texture or NULL on failure; call SDL_GetError() for
 *          more information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CreateProperties
 * \sa SDL_CreateTexture
 * \sa SDL_CreateTextureFromSurface
 * \sa SDL_DestroyTexture
 * \sa SDL_GetTextureSize
 * \sa SDL_UpdateTexture
 *)
function SDL_CreateTextureWithProperties(renderer: SDL_Renderer; props: SDL_PropertiesID): PSDL_Texture; cdecl;
  external LIB_SDL3 name _PU + 'SDL_CreateTextureWithProperties';

const
  SDL_PROP_TEXTURE_CREATE_COLORSPACE_NUMBER = 'SDL.texture.create.colorspace';
  SDL_PROP_TEXTURE_CREATE_FORMAT_NUMBER = 'SDL.texture.create.format';
  SDL_PROP_TEXTURE_CREATE_ACCESS_NUMBER = 'SDL.texture.create.access';
  SDL_PROP_TEXTURE_CREATE_WIDTH_NUMBER = 'SDL.texture.create.width';
  SDL_PROP_TEXTURE_CREATE_HEIGHT_NUMBER = 'SDL.texture.create.height';
  SDL_PROP_TEXTURE_CREATE_SDR_WHITE_POINT_FLOAT = 'SDL.texture.create.SDR_white_point';
  SDL_PROP_TEXTURE_CREATE_HDR_HEADROOM_FLOAT = 'SDL.texture.create.HDR_headroom';
  SDL_PROP_TEXTURE_CREATE_D3D11_TEXTURE_POINTER = 'SDL.texture.create.d3d11.texture';
  SDL_PROP_TEXTURE_CREATE_D3D11_TEXTURE_U_POINTER = 'SDL.texture.create.d3d11.texture_u';
  SDL_PROP_TEXTURE_CREATE_D3D11_TEXTURE_V_POINTER = 'SDL.texture.create.d3d11.texture_v';
  SDL_PROP_TEXTURE_CREATE_D3D12_TEXTURE_POINTER = 'SDL.texture.create.d3d12.texture';
  SDL_PROP_TEXTURE_CREATE_D3D12_TEXTURE_U_POINTER = 'SDL.texture.create.d3d12.texture_u';
  SDL_PROP_TEXTURE_CREATE_D3D12_TEXTURE_V_POINTER = 'SDL.texture.create.d3d12.texture_v';
  SDL_PROP_TEXTURE_CREATE_METAL_PIXELBUFFER_POINTER = 'SDL.texture.create.metal.pixelbuffer';
  SDL_PROP_TEXTURE_CREATE_OPENGL_TEXTURE_NUMBER = 'SDL.texture.create.opengl.texture';
  SDL_PROP_TEXTURE_CREATE_OPENGL_TEXTURE_UV_NUMBER = 'SDL.texture.create.opengl.texture_uv';
  SDL_PROP_TEXTURE_CREATE_OPENGL_TEXTURE_U_NUMBER = 'SDL.texture.create.opengl.texture_u';
  SDL_PROP_TEXTURE_CREATE_OPENGL_TEXTURE_V_NUMBER = 'SDL.texture.create.opengl.texture_v';
  SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_NUMBER = 'SDL.texture.create.opengles2.texture';
  SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_UV_NUMBER = 'SDL.texture.create.opengles2.texture_uv';
  SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_U_NUMBER = 'SDL.texture.create.opengles2.texture_u';
  SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_V_NUMBER = 'SDL.texture.create.opengles2.texture_v';
  SDL_PROP_TEXTURE_CREATE_VULKAN_TEXTURE_NUMBER = 'SDL.texture.create.vulkan.texture';

(**
 * Get the properties associated with a texture.
 *
 * The following read-only properties are provided by SDL:
 *
 * - `SDL_PROP_TEXTURE_COLORSPACE_NUMBER`: an SDL_Colorspace value describing
 *   the texture colorspace.
 * - `SDL_PROP_TEXTURE_FORMAT_NUMBER`: one of the enumerated values in
 *   SDL_PixelFormat.
 * - `SDL_PROP_TEXTURE_ACCESS_NUMBER`: one of the enumerated values in
 *   SDL_TextureAccess.
 * - `SDL_PROP_TEXTURE_WIDTH_NUMBER`: the width of the texture in pixels.
 * - `SDL_PROP_TEXTURE_HEIGHT_NUMBER`: the height of the texture in pixels.
 * - `SDL_PROP_TEXTURE_SDR_WHITE_POINT_FLOAT`: for HDR10 and floating point
 *   textures, this defines the value of 100% diffuse white, with higher
 *   values being displayed in the High Dynamic Range headroom. This defaults
 *   to 100 for HDR10 textures and 1.0 for other textures.
 * - `SDL_PROP_TEXTURE_HDR_HEADROOM_FLOAT`: for HDR10 and floating point
 *   textures, this defines the maximum dynamic range used by the content, in
 *   terms of the SDR white point. If this is defined, any values outside the
 *   range supported by the display will be scaled into the available HDR
 *   headroom, otherwise they are clipped. This defaults to 1.0 for SDR
 *   textures, 4.0 for HDR10 textures, and no default for floating point
 *   textures.
 *
 * With the direct3d11 renderer:
 *
 * - `SDL_PROP_TEXTURE_D3D11_TEXTURE_POINTER`: the ID3D11Texture2D associated
 *   with the texture
 * - `SDL_PROP_TEXTURE_D3D11_TEXTURE_U_POINTER`: the ID3D11Texture2D
 *   associated with the U plane of a YUV texture
 * - `SDL_PROP_TEXTURE_D3D11_TEXTURE_V_POINTER`: the ID3D11Texture2D
 *   associated with the V plane of a YUV texture
 *
 * With the direct3d12 renderer:
 *
 * - `SDL_PROP_TEXTURE_D3D12_TEXTURE_POINTER`: the ID3D12Resource associated
 *   with the texture
 * - `SDL_PROP_TEXTURE_D3D12_TEXTURE_U_POINTER`: the ID3D12Resource associated
 *   with the U plane of a YUV texture
 * - `SDL_PROP_TEXTURE_D3D12_TEXTURE_V_POINTER`: the ID3D12Resource associated
 *   with the V plane of a YUV texture
 *
 * With the vulkan renderer:
 *
 * - `SDL_PROP_TEXTURE_VULKAN_TEXTURE_NUMBER`: the VkImage associated with the
 *   texture
 *
 * With the opengl renderer:
 *
 * - `SDL_PROP_TEXTURE_OPENGL_TEXTURE_NUMBER`: the GLuint texture associated
 *   with the texture
 * - `SDL_PROP_TEXTURE_OPENGL_TEXTURE_UV_NUMBER`: the GLuint texture
 *   associated with the UV plane of an NV12 texture
 * - `SDL_PROP_TEXTURE_OPENGL_TEXTURE_U_NUMBER`: the GLuint texture associated
 *   with the U plane of a YUV texture
 * - `SDL_PROP_TEXTURE_OPENGL_TEXTURE_V_NUMBER`: the GLuint texture associated
 *   with the V plane of a YUV texture
 * - `SDL_PROP_TEXTURE_OPENGL_TEXTURE_TARGET_NUMBER`: the GLenum for the
 *   texture target (`GL_TEXTURE_2D`, `GL_TEXTURE_RECTANGLE_ARB`, etc)
 * - `SDL_PROP_TEXTURE_OPENGL_TEX_W_FLOAT`: the texture coordinate width of
 *   the texture (0.0 - 1.0)
 * - `SDL_PROP_TEXTURE_OPENGL_TEX_H_FLOAT`: the texture coordinate height of
 *   the texture (0.0 - 1.0)
 *
 * With the opengles2 renderer:
 *
 * - `SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_NUMBER`: the GLuint texture
 *   associated with the texture
 * - `SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_UV_NUMBER`: the GLuint texture
 *   associated with the UV plane of an NV12 texture
 * - `SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_U_NUMBER`: the GLuint texture
 *   associated with the U plane of a YUV texture
 * - `SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_V_NUMBER`: the GLuint texture
 *   associated with the V plane of a YUV texture
 * - `SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_TARGET_NUMBER`: the GLenum for the
 *   texture target (`GL_TEXTURE_2D`, `GL_TEXTURE_EXTERNAL_OES`, etc)
 *
 * \param texture the texture to query.
 * \returns a valid property ID on success or 0 on failure; call
 *          SDL_GetError() for more information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetTextureProperties(texture: PSDL_Texture): SDL_PropertiesID; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetTextureProperties';

const
  SDL_PROP_TEXTURE_COLORSPACE_NUMBER = 'SDL.texture.colorspace';
  SDL_PROP_TEXTURE_FORMAT_NUMBER = 'SDL.texture.format';
  SDL_PROP_TEXTURE_ACCESS_NUMBER = 'SDL.texture.access';
  SDL_PROP_TEXTURE_WIDTH_NUMBER = 'SDL.texture.width';
  SDL_PROP_TEXTURE_HEIGHT_NUMBER = 'SDL.texture.height';
  SDL_PROP_TEXTURE_SDR_WHITE_POINT_FLOAT = 'SDL.texture.SDR_white_point';
  SDL_PROP_TEXTURE_HDR_HEADROOM_FLOAT = 'SDL.texture.HDR_headroom';
  SDL_PROP_TEXTURE_D3D11_TEXTURE_POINTER = 'SDL.texture.d3d11.texture';
  SDL_PROP_TEXTURE_D3D11_TEXTURE_U_POINTER = 'SDL.texture.d3d11.texture_u';
  SDL_PROP_TEXTURE_D3D11_TEXTURE_V_POINTER = 'SDL.texture.d3d11.texture_v';
  SDL_PROP_TEXTURE_D3D12_TEXTURE_POINTER = 'SDL.texture.d3d12.texture';
  SDL_PROP_TEXTURE_D3D12_TEXTURE_U_POINTER = 'SDL.texture.d3d12.texture_u';
  SDL_PROP_TEXTURE_D3D12_TEXTURE_V_POINTER = 'SDL.texture.d3d12.texture_v';
  SDL_PROP_TEXTURE_OPENGL_TEXTURE_NUMBER = 'SDL.texture.opengl.texture';
  SDL_PROP_TEXTURE_OPENGL_TEXTURE_UV_NUMBER = 'SDL.texture.opengl.texture_uv';
  SDL_PROP_TEXTURE_OPENGL_TEXTURE_U_NUMBER = 'SDL.texture.opengl.texture_u';
  SDL_PROP_TEXTURE_OPENGL_TEXTURE_V_NUMBER = 'SDL.texture.opengl.texture_v';
  SDL_PROP_TEXTURE_OPENGL_TEXTURE_TARGET_NUMBER = 'SDL.texture.opengl.target';
  SDL_PROP_TEXTURE_OPENGL_TEX_W_FLOAT = 'SDL.texture.opengl.tex_w';
  SDL_PROP_TEXTURE_OPENGL_TEX_H_FLOAT = 'SDL.texture.opengl.tex_h';
  SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_NUMBER = 'SDL.texture.opengles2.texture';
  SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_UV_NUMBER = 'SDL.texture.opengles2.texture_uv';
  SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_U_NUMBER = 'SDL.texture.opengles2.texture_u';
  SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_V_NUMBER = 'SDL.texture.opengles2.texture_v';
  SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_TARGET_NUMBER = 'SDL.texture.opengles2.target';
  SDL_PROP_TEXTURE_VULKAN_TEXTURE_NUMBER = 'SDL.texture.vulkan.texture';

(**
 * Get the renderer that created an SDL_Texture.
 *
 * \param texture the texture to query.
 * \returns a pointer to the SDL_Renderer that created the texture, or NULL on
 *          failure; call SDL_GetError() for more information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetRendererFromTexture(texture: PSDL_Texture): SDL_Renderer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetRendererFromTexture';

(**
 * Get the size of a texture, as floating point values.
 *
 * \param texture the texture to query.
 * \param w a pointer filled in with the width of the texture in pixels. This
 *          argument can be NULL if you don't need this information.
 * \param h a pointer filled in with the height of the texture in pixels. This
 *          argument can be NULL if you don't need this information.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetTextureSize(texture: PSDL_Texture; w: PSingle; h: PSingle): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetTextureSize';

(**
 * Set an additional color value multiplied into render copy operations.
 *
 * When this texture is rendered, during the copy operation each source color
 * channel is modulated by the appropriate color value according to the
 * following formula:
 *
 * `srcC = srcC * (color / 255)`
 *
 * Color modulation is not always supported by the renderer; it will return
 * false if color modulation is not supported.
 *
 * \param texture the texture to update.
 * \param r the red color value multiplied into copy operations.
 * \param g the green color value multiplied into copy operations.
 * \param b the blue color value multiplied into copy operations.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetTextureColorMod
 * \sa SDL_SetTextureAlphaMod
 * \sa SDL_SetTextureColorModFloat
 *)
function SDL_SetTextureColorMod(texture: PSDL_Texture; r: Uint8; g: Uint8; b: Uint8): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetTextureColorMod';

(**
 * Set an additional color value multiplied into render copy operations.
 *
 * When this texture is rendered, during the copy operation each source color
 * channel is modulated by the appropriate color value according to the
 * following formula:
 *
 * `srcC = srcC * color`
 *
 * Color modulation is not always supported by the renderer; it will return
 * false if color modulation is not supported.
 *
 * \param texture the texture to update.
 * \param r the red color value multiplied into copy operations.
 * \param g the green color value multiplied into copy operations.
 * \param b the blue color value multiplied into copy operations.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetTextureColorModFloat
 * \sa SDL_SetTextureAlphaModFloat
 * \sa SDL_SetTextureColorMod
 *)
function SDL_SetTextureColorModFloat(texture: PSDL_Texture; r: Single; g: Single; b: Single): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetTextureColorModFloat';

(**
 * Get the additional color value multiplied into render copy operations.
 *
 * \param texture the texture to query.
 * \param r a pointer filled in with the current red color value.
 * \param g a pointer filled in with the current green color value.
 * \param b a pointer filled in with the current blue color value.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetTextureAlphaMod
 * \sa SDL_GetTextureColorModFloat
 * \sa SDL_SetTextureColorMod
 *)
function SDL_GetTextureColorMod(texture: PSDL_Texture; r: PUint8; g: PUint8; b: PUint8): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetTextureColorMod';

(**
 * Get the additional color value multiplied into render copy operations.
 *
 * \param texture the texture to query.
 * \param r a pointer filled in with the current red color value.
 * \param g a pointer filled in with the current green color value.
 * \param b a pointer filled in with the current blue color value.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetTextureAlphaModFloat
 * \sa SDL_GetTextureColorMod
 * \sa SDL_SetTextureColorModFloat
 *)
function SDL_GetTextureColorModFloat(texture: PSDL_Texture; r: PSingle; g: PSingle; b: PSingle): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetTextureColorModFloat';

(**
 * Set an additional alpha value multiplied into render copy operations.
 *
 * When this texture is rendered, during the copy operation the source alpha
 * value is modulated by this alpha value according to the following formula:
 *
 * `srcA = srcA * (alpha / 255)`
 *
 * Alpha modulation is not always supported by the renderer; it will return
 * false if alpha modulation is not supported.
 *
 * \param texture the texture to update.
 * \param alpha the source alpha value multiplied into copy operations.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetTextureAlphaMod
 * \sa SDL_SetTextureAlphaModFloat
 * \sa SDL_SetTextureColorMod
 *)
function SDL_SetTextureAlphaMod(texture: PSDL_Texture; alpha: Uint8): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetTextureAlphaMod';

(**
 * Set an additional alpha value multiplied into render copy operations.
 *
 * When this texture is rendered, during the copy operation the source alpha
 * value is modulated by this alpha value according to the following formula:
 *
 * `srcA = srcA * alpha`
 *
 * Alpha modulation is not always supported by the renderer; it will return
 * false if alpha modulation is not supported.
 *
 * \param texture the texture to update.
 * \param alpha the source alpha value multiplied into copy operations.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetTextureAlphaModFloat
 * \sa SDL_SetTextureAlphaMod
 * \sa SDL_SetTextureColorModFloat
 *)
function SDL_SetTextureAlphaModFloat(texture: PSDL_Texture; alpha: Single): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetTextureAlphaModFloat';

(**
 * Get the additional alpha value multiplied into render copy operations.
 *
 * \param texture the texture to query.
 * \param alpha a pointer filled in with the current alpha value.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetTextureAlphaModFloat
 * \sa SDL_GetTextureColorMod
 * \sa SDL_SetTextureAlphaMod
 *)
function SDL_GetTextureAlphaMod(texture: PSDL_Texture; alpha: PUint8): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetTextureAlphaMod';

(**
 * Get the additional alpha value multiplied into render copy operations.
 *
 * \param texture the texture to query.
 * \param alpha a pointer filled in with the current alpha value.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetTextureAlphaMod
 * \sa SDL_GetTextureColorModFloat
 * \sa SDL_SetTextureAlphaModFloat
 *)
function SDL_GetTextureAlphaModFloat(texture: PSDL_Texture; alpha: PSingle): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetTextureAlphaModFloat';

(**
 * Set the blend mode for a texture, used by SDL_RenderTexture().
 *
 * If the blend mode is not supported, the closest supported mode is chosen
 * and this function returns false.
 *
 * \param texture the texture to update.
 * \param blendMode the SDL_BlendMode to use for texture blending.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetTextureBlendMode
 *)
function SDL_SetTextureBlendMode(texture: PSDL_Texture; blendMode: SDL_BlendMode): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetTextureBlendMode';

(**
 * Get the blend mode used for texture copy operations.
 *
 * \param texture the texture to query.
 * \param blendMode a pointer filled in with the current SDL_BlendMode.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetTextureBlendMode
 *)
function SDL_GetTextureBlendMode(texture: PSDL_Texture; blendMode: PSDL_BlendMode): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetTextureBlendMode';

(**
 * Set the scale mode used for texture scale operations.
 *
 * The default texture scale mode is SDL_SCALEMODE_LINEAR.
 *
 * If the scale mode is not supported, the closest supported mode is chosen.
 *
 * \param texture the texture to update.
 * \param scaleMode the SDL_ScaleMode to use for texture scaling.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetTextureScaleMode
 *)
function SDL_SetTextureScaleMode(texture: PSDL_Texture; scaleMode: SDL_ScaleMode): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetTextureScaleMode';

(**
 * Get the scale mode used for texture scale operations.
 *
 * \param texture the texture to query.
 * \param scaleMode a pointer filled in with the current scale mode.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetTextureScaleMode
 *)
function SDL_GetTextureScaleMode(texture: PSDL_Texture; scaleMode: PSDL_ScaleMode): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetTextureScaleMode';

(**
 * Update the given texture rectangle with new pixel data.
 *
 * The pixel data must be in the pixel format of the texture, which can be
 * queried using the SDL_PROP_TEXTURE_FORMAT_NUMBER property.
 *
 * This is a fairly slow function, intended for use with static textures that
 * do not change often.
 *
 * If the texture is intended to be updated often, it is preferred to create
 * the texture as streaming and use the locking functions referenced below.
 * While this function will work with streaming textures, for optimization
 * reasons you may not get the pixels back if you lock the texture afterward.
 *
 * \param texture the texture to update.
 * \param rect an SDL_Rect structure representing the area to update, or NULL
 *             to update the entire texture.
 * \param pixels the raw pixel data in the format of the texture.
 * \param pitch the number of bytes in a row of pixel data, including padding
 *              between lines.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_LockTexture
 * \sa SDL_UnlockTexture
 * \sa SDL_UpdateNVTexture
 * \sa SDL_UpdateYUVTexture
 *)
function SDL_UpdateTexture(texture: PSDL_Texture; const rect: PSDL_Rect; const pixels: Pointer; pitch: Integer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_UpdateTexture';

(**
 * Update a rectangle within a planar YV12 or IYUV texture with new pixel
 * data.
 *
 * You can use SDL_UpdateTexture() as long as your pixel data is a contiguous
 * block of Y and U/V planes in the proper order, but this function is
 * available if your pixel data is not contiguous.
 *
 * \param texture the texture to update.
 * \param rect a pointer to the rectangle of pixels to update, or NULL to
 *             update the entire texture.
 * \param Yplane the raw pixel data for the Y plane.
 * \param Ypitch the number of bytes between rows of pixel data for the Y
 *               plane.
 * \param Uplane the raw pixel data for the U plane.
 * \param Upitch the number of bytes between rows of pixel data for the U
 *               plane.
 * \param Vplane the raw pixel data for the V plane.
 * \param Vpitch the number of bytes between rows of pixel data for the V
 *               plane.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_UpdateNVTexture
 * \sa SDL_UpdateTexture
 *)
function SDL_UpdateYUVTexture(texture: PSDL_Texture; const rect: PSDL_Rect; const Yplane: PUint8; Ypitch: Integer; const Uplane: PUint8; Upitch: Integer; const Vplane: PUint8; Vpitch: Integer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_UpdateYUVTexture';

(**
 * Update a rectangle within a planar NV12 or NV21 texture with new pixels.
 *
 * You can use SDL_UpdateTexture() as long as your pixel data is a contiguous
 * block of NV12/21 planes in the proper order, but this function is available
 * if your pixel data is not contiguous.
 *
 * \param texture the texture to update.
 * \param rect a pointer to the rectangle of pixels to update, or NULL to
 *             update the entire texture.
 * \param Yplane the raw pixel data for the Y plane.
 * \param Ypitch the number of bytes between rows of pixel data for the Y
 *               plane.
 * \param UVplane the raw pixel data for the UV plane.
 * \param UVpitch the number of bytes between rows of pixel data for the UV
 *                plane.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_UpdateTexture
 * \sa SDL_UpdateYUVTexture
 *)
function SDL_UpdateNVTexture(texture: PSDL_Texture; const rect: PSDL_Rect; const Yplane: PUint8; Ypitch: Integer; const UVplane: PUint8; UVpitch: Integer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_UpdateNVTexture';

(**
 * Lock a portion of the texture for **write-only** pixel access.
 *
 * As an optimization, the pixels made available for editing don't necessarily
 * contain the old texture data. This is a write-only operation, and if you
 * need to keep a copy of the texture data you should do that at the
 * application level.
 *
 * You must use SDL_UnlockTexture() to unlock the pixels and apply any
 * changes.
 *
 * \param texture the texture to lock for access, which was created with
 *                `SDL_TEXTUREACCESS_STREAMING`.
 * \param rect an SDL_Rect structure representing the area to lock for access;
 *             NULL to lock the entire texture.
 * \param pixels this is filled in with a pointer to the locked pixels,
 *               appropriately offset by the locked area.
 * \param pitch this is filled in with the pitch of the locked pixels; the
 *              pitch is the length of one row in bytes.
 * \returns true on success or false if the texture is not valid or was not
 *          created with `SDL_TEXTUREACCESS_STREAMING`; call SDL_GetError()
 *          for more information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_LockTextureToSurface
 * \sa SDL_UnlockTexture
 *)
function SDL_LockTexture(texture: PSDL_Texture; const rect: PSDL_Rect; pixels: PPointer; pitch: PInteger): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_LockTexture';

(**
 * Lock a portion of the texture for **write-only** pixel access, and expose
 * it as a SDL surface.
 *
 * Besides providing an SDL_Surface instead of raw pixel data, this function
 * operates like SDL_LockTexture.
 *
 * As an optimization, the pixels made available for editing don't necessarily
 * contain the old texture data. This is a write-only operation, and if you
 * need to keep a copy of the texture data you should do that at the
 * application level.
 *
 * You must use SDL_UnlockTexture() to unlock the pixels and apply any
 * changes.
 *
 * The returned surface is freed internally after calling SDL_UnlockTexture()
 * or SDL_DestroyTexture(). The caller should not free it.
 *
 * \param texture the texture to lock for access, which must be created with
 *                `SDL_TEXTUREACCESS_STREAMING`.
 * \param rect a pointer to the rectangle to lock for access. If the rect is
 *             NULL, the entire texture will be locked.
 * \param surface a pointer to an SDL surface of size **rect**. Don't assume
 *                any specific pixel content.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_LockTexture
 * \sa SDL_UnlockTexture
 *)
function SDL_LockTextureToSurface(texture: PSDL_Texture; const rect: PSDL_Rect; surface: PPSDL_Surface): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_LockTextureToSurface';

(**
 * Unlock a texture, uploading the changes to video memory, if needed.
 *
 * **Warning**: Please note that SDL_LockTexture() is intended to be
 * write-only; it will not guarantee the previous contents of the texture will
 * be provided. You must fully initialize any area of a texture that you lock
 * before unlocking it, as the pixels might otherwise be uninitialized memory.
 *
 * Which is to say: locking and immediately unlocking a texture can result in
 * corrupted textures, depending on the renderer in use.
 *
 * \param texture a texture locked by SDL_LockTexture().
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_LockTexture
 *)
procedure SDL_UnlockTexture(texture: PSDL_Texture); cdecl;
  external LIB_SDL3 name _PU + 'SDL_UnlockTexture';

(**
 * Set a texture as the current rendering target.
 *
 * The default render target is the window for which the renderer was created.
 * To stop rendering to a texture and render to the window again, call this
 * function with a NULL `texture`.
 *
 * \param renderer the rendering context.
 * \param texture the targeted texture, which must be created with the
 *                `SDL_TEXTUREACCESS_TARGET` flag, or NULL to render to the
 *                window instead of a texture.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetRenderTarget
 *)
function SDL_SetRenderTarget(renderer: SDL_Renderer; texture: PSDL_Texture): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetRenderTarget';

(**
 * Get the current render target.
 *
 * The default render target is the window for which the renderer was created,
 * and is reported a NULL here.
 *
 * \param renderer the rendering context.
 * \returns the current render target or NULL for the default render target.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetRenderTarget
 *)
function SDL_GetRenderTarget(renderer: SDL_Renderer): PSDL_Texture; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetRenderTarget';

(**
 * Set a device independent resolution and presentation mode for rendering.
 *
 * This function sets the width and height of the logical rendering output.
 * The renderer will act as if the window is always the requested dimensions,
 * scaling to the actual window resolution as necessary.
 *
 * This can be useful for games that expect a fixed size, but would like to
 * scale the output to whatever is available, regardless of how a user resizes
 * a window, or if the display is high DPI.
 *
 * You can disable logical coordinates by setting the mode to
 * SDL_LOGICAL_PRESENTATION_DISABLED, and in that case you get the full pixel
 * resolution of the output window; it is safe to toggle logical presentation
 * during the rendering of a frame: perhaps most of the rendering is done to
 * specific dimensions but to make fonts look sharp, the app turns off logical
 * presentation while drawing text.
 *
 * Letterboxing will only happen if logical presentation is enabled during
 * SDL_RenderPresent; be sure to reenable it first if you were using it.
 *
 * You can convert coordinates in an event into rendering coordinates using
 * SDL_ConvertEventToRenderCoordinates().
 *
 * \param renderer the rendering context.
 * \param w the width of the logical resolution.
 * \param h the height of the logical resolution.
 * \param mode the presentation mode used.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_ConvertEventToRenderCoordinates
 * \sa SDL_GetRenderLogicalPresentation
 * \sa SDL_GetRenderLogicalPresentationRect
 *)
function SDL_SetRenderLogicalPresentation(renderer: SDL_Renderer; w: Integer; h: Integer; mode: SDL_RendererLogicalPresentation): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetRenderLogicalPresentation';

(**
 * Get device independent resolution and presentation mode for rendering.
 *
 * This function gets the width and height of the logical rendering output, or
 * the output size in pixels if a logical resolution is not enabled.
 *
 * \param renderer the rendering context.
 * \param w an int to be filled with the width.
 * \param h an int to be filled with the height.
 * \param mode the presentation mode used.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetRenderLogicalPresentation
 *)
function SDL_GetRenderLogicalPresentation(renderer: SDL_Renderer; w: PInteger; h: PInteger; mode: PSDL_RendererLogicalPresentation): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetRenderLogicalPresentation';

(**
 * Get the final presentation rectangle for rendering.
 *
 * This function returns the calculated rectangle used for logical
 * presentation, based on the presentation mode and output size. If logical
 * presentation is disabled, it will fill the rectangle with the output size,
 * in pixels.
 *
 * \param renderer the rendering context.
 * \param rect a pointer filled in with the final presentation rectangle, may
 *             be NULL.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetRenderLogicalPresentation
 *)
function SDL_GetRenderLogicalPresentationRect(renderer: SDL_Renderer; rect: PSDL_FRect): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetRenderLogicalPresentationRect';

(**
 * Get a point in render coordinates when given a point in window coordinates.
 *
 * This takes into account several states:
 *
 * - The window dimensions.
 * - The logical presentation settings (SDL_SetRenderLogicalPresentation)
 * - The scale (SDL_SetRenderScale)
 * - The viewport (SDL_SetRenderViewport)
 *
 * \param renderer the rendering context.
 * \param window_x the x coordinate in window coordinates.
 * \param window_y the y coordinate in window coordinates.
 * \param x a pointer filled with the x coordinate in render coordinates.
 * \param y a pointer filled with the y coordinate in render coordinates.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetRenderLogicalPresentation
 * \sa SDL_SetRenderScale
 *)
function SDL_RenderCoordinatesFromWindow(renderer: SDL_Renderer; window_x: Single; window_y: Single; x: PSingle; y: PSingle): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_RenderCoordinatesFromWindow';

(**
 * Get a point in window coordinates when given a point in render coordinates.
 *
 * This takes into account several states:
 *
 * - The window dimensions.
 * - The logical presentation settings (SDL_SetRenderLogicalPresentation)
 * - The scale (SDL_SetRenderScale)
 * - The viewport (SDL_SetRenderViewport)
 *
 * \param renderer the rendering context.
 * \param x the x coordinate in render coordinates.
 * \param y the y coordinate in render coordinates.
 * \param window_x a pointer filled with the x coordinate in window
 *                 coordinates.
 * \param window_y a pointer filled with the y coordinate in window
 *                 coordinates.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetRenderLogicalPresentation
 * \sa SDL_SetRenderScale
 * \sa SDL_SetRenderViewport
 *)
function SDL_RenderCoordinatesToWindow(renderer: SDL_Renderer; x: Single; y: Single; window_x: PSingle; window_y: PSingle): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_RenderCoordinatesToWindow';

(**
 * Convert the coordinates in an event to render coordinates.
 *
 * This takes into account several states:
 *
 * - The window dimensions.
 * - The logical presentation settings (SDL_SetRenderLogicalPresentation)
 * - The scale (SDL_SetRenderScale)
 * - The viewport (SDL_SetRenderViewport)
 *
 * Various event types are converted with this function: mouse, touch, pen,
 * etc.
 *
 * Touch coordinates are converted from normalized coordinates in the window
 * to non-normalized rendering coordinates.
 *
 * Relative mouse coordinates (xrel and yrel event fields) are _also_
 * converted. Applications that do not want these fields converted should use
 * SDL_RenderCoordinatesFromWindow() on the specific event fields instead of
 * converting the entire event structure.
 *
 * Once converted, coordinates may be outside the rendering area.
 *
 * \param renderer the rendering context.
 * \param event the event to modify.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_RenderCoordinatesFromWindow
 *)
function SDL_ConvertEventToRenderCoordinates(renderer: SDL_Renderer; event: PSDL_Event): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_ConvertEventToRenderCoordinates';

(**
 * Set the drawing area for rendering on the current target.
 *
 * Drawing will clip to this area (separately from any clipping done with
 * SDL_SetRenderClipRect), and the top left of the area will become coordinate
 * (0, 0) for future drawing commands.
 *
 * The area's width and height must be >= 0.
 *
 * \param renderer the rendering context.
 * \param rect the SDL_Rect structure representing the drawing area, or NULL
 *             to set the viewport to the entire target.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetRenderViewport
 * \sa SDL_RenderViewportSet
 *)
function SDL_SetRenderViewport(renderer: SDL_Renderer; const rect: PSDL_Rect): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetRenderViewport';

(**
 * Get the drawing area for the current target.
 *
 * \param renderer the rendering context.
 * \param rect an SDL_Rect structure filled in with the current drawing area.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_RenderViewportSet
 * \sa SDL_SetRenderViewport
 *)
function SDL_GetRenderViewport(renderer: SDL_Renderer; rect: PSDL_Rect): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetRenderViewport';

(**
 * Return whether an explicit rectangle was set as the viewport.
 *
 * This is useful if you're saving and restoring the viewport and want to know
 * whether you should restore a specific rectangle or NULL. Note that the
 * viewport is always reset when changing rendering targets.
 *
 * \param renderer the rendering context.
 * \returns true if the viewport was set to a specific rectangle, or false if
 *          it was set to NULL (the entire target).
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetRenderViewport
 * \sa SDL_SetRenderViewport
 *)
function SDL_RenderViewportSet(renderer: SDL_Renderer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_RenderViewportSet';

(**
 * Get the safe area for rendering within the current viewport.
 *
 * Some devices have portions of the screen which are partially obscured or
 * not interactive, possibly due to on-screen controls, curved edges, camera
 * notches, TV overscan, etc. This function provides the area of the current
 * viewport which is safe to have interactible content. You should continue
 * rendering into the rest of the render target, but it should not contain
 * visually important or interactible content.
 *
 * \param renderer the rendering context.
 * \param rect a pointer filled in with the area that is safe for interactive
 *             content.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetRenderSafeArea(renderer: SDL_Renderer; rect: PSDL_Rect): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetRenderSafeArea';

(**
 * Set the clip rectangle for rendering on the specified target.
 *
 * \param renderer the rendering context.
 * \param rect an SDL_Rect structure representing the clip area, relative to
 *             the viewport, or NULL to disable clipping.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetRenderClipRect
 * \sa SDL_RenderClipEnabled
 *)
function SDL_SetRenderClipRect(renderer: SDL_Renderer; const rect: PSDL_Rect): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetRenderClipRect';

(**
 * Get the clip rectangle for the current target.
 *
 * \param renderer the rendering context.
 * \param rect an SDL_Rect structure filled in with the current clipping area
 *             or an empty rectangle if clipping is disabled.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_RenderClipEnabled
 * \sa SDL_SetRenderClipRect
 *)
function SDL_GetRenderClipRect(renderer: SDL_Renderer; rect: PSDL_Rect): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetRenderClipRect';

(**
 * Get whether clipping is enabled on the given renderer.
 *
 * \param renderer the rendering context.
 * \returns true if clipping is enabled or false if not; call SDL_GetError()
 *          for more information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetRenderClipRect
 * \sa SDL_SetRenderClipRect
 *)
function SDL_RenderClipEnabled(renderer: SDL_Renderer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_RenderClipEnabled';

(**
 * Set the drawing scale for rendering on the current target.
 *
 * The drawing coordinates are scaled by the x/y scaling factors before they
 * are used by the renderer. This allows resolution independent drawing with a
 * single coordinate system.
 *
 * If this results in scaling or subpixel drawing by the rendering backend, it
 * will be handled using the appropriate quality hints. For best results use
 * integer scaling factors.
 *
 * \param renderer the rendering context.
 * \param scaleX the horizontal scaling factor.
 * \param scaleY the vertical scaling factor.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetRenderScale
 *)
function SDL_SetRenderScale(renderer: SDL_Renderer; scaleX: Single; scaleY: Single): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetRenderScale';

(**
 * Get the drawing scale for the current target.
 *
 * \param renderer the rendering context.
 * \param scaleX a pointer filled in with the horizontal scaling factor.
 * \param scaleY a pointer filled in with the vertical scaling factor.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetRenderScale
 *)
function SDL_GetRenderScale(renderer: SDL_Renderer; scaleX: PSingle; scaleY: PSingle): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetRenderScale';

(**
 * Set the color used for drawing operations.
 *
 * Set the color for drawing or filling rectangles, lines, and points, and for
 * SDL_RenderClear().
 *
 * \param renderer the rendering context.
 * \param r the red value used to draw on the rendering target.
 * \param g the green value used to draw on the rendering target.
 * \param b the blue value used to draw on the rendering target.
 * \param a the alpha value used to draw on the rendering target; usually
 *          `SDL_ALPHA_OPAQUE` (255). Use SDL_SetRenderDrawBlendMode to
 *          specify how the alpha channel is used.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetRenderDrawColor
 * \sa SDL_SetRenderDrawColorFloat
 *)
function SDL_SetRenderDrawColor(renderer: SDL_Renderer; r: Uint8; g: Uint8; b: Uint8; a: Uint8): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetRenderDrawColor';

(**
 * Set the color used for drawing operations (Rect, Line and Clear).
 *
 * Set the color for drawing or filling rectangles, lines, and points, and for
 * SDL_RenderClear().
 *
 * \param renderer the rendering context.
 * \param r the red value used to draw on the rendering target.
 * \param g the green value used to draw on the rendering target.
 * \param b the blue value used to draw on the rendering target.
 * \param a the alpha value used to draw on the rendering target. Use
 *          SDL_SetRenderDrawBlendMode to specify how the alpha channel is
 *          used.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetRenderDrawColorFloat
 * \sa SDL_SetRenderDrawColor
 *)
function SDL_SetRenderDrawColorFloat(renderer: SDL_Renderer; r: Single; g: Single; b: Single; a: Single): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetRenderDrawColorFloat';

(**
 * Get the color used for drawing operations (Rect, Line and Clear).
 *
 * \param renderer the rendering context.
 * \param r a pointer filled in with the red value used to draw on the
 *          rendering target.
 * \param g a pointer filled in with the green value used to draw on the
 *          rendering target.
 * \param b a pointer filled in with the blue value used to draw on the
 *          rendering target.
 * \param a a pointer filled in with the alpha value used to draw on the
 *          rendering target; usually `SDL_ALPHA_OPAQUE` (255).
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetRenderDrawColorFloat
 * \sa SDL_SetRenderDrawColor
 *)
function SDL_GetRenderDrawColor(renderer: SDL_Renderer; r: PUint8; g: PUint8; b: PUint8; a: PUint8): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetRenderDrawColor';

(**
 * Get the color used for drawing operations (Rect, Line and Clear).
 *
 * \param renderer the rendering context.
 * \param r a pointer filled in with the red value used to draw on the
 *          rendering target.
 * \param g a pointer filled in with the green value used to draw on the
 *          rendering target.
 * \param b a pointer filled in with the blue value used to draw on the
 *          rendering target.
 * \param a a pointer filled in with the alpha value used to draw on the
 *          rendering target.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetRenderDrawColorFloat
 * \sa SDL_GetRenderDrawColor
 *)
function SDL_GetRenderDrawColorFloat(renderer: SDL_Renderer; r: PSingle; g: PSingle; b: PSingle; a: PSingle): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetRenderDrawColorFloat';

(**
 * Set the color scale used for render operations.
 *
 * The color scale is an additional scale multiplied into the pixel color
 * value while rendering. This can be used to adjust the brightness of colors
 * during HDR rendering, or changing HDR video brightness when playing on an
 * SDR display.
 *
 * The color scale does not affect the alpha channel, only the color
 * brightness.
 *
 * \param renderer the rendering context.
 * \param scale the color scale value.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetRenderColorScale
 *)
function SDL_SetRenderColorScale(renderer: SDL_Renderer; scale: Single): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetRenderColorScale';

(**
 * Get the color scale used for render operations.
 *
 * \param renderer the rendering context.
 * \param scale a pointer filled in with the current color scale value.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetRenderColorScale
 *)
function SDL_GetRenderColorScale(renderer: SDL_Renderer; scale: PSingle): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetRenderColorScale';

(**
 * Set the blend mode used for drawing operations (Fill and Line).
 *
 * If the blend mode is not supported, the closest supported mode is chosen.
 *
 * \param renderer the rendering context.
 * \param blendMode the SDL_BlendMode to use for blending.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetRenderDrawBlendMode
 *)
function SDL_SetRenderDrawBlendMode(renderer: SDL_Renderer; blendMode: SDL_BlendMode): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetRenderDrawBlendMode';

(**
 * Get the blend mode used for drawing operations.
 *
 * \param renderer the rendering context.
 * \param blendMode a pointer filled in with the current SDL_BlendMode.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetRenderDrawBlendMode
 *)
function SDL_GetRenderDrawBlendMode(renderer: SDL_Renderer; blendMode: PSDL_BlendMode): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetRenderDrawBlendMode';

(**
 * Clear the current rendering target with the drawing color.
 *
 * This function clears the entire rendering target, ignoring the viewport and
 * the clip rectangle. Note, that clearing will also set/fill all pixels of
 * the rendering target to current renderer draw color, so make sure to invoke
 * SDL_SetRenderDrawColor() when needed.
 *
 * \param renderer the rendering context.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetRenderDrawColor
 *)
function SDL_RenderClear(renderer: SDL_Renderer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_RenderClear';

(**
 * Draw a point on the current rendering target at subpixel precision.
 *
 * \param renderer the renderer which should draw a point.
 * \param x the x coordinate of the point.
 * \param y the y coordinate of the point.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_RenderPoints
 *)
function SDL_RenderPoint(renderer: SDL_Renderer; x: Single; y: Single): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_RenderPoint';

(**
 * Draw multiple points on the current rendering target at subpixel precision.
 *
 * \param renderer the renderer which should draw multiple points.
 * \param points the points to draw.
 * \param count the number of points to draw.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_RenderPoint
 *)
function SDL_RenderPoints(renderer: SDL_Renderer; const points: PSDL_FPoint; count: Integer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_RenderPoints';

(**
 * Draw a line on the current rendering target at subpixel precision.
 *
 * \param renderer the renderer which should draw a line.
 * \param x1 the x coordinate of the start point.
 * \param y1 the y coordinate of the start point.
 * \param x2 the x coordinate of the end point.
 * \param y2 the y coordinate of the end point.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_RenderLines
 *)
function SDL_RenderLine(renderer: SDL_Renderer; x1: Single; y1: Single; x2: Single; y2: Single): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_RenderLine';

(**
 * Draw a series of connected lines on the current rendering target at
 * subpixel precision.
 *
 * \param renderer the renderer which should draw multiple lines.
 * \param points the points along the lines.
 * \param count the number of points, drawing count-1 lines.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_RenderLine
 *)
function SDL_RenderLines(renderer: SDL_Renderer; const points: PSDL_FPoint; count: Integer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_RenderLines';

(**
 * Draw a rectangle on the current rendering target at subpixel precision.
 *
 * \param renderer the renderer which should draw a rectangle.
 * \param rect a pointer to the destination rectangle, or NULL to outline the
 *             entire rendering target.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_RenderRects
 *)
function SDL_RenderRect(renderer: SDL_Renderer; const rect: PSDL_FRect): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_RenderRect';

(**
 * Draw some number of rectangles on the current rendering target at subpixel
 * precision.
 *
 * \param renderer the renderer which should draw multiple rectangles.
 * \param rects a pointer to an array of destination rectangles.
 * \param count the number of rectangles.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_RenderRect
 *)
function SDL_RenderRects(renderer: SDL_Renderer; const rects: PSDL_FRect; count: Integer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_RenderRects';

(**
 * Fill a rectangle on the current rendering target with the drawing color at
 * subpixel precision.
 *
 * \param renderer the renderer which should fill a rectangle.
 * \param rect a pointer to the destination rectangle, or NULL for the entire
 *             rendering target.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_RenderFillRects
 *)
function SDL_RenderFillRect(renderer: SDL_Renderer; const rect: PSDL_FRect): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_RenderFillRect';

(**
 * Fill some number of rectangles on the current rendering target with the
 * drawing color at subpixel precision.
 *
 * \param renderer the renderer which should fill multiple rectangles.
 * \param rects a pointer to an array of destination rectangles.
 * \param count the number of rectangles.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_RenderFillRect
 *)
function SDL_RenderFillRects(renderer: SDL_Renderer; const rects: PSDL_FRect; count: Integer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_RenderFillRects';

(**
 * Copy a portion of the texture to the current rendering target at subpixel
 * precision.
 *
 * \param renderer the renderer which should copy parts of a texture.
 * \param texture the source texture.
 * \param srcrect a pointer to the source rectangle, or NULL for the entire
 *                texture.
 * \param dstrect a pointer to the destination rectangle, or NULL for the
 *                entire rendering target.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_RenderTextureRotated
 * \sa SDL_RenderTextureTiled
 *)
function SDL_RenderTexture(renderer: SDL_Renderer; texture: PSDL_Texture; const srcrect: PSDL_FRect; const dstrect: PSDL_FRect): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_RenderTexture';

(**
 * Copy a portion of the source texture to the current rendering target, with
 * rotation and flipping, at subpixel precision.
 *
 * \param renderer the renderer which should copy parts of a texture.
 * \param texture the source texture.
 * \param srcrect a pointer to the source rectangle, or NULL for the entire
 *                texture.
 * \param dstrect a pointer to the destination rectangle, or NULL for the
 *                entire rendering target.
 * \param angle an angle in degrees that indicates the rotation that will be
 *              applied to dstrect, rotating it in a clockwise direction.
 * \param center a pointer to a point indicating the point around which
 *               dstrect will be rotated (if NULL, rotation will be done
 *               around dstrect.w/2, dstrect.h/2).
 * \param flip an SDL_FlipMode value stating which flipping actions should be
 *             performed on the texture.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_RenderTexture
 *)
function SDL_RenderTextureRotated(renderer: SDL_Renderer; texture: PSDL_Texture; const srcrect: PSDL_FRect; const dstrect: PSDL_FRect; angle: Double; const center: PSDL_FPoint; flip: SDL_FlipMode): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_RenderTextureRotated';

(**
 * Copy a portion of the source texture to the current rendering target, with
 * affine transform, at subpixel precision.
 *
 * \param renderer the renderer which should copy parts of a texture.
 * \param texture the source texture.
 * \param srcrect a pointer to the source rectangle, or NULL for the entire
 *                texture.
 * \param origin a pointer to a point indicating where the top-left corner of
 *               srcrect should be mapped to, or NULL for the rendering
 *               target's origin.
 * \param right a pointer to a point indicating where the top-right corner of
 *              srcrect should be mapped to, or NULL for the rendering
 *              target's top-right corner.
 * \param down a pointer to a point indicating where the bottom-left corner of
 *             srcrect should be mapped to, or NULL for the rendering target's
 *             bottom-left corner.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety You may only call this function from the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_RenderTexture
 *)
function SDL_RenderTextureAffine(renderer: SDL_Renderer; texture: PSDL_Texture; const srcrect: PSDL_FRect; const origin: PSDL_FPoint; const right: PSDL_FPoint; const down: PSDL_FPoint): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_RenderTextureAffine';

(**
 * Tile a portion of the texture to the current rendering target at subpixel
 * precision.
 *
 * The pixels in `srcrect` will be repeated as many times as needed to
 * completely fill `dstrect`.
 *
 * \param renderer the renderer which should copy parts of a texture.
 * \param texture the source texture.
 * \param srcrect a pointer to the source rectangle, or NULL for the entire
 *                texture.
 * \param scale the scale used to transform srcrect into the destination
 *              rectangle, e.g. a 32x32 texture with a scale of 2 would fill
 *              64x64 tiles.
 * \param dstrect a pointer to the destination rectangle, or NULL for the
 *                entire rendering target.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_RenderTexture
 *)
function SDL_RenderTextureTiled(renderer: SDL_Renderer; texture: PSDL_Texture; const srcrect: PSDL_FRect; scale: Single; const dstrect: PSDL_FRect): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_RenderTextureTiled';

(**
 * Perform a scaled copy using the 9-grid algorithm to the current rendering
 * target at subpixel precision.
 *
 * The pixels in the texture are split into a 3x3 grid, using the different
 * corner sizes for each corner, and the sides and center making up the
 * remaining pixels. The corners are then scaled using `scale` and fit into
 * the corners of the destination rectangle. The sides and center are then
 * stretched into place to cover the remaining destination rectangle.
 *
 * \param renderer the renderer which should copy parts of a texture.
 * \param texture the source texture.
 * \param srcrect the SDL_Rect structure representing the rectangle to be used
 *                for the 9-grid, or NULL to use the entire texture.
 * \param left_width the width, in pixels, of the left corners in `srcrect`.
 * \param right_width the width, in pixels, of the right corners in `srcrect`.
 * \param top_height the height, in pixels, of the top corners in `srcrect`.
 * \param bottom_height the height, in pixels, of the bottom corners in
 *                      `srcrect`.
 * \param scale the scale used to transform the corner of `srcrect` into the
 *              corner of `dstrect`, or 0.0f for an unscaled copy.
 * \param dstrect a pointer to the destination rectangle, or NULL for the
 *                entire rendering target.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_RenderTexture
 *)
function SDL_RenderTexture9Grid(renderer: SDL_Renderer; texture: PSDL_Texture; const srcrect: PSDL_FRect; left_width: Single; right_width: Single; top_height: Single; bottom_height: Single; scale: Single; const dstrect: PSDL_FRect): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_RenderTexture9Grid';

(**
 * Render a list of triangles, optionally using a texture and indices into the
 * vertex array Color and alpha modulation is done per vertex
 * (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).
 *
 * \param renderer the rendering context.
 * \param texture (optional) The SDL texture to use.
 * \param vertices vertices.
 * \param num_vertices number of vertices.
 * \param indices (optional) An array of integer indices into the 'vertices'
 *                array, if NULL all vertices will be rendered in sequential
 *                order.
 * \param num_indices number of indices.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_RenderGeometryRaw
 *)
function SDL_RenderGeometry(renderer: SDL_Renderer; texture: PSDL_Texture; const vertices: PSDL_Vertex; num_vertices: Integer; const indices: PInteger; num_indices: Integer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_RenderGeometry';

(**
 * Render a list of triangles, optionally using a texture and indices into the
 * vertex arrays Color and alpha modulation is done per vertex
 * (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).
 *
 * \param renderer the rendering context.
 * \param texture (optional) The SDL texture to use.
 * \param xy vertex positions.
 * \param xy_stride byte size to move from one element to the next element.
 * \param color vertex colors (as SDL_FColor).
 * \param color_stride byte size to move from one element to the next element.
 * \param uv vertex normalized texture coordinates.
 * \param uv_stride byte size to move from one element to the next element.
 * \param num_vertices number of vertices.
 * \param indices (optional) An array of indices into the 'vertices' arrays,
 *                if NULL all vertices will be rendered in sequential order.
 * \param num_indices number of indices.
 * \param size_indices index size: 1 (byte), 2 (short), 4 (int).
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_RenderGeometry
 *)
function SDL_RenderGeometryRaw(renderer: SDL_Renderer; texture: PSDL_Texture; const xy: PSingle; xy_stride: Integer; const color: PSDL_FColor; color_stride: Integer; const uv: PSingle; uv_stride: Integer; num_vertices: Integer; const indices: Pointer; num_indices: Integer; size_indices: Integer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_RenderGeometryRaw';

(**
 * Read pixels from the current rendering target.
 *
 * The returned surface should be freed with SDL_DestroySurface()
 *
 * **WARNING**: This is a very slow operation, and should not be used
 * frequently. If you're using this on the main rendering target, it should be
 * called after rendering and before SDL_RenderPresent().
 *
 * \param renderer the rendering context.
 * \param rect an SDL_Rect structure representing the area in pixels relative
 *             to the to current viewport, or NULL for the entire viewport.
 * \returns a new SDL_Surface on success or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_RenderReadPixels(renderer: SDL_Renderer; const rect: PSDL_Rect): PSDL_Surface; cdecl;
  external LIB_SDL3 name _PU + 'SDL_RenderReadPixels';

(**
 * Update the screen with any rendering performed since the previous call.
 *
 * SDL's rendering functions operate on a backbuffer; that is, calling a
 * rendering function such as SDL_RenderLine() does not directly put a line on
 * the screen, but rather updates the backbuffer. As such, you compose your
 * entire scene and *present* the composed backbuffer to the screen as a
 * complete picture.
 *
 * Therefore, when using SDL's rendering API, one does all drawing intended
 * for the frame, and then calls this function once per frame to present the
 * final drawing to the user.
 *
 * The backbuffer should be considered invalidated after each present; do not
 * assume that previous contents will exist between frames. You are strongly
 * encouraged to call SDL_RenderClear() to initialize the backbuffer before
 * starting each new frame's drawing, even if you plan to overwrite every
 * pixel.
 *
 * Please note, that in case of rendering to a texture - there is **no need**
 * to call `SDL_RenderPresent` after drawing needed objects to a texture, and
 * should not be done; you are only required to change back the rendering
 * target to default via `SDL_SetRenderTarget(renderer, NULL)` afterwards, as
 * textures by themselves do not have a concept of backbuffers. Calling
 * SDL_RenderPresent while rendering to a texture will still update the screen
 * with any current drawing that has been done _to the window itself_.
 *
 * \param renderer the rendering context.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CreateRenderer
 * \sa SDL_RenderClear
 * \sa SDL_RenderFillRect
 * \sa SDL_RenderFillRects
 * \sa SDL_RenderLine
 * \sa SDL_RenderLines
 * \sa SDL_RenderPoint
 * \sa SDL_RenderPoints
 * \sa SDL_RenderRect
 * \sa SDL_RenderRects
 * \sa SDL_SetRenderDrawBlendMode
 * \sa SDL_SetRenderDrawColor
 *)
function SDL_RenderPresent(renderer: SDL_Renderer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_RenderPresent';

(**
 * Destroy the specified texture.
 *
 * Passing NULL or an otherwise invalid texture will set the SDL error message
 * to "Invalid texture".
 *
 * \param texture the texture to destroy.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CreateTexture
 * \sa SDL_CreateTextureFromSurface
 *)
procedure SDL_DestroyTexture(texture: PSDL_Texture); cdecl;
  external LIB_SDL3 name _PU + 'SDL_DestroyTexture';

(**
 * Destroy the rendering context for a window and free all associated
 * textures.
 *
 * This should be called before destroying the associated window.
 *
 * \param renderer the rendering context.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CreateRenderer
 *)
procedure SDL_DestroyRenderer(renderer: SDL_Renderer); cdecl;
  external LIB_SDL3 name _PU + 'SDL_DestroyRenderer';

(**
 * Force the rendering context to flush any pending commands and state.
 *
 * You do not need to (and in fact, shouldn't) call this function unless you
 * are planning to call into OpenGL/Direct3D/Metal/whatever directly, in
 * addition to using an SDL_Renderer.
 *
 * This is for a very-specific case: if you are using SDL's render API, and
 * you plan to make OpenGL/D3D/whatever calls in addition to SDL render API
 * calls. If this applies, you should call this function between calls to
 * SDL's render API and the low-level API you're using in cooperation.
 *
 * In all other cases, you can ignore this function.
 *
 * This call makes SDL flush any pending rendering work it was queueing up to
 * do later in a single batch, and marks any internal cached state as invalid,
 * so it'll prepare all its state again later, from scratch.
 *
 * This means you do not need to save state in your rendering code to protect
 * the SDL renderer. However, there lots of arbitrary pieces of Direct3D and
 * OpenGL state that can confuse things; you should use your best judgment and
 * be prepared to make changes if specific state needs to be protected.
 *
 * \param renderer the rendering context.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_FlushRenderer(renderer: SDL_Renderer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_FlushRenderer';

(**
 * Get the CAMetalLayer associated with the given Metal renderer.
 *
 * This function returns `void *`, so SDL doesn't have to include Metal's
 * headers, but it can be safely cast to a `CAMetalLayer *`.
 *
 * \param renderer the renderer to query.
 * \returns a `CAMetalLayer *` on success, or NULL if the renderer isn't a
 *          Metal renderer.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetRenderMetalCommandEncoder
 *)
function SDL_GetRenderMetalLayer(renderer: SDL_Renderer): Pointer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetRenderMetalLayer';

(**
 * Get the Metal command encoder for the current frame.
 *
 * This function returns `void *`, so SDL doesn't have to include Metal's
 * headers, but it can be safely cast to an `id<MTLRenderCommandEncoder>`.
 *
 * This will return NULL if Metal refuses to give SDL a drawable to render to,
 * which might happen if the window is hidden/minimized/offscreen. This
 * doesn't apply to command encoders for render targets, just the window's
 * backbuffer. Check your return values!
 *
 * \param renderer the renderer to query.
 * \returns an `id<MTLRenderCommandEncoder>` on success, or NULL if the
 *          renderer isn't a Metal renderer or there was an error.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetRenderMetalLayer
 *)
function SDL_GetRenderMetalCommandEncoder(renderer: SDL_Renderer): Pointer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetRenderMetalCommandEncoder';

(**
 * Add a set of synchronization semaphores for the current frame.
 *
 * The Vulkan renderer will wait for `wait_semaphore` before submitting
 * rendering commands and signal `signal_semaphore` after rendering commands
 * are complete for this frame.
 *
 * This should be called each frame that you want semaphore synchronization.
 * The Vulkan renderer may have multiple frames in flight on the GPU, so you
 * should have multiple semaphores that are used for synchronization. Querying
 * SDL_PROP_RENDERER_VULKAN_SWAPCHAIN_IMAGE_COUNT_NUMBER will give you the
 * maximum number of semaphores you'll need.
 *
 * \param renderer the rendering context.
 * \param wait_stage_mask the VkPipelineStageFlags for the wait.
 * \param wait_semaphore a VkSempahore to wait on before rendering the current
 *                       frame, or 0 if not needed.
 * \param signal_semaphore a VkSempahore that SDL will signal when rendering
 *                         for the current frame is complete, or 0 if not
 *                         needed.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety It is **NOT** safe to call this function from two threads at
 *               once.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_AddVulkanRenderSemaphores(renderer: SDL_Renderer; wait_stage_mask: Uint32; wait_semaphore: Sint64; signal_semaphore: Sint64): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_AddVulkanRenderSemaphores';

(**
 * Toggle VSync of the given renderer.
 *
 * When a renderer is created, vsync defaults to SDL_RENDERER_VSYNC_DISABLED.
 *
 * The `vsync` parameter can be 1 to synchronize present with every vertical
 * refresh, 2 to synchronize present with every second vertical refresh, etc.,
 * SDL_RENDERER_VSYNC_ADAPTIVE for late swap tearing (adaptive vsync), or
 * SDL_RENDERER_VSYNC_DISABLED to disable. Not every value is supported by
 * every driver, so you should check the return value to see whether the
 * requested setting is supported.
 *
 * \param renderer the renderer to toggle.
 * \param vsync the vertical refresh sync interval.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetRenderVSync
 *)
function SDL_SetRenderVSync(renderer: SDL_Renderer; vsync: Integer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetRenderVSync';

const
  SDL_RENDERER_VSYNC_DISABLED = 0;
  SDL_RENDERER_VSYNC_ADAPTIVE = -1;

(**
 * Get VSync of the given renderer.
 *
 * \param renderer the renderer to toggle.
 * \param vsync an int filled with the current vertical refresh sync interval.
 *              See SDL_SetRenderVSync() for the meaning of the value.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetRenderVSync
 *)
function SDL_GetRenderVSync(renderer: SDL_Renderer; vsync: PInteger): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetRenderVSync';

const
  (**
   * The size, in pixels, of a single SDL_RenderDebugText() character.
   *
   * The font is monospaced and square, so this applies to all characters.
   *
   * \since This macro is available since SDL 3.2.0.
   *
   * \sa SDL_RenderDebugText
   *)
  SDL_DEBUG_TEXT_FONT_CHARACTER_SIZE = 8;

(**
 * Draw debug text to an SDL_Renderer.
 *
 * This function will render a string of text to an SDL_Renderer. Note that
 * this is a convenience function for debugging, with severe limitations, and
 * not intended to be used for production apps and games.
 *
 * Among these limitations:
 *
 * - It accepts UTF-8 strings, but will only renders ASCII characters.
 * - It has a single, tiny size (8x8 pixels). One can use logical presentation
 *   or scaling to adjust it, but it will be blurry.
 * - It uses a simple, hardcoded bitmap font. It does not allow different font
 *   selections and it does not support truetype, for proper scaling.
 * - It does no word-wrapping and does not treat newline characters as a line
 *   break. If the text goes out of the window, it's gone.
 *
 * For serious text rendering, there are several good options, such as
 * SDL_ttf, stb_truetype, or other external libraries.
 *
 * On first use, this will create an internal texture for rendering glyphs.
 * This texture will live until the renderer is destroyed.
 *
 * The text is drawn in the color specified by SDL_SetRenderDrawColor().
 *
 * \param renderer the renderer which should draw a line of text.
 * \param x the x coordinate where the top-left corner of the text will draw.
 * \param y the y coordinate where the top-left corner of the text will draw.
 * \param str the string to render.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_RenderDebugTextFormat
 * \sa SDL_DEBUG_TEXT_FONT_CHARACTER_SIZE
 *)
function SDL_RenderDebugText(renderer: SDL_Renderer; x: Single; y: Single; const str: PUTF8Char): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_RenderDebugText';

(**
 * Draw debug text to an SDL_Renderer.
 *
 * This function will render a printf()-style format string to a renderer.
 * Note that this is a convinence function for debugging, with severe
 * limitations, and is not intended to be used for production apps and games.
 *
 * For the full list of limitations and other useful information, see
 * SDL_RenderDebugText.
 *
 * \param renderer the renderer which should draw the text.
 * \param x the x coordinate where the top-left corner of the text will draw.
 * \param y the y coordinate where the top-left corner of the text will draw.
 * \param fmt the format string to draw.
 * \param ... additional parameters matching % tokens in the `fmt` string, if
 *            any.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_RenderDebugText
 * \sa SDL_DEBUG_TEXT_FONT_CHARACTER_SIZE
 *)
function SDL_RenderDebugTextFormat(renderer: SDL_Renderer; x: Single; y: Single; const fmt: PUTF8Char): Boolean varargs; cdecl;
  external LIB_SDL3 name _PU + 'SDL_RenderDebugTextFormat';
{$ENDREGION 'SDL_render.h'}

{$REGION 'SDL_storage.h'}
(**
 * # CategoryStorage
 *
 * The storage API is a high-level API designed to abstract away the
 * portability issues that come up when using something lower-level (in SDL's
 * case, this sits on top of the [Filesystem](CategoryFilesystem) and
 * [IOStream](CategoryIOStream) subsystems). It is significantly more
 * restrictive than a typical filesystem API, for a number of reasons:
 *
 * 1. **What to Access:** A common pitfall with existing filesystem APIs is
 * the assumption that all storage is monolithic. However, many other
 * platforms (game consoles in particular) are more strict about what _type_
 * of filesystem is being accessed; for example, game content and user data
 * are usually two separate storage devices with entirely different
 * characteristics (and possibly different low-level APIs altogether!).
 *
 * 2. **How to Access:** Another common mistake is applications assuming that
 * all storage is universally writeable - again, many platforms treat game
 * content and user data as two separate storage devices, and only user data
 * is writeable while game content is read-only.
 *
 * 3. **When to Access:** The most common portability issue with filesystem
 * access is _timing_ - you cannot always assume that the storage device is
 * always accessible all of the time, nor can you assume that there are no
 * limits to how long you have access to a particular device.
 *
 * Consider the following example:
 *
 * ```c
 * void ReadGameData(void)
 * {
 *     extern char** fileNames;
 *     extern size_t numFiles;
 *     for (size_t i = 0; i < numFiles; i += 1) {
 *         FILE *data = fopen(fileNames[i], "rwb");
 *         if (data == NULL) {
 *             // Something bad happened!
 *         } else {
 *             // A bunch of stuff happens here
 *             fclose(data);
 *         }
 *     }
 * }
 *
 * void ReadSave(void)
 * {
 *     FILE *save = fopen("saves/save0.sav", "rb");
 *     if (save == NULL) {
 *         // Something bad happened!
 *     } else {
 *         // A bunch of stuff happens here
 *         fclose(save);
 *     }
 * }
 *
 * void WriteSave(void)
 * {
 *     FILE *save = fopen("saves/save0.sav", "wb");
 *     if (save == NULL) {
 *         // Something bad happened!
 *     } else {
 *         // A bunch of stuff happens here
 *         fclose(save);
 *     }
 * }
 * ```
 *
 * Going over the bullet points again:
 *
 * 1. **What to Access:** This code accesses a global filesystem; game data
 * and saves are all presumed to be in the current working directory (which
 * may or may not be the game's installation folder!).
 *
 * 2. **How to Access:** This code assumes that content paths are writeable,
 * and that save data is also writeable despite being in the same location as
 * the game data.
 *
 * 3. **When to Access:** This code assumes that they can be called at any
 * time, since the filesystem is always accessible and has no limits on how
 * long the filesystem is being accessed.
 *
 * Due to these assumptions, the filesystem code is not portable and will fail
 * under these common scenarios:
 *
 * - The game is installed on a device that is read-only, both content loading
 *   and game saves will fail or crash outright
 * - Game/User storage is not implicitly mounted, so no files will be found
 *   for either scenario when a platform requires explicitly mounting
 *   filesystems
 * - Save data may not be safe since the I/O is not being flushed or
 *   validated, so an error occurring elsewhere in the program may result in
 *   missing/corrupted save data
 *
 * When using SDL_Storage, these types of problems are virtually impossible to
 * trip over:
 *
 * ```c
 * void ReadGameData(void)
 * {
 *     extern char** fileNames;
 *     extern size_t numFiles;
 *
 *     SDL_Storage *title = SDL_OpenTitleStorage(NULL, 0);
 *     if (title == NULL) {
 *         // Something bad happened!
 *     }
 *     while (!SDL_StorageReady(title)) {
 *         SDL_Delay(1);
 *     }
 *
 *     for (size_t i = 0; i < numFiles; i += 1) {
 *         void* dst;
 *         Uint64 dstLen = 0;
 *
 *         if (SDL_GetStorageFileSize(title, fileNames[i], &dstLen) && dstLen > 0) {
 *             dst = SDL_malloc(dstLen);
 *             if (SDL_ReadStorageFile(title, fileNames[i], dst, dstLen)) {
 *                 // A bunch of stuff happens here
 *             } else {
 *                 // Something bad happened!
 *             }
 *             SDL_free(dst);
 *         } else {
 *             // Something bad happened!
 *         }
 *     }
 *
 *     SDL_CloseStorage(title);
 * }
 *
 * void ReadSave(void)
 * {
 *     SDL_Storage *user = SDL_OpenUserStorage("libsdl", "Storage Example", 0);
 *     if (user == NULL) {
 *         // Something bad happened!
 *     }
 *     while (!SDL_StorageReady(user)) {
 *         SDL_Delay(1);
 *     }
 *
 *     Uint64 saveLen = 0;
 *     if (SDL_GetStorageFileSize(user, "save0.sav", &saveLen) && saveLen > 0) {
 *         void* dst = SDL_malloc(saveLen);
 *         if (SDL_ReadStorageFile(user, "save0.sav", dst, saveLen)) {
 *             // A bunch of stuff happens here
 *         } else {
 *             // Something bad happened!
 *         }
 *         SDL_free(dst);
 *     } else {
 *         // Something bad happened!
 *     }
 *
 *     SDL_CloseStorage(user);
 * }
 *
 * void WriteSave(void)
 * {
 *     SDL_Storage *user = SDL_OpenUserStorage("libsdl", "Storage Example", 0);
 *     if (user == NULL) {
 *         // Something bad happened!
 *     }
 *     while (!SDL_StorageReady(user)) {
 *         SDL_Delay(1);
 *     }
 *
 *     extern void *saveData; // A bunch of stuff happened here...
 *     extern Uint64 saveLen;
 *     if (!SDL_WriteStorageFile(user, "save0.sav", saveData, saveLen)) {
 *         // Something bad happened!
 *     }
 *
 *     SDL_CloseStorage(user);
 * }
 * ```
 *
 * Note the improvements that SDL_Storage makes:
 *
 * 1. **What to Access:** This code explicitly reads from a title or user
 * storage device based on the context of the function.
 *
 * 2. **How to Access:** This code explicitly uses either a read or write
 * function based on the context of the function.
 *
 * 3. **When to Access:** This code explicitly opens the device when it needs
 * to, and closes it when it is finished working with the filesystem.
 *
 * The result is an application that is significantly more robust against the
 * increasing demands of platforms and their filesystems!
 *
 * A publicly available example of an SDL_Storage backend is the
 * [Steam Cloud](https://partner.steamgames.com/doc/features/cloud)
 * backend - you can initialize Steamworks when starting the program, and then
 * SDL will recognize that Steamworks is initialized and automatically use
 * ISteamRemoteStorage when the application opens user storage. More
 * importantly, when you _open_ storage it knows to begin a "batch" of
 * filesystem operations, and when you _close_ storage it knows to end and
 * flush the batch. This is used by Steam to support
 * [Dynamic Cloud Sync](https://steamcommunity.com/groups/steamworks/announcements/detail/3142949576401813670)
 * ; users can save data on one PC, put the device to sleep, and then continue
 * playing on another PC (and vice versa) with the save data fully
 * synchronized across all devices, allowing for a seamless experience without
 * having to do full restarts of the program.
 *
 * ## Notes on valid paths
 *
 * All paths in the Storage API use Unix-style path separators ('/'). Using a
 * different path separator will not work, even if the underlying platform
 * would otherwise accept it. This is to keep code using the Storage API
 * portable between platforms and Storage implementations and simplify app
 * code.
 *
 * Paths with relative directories ("." and "..") are forbidden by the Storage
 * API.
 *
 * All valid UTF-8 strings (discounting the NULL terminator character and the
 * '/' path separator) are usable for filenames, however, an underlying
 * Storage implementation may not support particularly strange sequences and
 * refuse to create files with those names, etc.
 *)

type
  (**
   * Function interface for SDL_Storage.
   *
   * Apps that want to supply a custom implementation of SDL_Storage will fill
   * in all the functions in this struct, and then pass it to SDL_OpenStorage to
   * create a custom SDL_Storage object.
   *
   * It is not usually necessary to do this; SDL provides standard
   * implementations for many things you might expect to do with an SDL_Storage.
   *
   * This structure should be initialized using SDL_INIT_INTERFACE()
   *
   * \since This struct is available since SDL 3.2.0.
   *
   * \sa SDL_INIT_INTERFACE
   *)
  SDL_StorageInterface = record
    version: Uint32;
    close: function(userdata: Pointer): Boolean; cdecl;
    ready: function(userdata: Pointer): Boolean; cdecl;
    enumerate: function(userdata: Pointer; const path: PUTF8Char; callback: SDL_EnumerateDirectoryCallback; callback_userdata: Pointer): Boolean; cdecl;
    info: function(userdata: Pointer; const path: PUTF8Char; info: PSDL_PathInfo): Boolean; cdecl;
    read_file: function(userdata: Pointer; const path: PUTF8Char; destination: Pointer; length: Uint64): Boolean; cdecl;
    write_file: function(userdata: Pointer; const path: PUTF8Char; const source: Pointer; length: Uint64): Boolean; cdecl;
    mkdir: function(userdata: Pointer; const path: PUTF8Char): Boolean; cdecl;
    remove: function(userdata: Pointer; const path: PUTF8Char): Boolean; cdecl;
    rename: function(userdata: Pointer; const oldpath: PUTF8Char; const newpath: PUTF8Char): Boolean; cdecl;
    copy: function(userdata: Pointer; const oldpath: PUTF8Char; const newpath: PUTF8Char): Boolean; cdecl;
    space_remaining: function(userdata: Pointer): Uint64; cdecl;
  end;
  PSDL_StorageInterface = ^SDL_StorageInterface;

type
  (**
   * An abstract interface for filesystem access.
   *
   * This is an opaque datatype. One can create this object using standard SDL
   * functions like SDL_OpenTitleStorage or SDL_OpenUserStorage, etc, or create
   * an object with a custom implementation using SDL_OpenStorage.
   *
   * \since This struct is available since SDL 3.2.0.
   *)
  SDL_Storage = THandle;

(**
 * Opens up a read-only container for the application's filesystem.
 *
 * \param override a path to override the backend's default title root.
 * \param props a property list that may contain backend-specific information.
 * \returns a title storage container on success or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CloseStorage
 * \sa SDL_GetStorageFileSize
 * \sa SDL_OpenUserStorage
 * \sa SDL_ReadStorageFile
 *)
function SDL_OpenTitleStorage(const &override: PUTF8Char; props: SDL_PropertiesID): SDL_Storage; cdecl;
  external LIB_SDL3 name _PU + 'SDL_OpenTitleStorage';

(**
 * Opens up a container for a user's unique read/write filesystem.
 *
 * While title storage can generally be kept open throughout runtime, user
 * storage should only be opened when the client is ready to read/write files.
 * This allows the backend to properly batch file operations and flush them
 * when the container has been closed; ensuring safe and optimal save I/O.
 *
 * \param org the name of your organization.
 * \param app the name of your application.
 * \param props a property list that may contain backend-specific information.
 * \returns a user storage container on success or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CloseStorage
 * \sa SDL_GetStorageFileSize
 * \sa SDL_GetStorageSpaceRemaining
 * \sa SDL_OpenTitleStorage
 * \sa SDL_ReadStorageFile
 * \sa SDL_StorageReady
 * \sa SDL_WriteStorageFile
 *)
function SDL_OpenUserStorage(const org: PUTF8Char; const app: PUTF8Char; props: SDL_PropertiesID): SDL_Storage; cdecl;
  external LIB_SDL3 name _PU + 'SDL_OpenUserStorage';

(**
 * Opens up a container for local filesystem storage.
 *
 * This is provided for development and tools. Portable applications should
 * use SDL_OpenTitleStorage() for access to game data and
 * SDL_OpenUserStorage() for access to user data.
 *
 * \param path the base path prepended to all storage paths, or NULL for no
 *             base path.
 * \returns a filesystem storage container on success or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CloseStorage
 * \sa SDL_GetStorageFileSize
 * \sa SDL_GetStorageSpaceRemaining
 * \sa SDL_OpenTitleStorage
 * \sa SDL_OpenUserStorage
 * \sa SDL_ReadStorageFile
 * \sa SDL_WriteStorageFile
 *)
function SDL_OpenFileStorage(const path: PUTF8Char): SDL_Storage; cdecl;
  external LIB_SDL3 name _PU + 'SDL_OpenFileStorage';

(**
 * Opens up a container using a client-provided storage interface.
 *
 * Applications do not need to use this function unless they are providing
 * their own SDL_Storage implementation. If you just need an SDL_Storage, you
 * should use the built-in implementations in SDL, like SDL_OpenTitleStorage()
 * or SDL_OpenUserStorage().
 *
 * This function makes a copy of `iface` and the caller does not need to keep
 * it around after this call.
 *
 * \param iface the interface that implements this storage, initialized using
 *              SDL_INIT_INTERFACE().
 * \param userdata the pointer that will be passed to the interface functions.
 * \returns a storage container on success or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CloseStorage
 * \sa SDL_GetStorageFileSize
 * \sa SDL_GetStorageSpaceRemaining
 * \sa SDL_INIT_INTERFACE
 * \sa SDL_ReadStorageFile
 * \sa SDL_StorageReady
 * \sa SDL_WriteStorageFile
 *)
function SDL_OpenStorage(const iface: PSDL_StorageInterface; userdata: Pointer): SDL_Storage; cdecl;
  external LIB_SDL3 name _PU + 'SDL_OpenStorage';

(**
 * Closes and frees a storage container.
 *
 * \param storage a storage container to close.
 * \returns true if the container was freed with no errors, false otherwise;
 *          call SDL_GetError() for more information. Even if the function
 *          returns an error, the container data will be freed; the error is
 *          only for informational purposes.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_OpenFileStorage
 * \sa SDL_OpenStorage
 * \sa SDL_OpenTitleStorage
 * \sa SDL_OpenUserStorage
 *)
function SDL_CloseStorage(storage: SDL_Storage): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_CloseStorage';

(**
 * Checks if the storage container is ready to use.
 *
 * This function should be called in regular intervals until it returns true -
 * however, it is not recommended to spinwait on this call, as the backend may
 * depend on a synchronous message loop.
 *
 * \param storage a storage container to query.
 * \returns true if the container is ready, false otherwise.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_StorageReady(storage: SDL_Storage): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_StorageReady';

(**
 * Query the size of a file within a storage container.
 *
 * \param storage a storage container to query.
 * \param path the relative path of the file to query.
 * \param length a pointer to be filled with the file's length.
 * \returns true if the file could be queried or false on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_ReadStorageFile
 * \sa SDL_StorageReady
 *)
function SDL_GetStorageFileSize(storage: SDL_Storage; const path: PUTF8Char; length: PUint64): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetStorageFileSize';

(**
 * Synchronously read a file from a storage container into a client-provided
 * buffer.
 *
 * The value of `length` must match the length of the file exactly; call
 * SDL_GetStorageFileSize() to get this value. This behavior may be relaxed in
 * a future release.
 *
 * \param storage a storage container to read from.
 * \param path the relative path of the file to read.
 * \param destination a client-provided buffer to read the file into.
 * \param length the length of the destination buffer.
 * \returns true if the file was read or false on failure; call SDL_GetError()
 *          for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetStorageFileSize
 * \sa SDL_StorageReady
 * \sa SDL_WriteStorageFile
 *)
function SDL_ReadStorageFile(storage: SDL_Storage; const path: PUTF8Char; destination: Pointer; length: Uint64): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_ReadStorageFile';

(**
 * Synchronously write a file from client memory into a storage container.
 *
 * \param storage a storage container to write to.
 * \param path the relative path of the file to write.
 * \param source a client-provided buffer to write from.
 * \param length the length of the source buffer.
 * \returns true if the file was written or false on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetStorageSpaceRemaining
 * \sa SDL_ReadStorageFile
 * \sa SDL_StorageReady
 *)
function SDL_WriteStorageFile(storage: SDL_Storage; const path: PUTF8Char; const source: Pointer; length: Uint64): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_WriteStorageFile';

(**
 * Create a directory in a writable storage container.
 *
 * \param storage a storage container.
 * \param path the path of the directory to create.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_StorageReady
 *)
function SDL_CreateStorageDirectory(storage: SDL_Storage; const path: PUTF8Char): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_CreateStorageDirectory';

(**
 * Enumerate a directory in a storage container through a callback function.
 *
 * This function provides every directory entry through an app-provided
 * callback, called once for each directory entry, until all results have been
 * provided or the callback returns either SDL_ENUM_SUCCESS or
 * SDL_ENUM_FAILURE.
 *
 * This will return false if there was a system problem in general, or if a
 * callback returns SDL_ENUM_FAILURE. A successful return means a callback
 * returned SDL_ENUM_SUCCESS to halt enumeration, or all directory entries
 * were enumerated.
 *
 * If `path` is NULL, this is treated as a request to enumerate the root of
 * the storage container's tree. An empty string also works for this.
 *
 * \param storage a storage container.
 * \param path the path of the directory to enumerate, or NULL for the root.
 * \param callback a function that is called for each entry in the directory.
 * \param userdata a pointer that is passed to `callback`.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_StorageReady
 *)
function SDL_EnumerateStorageDirectory(storage: SDL_Storage; const path: PUTF8Char; callback: SDL_EnumerateDirectoryCallback; userdata: Pointer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_EnumerateStorageDirectory';

(**
 * Remove a file or an empty directory in a writable storage container.
 *
 * \param storage a storage container.
 * \param path the path of the directory to enumerate.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_StorageReady
 *)
function SDL_RemoveStoragePath(storage: SDL_Storage; const path: PUTF8Char): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_RemoveStoragePath';

(**
 * Rename a file or directory in a writable storage container.
 *
 * \param storage a storage container.
 * \param oldpath the old path.
 * \param newpath the new path.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_StorageReady
 *)
function SDL_RenameStoragePath(storage: SDL_Storage; const oldpath: PUTF8Char; const newpath: PUTF8Char): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_RenameStoragePath';

(**
 * Copy a file in a writable storage container.
 *
 * \param storage a storage container.
 * \param oldpath the old path.
 * \param newpath the new path.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_StorageReady
 *)
function SDL_CopyStorageFile(storage: SDL_Storage; const oldpath: PUTF8Char; const newpath: PUTF8Char): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_CopyStorageFile';

(**
 * Get information about a filesystem path in a storage container.
 *
 * \param storage a storage container.
 * \param path the path to query.
 * \param info a pointer filled in with information about the path, or NULL to
 *             check for the existence of a file.
 * \returns true on success or false if the file doesn't exist, or another
 *          failure; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_StorageReady
 *)
function SDL_GetStoragePathInfo(storage: SDL_Storage; const path: PUTF8Char; info: PSDL_PathInfo): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetStoragePathInfo';

(**
 * Queries the remaining space in a storage container.
 *
 * \param storage a storage container to query.
 * \returns the amount of remaining space, in bytes.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_StorageReady
 * \sa SDL_WriteStorageFile
 *)
function SDL_GetStorageSpaceRemaining(storage: SDL_Storage): Uint64; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetStorageSpaceRemaining';

(**
 * Enumerate a directory tree, filtered by pattern, and return a list.
 *
 * Files are filtered out if they don't match the string in `pattern`, which
 * may contain wildcard characters '*' (match everything) and '?' (match one
 * character). If pattern is NULL, no filtering is done and all results are
 * returned. Subdirectories are permitted, and are specified with a path
 * separator of '/'. Wildcard characters '*' and '?' never match a path
 * separator.
 *
 * `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching
 * case-insensitive.
 *
 * The returned array is always NULL-terminated, for your iterating
 * convenience, but if `count` is non-NULL, on return it will contain the
 * number of items in the array, not counting the NULL terminator.
 *
 * If `path` is NULL, this is treated as a request to enumerate the root of
 * the storage container's tree. An empty string also works for this.
 *
 * \param storage a storage container.
 * \param path the path of the directory to enumerate, or NULL for the root.
 * \param pattern the pattern that files in the directory must match. Can be
 *                NULL.
 * \param flags `SDL_GLOB_*` bitflags that affect this search.
 * \param count on return, will be set to the number of items in the returned
 *              array. Can be NULL.
 * \returns an array of strings on success or NULL on failure; call
 *          SDL_GetError() for more information. The caller should pass the
 *          returned pointer to SDL_free when done with it. This is a single
 *          allocation that should be freed with SDL_free() when it is no
 *          longer needed.
 *
 * \threadsafety It is safe to call this function from any thread, assuming
 *               the `storage` object is thread-safe.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GlobStorageDirectory(storage: SDL_Storage; const path: PUTF8Char; const pattern: PUTF8Char; flags: SDL_GlobFlags; count: PInteger): PPUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GlobStorageDirectory';
{$ENDREGION 'SDL_storage.h'}

{$REGION 'SDL_system.h'}
(**
 * # CategorySystem
 *
 * Platform-specific SDL API functions. These are functions that deal with
 * needs of specific operating systems, that didn't make sense to offer as
 * platform-independent, generic APIs.
 *
 * Most apps can make do without these functions, but they can be useful for
 * integrating with other parts of a specific system, adding platform-specific
 * polish to an app, or solving problems that only affect one target.
 *)

{$IF Defined(MSWINDOWS)}
type
  PMSG = Pointer;

type
  (**
   * A callback to be used with SDL_SetWindowsMessageHook.
   *
   * This callback may modify the message, and should return true if the message
   * should continue to be processed, or false to prevent further processing.
   *
   * As this is processing a message directly from the Windows event loop, this
   * callback should do the minimum required work and return quickly.
   *
   * \param userdata the app-defined pointer provided to
   *                 SDL_SetWindowsMessageHook.
   * \param msg a pointer to a Win32 event structure to process.
   * \returns true to let event continue on, false to drop it.
   *
   * \threadsafety This may only be called (by SDL) from the thread handling the
   *               Windows event loop.
   *
   * \since This datatype is available since SDL 3.2.0.
   *
   * \sa SDL_SetWindowsMessageHook
   * \sa SDL_HINT_WINDOWS_ENABLE_MESSAGELOOP
   *)
  SDL_WindowsMessageHook = function(userdata: Pointer; msg: PMSG): Boolean; cdecl;

(**
 * Set a callback for every Windows message, run before TranslateMessage().
 *
 * The callback may modify the message, and should return true if the message
 * should continue to be processed, or false to prevent further processing.
 *
 * \param callback the SDL_WindowsMessageHook function to call.
 * \param userdata a pointer to pass to every iteration of `callback`.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_WindowsMessageHook
 * \sa SDL_HINT_WINDOWS_ENABLE_MESSAGELOOP
 *)
procedure SDL_SetWindowsMessageHook(callback: SDL_WindowsMessageHook; userdata: Pointer); cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetWindowsMessageHook';

(**
 * Get the D3D9 adapter index that matches the specified display.
 *
 * The returned adapter index can be passed to `IDirect3D9::CreateDevice` and
 * controls on which monitor a full screen application will appear.
 *
 * \param displayID the instance of the display to query.
 * \returns the D3D9 adapter index on success or -1 on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetDirect3D9AdapterIndex(displayID: SDL_DisplayID): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetDirect3D9AdapterIndex';

(**
 * Get the DXGI Adapter and Output indices for the specified display.
 *
 * The DXGI Adapter and Output indices can be passed to `EnumAdapters` and
 * `EnumOutputs` respectively to get the objects required to create a DX10 or
 * DX11 device and swap chain.
 *
 * \param displayID the instance of the display to query.
 * \param adapterIndex a pointer to be filled in with the adapter index.
 * \param outputIndex a pointer to be filled in with the output index.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetDXGIOutputInfo(displayID: SDL_DisplayID; adapterIndex: PInteger; outputIndex: PInteger): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetDXGIOutputInfo';
{$ELSEIF Defined(IOS)}
type
  (**
   * The prototype for an Apple iOS animation callback.
   *
   * This datatype is only useful on Apple iOS.
   *
   * After passing a function pointer of this type to
   * SDL_SetiOSAnimationCallback, the system will call that function pointer at
   * a regular interval.
   *
   * \param userdata what was passed as `callbackParam` to
   *                 SDL_SetiOSAnimationCallback as `callbackParam`.
   *
   * \since This datatype is available since SDL 3.2.0.
   *
   * \sa SDL_SetiOSAnimationCallback
   *)
  SDL_iOSAnimationCallback = procedure(userdata: Pointer); cdecl;

(**
 * Use this function to set the animation callback on Apple iOS.
 *
 * The function prototype for `callback` is:
 *
 * ```c
 * void callback(void *callbackParam);
 * ```
 *
 * Where its parameter, `callbackParam`, is what was passed as `callbackParam`
 * to SDL_SetiOSAnimationCallback().
 *
 * This function is only available on Apple iOS.
 *
 * For more information see:
 *
 * https://wiki.libsdl.org/SDL3/README/ios
 *
 * Note that if you use the "main callbacks" instead of a standard C `main`
 * function, you don't have to use this API, as SDL will manage this for you.
 *
 * Details on main callbacks are here:
 *
 * https://wiki.libsdl.org/SDL3/README/main-functions
 *
 * \param window the window for which the animation callback should be set.
 * \param interval the number of frames after which **callback** will be
 *                 called.
 * \param callback the function to call for every frame.
 * \param callbackParam a pointer that is passed to `callback`.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetiOSEventPump
 *)
function SDL_SetiOSAnimationCallback(window: SDL_Window; interval: Integer; callback: SDL_iOSAnimationCallback; callbackParam: Pointer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetiOSAnimationCallback';

(**
 * Use this function to enable or disable the SDL event pump on Apple iOS.
 *
 * This function is only available on Apple iOS.
 *
 * \param enabled true to enable the event pump, false to disable it.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_SetiOSAnimationCallback
 *)
procedure SDL_SetiOSEventPump(enabled: Boolean); cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetiOSEventPump';

(**
 * Let iOS apps with external event handling report
 * onApplicationDidChangeStatusBarOrientation.
 *
 * This functions allows iOS apps that have their own event handling to hook
 * into SDL to generate SDL events. This maps directly to an iOS-specific
 * event, but since it doesn't do anything iOS-specific internally, it is
 * available on all platforms, in case it might be useful for some specific
 * paradigm. Most apps do not need to use this directly; SDL's internal event
 * code will handle all this for windows created by SDL_CreateWindow!
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_OnApplicationDidChangeStatusBarOrientation; cdecl;
  external LIB_SDL3 name _PU + 'SDL_OnApplicationDidChangeStatusBarOrientation';
{$ELSEIF Defined(ANDROID)}
(**
 * Get the Android Java Native Interface Environment of the current thread.
 *
 * This is the JNIEnv one needs to access the Java virtual machine from native
 * code, and is needed for many Android APIs to be usable from C.
 *
 * The prototype of the function in SDL's code actually declare a void* return
 * type, even if the implementation returns a pointer to a JNIEnv. The
 * rationale being that the SDL headers can avoid including jni.h.
 *
 * \returns a pointer to Java native interface object (JNIEnv) to which the
 *          current thread is attached, or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetAndroidActivity
 *)
function SDL_GetAndroidJNIEnv(): Pointer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetAndroidJNIEnv';

(**
 * Retrieve the Java instance of the Android activity class.
 *
 * The prototype of the function in SDL's code actually declares a void*
 * return type, even if the implementation returns a jobject. The rationale
 * being that the SDL headers can avoid including jni.h.
 *
 * The jobject returned by the function is a local reference and must be
 * released by the caller. See the PushLocalFrame() and PopLocalFrame() or
 * DeleteLocalRef() functions of the Java native interface:
 *
 * https://docs.oracle.com/javase/1.5.0/docs/guide/jni/spec/functions.html
 *
 * \returns the jobject representing the instance of the Activity class of the
 *          Android application, or NULL on failure; call SDL_GetError() for
 *          more information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetAndroidJNIEnv
 *)
function SDL_GetAndroidActivity(): Pointer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetAndroidActivity';

(**
 * Query Android API level of the current device.
 *
 * - API level 35: Android 15 (VANILLA_ICE_CREAM)
 * - API level 34: Android 14 (UPSIDE_DOWN_CAKE)
 * - API level 33: Android 13 (TIRAMISU)
 * - API level 32: Android 12L (S_V2)
 * - API level 31: Android 12 (S)
 * - API level 30: Android 11 (R)
 * - API level 29: Android 10 (Q)
 * - API level 28: Android 9 (P)
 * - API level 27: Android 8.1 (O_MR1)
 * - API level 26: Android 8.0 (O)
 * - API level 25: Android 7.1 (N_MR1)
 * - API level 24: Android 7.0 (N)
 * - API level 23: Android 6.0 (M)
 * - API level 22: Android 5.1 (LOLLIPOP_MR1)
 * - API level 21: Android 5.0 (LOLLIPOP, L)
 * - API level 20: Android 4.4W (KITKAT_WATCH)
 * - API level 19: Android 4.4 (KITKAT)
 * - API level 18: Android 4.3 (JELLY_BEAN_MR2)
 * - API level 17: Android 4.2 (JELLY_BEAN_MR1)
 * - API level 16: Android 4.1 (JELLY_BEAN)
 * - API level 15: Android 4.0.3 (ICE_CREAM_SANDWICH_MR1)
 * - API level 14: Android 4.0 (ICE_CREAM_SANDWICH)
 * - API level 13: Android 3.2 (HONEYCOMB_MR2)
 * - API level 12: Android 3.1 (HONEYCOMB_MR1)
 * - API level 11: Android 3.0 (HONEYCOMB)
 * - API level 10: Android 2.3.3 (GINGERBREAD_MR1)
 *
 * \returns the Android API level.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetAndroidSDKVersion(): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetAndroidSDKVersion';

(**
 * Query if the application is running on a Chromebook.
 *
 * \returns true if this is a Chromebook, false otherwise.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_IsChromebook(): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_IsChromebook';

(**
 * Query if the application is running on a Samsung DeX docking station.
 *
 * \returns true if this is a DeX docking station, false otherwise.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_IsDeXMode(): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_IsDeXMode';

(**
 * Trigger the Android system back button behavior.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_SendAndroidBackButton(); cdecl;
  external LIB_SDL3 name _PU + 'SDL_SendAndroidBackButton';

const
  (**
   * See the official Android developer guide for more information:
   * http://developer.android.com/guide/topics/data/data-storage.html
   *
   * \since This macro is available since SDL 3.2.0.
   *)
  SDL_ANDROID_EXTERNAL_STORAGE_READ = $01;

  (**
   * See the official Android developer guide for more information:
   * http://developer.android.com/guide/topics/data/data-storage.html
   *
   * \since This macro is available since SDL 3.2.0.
   *)
  SDL_ANDROID_EXTERNAL_STORAGE_WRITE = $02;

(**
 * Get the path used for internal storage for this Android application.
 *
 * This path is unique to your application and cannot be written to by other
 * applications.
 *
 * Your internal storage path is typically:
 * `/data/data/your.app.package/files`.
 *
 * This is a C wrapper over `android.content.Context.getFilesDir()`:
 *
 * https://developer.android.com/reference/android/content/Context#getFilesDir()
 *
 * \returns the path used for internal storage or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetAndroidExternalStoragePath
 * \sa SDL_GetAndroidCachePath
 *)
function SDL_GetAndroidInternalStoragePath(): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetAndroidInternalStoragePath';

(**
 * Get the current state of external storage for this Android application.
 *
 * The current state of external storage, a bitmask of these values:
 * `SDL_ANDROID_EXTERNAL_STORAGE_READ`, `SDL_ANDROID_EXTERNAL_STORAGE_WRITE`.
 *
 * If external storage is currently unavailable, this will return 0.
 *
 * \returns the current state of external storage, or 0 if external storage is
 *          currently unavailable.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetAndroidExternalStoragePath
 *)
function SDL_GetAndroidExternalStorageState(): UInt32; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetAndroidExternalStorageState';

(**
 * Get the path used for external storage for this Android application.
 *
 * This path is unique to your application, but is public and can be written
 * to by other applications.
 *
 * Your external storage path is typically:
 * `/storage/sdcard0/Android/data/your.app.package/files`.
 *
 * This is a C wrapper over `android.content.Context.getExternalFilesDir()`:
 *
 * https://developer.android.com/reference/android/content/Context#getExternalFilesDir()
 *
 * \returns the path used for external storage for this application on success
 *          or NULL on failure; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetAndroidExternalStorageState
 * \sa SDL_GetAndroidInternalStoragePath
 * \sa SDL_GetAndroidCachePath
 *)
function SDL_GetAndroidExternalStoragePath(): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetAndroidExternalStoragePath';

(**
 * Get the path used for caching data for this Android application.
 *
 * This path is unique to your application, but is public and can be written
 * to by other applications.
 *
 * Your cache path is typically: `/data/data/your.app.package/cache/`.
 *
 * This is a C wrapper over `android.content.Context.getCacheDir()`:
 *
 * https://developer.android.com/reference/android/content/Context#getCacheDir()
 *
 * \returns the path used for caches for this application on success or NULL
 *          on failure; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetAndroidInternalStoragePath
 * \sa SDL_GetAndroidExternalStoragePath
 *)
function SDL_GetAndroidCachePath(): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetAndroidCachePath';

type
  (**
   * Callback that presents a response from a SDL_RequestAndroidPermission call.
   *
   * \param userdata an app-controlled pointer that is passed to the callback.
   * \param permission the Android-specific permission name that was requested.
   * \param granted true if permission is granted, false if denied.
   *
   * \since This datatype is available since SDL 3.2.0.
   *
   * \sa SDL_RequestAndroidPermission
   *)
  SDL_RequestAndroidPermissionCallback = procedure(userdata: Pointer; const permission: PUTF8Char; granted: Boolean); cdecl;

(**
 * Request permissions at runtime, asynchronously.
 *
 * You do not need to call this for built-in functionality of SDL; recording
 * from a microphone or reading images from a camera, using standard SDL APIs,
 * will manage permission requests for you.
 *
 * This function never blocks. Instead, the app-supplied callback will be
 * called when a decision has been made. This callback may happen on a
 * different thread, and possibly much later, as it might wait on a user to
 * respond to a system dialog. If permission has already been granted for a
 * specific entitlement, the callback will still fire, probably on the current
 * thread and before this function returns.
 *
 * If the request submission fails, this function returns -1 and the callback
 * will NOT be called, but this should only happen in catastrophic conditions,
 * like memory running out. Normally there will be a yes or no to the request
 * through the callback.
 *
 * For the `permission` parameter, choose a value from here:
 *
 * https://developer.android.com/reference/android/Manifest.permission
 *
 * \param permission the permission to request.
 * \param cb the callback to trigger when the request has a response.
 * \param userdata an app-controlled pointer that is passed to the callback.
 * \returns true if the request was submitted, false if there was an error
 *          submitting. The result of the request is only ever reported
 *          through the callback, not this return value.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_RequestAndroidPermission(const permission: PUTF8Char; cb: SDL_RequestAndroidPermissionCallback; userdata: Pointer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_RequestAndroidPermission';

(**
 * Shows an Android toast notification.
 *
 * Toasts are a sort of lightweight notification that are unique to Android.
 *
 * https://developer.android.com/guide/topics/ui/notifiers/toasts
 *
 * Shows toast in UI thread.
 *
 * For the `gravity` parameter, choose a value from here, or -1 if you don't
 * have a preference:
 *
 * https://developer.android.com/reference/android/view/Gravity
 *
 * \param message text message to be shown.
 * \param duration 0=short, 1=long.
 * \param gravity where the notification should appear on the screen.
 * \param xoffset set this parameter only when gravity >=0.
 * \param yoffset set this parameter only when gravity >=0.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_ShowAndroidToast(const message: PUTF8Char; duration, gravity, xoffset, yoffset: Integer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_ShowAndroidToast';

(**
 * Send a user command to SDLActivity.
 *
 * Override "boolean onUnhandledMessage(Message msg)" to handle the message.
 *
 * \param command user command that must be greater or equal to 0x8000.
 * \param param user parameter.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_SendAndroidMessage(command: Uint32; param: Integer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_SendAndroidMessage';
{$ENDIF}

(**
 * Query if the current device is a tablet.
 *
 * If SDL can't determine this, it will return false.
 *
 * \returns true if the device is a tablet, false otherwise.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_IsTablet(): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_IsTablet';

(**
 * Query if the current device is a TV.
 *
 * If SDL can't determine this, it will return false.
 *
 * \returns true if the device is a TV, false otherwise.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_IsTV(): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_IsTV';

(**
 * Application sandbox environment.
 *
 * \since This enum is available since SDL 3.2.0.
 *)
type
  SDL_Sandbox = Integer;

const
  SDL_SANDBOX_NONE = 0;
  SDL_SANDBOX_UNKNOWN_CONTAINER = 1;
  SDL_SANDBOX_FLATPAK = 2;
  SDL_SANDBOX_SNAP = 3;
  SDL_SANDBOX_MACOS = 4;

(**
 * Get the application sandbox environment, if any.
 *
 * \returns the application sandbox environment or SDL_SANDBOX_NONE if the
 *          application is not running in a sandbox environment.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetSandbox(): SDL_Sandbox; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetSandbox';

(**
 * Let iOS apps with external event handling report
 * onApplicationWillTerminate.
 *
 * This functions allows iOS apps that have their own event handling to hook
 * into SDL to generate SDL events. This maps directly to an iOS-specific
 * event, but since it doesn't do anything iOS-specific internally, it is
 * available on all platforms, in case it might be useful for some specific
 * paradigm. Most apps do not need to use this directly; SDL's internal event
 * code will handle all this for windows created by SDL_CreateWindow!
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_OnApplicationWillTerminate(); cdecl;
  external LIB_SDL3 name _PU + 'SDL_OnApplicationWillTerminate';

(**
 * Let iOS apps with external event handling report
 * onApplicationDidReceiveMemoryWarning.
 *
 * This functions allows iOS apps that have their own event handling to hook
 * into SDL to generate SDL events. This maps directly to an iOS-specific
 * event, but since it doesn't do anything iOS-specific internally, it is
 * available on all platforms, in case it might be useful for some specific
 * paradigm. Most apps do not need to use this directly; SDL's internal event
 * code will handle all this for windows created by SDL_CreateWindow!
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_OnApplicationDidReceiveMemoryWarning(); cdecl;
  external LIB_SDL3 name _PU + 'SDL_OnApplicationDidReceiveMemoryWarning';

(**
 * Let iOS apps with external event handling report
 * onApplicationWillResignActive.
 *
 * This functions allows iOS apps that have their own event handling to hook
 * into SDL to generate SDL events. This maps directly to an iOS-specific
 * event, but since it doesn't do anything iOS-specific internally, it is
 * available on all platforms, in case it might be useful for some specific
 * paradigm. Most apps do not need to use this directly; SDL's internal event
 * code will handle all this for windows created by SDL_CreateWindow!
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_OnApplicationWillEnterBackground(); cdecl;
  external LIB_SDL3 name _PU + 'SDL_OnApplicationWillEnterBackground';

(**
 * Let iOS apps with external event handling report
 * onApplicationDidEnterBackground.
 *
 * This functions allows iOS apps that have their own event handling to hook
 * into SDL to generate SDL events. This maps directly to an iOS-specific
 * event, but since it doesn't do anything iOS-specific internally, it is
 * available on all platforms, in case it might be useful for some specific
 * paradigm. Most apps do not need to use this directly; SDL's internal event
 * code will handle all this for windows created by SDL_CreateWindow!
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_OnApplicationDidEnterBackground(); cdecl;
  external LIB_SDL3 name _PU + 'SDL_OnApplicationDidEnterBackground';

(**
 * Let iOS apps with external event handling report
 * onApplicationWillEnterForeground.
 *
 * This functions allows iOS apps that have their own event handling to hook
 * into SDL to generate SDL events. This maps directly to an iOS-specific
 * event, but since it doesn't do anything iOS-specific internally, it is
 * available on all platforms, in case it might be useful for some specific
 * paradigm. Most apps do not need to use this directly; SDL's internal event
 * code will handle all this for windows created by SDL_CreateWindow!
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_OnApplicationWillEnterForeground(); cdecl;
  external LIB_SDL3 name _PU + 'SDL_OnApplicationWillEnterForeground';

(**
 * Let iOS apps with external event handling report
 * onApplicationDidBecomeActive.
 *
 * This functions allows iOS apps that have their own event handling to hook
 * into SDL to generate SDL events. This maps directly to an iOS-specific
 * event, but since it doesn't do anything iOS-specific internally, it is
 * available on all platforms, in case it might be useful for some specific
 * paradigm. Most apps do not need to use this directly; SDL's internal event
 * code will handle all this for windows created by SDL_CreateWindow!
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_OnApplicationDidEnterForeground(); cdecl;
  external LIB_SDL3 name _PU + 'SDL_OnApplicationDidEnterForeground';
{$ENDREGION 'SDL_system.h'}

{$REGION 'SDL_time.h'}
(**
 * # CategoryTime
 *
 * SDL realtime clock and date/time routines.
 *
 * There are two data types that are used in this category: SDL_Time, which
 * represents the nanoseconds since a specific moment (an "epoch"), and
 * SDL_DateTime, which breaks time down into human-understandable components:
 * years, months, days, hours, etc.
 *
 * Much of the functionality is involved in converting those two types to
 * other useful forms.
 *)

type
  (**
   * A structure holding a calendar date and time broken down into its
   * components.
   *
   * \since This struct is available since SDL 3.2.0.
   *)
  SDL_DateTime = record
    (** Year *)
    year: Integer;
    (** Month [01-12] *)
    month: Integer;
    (** Day of the month [01-31] *)
    day: Integer;
    (** Hour [0-23] *)
    hour: Integer;
    (** Minute [0-59] *)
    minute: Integer;
    (** Seconds [0-60] *)
    second: Integer;
    (** Nanoseconds [0-999999999] *)
    nanosecond: Integer;
    (** Day of the week [0-6] (0 being Sunday) *)
    day_of_week: Integer;
    (** Seconds east of UTC *)
    utc_offset: Integer;
  end;
  PSDL_DateTime = ^SDL_DateTime;

(**
 * The preferred date format of the current system locale.
 *
 * \since This enum is available since SDL 3.2.0.
 *
 * \sa SDL_GetDateTimeLocalePreferences
 *)
type
  SDL_DateFormat = Integer;
  PSDL_DateFormat = ^SDL_DateFormat;

const
  (** Year/Month/Day *)
  SDL_DATE_FORMAT_YYYYMMDD = 0;
  (** Day/Month/Year *)
  SDL_DATE_FORMAT_DDMMYYYY = 1;
  (** Month/Day/Year *)
  SDL_DATE_FORMAT_MMDDYYYY = 2;

(**
 * The preferred time format of the current system locale.
 *
 * \since This enum is available since SDL 3.2.0.
 *
 * \sa SDL_GetDateTimeLocalePreferences
 *)
type
  SDL_TimeFormat = Integer;
  PSDL_TimeFormat = ^SDL_TimeFormat;

const
  (** 24 hour time *)
  SDL_TIME_FORMAT_24HR = 0;
  (** 12 hour time *)
  SDL_TIME_FORMAT_12HR = 1;

(**
 * Gets the current preferred date and time format for the system locale.
 *
 * This might be a "slow" call that has to query the operating system. It's
 * best to ask for this once and save the results. However, the preferred
 * formats can change, usually because the user has changed a system
 * preference outside of your program.
 *
 * \param dateFormat a pointer to the SDL_DateFormat to hold the returned date
 *                   format, may be NULL.
 * \param timeFormat a pointer to the SDL_TimeFormat to hold the returned time
 *                   format, may be NULL.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetDateTimeLocalePreferences(dateFormat: PSDL_DateFormat; timeFormat: PSDL_TimeFormat): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetDateTimeLocalePreferences';

(**
 * Gets the current value of the system realtime clock in nanoseconds since
 * Jan 1, 1970 in Universal Coordinated Time (UTC).
 *
 * \param ticks the SDL_Time to hold the returned tick count.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetCurrentTime(ticks: PSDL_Time): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetCurrentTime';

(**
 * Converts an SDL_Time in nanoseconds since the epoch to a calendar time in
 * the SDL_DateTime format.
 *
 * \param ticks the SDL_Time to be converted.
 * \param dt the resulting SDL_DateTime.
 * \param localTime the resulting SDL_DateTime will be expressed in local time
 *                  if true, otherwise it will be in Universal Coordinated
 *                  Time (UTC).
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_TimeToDateTime(ticks: SDL_Time; dt: PSDL_DateTime; localTime: Boolean): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_TimeToDateTime';

(**
 * Converts a calendar time to an SDL_Time in nanoseconds since the epoch.
 *
 * This function ignores the day_of_week member of the SDL_DateTime struct, so
 * it may remain unset.
 *
 * \param dt the source SDL_DateTime.
 * \param ticks the resulting SDL_Time.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_DateTimeToTime(const dt: PSDL_DateTime; ticks: PSDL_Time): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_DateTimeToTime';

(**
 * Converts an SDL time into a Windows FILETIME (100-nanosecond intervals
 * since January 1, 1601).
 *
 * This function fills in the two 32-bit values of the FILETIME structure.
 *
 * \param ticks the time to convert.
 * \param dwLowDateTime a pointer filled in with the low portion of the
 *                      Windows FILETIME value.
 * \param dwHighDateTime a pointer filled in with the high portion of the
 *                       Windows FILETIME value.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_TimeToWindows(ticks: SDL_Time; dwLowDateTime: PUint32; dwHighDateTime: PUint32); cdecl;
  external LIB_SDL3 name _PU + 'SDL_TimeToWindows';

(**
 * Converts a Windows FILETIME (100-nanosecond intervals since January 1,
 * 1601) to an SDL time.
 *
 * This function takes the two 32-bit values of the FILETIME structure as
 * parameters.
 *
 * \param dwLowDateTime the low portion of the Windows FILETIME value.
 * \param dwHighDateTime the high portion of the Windows FILETIME value.
 * \returns the converted SDL time.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_TimeFromWindows(dwLowDateTime: Uint32; dwHighDateTime: Uint32): SDL_Time; cdecl;
  external LIB_SDL3 name _PU + 'SDL_TimeFromWindows';

(**
 * Get the number of days in a month for a given year.
 *
 * \param year the year.
 * \param month the month [1-12].
 * \returns the number of days in the requested month or -1 on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetDaysInMonth(year: Integer; month: Integer): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetDaysInMonth';

(**
 * Get the day of year for a calendar date.
 *
 * \param year the year component of the date.
 * \param month the month component of the date.
 * \param day the day component of the date.
 * \returns the day of year [0-365] if the date is valid or -1 on failure;
 *          call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetDayOfYear(year: Integer; month: Integer; day: Integer): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetDayOfYear';

(**
 * Get the day of week for a calendar date.
 *
 * \param year the year component of the date.
 * \param month the month component of the date.
 * \param day the day component of the date.
 * \returns a value between 0 and 6 (0 being Sunday) if the date is valid or
 *          -1 on failure; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetDayOfWeek(year: Integer; month: Integer; day: Integer): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetDayOfWeek';
{$ENDREGION 'SDL_time.h'}

{$REGION 'SDL_timer.h'}
(**
 * # CategoryTimer
 *
 * SDL provides time management functionality. It is useful for dealing with
 * (usually) small durations of time.
 *
 * This is not to be confused with _calendar time_ management, which is
 * provided by [CategoryTime](CategoryTime).
 *
 * This category covers measuring time elapsed (SDL_GetTicks(),
 * SDL_GetPerformanceCounter()), putting a thread to sleep for a certain
 * amount of time (SDL_Delay(), SDL_DelayNS(), SDL_DelayPrecise()), and firing
 * a callback function after a certain amount of time has elasped
 * (SDL_AddTimer(), etc).
 *
 * There are also useful macros to convert between time units, like
 * SDL_SECONDS_TO_NS() and such.
 *)

const
  (**
   * Number of milliseconds in a second.
   *
   * This is always 1000.
   *
   * \since This macro is available since SDL 3.2.0.
   *)
  SDL_MS_PER_SECOND = 1000;

  (**
   * Number of microseconds in a second.
   *
   * This is always 1000000.
   *
   * \since This macro is available since SDL 3.2.0.
   *)
  SDL_US_PER_SECOND = 1000000;

  (**
   * Number of nanoseconds in a second.
   *
   * This is always 1000000000.
   *
   * \since This macro is available since SDL 3.2.0.
   *)
  SDL_NS_PER_SECOND = 1000000000;

  (**
   * Number of nanoseconds in a millisecond.
   *
   * This is always 1000000.
   *
   * \since This macro is available since SDL 3.2.0.
   *)
  SDL_NS_PER_MS = 1000000;

  (**
   * Number of nanoseconds in a microsecond.
   *
   * This is always 1000.
   *
   * \since This macro is available since SDL 3.2.0.
   *)
  SDL_NS_PER_US = 1000;

(**
 * Convert seconds to nanoseconds.
 *
 * This only converts whole numbers, not fractional seconds.
 *
 * \param S the number of seconds to convert.
 * \returns S, expressed in nanoseconds.
 *
 * \threadsafety It is safe to call this macro from any thread.
 *
 * \since This macro is available since SDL 3.2.0.
 *)
function SDL_SecondsToNS(S: Double): Int64; inline;

(**
 * Convert nanoseconds to seconds.
 *
 * This performs a division, so the results can be dramatically different if
 * `NS` is an integer or floating point value.
 *
 * \param NS the number of nanoseconds to convert.
 * \returns NS, expressed in seconds.
 *
 * \threadsafety It is safe to call this macro from any thread.
 *
 * \since This macro is available since SDL 3.2.0.
 *)
function SDL_NSToSeconds(NS: Int64): Double; inline;

(**
 * Convert milliseconds to nanoseconds.
 *
 * This only converts whole numbers, not fractional milliseconds.
 *
 * \param MS the number of milliseconds to convert.
 * \returns MS, expressed in nanoseconds.
 *
 * \threadsafety It is safe to call this macro from any thread.
 *
 * \since This macro is available since SDL 3.2.0.
 *)
function SDL_MSToNS(MS: Integer): Int64; inline;

(**
 * Convert nanoseconds to milliseconds.
 *
 * This performs a division, so the results can be dramatically different if
 * `NS` is an integer or floating point value.
 *
 * \param NS the number of nanoseconds to convert.
 * \returns NS, expressed in milliseconds.
 *
 * \threadsafety It is safe to call this macro from any thread.
 *
 * \since This macro is available since SDL 3.2.0.
 *)
function SDL_NSToMS(NS: Int64): Integer; inline;

(**
 * Convert microseconds to nanoseconds.
 *
 * This only converts whole numbers, not fractional microseconds.
 *
 * \param US the number of microseconds to convert.
 * \returns US, expressed in nanoseconds.
 *
 * \threadsafety It is safe to call this macro from any thread.
 *
 * \since This macro is available since SDL 3.2.0.
 *)
function SDL_USToNS(US: Int64): Int64; inline;

(**
 * Convert nanoseconds to microseconds.
 *
 * This performs a division, so the results can be dramatically different if
 * `NS` is an integer or floating point value.
 *
 * \param NS the number of nanoseconds to convert.
 * \returns NS, expressed in microseconds.
 *
 * \threadsafety It is safe to call this macro from any thread.
 *
 * \since This macro is available since SDL 3.2.0.
 *)
function SDL_NSToUS(NS: Int64): Int64; inline;

(**
 * Get the number of milliseconds since SDL library initialization.
 *
 * \returns an unsigned 64-bit value representing the number of milliseconds
 *          since the SDL library initialized.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetTicks(): Uint64; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetTicks';

(**
 * Get the number of nanoseconds since SDL library initialization.
 *
 * \returns an unsigned 64-bit value representing the number of nanoseconds
 *          since the SDL library initialized.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_GetTicksNS(): Uint64; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetTicksNS';

(**
 * Get the current value of the high resolution counter.
 *
 * This function is typically used for profiling.
 *
 * The counter values are only meaningful relative to each other. Differences
 * between values can be converted to times by using
 * SDL_GetPerformanceFrequency().
 *
 * \returns the current counter value.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetPerformanceFrequency
 *)
function SDL_GetPerformanceCounter(): Uint64; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetPerformanceCounter';

(**
 * Get the count per second of the high resolution counter.
 *
 * \returns a platform-specific count per second.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetPerformanceCounter
 *)
function SDL_GetPerformanceFrequency(): Uint64; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetPerformanceFrequency';

(**
 * Wait a specified number of milliseconds before returning.
 *
 * This function waits a specified number of milliseconds before returning. It
 * waits at least the specified time, but possibly longer due to OS
 * scheduling.
 *
 * \param ms the number of milliseconds to delay.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_DelayNS
 * \sa SDL_DelayPrecise
 *)
procedure SDL_Delay(ms: Uint32); cdecl;
  external LIB_SDL3 name _PU + 'SDL_Delay';

(**
 * Wait a specified number of nanoseconds before returning.
 *
 * This function waits a specified number of nanoseconds before returning. It
 * waits at least the specified time, but possibly longer due to OS
 * scheduling.
 *
 * \param ns the number of nanoseconds to delay.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_Delay
 * \sa SDL_DelayPrecise
 *)
procedure SDL_DelayNS(ns: Uint64); cdecl;
  external LIB_SDL3 name _PU + 'SDL_DelayNS';

(**
 * Wait a specified number of nanoseconds before returning.
 *
 * This function waits a specified number of nanoseconds before returning. It
 * will attempt to wait as close to the requested time as possible, busy
 * waiting if necessary, but could return later due to OS scheduling.
 *
 * \param ns the number of nanoseconds to delay.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_Delay
 * \sa SDL_DelayNS
 *)
procedure SDL_DelayPrecise(ns: Uint64); cdecl;
  external LIB_SDL3 name _PU + 'SDL_DelayPrecise';

type
  (**
   * Definition of the timer ID type.
   *
   * \since This datatype is available since SDL 3.2.0.
   *)
  SDL_TimerID = Uint32;

type
  (**
   * Function prototype for the millisecond timer callback function.
   *
   * The callback function is passed the current timer interval and returns the
   * next timer interval, in milliseconds. If the returned value is the same as
   * the one passed in, the periodic alarm continues, otherwise a new alarm is
   * scheduled. If the callback returns 0, the periodic alarm is canceled and
   * will be removed.
   *
   * \param userdata an arbitrary pointer provided by the app through
   *                 SDL_AddTimer, for its own use.
   * \param timerID the current timer being processed.
   * \param interval the current callback time interval.
   * \returns the new callback time interval, or 0 to disable further runs of
   *          the callback.
   *
   * \threadsafety SDL may call this callback at any time from a background
   *               thread; the application is responsible for locking resources
   *               the callback touches that need to be protected.
   *
   * \since This datatype is available since SDL 3.2.0.
   *
   * \sa SDL_AddTimer
   *)
  SDL_TimerCallback = function(userdata: Pointer; timerID: SDL_TimerID; interval: Uint32): Uint32; cdecl;

(**
 * Call a callback function at a future time.
 *
 * The callback function is passed the current timer interval and the user
 * supplied parameter from the SDL_AddTimer() call and should return the next
 * timer interval. If the value returned from the callback is 0, the timer is
 * canceled and will be removed.
 *
 * The callback is run on a separate thread, and for short timeouts can
 * potentially be called before this function returns.
 *
 * Timers take into account the amount of time it took to execute the
 * callback. For example, if the callback took 250 ms to execute and returned
 * 1000 (ms), the timer would only wait another 750 ms before its next
 * iteration.
 *
 * Timing may be inexact due to OS scheduling. Be sure to note the current
 * time with SDL_GetTicksNS() or SDL_GetPerformanceCounter() in case your
 * callback needs to adjust for variances.
 *
 * \param interval the timer delay, in milliseconds, passed to `callback`.
 * \param callback the SDL_TimerCallback function to call when the specified
 *                 `interval` elapses.
 * \param userdata a pointer that is passed to `callback`.
 * \returns a timer ID or 0 on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_AddTimerNS
 * \sa SDL_RemoveTimer
 *)
function SDL_AddTimer(interval: Uint32; callback: SDL_TimerCallback; userdata: Pointer): SDL_TimerID; cdecl;
  external LIB_SDL3 name _PU + 'SDL_AddTimer';

type
  (**
   * Function prototype for the nanosecond timer callback function.
   *
   * The callback function is passed the current timer interval and returns the
   * next timer interval, in nanoseconds. If the returned value is the same as
   * the one passed in, the periodic alarm continues, otherwise a new alarm is
   * scheduled. If the callback returns 0, the periodic alarm is canceled and
   * will be removed.
   *
   * \param userdata an arbitrary pointer provided by the app through
   *                 SDL_AddTimer, for its own use.
   * \param timerID the current timer being processed.
   * \param interval the current callback time interval.
   * \returns the new callback time interval, or 0 to disable further runs of
   *          the callback.
   *
   * \threadsafety SDL may call this callback at any time from a background
   *               thread; the application is responsible for locking resources
   *               the callback touches that need to be protected.
   *
   * \since This datatype is available since SDL 3.2.0.
   *
   * \sa SDL_AddTimerNS
   *)
  SDL_NSTimerCallback = function(userdata: Pointer; timerID: SDL_TimerID; interval: Uint64): Uint64; cdecl;

(**
 * Call a callback function at a future time.
 *
 * The callback function is passed the current timer interval and the user
 * supplied parameter from the SDL_AddTimerNS() call and should return the
 * next timer interval. If the value returned from the callback is 0, the
 * timer is canceled and will be removed.
 *
 * The callback is run on a separate thread, and for short timeouts can
 * potentially be called before this function returns.
 *
 * Timers take into account the amount of time it took to execute the
 * callback. For example, if the callback took 250 ns to execute and returned
 * 1000 (ns), the timer would only wait another 750 ns before its next
 * iteration.
 *
 * Timing may be inexact due to OS scheduling. Be sure to note the current
 * time with SDL_GetTicksNS() or SDL_GetPerformanceCounter() in case your
 * callback needs to adjust for variances.
 *
 * \param interval the timer delay, in nanoseconds, passed to `callback`.
 * \param callback the SDL_TimerCallback function to call when the specified
 *                 `interval` elapses.
 * \param userdata a pointer that is passed to `callback`.
 * \returns a timer ID or 0 on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_AddTimer
 * \sa SDL_RemoveTimer
 *)
function SDL_AddTimerNS(interval: Uint64; callback: SDL_NSTimerCallback; userdata: Pointer): SDL_TimerID; cdecl;
  external LIB_SDL3 name _PU + 'SDL_AddTimerNS';

(**
 * Remove a timer created with SDL_AddTimer().
 *
 * \param id the ID of the timer to remove.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety It is safe to call this function from any thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_AddTimer
 *)
function SDL_RemoveTimer(id: SDL_TimerID): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_RemoveTimer';
{$ENDREGION 'SDL_timer.h'}

{$REGION 'SDL_tray.h'}
(**
 * # CategoryTray
 *
 * SDL offers a way to add items to the "system tray" (more correctly called
 * the "notification area" on Windows). On platforms that offer this concept,
 * an SDL app can add a tray icon, submenus, checkboxes, and clickable
 * entries, and register a callback that is fired when the user clicks on
 * these pieces.
 *)

type
  (**
   * An opaque handle representing a toplevel system tray object.
   *
   * \since This struct is available since SDL 3.2.0.
   *)
  SDL_Tray = THandle;

  (**
   * An opaque handle representing a menu/submenu on a system tray object.
   *
   * \since This struct is available since SDL 3.2.0.
   *)
  SDL_TrayMenu = THandle;

  (**
   * An opaque handle representing an entry on a system tray object.
   *
   * \since This struct is available since SDL 3.2.0.
   *)
  SDL_TrayEntry = THandle;
  PSDL_TrayEntry = ^SDL_TrayEntry;

type
  (**
   * Flags that control the creation of system tray entries.
   *
   * Some of these flags are required; exactly one of them must be specified at
   * the time a tray entry is created. Other flags are optional; zero or more of
   * those can be OR'ed together with the required flag.
   *
   * \since This datatype is available since SDL 3.2.0.
   *
   * \sa SDL_InsertTrayEntryAt
   *)
  SDL_TrayEntryFlags = Uint32;

const
  SDL_TRAYENTRY_BUTTON   = $00000001; // Make the entry a simple button. Required.
  SDL_TRAYENTRY_CHECKBOX = $00000002; // Make the entry a checkbox. Required.
  SDL_TRAYENTRY_SUBMENU  = $00000004; // Prepare the entry to have a submenu. Required.
  SDL_TRAYENTRY_DISABLED = $80000000; // Make the entry disabled. Optional.
  SDL_TRAYENTRY_CHECKED  = $40000000; // Make the entry checked. This is valid only for checkboxes. Optional.

type
  (**
   * A callback that is invoked when a tray entry is selected.
   *
   * \param userdata an optional pointer to pass extra data to the callback when
   *                 it will be invoked.
   * \param entry the tray entry that was selected.
   *
   * \since This datatype is available since SDL 3.2.0.
   *
   * \sa SDL_SetTrayEntryCallback
   *)
  SDL_TrayCallback = procedure(userdata: Pointer; entry: SDL_TrayEntry); cdecl;

(**
 * Create an icon to be placed in the operating system's tray, or equivalent.
 *
 * Many platforms advise not using a system tray unless persistence is a
 * necessary feature. Avoid needlessly creating a tray icon, as the user may
 * feel like it clutters their interface.
 *
 * Using tray icons require the video subsystem.
 *
 * \param icon a surface to be used as icon. May be NULL.
 * \param tooltip a tooltip to be displayed when the mouse hovers the icon in
 *                UTF-8 encoding. Not supported on all platforms. May be NULL.
 * \returns The newly created system tray icon.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CreateTrayMenu
 * \sa SDL_GetTrayMenu
 * \sa SDL_DestroyTray
 *)
function SDL_CreateTray(icon: PSDL_Surface; const tooltip: PUTF8Char): SDL_Tray; cdecl;
  external LIB_SDL3 name _PU + 'SDL_CreateTray';

(**
 * Updates the system tray icon's icon.
 *
 * \param tray the tray icon to be updated.
 * \param icon the new icon. May be NULL.
 *
 * \threadsafety This function should be called on the thread that created the
 *               tray.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CreateTray
 *)
procedure SDL_SetTrayIcon(tray: SDL_Tray; icon: PSDL_Surface); cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetTrayIcon';

(**
 * Updates the system tray icon's tooltip.
 *
 * \param tray the tray icon to be updated.
 * \param tooltip the new tooltip in UTF-8 encoding. May be NULL.
 *
 * \threadsafety This function should be called on the thread that created the
 *               tray.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CreateTray
 *)
procedure SDL_SetTrayTooltip(tray: SDL_Tray; const tooltip: PUTF8Char); cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetTrayTooltip';

(**
 * Create a menu for a system tray.
 *
 * This should be called at most once per tray icon.
 *
 * This function does the same thing as SDL_CreateTraySubmenu(), except that
 * it takes a SDL_Tray instead of a SDL_TrayEntry.
 *
 * A menu does not need to be destroyed; it will be destroyed with the tray.
 *
 * \param tray the tray to bind the menu to.
 * \returns the newly created menu.
 *
 * \threadsafety This function should be called on the thread that created the
 *               tray.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CreateTray
 * \sa SDL_GetTrayMenu
 * \sa SDL_GetTrayMenuParentTray
 *)
function SDL_CreateTrayMenu(tray: SDL_Tray): SDL_TrayMenu; cdecl;
  external LIB_SDL3 name _PU + 'SDL_CreateTrayMenu';

(**
 * Create a submenu for a system tray entry.
 *
 * This should be called at most once per tray entry.
 *
 * This function does the same thing as SDL_CreateTrayMenu, except that it
 * takes a SDL_TrayEntry instead of a SDL_Tray.
 *
 * A menu does not need to be destroyed; it will be destroyed with the tray.
 *
 * \param entry the tray entry to bind the menu to.
 * \returns the newly created menu.
 *
 * \threadsafety This function should be called on the thread that created the
 *               tray.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_InsertTrayEntryAt
 * \sa SDL_GetTraySubmenu
 * \sa SDL_GetTrayMenuParentEntry
 *)
function SDL_CreateTraySubmenu(entry: SDL_TrayEntry): SDL_TrayMenu; cdecl;
  external LIB_SDL3 name _PU + 'SDL_CreateTraySubmenu';

(**
 * Gets a previously created tray menu.
 *
 * You should have called SDL_CreateTrayMenu() on the tray object. This
 * function allows you to fetch it again later.
 *
 * This function does the same thing as SDL_GetTraySubmenu(), except that it
 * takes a SDL_Tray instead of a SDL_TrayEntry.
 *
 * A menu does not need to be destroyed; it will be destroyed with the tray.
 *
 * \param tray the tray entry to bind the menu to.
 * \returns the newly created menu.
 *
 * \threadsafety This function should be called on the thread that created the
 *               tray.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CreateTray
 * \sa SDL_CreateTrayMenu
 *)
function SDL_GetTrayMenu(tray: SDL_Tray): SDL_TrayMenu; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetTrayMenu';

(**
 * Gets a previously created tray entry submenu.
 *
 * You should have called SDL_CreateTraySubmenu() on the entry object. This
 * function allows you to fetch it again later.
 *
 * This function does the same thing as SDL_GetTrayMenu(), except that it
 * takes a SDL_TrayEntry instead of a SDL_Tray.
 *
 * A menu does not need to be destroyed; it will be destroyed with the tray.
 *
 * \param entry the tray entry to bind the menu to.
 * \returns the newly created menu.
 *
 * \threadsafety This function should be called on the thread that created the
 *               tray.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_InsertTrayEntryAt
 * \sa SDL_CreateTraySubmenu
 *)
function SDL_GetTraySubmenu(entry: SDL_TrayEntry): SDL_TrayMenu; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetTraySubmenu';

(**
 * Returns a list of entries in the menu, in order.
 *
 * \param menu The menu to get entries from.
 * \param count An optional pointer to obtain the number of entries in the
 *             menu.
 * \returns a NULL-terminated list of entries within the given menu. The
 *          pointer becomes invalid when any function that inserts or deletes
 *          entries in the menu is called.
 *
 * \threadsafety This function should be called on the thread that created the
 *               tray.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_RemoveTrayEntry
 * \sa SDL_InsertTrayEntryAt
 *)
function SDL_GetTrayEntries(menu: SDL_TrayMenu; count: PInteger): PSDL_TrayEntry; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetTrayEntries';

(**
 * Removes a tray entry.
 *
 * \param entry The entry to be deleted.
 *
 * \threadsafety This function should be called on the thread that created the
 *               tray.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetTrayEntries
 * \sa SDL_InsertTrayEntryAt
 *)
procedure SDL_RemoveTrayEntry(entry: SDL_TrayEntry); cdecl;
  external LIB_SDL3 name _PU + 'SDL_RemoveTrayEntry';

(**
 * Insert a tray entry at a given position.
 *
 * If label is NULL, the entry will be a separator. Many functions won't work
 * for an entry that is a separator.
 *
 * An entry does not need to be destroyed; it will be destroyed with the tray.
 *
 * \param menu the menu to append the entry to.
 * \param pos the desired position for the new entry. Entries at or following
 *            this place will be moved. If pos is -1, the entry is appended.
 * \param label the text to be displayed on the entry, in UTF-8 encoding, or
 *              NULL for a separator.
 * \param flags a combination of flags, some of which are mandatory.
 * \returns the newly created entry, or NULL if pos is out of bounds.
 *
 * \threadsafety This function should be called on the thread that created the
 *               tray.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_TrayEntryFlags
 * \sa SDL_GetTrayEntries
 * \sa SDL_RemoveTrayEntry
 * \sa SDL_GetTrayEntryParent
 *)
function SDL_InsertTrayEntryAt(menu: SDL_TrayMenu; pos: Integer; const &label: PUTF8Char; flags: SDL_TrayEntryFlags): SDL_TrayEntry; cdecl;
  external LIB_SDL3 name _PU + 'SDL_InsertTrayEntryAt';

(**
 * Sets the label of an entry.
 *
 * An entry cannot change between a separator and an ordinary entry; that is,
 * it is not possible to set a non-NULL label on an entry that has a NULL
 * label (separators), or to set a NULL label to an entry that has a non-NULL
 * label. The function will silently fail if that happens.
 *
 * \param entry the entry to be updated.
 * \param label the new label for the entry in UTF-8 encoding.
 *
 * \threadsafety This function should be called on the thread that created the
 *               tray.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetTrayEntries
 * \sa SDL_InsertTrayEntryAt
 * \sa SDL_GetTrayEntryLabel
 *)
procedure SDL_SetTrayEntryLabel(entry: SDL_TrayEntry; const &label: PUTF8Char); cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetTrayEntryLabel';

(**
 * Gets the label of an entry.
 *
 * If the returned value is NULL, the entry is a separator.
 *
 * \param entry the entry to be read.
 * \returns the label of the entry in UTF-8 encoding.
 *
 * \threadsafety This function should be called on the thread that created the
 *               tray.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetTrayEntries
 * \sa SDL_InsertTrayEntryAt
 * \sa SDL_SetTrayEntryLabel
 *)
function SDL_GetTrayEntryLabel(entry: SDL_TrayEntry): PUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetTrayEntryLabel';

(**
 * Sets whether or not an entry is checked.
 *
 * The entry must have been created with the SDL_TRAYENTRY_CHECKBOX flag.
 *
 * \param entry the entry to be updated.
 * \param checked true if the entry should be checked; false otherwise.
 *
 * \threadsafety This function should be called on the thread that created the
 *               tray.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetTrayEntries
 * \sa SDL_InsertTrayEntryAt
 * \sa SDL_GetTrayEntryChecked
 *)
procedure SDL_SetTrayEntryChecked(entry: SDL_TrayEntry; checked: Boolean); cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetTrayEntryChecked';

(**
 * Gets whether or not an entry is checked.
 *
 * The entry must have been created with the SDL_TRAYENTRY_CHECKBOX flag.
 *
 * \param entry the entry to be read.
 * \returns true if the entry is checked; false otherwise.
 *
 * \threadsafety This function should be called on the thread that created the
 *               tray.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetTrayEntries
 * \sa SDL_InsertTrayEntryAt
 * \sa SDL_SetTrayEntryChecked
 *)
function SDL_GetTrayEntryChecked(entry: SDL_TrayEntry): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetTrayEntryChecked';

(**
 * Sets whether or not an entry is enabled.
 *
 * \param entry the entry to be updated.
 * \param enabled true if the entry should be enabled; false otherwise.
 *
 * \threadsafety This function should be called on the thread that created the
 *               tray.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetTrayEntries
 * \sa SDL_InsertTrayEntryAt
 * \sa SDL_GetTrayEntryEnabled
 *)
procedure SDL_SetTrayEntryEnabled(entry: SDL_TrayEntry; enabled: Boolean); cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetTrayEntryEnabled';

(**
 * Gets whether or not an entry is enabled.
 *
 * \param entry the entry to be read.
 * \returns true if the entry is enabled; false otherwise.
 *
 * \threadsafety This function should be called on the thread that created the
 *               tray.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetTrayEntries
 * \sa SDL_InsertTrayEntryAt
 * \sa SDL_SetTrayEntryEnabled
 *)
function SDL_GetTrayEntryEnabled(entry: SDL_TrayEntry): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetTrayEntryEnabled';

(**
 * Sets a callback to be invoked when the entry is selected.
 *
 * \param entry the entry to be updated.
 * \param callback a callback to be invoked when the entry is selected.
 * \param userdata an optional pointer to pass extra data to the callback when
 *                 it will be invoked.
 *
 * \threadsafety This function should be called on the thread that created the
 *               tray.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_GetTrayEntries
 * \sa SDL_InsertTrayEntryAt
 *)
procedure SDL_SetTrayEntryCallback(entry: SDL_TrayEntry; callback: SDL_TrayCallback; userdata: Pointer); cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetTrayEntryCallback';

(**
 * Simulate a click on a tray entry.
 *
 * \param entry The entry to activate.
 *
 * \threadsafety This function should be called on the thread that created the
 *               tray.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_ClickTrayEntry(entry: SDL_TrayEntry); cdecl;
  external LIB_SDL3 name _PU + 'SDL_ClickTrayEntry';

(**
 * Destroys a tray object.
 *
 * This also destroys all associated menus and entries.
 *
 * \param tray the tray icon to be destroyed.
 *
 * \threadsafety This function should be called on the thread that created the
 *               tray.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CreateTray
 *)
procedure SDL_DestroyTray(tray: SDL_Tray); cdecl;
  external LIB_SDL3 name _PU + 'SDL_DestroyTray';

(**
 * Gets the menu containing a certain tray entry.
 *
 * \param entry the entry for which to get the parent menu.
 * \returns the parent menu.
 *
 * \threadsafety This function should be called on the thread that created the
 *               tray.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_InsertTrayEntryAt
 *)
function SDL_GetTrayEntryParent(entry: SDL_TrayEntry): SDL_TrayMenu; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetTrayEntryParent';

(**
 * Gets the entry for which the menu is a submenu, if the current menu is a
 * submenu.
 *
 * Either this function or SDL_GetTrayMenuParentTray() will return non-NULL
 * for any given menu.
 *
 * \param menu the menu for which to get the parent entry.
 * \returns the parent entry, or NULL if this menu is not a submenu.
 *
 * \threadsafety This function should be called on the thread that created the
 *               tray.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CreateTraySubmenu
 * \sa SDL_GetTrayMenuParentTray
 *)
function SDL_GetTrayMenuParentEntry(menu: SDL_TrayMenu): SDL_TrayEntry; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetTrayMenuParentEntry';

(**
 * Gets the tray for which this menu is the first-level menu, if the current
 * menu isn't a submenu.
 *
 * Either this function or SDL_GetTrayMenuParentEntry() will return non-NULL
 * for any given menu.
 *
 * \param menu the menu for which to get the parent enttrayry.
 * \returns the parent tray, or NULL if this menu is a submenu.
 *
 * \threadsafety This function should be called on the thread that created the
 *               tray.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_CreateTrayMenu
 * \sa SDL_GetTrayMenuParentEntry
 *)
function SDL_GetTrayMenuParentTray(menu: SDL_TrayMenu): SDL_Tray; cdecl;
  external LIB_SDL3 name _PU + 'SDL_GetTrayMenuParentTray';

(**
 * Update the trays.
 *
 * This is called automatically by the event loop and is only needed if you're
 * using trays but aren't handling SDL events.
 *
 * \threadsafety This function should only be called on the main thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_UpdateTrays(); cdecl;
  external LIB_SDL3 name _PU + 'SDL_UpdateTrays';
{$ENDREGION 'SDL_tray.h'}

{$REGION 'SDL_main.h'}
(**
 * # CategoryMain
 *
 * Redefine main() if necessary so that it is called by SDL.
 *
 * In order to make this consistent on all platforms, the application's main()
 * should look like this:
 *
 * ```c
 * int main(int argc, char *argv[])
 * {
 * }
 * ```
 *
 * SDL will take care of platform specific details on how it gets called.
 *
 * This is also where an app can be configured to use the main callbacks, via
 * the SDL_MAIN_USE_CALLBACKS macro.
 *
 * This is a "single-header library," which is to say that including this
 * header inserts code into your program, and you should only include it once
 * in most cases. SDL.h does not include this header automatically.
 *
 * For more information, see:
 *
 * https://wiki.libsdl.org/SDL3/README/main-functions
 *)

type
 (**
   * The prototype for the application's main() function
   *
   * \param argc an ANSI-C style main function's argc.
   * \param argv an ANSI-C style main function's argv.
   * \returns an ANSI-C main return code; generally 0 is considered successful
   *          program completion, and small non-zero values are considered
   *          errors.
   *
   * \since This datatype is available since SDL 3.2.0.
   *)
  SDL_main_func = function(argc: Integer; argv: PPUTF8Char): Integer; cdecl;

(**
 * An app-supplied function for program entry.
 *
 * Apps do not directly create this function; they should create a standard
 * ANSI-C `main` function instead. If SDL needs to insert some startup code
 * before `main` runs, or the platform doesn't actually _use_ a function
 * called "main", SDL will do some macro magic to redefine `main` to
 * `SDL_main` and provide its own `main`.
 *
 * Apps should include `SDL_main.h` in the same file as their `main` function,
 * and they should not use that symbol for anything else in that file, as it
 * might get redefined.
 *
 * This function is only provided by the app if it isn't using
 * SDL_MAIN_USE_CALLBACKS.
 *
 * Program startup is a surprisingly complex topic. Please see
 * [README/main-functions](README/main-functions), (or
 * docs/README-main-functions.md in the source tree) for a more detailed
 * explanation.
 *
 * \param argc an ANSI-C style main function's argc.
 * \param argv an ANSI-C style main function's argv.
 * \returns an ANSI-C main return code; generally 0 is considered successful
 *          program completion, and small non-zero values are considered
 *          errors.
 *
 * \threadsafety This is the program entry point.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_main(argc: Integer; argv: PPUTF8Char): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_main';

(**
 * Circumvent failure of SDL_Init() when not using SDL_main() as an entry
 * point.
 *
 * This function is defined in SDL_main.h, along with the preprocessor rule to
 * redefine main() as SDL_main(). Thus to ensure that your main() function
 * will not be changed it is necessary to define SDL_MAIN_HANDLED before
 * including SDL.h.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_Init
 *)
procedure SDL_SetMainReady(); cdecl;
  external LIB_SDL3 name _PU + 'SDL_SetMainReady';

(**
 * Initializes and launches an SDL application, by doing platform-specific
 * initialization before calling your mainFunction and cleanups after it
 * returns, if that is needed for a specific platform, otherwise it just calls
 * mainFunction.
 *
 * You can use this if you want to use your own main() implementation without
 * using SDL_main (like when using SDL_MAIN_HANDLED). When using this, you do
 * *not* need SDL_SetMainReady().
 *
 * \param argc the argc parameter from the application's main() function, or 0
 *             if the platform's main-equivalent has no argc.
 * \param argv the argv parameter from the application's main() function, or
 *             NULL if the platform's main-equivalent has no argv.
 * \param mainFunction your SDL app's C-style main(). NOT the function you're
 *                     calling this from! Its name doesn't matter; it doesn't
 *                     literally have to be `main`.
 * \param reserved should be NULL (reserved for future use, will probably be
 *                 platform-specific then).
 * \returns the return value from mainFunction: 0 on success, otherwise
 *          failure; SDL_GetError() might have more information on the
 *          failure.
 *
 * \threadsafety Generally this is called once, near startup, from the
 *               process's initial thread.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_RunApp(argc: Integer; argv: PPUTF8Char; mainFunction: SDL_main_func; reserved: Pointer): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_RunApp';

(**
 * An entry point for SDL's use in SDL_MAIN_USE_CALLBACKS.
 *
 * Generally, you should not call this function directly. This only exists to
 * hand off work into SDL as soon as possible, where it has a lot more control
 * and functionality available, and make the inline code in SDL_main.h as
 * small as possible.
 *
 * Not all platforms use this, it's actual use is hidden in a magic
 * header-only library, and you should not call this directly unless you
 * _really_ know what you're doing.
 *
 * \param argc standard Unix main argc.
 * \param argv standard Unix main argv.
 * \param appinit the application's SDL_AppInit function.
 * \param appiter the application's SDL_AppIterate function.
 * \param appevent the application's SDL_AppEvent function.
 * \param appquit the application's SDL_AppQuit function.
 * \returns standard Unix main return value.
 *
 * \threadsafety It is not safe to call this anywhere except as the only
 *               function call in SDL_main.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_EnterAppMainCallbacks(argc: Integer; argv: PPUTF8Char; appinit: SDL_AppInit_func; appiter: SDL_AppIterate_func; appevent: SDL_AppEvent_func; appquit: SDL_AppQuit_func): Integer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_EnterAppMainCallbacks';

{$IF Defined(MSWINDOWS)}
(**
 * Register a win32 window class for SDL's use.
 *
 * This can be called to set the application window class at startup. It is
 * safe to call this multiple times, as long as every call is eventually
 * paired with a call to SDL_UnregisterApp, but a second registration attempt
 * while a previous registration is still active will be ignored, other than
 * to increment a counter.
 *
 * Most applications do not need to, and should not, call this directly; SDL
 * will call it when initializing the video subsystem.
 *
 * \param name the window class name, in UTF-8 encoding. If NULL, SDL
 *             currently uses "SDL_app" but this isn't guaranteed.
 * \param style the value to use in WNDCLASSEX::style. If `name` is NULL, SDL
 *              currently uses `(CS_BYTEALIGNCLIENT | CS_OWNDC)` regardless of
 *              what is specified here.
 * \param hInst the HINSTANCE to use in WNDCLASSEX::hInstance. If zero, SDL
 *              will use `GetModuleHandle(NULL)` instead.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_RegisterApp(const name: PUTF8Char; style: Uint32; hInst: Pointer): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_RegisterApp';

(**
 * Deregister the win32 window class from an SDL_RegisterApp call.
 *
 * This can be called to undo the effects of SDL_RegisterApp.
 *
 * Most applications do not need to, and should not, call this directly; SDL
 * will call it when deinitializing the video subsystem.
 *
 * It is safe to call this multiple times, as long as every call is eventually
 * paired with a prior call to SDL_RegisterApp. The window class will only be
 * deregistered when the registration counter in SDL_RegisterApp decrements to
 * zero through calls to this function.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_UnregisterApp(); cdecl;
  external LIB_SDL3 name _PU + 'SDL_UnregisterApp';
{$ENDIF}

(**
 * Callback from the application to let the suspend continue.
 *
 * This function is only needed for Xbox GDK support; all other platforms will
 * do nothing and set an "unsupported" error message.
 *
 * \since This function is available since SDL 3.2.0.
 *)
procedure SDL_GDKSuspendComplete(); cdecl;
  external LIB_SDL3 name _PU + 'SDL_GDKSuspendComplete';
{$ENDREGION 'SDL_main.h'}

{$REGION 'SDL_vulkan.h'}
(**
 * # CategoryVulkan
 *
 * Functions for creating Vulkan surfaces on SDL windows.
 *
 * For the most part, Vulkan operates independent of SDL, but it benefits from
 * a little support during setup.
 *
 * Use SDL_Vulkan_GetInstanceExtensions() to get platform-specific bits for
 * creating a VkInstance, then SDL_Vulkan_GetVkGetInstanceProcAddr() to get
 * the appropriate function for querying Vulkan entry points. Then
 * SDL_Vulkan_CreateSurface() will get you the final pieces you need to
 * prepare for rendering into an SDL_Window with Vulkan.
 *
 * Unlike OpenGL, most of the details of "context" creation and window buffer
 * swapping are handled by the Vulkan API directly, so SDL doesn't provide
 * Vulkan equivalents of SDL_GL_SwapWindow(), etc; they aren't necessary.
 *)

type
  VkInstance = Pointer;
  VkPhysicalDevice = Pointer;
  VkSurfaceKHR = Pointer;
  PVkSurfaceKHR = ^VkSurfaceKHR;
  PVkAllocationCallbacks = Pointer;

(**
 * Dynamically load the Vulkan loader library.
 *
 * This should be called after initializing the video driver, but before
 * creating any Vulkan windows. If no Vulkan loader library is loaded, the
 * default library will be loaded upon creation of the first Vulkan window.
 *
 * SDL keeps a counter of how many times this function has been successfully
 * called, so it is safe to call this function multiple times, so long as it
 * is eventually paired with an equivalent number of calls to
 * SDL_Vulkan_UnloadLibrary. The `path` argument is ignored unless there is no
 * library currently loaded, and and the library isn't actually unloaded until
 * there have been an equivalent number of calls to SDL_Vulkan_UnloadLibrary.
 *
 * It is fairly common for Vulkan applications to link with libvulkan instead
 * of explicitly loading it at run time. This will work with SDL provided the
 * application links to a dynamic library and both it and SDL use the same
 * search path.
 *
 * If you specify a non-NULL `path`, an application should retrieve all of the
 * Vulkan functions it uses from the dynamic library using
 * SDL_Vulkan_GetVkGetInstanceProcAddr unless you can guarantee `path` points
 * to the same vulkan loader library the application linked to.
 *
 * On Apple devices, if `path` is NULL, SDL will attempt to find the
 * `vkGetInstanceProcAddr` address within all the Mach-O images of the current
 * process. This is because it is fairly common for Vulkan applications to
 * link with libvulkan (and historically MoltenVK was provided as a static
 * library). If it is not found, on macOS, SDL will attempt to load
 * `vulkan.framework/vulkan`, `libvulkan.1.dylib`,
 * `MoltenVK.framework/MoltenVK`, and `libMoltenVK.dylib`, in that order. On
 * iOS, SDL will attempt to load `libMoltenVK.dylib`. Applications using a
 * dynamic framework or .dylib must ensure it is included in its application
 * bundle.
 *
 * On non-Apple devices, application linking with a static libvulkan is not
 * supported. Either do not link to the Vulkan loader or link to a dynamic
 * library version.
 *
 * \param path the platform dependent Vulkan loader library name or NULL.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \threadsafety This function is not thread safe.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_Vulkan_GetVkGetInstanceProcAddr
 * \sa SDL_Vulkan_UnloadLibrary
 *)
function SDL_Vulkan_LoadLibrary(const path: PUTF8Char): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_Vulkan_LoadLibrary';

(**
 * Get the address of the `vkGetInstanceProcAddr` function.
 *
 * This should be called after either calling SDL_Vulkan_LoadLibrary() or
 * creating an SDL_Window with the `SDL_WINDOW_VULKAN` flag.
 *
 * The actual type of the returned function pointer is
 * PFN_vkGetInstanceProcAddr, but that isn't available because the Vulkan
 * headers are not included here. You should cast the return value of this
 * function to that type, e.g.
 *
 * `vkGetInstanceProcAddr =
 * (PFN_vkGetInstanceProcAddr)SDL_Vulkan_GetVkGetInstanceProcAddr();`
 *
 * \returns the function pointer for `vkGetInstanceProcAddr` or NULL on
 *          failure; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *)
function SDL_Vulkan_GetVkGetInstanceProcAddr(): SDL_FunctionPointer; cdecl;
  external LIB_SDL3 name _PU + 'SDL_Vulkan_GetVkGetInstanceProcAddr';

(**
 * Unload the Vulkan library previously loaded by SDL_Vulkan_LoadLibrary().
 *
 * SDL keeps a counter of how many times this function has been called, so it
 * is safe to call this function multiple times, so long as it is paired with
 * an equivalent number of calls to SDL_Vulkan_LoadLibrary. The library isn't
 * actually unloaded until there have been an equivalent number of calls to
 * SDL_Vulkan_UnloadLibrary.
 *
 * Once the library has actually been unloaded, if any Vulkan instances
 * remain, they will likely crash the program. Clean up any existing Vulkan
 * resources, and destroy appropriate windows, renderers and GPU devices
 * before calling this function.
 *
 * \threadsafety This function is not thread safe.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_Vulkan_LoadLibrary
 *)
procedure SDL_Vulkan_UnloadLibrary(); cdecl;
  external LIB_SDL3 name _PU + 'SDL_Vulkan_UnloadLibrary';

(**
 * Get the Vulkan instance extensions needed for vkCreateInstance.
 *
 * This should be called after either calling SDL_Vulkan_LoadLibrary() or
 * creating an SDL_Window with the `SDL_WINDOW_VULKAN` flag.
 *
 * On return, the variable pointed to by `count` will be set to the number of
 * elements returned, suitable for using with
 * VkInstanceCreateInfo::enabledExtensionCount, and the returned array can be
 * used with VkInstanceCreateInfo::ppEnabledExtensionNames, for calling
 * Vulkan's vkCreateInstance API.
 *
 * You should not free the returned array; it is owned by SDL.
 *
 * \param count a pointer filled in with the number of extensions returned.
 * \returns an array of extension name strings on success, NULL on failure;
 *          call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_Vulkan_CreateSurface
 *)
function SDL_Vulkan_GetInstanceExtensions(count: PUint32): PPUTF8Char; cdecl;
  external LIB_SDL3 name _PU + 'SDL_Vulkan_GetInstanceExtensions';

(**
 * Create a Vulkan rendering surface for a window.
 *
 * The `window` must have been created with the `SDL_WINDOW_VULKAN` flag and
 * `instance` must have been created with extensions returned by
 * SDL_Vulkan_GetInstanceExtensions() enabled.
 *
 * If `allocator` is NULL, Vulkan will use the system default allocator. This
 * argument is passed directly to Vulkan and isn't used by SDL itself.
 *
 * \param window the window to which to attach the Vulkan surface.
 * \param instance the Vulkan instance handle.
 * \param allocator a VkAllocationCallbacks struct, which lets the app set the
 *                  allocator that creates the surface. Can be NULL.
 * \param surface a pointer to a VkSurfaceKHR handle to output the newly
 *                created surface.
 * \returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_Vulkan_GetInstanceExtensions
 * \sa SDL_Vulkan_DestroySurface
 *)
function SDL_Vulkan_CreateSurface(window: SDL_Window; instance: VkInstance; const allocator: PVkAllocationCallbacks; surface: PVkSurfaceKHR): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_Vulkan_CreateSurface';

(**
 * Destroy the Vulkan rendering surface of a window.
 *
 * This should be called before SDL_DestroyWindow, if SDL_Vulkan_CreateSurface
 * was called after SDL_CreateWindow.
 *
 * The `instance` must have been created with extensions returned by
 * SDL_Vulkan_GetInstanceExtensions() enabled and `surface` must have been
 * created successfully by an SDL_Vulkan_CreateSurface() call.
 *
 * If `allocator` is NULL, Vulkan will use the system default allocator. This
 * argument is passed directly to Vulkan and isn't used by SDL itself.
 *
 * \param instance the Vulkan instance handle.
 * \param surface vkSurfaceKHR handle to destroy.
 * \param allocator a VkAllocationCallbacks struct, which lets the app set the
 *                  allocator that destroys the surface. Can be NULL.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_Vulkan_GetInstanceExtensions
 * \sa SDL_Vulkan_CreateSurface
 *)
procedure SDL_Vulkan_DestroySurface(instance: VkInstance; surface: VkSurfaceKHR; const allocator: PVkAllocationCallbacks); cdecl;
  external LIB_SDL3 name _PU + 'SDL_Vulkan_DestroySurface';

(**
 * Query support for presentation via a given physical device and queue
 * family.
 *
 * The `instance` must have been created with extensions returned by
 * SDL_Vulkan_GetInstanceExtensions() enabled.
 *
 * \param instance the Vulkan instance handle.
 * \param physicalDevice a valid Vulkan physical device handle.
 * \param queueFamilyIndex a valid queue family index for the given physical
 *                         device.
 * \returns true if supported, false if unsupported or an error occurred.
 *
 * \since This function is available since SDL 3.2.0.
 *
 * \sa SDL_Vulkan_GetInstanceExtensions
 *)
function SDL_Vulkan_GetPresentationSupport(instance: VkInstance; physicalDevice: VkPhysicalDevice; queueFamilyIndex: Uint32): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_Vulkan_GetPresentationSupport';
{$ENDREGION 'SDL_vulkan.h'}

implementation

{$REGION 'Implementation'}
{$IF Defined(MACOS)}
{ Force linking in some frameworks that are required by SDL.
  Note that these are just dummy procedures that are never actually called.
  They are just here to force the Delphi linker to link the corresponding
  framework.

  If you get a linking error here, make sure you added the corresponding
  framework to Delphi's SDK manager (see README.md for details).

  These frameworks are required on both macOS and iOS: }
procedure __DummyAudioToolbox; cdecl; external '/System/Library/Frameworks/AudioToolbox.framework/AudioToolbox' name 'AudioQueueStart';
procedure __DummyAVFoundation; cdecl; external '/System/Library/Frameworks/AVFoundation.framework/AVFoundation' name 'AVMediaTypeVideo';
procedure __DummyCoreHaptics; cdecl; external '/System/Library/Frameworks/CoreHaptics.framework/CoreHaptics' name 'CHHapticEventTypeHapticContinuous';
procedure __DummyCoreMedia; cdecl; external '/System/Library/Frameworks/CoreMedia.framework/CoreMedia' name 'CMFormatDescriptionGetMediaType';
procedure __DummyCoreVideo; cdecl; external '/System/Library/Frameworks/CoreVideo.framework/CoreVideo' name 'CVPixelBufferGetBytesPerRow';
procedure __DummyGameController; cdecl; external '/System/Library/Frameworks/GameController.framework/GameController' name 'GCInputXboxPaddleTwo';
procedure __DummyMetal; cdecl; external '/System/Library/Frameworks/Metal.framework/Metal' name 'MTLCreateSystemDefaultDevice';
procedure __DummyQuartzCore; cdecl; external '/System/Library/Frameworks/QuartzCore.framework/QuartzCore' name 'CACurrentMediaTime';

{$IF Defined(IOS)}
{ These frameworks are required for iOS only: }
procedure __DummyCoreGraphics; cdecl; external '/System/Library/Frameworks/CoreGraphics.framework/CoreGraphics' name 'CGAffineTransformConcat';
procedure __DummyCoreMotion; cdecl; external '/System/Library/Frameworks/CoreMotion.framework/CoreMotion' name 'CMAttitudeReferenceFrameXArbitraryZVertical';
procedure __DummyFoundation; cdecl; external '/System/Library/Frameworks/Foundation.framework/Foundation' name 'CFBridgingRelease';
procedure __DummyOpenGLES; cdecl; external '/System/Library/Frameworks/OpenGLES.framework/OpenGLES' name 'glActiveTexture';
procedure __DummyUIKit; cdecl; external '/System/Library/Frameworks/UIKit.framework/UIKit' name 'UIEdgeInsetsMake';
{$ELSE}
{ These frameworks are required for macOS only: }
procedure __DummyAppKit; cdecl; external '/System/Library/Frameworks/AppKit.framework/AppKit' name 'NSWindowWillExitFullScreenNotification';
procedure __DummyCoreAudio; cdecl; external '/System/Library/Frameworks/CoreAudio.framework/CoreAudio' name 'AudioObjectGetPropertyData';
procedure __DummyForceFeedback; cdecl; external '/System/Library/Frameworks/ForceFeedback.framework/ForceFeedback' name 'FFIsForceFeedback';
procedure __DummyHIToolbox; cdecl; external '/System/Library/Frameworks/Carbon.framework/Frameworks/HIToolbox.framework/HIToolbox' name 'LMGetKbdType';
procedure __DummyIOKit; cdecl; external '/System/Library/Frameworks/IOKit.framework/IOKit' name 'IONotificationPortCreate';
procedure __DummyUniformTypeIdentifiers; cdecl; external '/System/Library/Frameworks/UniformTypeIdentifiers.framework/UniformTypeIdentifiers' name 'UTTagClassMIMEType';
{$ENDIF}

{ The SDL source code uses the @available() macro a couple of times.
  This translates to a call to __isPlatformVersionAtLeast inside
  libclang_rt.*.a. However, this library is (currently) not linked by Delphi
  and I don't want to deploy this library manually (since it is tied to a
  specific macOS/iOS version).

  So instead, we implement this function ourselves.
  The code is based on the LLVM compiler-rt project:
  * https://github.com/llvm-mirror/compiler-rt
  In the file lib\builtins\os_version_check.c }
function __isPlatformVersionAtLeast(Platf, Major, Minor, Subminor: Int32): Int32; cdecl;
begin
  Result := Ord(TOSVersion.Check(Major, Minor));
end;

exports
  __isPlatformVersionAtLeast;
{$ELSEIF Defined(ANDROID)}
{ Android needs a special approach because of Java interop. }
uses
  Neslib.Sdl3.Android;
{$ELSEIF Defined(MSWINDOWS)}
uses
  System.Win.Crtl;
{$ENDIF}

var
  GMainProc: TSdlProc = nil;

function SDL_VersionNum(major, minor, patch: Integer): Integer; inline;
begin
  Result := (major * 1000000) + (minor * 1000) + patch;
end;

function SDL_VersionNumMajor(version: Integer): Integer; inline;
begin
  Result := version div 1000000;
end;

function SDL_VersionNumMinor(version: Integer): Integer; inline;
begin
  Result := (version div 1000) mod 1000;
end;

function SDL_VersionNumMicro(version: Integer): Integer; inline;
begin
  Result := version mod 1000;
end;

function SDL_VersionAtLeast(major, minor, patch: Integer): Boolean; inline;
begin
  Result := (SDL_VERSION >= SDL_VersionNum(major, minor, patch));
end;

function __SDL_Init(flags: SDL_InitFlags): Boolean; cdecl;
  external LIB_SDL3 name _PU + 'SDL_Init';

function SDL_Init(flags: SDL_InitFlags): Boolean;
begin
  if (not Assigned(GMainProc)) then
    raise EInvalidOpException.Create('Invalid startup method. Use SdlMain to start your application.');
  Result := __SDL_Init(flags);
end;

function SDL_FourCC(const A, B, C, D: Byte): UInt32; inline;
begin
  Result := A or (B shl 8) or (C shl 16) or (D shl 24);
end;

function SDL_iconv_utf8_locale(S: PUTF8Char): PUTF8Char; inline;
begin
  Result := SDL_iconv_string('', 'UTF-8', S, SDL_strlen(S) + 1);
end;

function SDL_iconv_utf8_ucs2(S: PUTF8Char): PUTF8Char; inline;
begin
  Result := SDL_iconv_string('UCS-2', 'UTF-8', S, SDL_strlen(S) + 1);
end;

function SDL_iconv_utf8_ucs4(S: PUTF8Char): PUTF8Char; inline;
begin
  Result := SDL_iconv_string('UCS-4', 'UTF-8', S, SDL_strlen(S) + 1);
end;

function SDL_iconv_wchar_utf8(S: PWideChar): PUTF8Char; inline;
begin
  Result := SDL_iconv_string('UTF-8', 'WCHAR_T', Pointer(S), (SDL_wcslen(S) + 1) * SizeOf(WideChar));
end;

function SDL_size_mul_check_overflow(a, b: size_t; out ret: size_t): Boolean; inline;
begin
  if (a <> 0) and (b > (SDL_SIZE_MAX div a)) then
    Exit(False);

  ret := a * b;
  Result := False;
end;

function SDL_size_add_check_overflow(a, b: size_t; out ret: size_t): Boolean; inline;
begin
  if (b > (SDL_SIZE_MAX - a)) then
    Exit(False);

  ret := a + b;
  Result := True;
end;

function SDL_DefineAudioFormat(signed, bigendian, flt: Boolean; size: Byte): Word; inline;
begin
  Result := (Ord(signed) shl 15) or (Ord(bigendian) shl 12) or (Ord(flt) shl 8) or size;
end;

function SDL_AudioBitSize(x: Word): Byte; inline;
begin
  Result := x and SDL_AUDIO_MASK_BITSIZE;
end;

function SDL_AudioByteSize(x: Word): Byte; inline;
begin
  Result := SDL_AudioBitsize(x) shr 3;
end;

function SDL_AudioIsFloat(x: Word): Boolean; inline;
begin
  Result := ((x and SDL_AUDIO_MASK_FLOAT) <> 0);
end;

function SDL_AudioIsBigEndian(x: Word): Boolean; inline;
begin
  Result := ((x and SDL_AUDIO_MASK_BIG_ENDIAN) <> 0);
end;

function SDL_AudioIsLittleEndian(x: Word): Boolean; inline;
begin
  Result := ((x and SDL_AUDIO_MASK_BIG_ENDIAN) = 0);
end;

function SDL_AudioIsSigned(x: Word): Boolean; inline;
begin
  Result := ((x and SDL_AUDIO_MASK_SIGNED) <> 0);
end;

function SDL_AudioIsInt(x: Word): Boolean; inline;
begin
  Result := ((x and SDL_AUDIO_MASK_FLOAT) = 0);
end;

function SDL_AudioIsUnsigned(x: Word): Boolean; inline;
begin
  Result := ((x and SDL_AUDIO_MASK_SIGNED) = 0);
end;

function SDL_AudioFrameSize(x: SDL_AudioSpec): Integer; inline;
begin
  Result := SDL_AudioByteSize(x.format) * x.channels;
end;

function SDL_DefinePixelFourCC(A, B, C, D: Byte): UInt32; inline;
begin
  Result := SDL_FourCC(A, B, C, D);
end;

function SDL_DefinePixelFormat(typ: SDL_PixelType; order: Integer;
  layout: SDL_PackedLayout; bits, bytes: Integer): SDL_PixelFormat; inline;
begin
  Result := (1 shl 28) or (typ shl 24) or (order shl 20) or (layout shl 16) or (bits shl 8) or bytes;
end;

function SDL_GetPixelFlag(format: SDL_PixelFormat): Integer; inline;
begin
  Result := (format shr 28) and $0F;
end;

function SDL_GetPixelType(format: SDL_PixelFormat): SDL_PixelType; inline;
begin
  Result := (format shr 24) and $0F;
end;

function SDL_GetPixelOrder(format: SDL_PixelFormat): Integer; inline;
begin
  Result := (format shr 20) and $0F;
end;

function SDL_GetPixelLayout(format: SDL_PixelFormat): SDL_PackedLayout; inline;
begin
  Result := (format shr 16) and $0F;
end;

function SDL_GetBitsPerPixel(format: SDL_PixelFormat): Integer; inline;
begin
  if (SDL_IsPixelFormatFourCC(format)) then
    Result := 0
  else
    Result := (format shr 8) and $FF;
end;

function SDL_GetBytesPerPixel(format: SDL_PixelFormat): Integer; inline;
begin
  if (SDL_IsPixelFormatFourCC(format)) then
  begin
    if (format = SDL_PIXELFORMAT_YUY2) or (format = SDL_PIXELFORMAT_UYVY)
      or (format = SDL_PIXELFORMAT_YVYU) or (format = SDL_PIXELFORMAT_P010)
    then
      Result := 2
    else
      Result := 1;
  end
  else
    Result := format and $FF;
end;

function SDL_IsPixelFormatIndexed(format: SDL_PixelFormat): Boolean; inline;
begin
  Result := not SDL_IsPixelFormatFourCC(format);
  if (Result) then
  begin
    var Typ := SDL_GetPixelType(format);
    Result := (Typ = SDL_PIXELTYPE_INDEX1) or (Typ = SDL_PIXELTYPE_INDEX2)
      or (Typ = SDL_PIXELTYPE_INDEX4) or (Typ = SDL_PIXELTYPE_INDEX8);
  end;
end;

function SDL_IsPixelFormatPacked(format: SDL_PixelFormat): Boolean; inline;
begin
  Result := not SDL_IsPixelFormatFourCC(format);
  if (Result) then
  begin
    var Typ := SDL_GetPixelType(format);
    Result := (Typ = SDL_PIXELTYPE_PACKED8) or (Typ = SDL_PIXELTYPE_PACKED16)
      or (Typ = SDL_PIXELTYPE_PACKED32);
  end;
end;

function SDL_IsPixelFormatArray(format: SDL_PixelFormat): Boolean; inline;
begin
  Result := not SDL_IsPixelFormatFourCC(format);
  if (Result) then
  begin
    var Typ := SDL_GetPixelType(format);
    Result := (Typ = SDL_PIXELTYPE_ARRAYU8) or (Typ = SDL_PIXELTYPE_ARRAYU16)
      or (Typ = SDL_PIXELTYPE_ARRAYU32) or (Typ = SDL_PIXELTYPE_ARRAYF16)
      or (Typ = SDL_PIXELTYPE_ARRAYF32);
  end;
end;

function SDL_IsPixelFormat10Bit(format: SDL_PixelFormat): Boolean; inline;
begin
  Result := not SDL_IsPixelFormatFourCC(format)
    and (SDL_GetPixelType(format) = SDL_PIXELTYPE_PACKED32)
    and (SDL_GetPixelLayout(format) = SDL_PACKEDLAYOUT_2101010);
end;

function SDL_IsPixelFormatFloat(format: SDL_PixelFormat): Boolean; inline;
begin
  Result := not SDL_IsPixelFormatFourCC(format);
  if (Result) then
  begin
    var Typ := SDL_GetPixelType(format);
    Result := (Typ = SDL_PIXELTYPE_ARRAYF16) or (Typ = SDL_PIXELTYPE_ARRAYF32);
  end;
end;

function SDL_IsPixelFormatAlpha(format: SDL_PixelFormat): Boolean; inline;
begin
  var Order := SDL_GetPixelOrder(format);
  Result := (SDL_IsPixelFormatPacked(format)
      and ((Order = SDL_PACKEDORDER_ARGB) or (Order = SDL_PACKEDORDER_RGBA)
        or (Order = SDL_PACKEDORDER_ABGR) or (Order = SDL_PACKEDORDER_BGRA)))
    or (SDL_IsPixelFormatArray(format)
      and ((Order = SDL_PACKEDORDER_ARGB) or (Order = SDL_PACKEDORDER_RGBA)
        or (Order = SDL_PACKEDORDER_ABGR) or (Order = SDL_PACKEDORDER_BGRA)));
end;

function SDL_IsPixelFormatFourCC(format: SDL_PixelFormat): Boolean; inline;
begin
  Result := (format <> 0) and (SDL_GetPixelFlag(format) <> 1);
end;

function SDL_DefineColorspace(typ: SDL_ColorType; range: SDL_ColorRange;
  primaries: SDL_ColorPrimaries; transfer: SDL_TransferCharacteristics;
  matrix: SDL_MatrixCoefficients; chroma: SDL_ChromaLocation): SDL_Colorspace;
begin
  Result := (typ shl 28) or (range shl 24) or (chroma shl 20)
    or (primaries shl 10) or (transfer shl 5) or matrix;
end;

function SDL_GetColorspaceType(cspace: SDL_Colorspace): SDL_ColorType; inline;
begin
  Result := (cspace shr 28) and $0F;
end;

function SDL_GetColorspaceRange(cspace: SDL_Colorspace): SDL_ColorRange; inline;
begin
  Result := (cspace shr 24) and $0F;
end;

function SDL_GetColorspaceChroma(cspace: SDL_Colorspace): SDL_ChromaLocation; inline;
begin
  Result := (cspace shr 20) and $0F;
end;

function SDL_GetColorspacePrimaries(cspace: SDL_Colorspace): SDL_ColorPrimaries; inline;
begin
  Result := (cspace shr 10) and $1F;
end;

function SDL_GetColorspaceTransfer(cspace: SDL_Colorspace): SDL_TransferCharacteristics; inline;
begin
  Result := (cspace shr 5) and $1F;
end;

function SDL_GetColorspaceMatrix(cspace: SDL_Colorspace): SDL_MatrixCoefficients; inline;
begin
  Result := cspace and $1F;
end;

function SDL_IsColorspaceMatrixBT601(cspace: SDL_Colorspace): Boolean; inline;
begin
  var Matrix := SDL_GetColorspaceMatrix(cspace);
  Result := (Matrix = SDL_MATRIX_COEFFICIENTS_BT601)
         or (Matrix = SDL_MATRIX_COEFFICIENTS_BT470BG);
end;

function SDL_IsColorspaceMatrixBT709(cspace: SDL_Colorspace): Boolean; inline;
begin
  Result := (SDL_GetColorspaceMatrix(cspace) = SDL_MATRIX_COEFFICIENTS_BT709);
end;

function SDL_IsColorspaceMatrixBT2020Ncl(cspace: SDL_Colorspace): Boolean; inline;
begin
  Result := (SDL_GetColorspaceMatrix(cspace) = SDL_MATRIX_COEFFICIENTS_BT2020_NCL);
end;

function SDL_IsColorspaceLimitedRange(cspace: SDL_Colorspace): Boolean; inline;
begin
  Result := (SDL_GetColorspaceRange(cspace) <> SDL_COLOR_RANGE_FULL);
end;

function SDL_IsColorspaceFullRange(cspace: SDL_Colorspace): Boolean; inline;
begin
  Result := (SDL_GetColorspaceRange(cspace) = SDL_COLOR_RANGE_FULL);
end;

function SDL_MustLock(S: SDL_Surface): Boolean; inline;
begin
  Result := ((S.Flags and SDL_SURFACE_LOCK_NEEDED) = SDL_SURFACE_LOCK_NEEDED);
end;

procedure SDL_RectToFRect(const rect: SDL_Rect; out frect: SDL_FRect); inline;
begin
  frect.x := rect.x;
  frect.y := rect.y;
  frect.w := rect.w;
  frect.h := rect.h;
end;

function SDL_PointInRect(const p: SDL_Point; const r: SDL_Rect): Boolean; inline;
begin
  Result := (p.x >= r.x) and (p.x < (r.x + r.w))
    and (p.y >= r.y) and (p.y < (r.y + r.h));
end;

function SDL_RectEmpty(const r: SDL_Rect): Boolean; inline;
begin
  Result := (r.w <= 0) or (r.h <= 0);
end;

function SDL_RectsEqual(const a, b: SDL_Rect): Boolean; inline;
begin
  Result := (a.x = b.x) and (a.y = b.y) and (a.w = b.w) and (a.h = b.h)
end;

function SDL_PointInRectFloat(const p: SDL_FPoint; const r: SDL_FRect): Boolean; inline;
begin
  Result := (p.x >= r.x) and (p.x <= (r.x + r.w))
    and (p.y >= r.y) and (p.y <= (r.y + r.h));
end;

function SDL_RectEmptyFloat(const r: SDL_FRect): Boolean; inline;
begin
  Result := (r.w < 0) or (r.h < 0);
end;

function SDL_RectsEqualEpsilon(const a, b: SDL_FRect; const epsilon: Single): Boolean; inline;
begin
  Result := (Abs(a.x - b.x) <= epsilon)
        and (Abs(a.y - b.y) <= epsilon)
        and (Abs(a.w - b.w) <= epsilon)
        and (Abs(a.h - b.h) <= epsilon)
end;

function SDL_RectsEqualFloat(const a, b: SDL_FRect): Boolean; inline;
begin
  Result := SDL_RectsEqualEpsilon(a, b, SDL_FLT_EPSILON);
end;

function SDL_WindowPosUndefinedDisplay(X: UInt32): UInt32; inline;
begin
  Result := SDL_WINDOWPOS_UNDEFINED_MASK or X;
end;

function SDL_WindowPosIsUndefined(X: UInt32): Boolean; inline;
begin
  Result := ((X and $FFFF0000) = SDL_WINDOWPOS_UNDEFINED_MASK);
end;

function SDL_WindowPosCenteredDisplay(X: UInt32): UInt32; inline;
begin
  Result := SDL_WINDOWPOS_CENTERED_MASK or X;
end;

function SDL_WindowPosIsCentered(X: UInt32): Boolean; inline;
begin
  Result := ((X and $FFFF0000) = SDL_WINDOWPOS_CENTERED_MASK);
end;

function SDL_Swap16(x: UInt16): UInt16; inline;
begin
  Result := Swap(x);
end;

function SDL_Swap32(x: UInt32): UInt32; inline;
begin
  Result := (Swap(x) shl 16) or (Swap(x shr 16));
end;

function SDL_Swap64(x: UInt64): UInt64; inline;
begin
  Result := (SDL_Swap32(x) shl 32) or (SDL_Swap32(x shr 32));
end;

function SDL_SwapFloat(x: Single): Single; inline;
var
  Src: UInt32 absolute x;
  Dst: UInt32 absolute Result;
begin
  Dst := SDL_Swap32(Src);
end;

function SDL_ScancodeToKeycode(X: SDL_Scancode): SDL_Keycode; inline;
begin
  Result := X or SDLK_SCANCODE_MASK;
end;

function SDL_CreateThread(fn: SDL_ThreadFunction; const name: PUTF8Char; data: Pointer): SDL_Thread; inline;
begin
  Result := SDL_CreateThreadRuntime(fn, name, data,
    {$IFDEF MSWINDOWS}@_beginthreadex, @_endthreadex{$ELSE}nil, nil{$ENDIF});
end;

function SDL_CreateThreadWithProperties(props: SDL_PropertiesID): SDL_Thread; inline;
begin
  Result := SDL_CreateThreadWithPropertiesRuntime(props,
    {$IFDEF MSWINDOWS}@_beginthreadex, @_endthreadex{$ELSE}nil, nil{$ENDIF});
end;

function SDL_SecondsToNS(S: Double): Int64; inline;
begin
  Result := Trunc(S * SDL_NS_PER_SECOND);
end;

function SDL_NSToSeconds(NS: Int64): Double; inline;
begin
  Result := NS / SDL_NS_PER_SECOND
end;

function SDL_MSToNS(MS: Integer): Int64; inline;
begin
  Result := MS * SDL_NS_PER_MS;
end;

function SDL_NSToMS(NS: Int64): Integer; inline;
begin
  Result := NS div SDL_NS_PER_MS;
end;

function SDL_USToNS(US: Int64): Int64; inline;
begin
  Result := US * SDL_NS_PER_US;
end;

function SDL_NSToUS(NS: Int64): Int64; inline;
begin
  Result := NS div SDL_NS_PER_US;
end;

procedure SdlMain(const AMainProc: TSdlProc);
begin
  Assert(Assigned(AMainProc));
  GMainProc := AMainProc;
  {$IF Defined(ANDROID)}
  AndroidInitSdl(AMainProc);
  {$ELSE}
  AMainProc();
  {$ENDIF}
end;
{$ENDREGION 'Implementation'}

end.
